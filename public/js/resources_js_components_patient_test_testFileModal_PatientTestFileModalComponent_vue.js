/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["resources_js_components_patient_test_testFileModal_PatientTestFileModalComponent_vue"],{

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-22!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.ts?vue&type=script&lang=ts":
/*!******************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-22!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.ts?vue&type=script&lang=ts ***!
  \******************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _data_Medical_Result_TestFileResult_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @data/Medical/Result/TestFileResult.data */ \"./resources/js/defaultData/Medical/Result/TestFileResult.data.ts\");\n/* harmony import */ var _vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @vue/runtime-core */ \"./node_modules/@vue/runtime-core/dist/runtime-core.esm-bundler.js\");\n/* harmony import */ var pdfobject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pdfobject */ \"./node_modules/pdfobject/pdfobject.js\");\n/* harmony import */ var pdfobject__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pdfobject__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var vue3_pdf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vue3-pdf */ \"./node_modules/vue3-pdf/src/vuePdfNoSss.vue\");\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_vue_runtime_core__WEBPACK_IMPORTED_MODULE_3__.defineComponent)({\n  components: {\n    pdf: vue3_pdf__WEBPACK_IMPORTED_MODULE_2__.default\n  },\n  props: {\n    id: {\n      type: String,\n      \"default\": ''\n    },\n    results: {\n      type: Object,\n      \"default\": _data_Medical_Result_TestFileResult_data__WEBPACK_IMPORTED_MODULE_0__.TestFileResultData\n    }\n  },\n  data: function data() {\n    return {\n      pdfSelected: ''\n    };\n  },\n  watch: {},\n  mounted: function mounted() {},\n  methods: {\n    selectPDF: function selectPDF(file) {\n      (0,pdfobject__WEBPACK_IMPORTED_MODULE_1__.embed)(\"/estudio/archivo/\" + file, '#example1');\n    }\n  }\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC50cz9hYTY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBR0E7QUFDQTtBQUVBO0FBRUEsaUVBQWUsa0VBQWUsQ0FBQztBQUMzQixZQUFVLEVBQUU7QUFDUixPQUFHO0FBREssR0FEZTtBQUkzQixPQUFLLEVBQUU7QUFDSCxNQUFFLEVBQUU7QUFDQSxVQUFJLEVBQUUsTUFETjtBQUVBLGlCQUFTO0FBRlQsS0FERDtBQUtILFdBQU8sRUFBRTtBQUNMLFVBQUksRUFBRSxNQUREO0FBRUwsaUJBQVMsd0ZBQWtCO0FBRnRCO0FBTE4sR0FKb0I7QUFjM0IsTUFBSTtBQUNBLFdBQU87QUFDSCxpQkFBVyxFQUFFO0FBRFYsS0FBUDtBQUdILEdBbEIwQjtBQW1CM0IsT0FBSyxFQUNMLEVBcEIyQjtBQXNCM0IsU0FBTyxzQkFDTixDQXZCMEI7QUF3QjNCLFNBQU8sRUFBRTtBQUNMLGFBQVMsRUFBVCxtQkFBVSxJQUFWLEVBQW1CO0FBRWYsc0RBQUssQ0FBQyxzQkFBb0IsSUFBckIsRUFBNkIsV0FBN0IsQ0FBTDtBQUNIO0FBSkk7QUF4QmtCLENBQUQsQ0FBOUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYi9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC01LnVzZVswXSEuL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMjIhLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC50cz92dWUmdHlwZT1zY3JpcHQmbGFuZz10cy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRlc3RGaWxlUmVzdWx0RGF0YSB9IGZyb20gJ0BkYXRhL01lZGljYWwvUmVzdWx0L1Rlc3RGaWxlUmVzdWx0LmRhdGEnO1xyXG5pbXBvcnQgeyBQcmVzY3JpcHRpb24gfSBmcm9tICdAaW50ZXJmYWNlL01lZGljYWwvUHJlc2NyaXB0aW9uLmludGVyZmFjZSc7XHJcbmltcG9ydCB7IFRlc3RGaWxlUmVzdWx0IH0gZnJvbSAnQGludGVyZmFjZS9NZWRpY2FsL1Jlc3VsdC9UZXN0RmlsZVJlc3VsdC5pbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBkZWZpbmVDb21wb25lbnQgfSBmcm9tICdAdnVlL3J1bnRpbWUtY29yZSc7XHJcbmltcG9ydCB7IGVtYmVkIH0gZnJvbSAncGRmb2JqZWN0JztcclxuaW1wb3J0IHsgUHJvcFR5cGUgfSBmcm9tICd2dWUnO1xyXG5pbXBvcnQgcGRmIGZyb20gJ3Z1ZTMtcGRmJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGRlZmluZUNvbXBvbmVudCh7XHJcbiAgICBjb21wb25lbnRzOiB7XHJcbiAgICAgICAgcGRmXHJcbiAgICB9LFxyXG4gICAgcHJvcHM6IHtcclxuICAgICAgICBpZDoge1xyXG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6ICcnXHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXN1bHRzOiB7XHJcbiAgICAgICAgICAgIHR5cGU6IE9iamVjdCBhcyBQcm9wVHlwZTxUZXN0RmlsZVJlc3VsdD4sXHJcbiAgICAgICAgICAgIGRlZmF1bHQ6IFRlc3RGaWxlUmVzdWx0RGF0YVxyXG4gICAgICAgIH1cclxuICAgIH0sXHJcbiAgICBkYXRhKCkge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBkZlNlbGVjdGVkOiAnJ1xyXG4gICAgICAgIH07XHJcbiAgICB9LFxyXG4gICAgd2F0Y2g6XHJcbiAgICB7XHJcbiAgICB9LFxyXG4gICAgbW91bnRlZCgpIHtcclxuICAgIH0sXHJcbiAgICBtZXRob2RzOiB7XHJcbiAgICAgICAgc2VsZWN0UERGKGZpbGU6IGFueSlcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIGVtYmVkKGAvZXN0dWRpby9hcmNoaXZvLyR7ZmlsZX1gLCAnI2V4YW1wbGUxJylcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn0pIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-22!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.ts?vue&type=script&lang=ts\n");

/***/ }),

/***/ "./resources/js/defaultData/Medical/Result/TestFileResult.data.ts":
/*!************************************************************************!*\
  !*** ./resources/js/defaultData/Medical/Result/TestFileResult.data.ts ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"TestFileResultData\": () => (/* binding */ TestFileResultData)\n/* harmony export */ });\nvar TestFileResultData = {\n  type: 'files',\n  files: []\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvZGVmYXVsdERhdGEvTWVkaWNhbC9SZXN1bHQvVGVzdEZpbGVSZXN1bHQuZGF0YS50cz9iMTgyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFFTyxJQUFNLGtCQUFrQixHQUFtQjtBQUM5QyxNQUFJLEVBQUUsT0FEd0M7QUFFOUMsT0FBSyxFQUFFO0FBRnVDLENBQTNDIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2RlZmF1bHREYXRhL01lZGljYWwvUmVzdWx0L1Rlc3RGaWxlUmVzdWx0LmRhdGEudHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUZXN0RmlsZVJlc3VsdCB9IGZyb20gXCJAaW50ZXJmYWNlL01lZGljYWwvUmVzdWx0L1Rlc3RGaWxlUmVzdWx0LmludGVyZmFjZVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IFRlc3RGaWxlUmVzdWx0RGF0YTogVGVzdEZpbGVSZXN1bHQgPSB7XHJcbiAgICB0eXBlOiAnZmlsZXMnLFxyXG4gICAgZmlsZXM6IFtdXHJcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/defaultData/Medical/Result/TestFileResult.data.ts\n");

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true":
/*!******************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true ***!
  \******************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"render\": () => (/* binding */ render)\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\");\n\n\nvar _withId = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.withScopeId)(\"data-v-602a6bea\");\n\n(0,vue__WEBPACK_IMPORTED_MODULE_0__.pushScopeId)(\"data-v-602a6bea\");\n\nvar _hoisted_1 = {\n  \"class\": \"modal-dialog modal-dialog-centered rounded-bottom\",\n  role: \"document\"\n};\nvar _hoisted_2 = {\n  \"class\": \"modal-content rounded-bottom\"\n};\n\nvar _hoisted_3 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"div\", {\n  \"class\": \"modal-header e-info-header bg-primary text-center py-2\"\n}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"h6\", {\n  \"class\": \"modal-title e-info-title text-white\"\n}, \"Resultados\"), /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"button\", {\n  type: \"button\",\n  \"class\": \"btn btn-icon btn-circle btn-outline-primary p-0\",\n  \"data-dismiss\": \"modal\",\n  \"aria-label\": \"Close\"\n}, [/*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"img\", {\n  src: \"/svg/close.svg\",\n  alt: \"Alert logo\",\n  style: {\n    \"filter\": \"invert(1)\"\n  }\n})])], -1\n/* HOISTED */\n);\n\nvar _hoisted_4 = {\n  \"class\": \"modal-body p-0\"\n};\nvar _hoisted_5 = {\n  \"class\": \"px-3\"\n};\nvar _hoisted_6 = {\n  \"class\": \"btn-group atbd-button-group btn-group-normal my-2 bg-white\"\n};\n\nvar _hoisted_7 = /*#__PURE__*/(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"div\", {\n  id: \"example1\",\n  \"class\": \"pdf\"\n}, null, -1\n/* HOISTED */\n);\n\n(0,vue__WEBPACK_IMPORTED_MODULE_0__.popScopeId)();\n\nvar render = /*#__PURE__*/_withId(function (_ctx, _cache, $props, $setup, $data, $options) {\n  return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(\"div\", {\n    \"class\": \"modal-info-confirmed modal fade show w-100\",\n    id: _ctx.id,\n    tabindex: \"-1\",\n    role: \"dialog\",\n    \"aria-modal\": \"true\"\n  }, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"div\", _hoisted_1, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"div\", _hoisted_2, [_hoisted_3, (0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"div\", _hoisted_4, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"div\", _hoisted_5, [(0,vue__WEBPACK_IMPORTED_MODULE_0__.createVNode)(\"div\", _hoisted_6, [((0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(true), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(vue__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,vue__WEBPACK_IMPORTED_MODULE_0__.renderList)(_ctx.results.files, function (file, index) {\n    return (0,vue__WEBPACK_IMPORTED_MODULE_0__.openBlock)(), (0,vue__WEBPACK_IMPORTED_MODULE_0__.createBlock)(\"button\", {\n      type: \"button\",\n      \"class\": \"btn btn-default btn-squared btn-outline-primary \",\n      key: \"ptfmc\".concat(index),\n      onClick: function onClick($event) {\n        return _ctx.selectPDF(file);\n      }\n    }, (0,vue__WEBPACK_IMPORTED_MODULE_0__.toDisplayString)(file), 9\n    /* TEXT, PROPS */\n    , [\"onClick\"]);\n  }), 128\n  /* KEYED_FRAGMENT */\n  ))])]), _hoisted_7])])])], 8\n  /* PROPS */\n  , [\"id\"]);\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC52dWU/ZDFmZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFFYSxXQUFNLG1EO0FBQW9ELE1BQUksRUFBQzs7O0FBQzNELFdBQU07Ozs4QkFDUCxpREFNTSxLQU5OLEVBTU07QUFORCxXQUFNO0FBTUwsQ0FOTixFQUFtRSxDLGFBQy9ELGlEQUErRCxJQUEvRCxFQUErRDtBQUEzRCxXQUFNO0FBQXFELENBQS9ELEVBQWdELFlBQWhELENBRCtELEUsYUFFL0QsaURBR1MsUUFIVCxFQUdTO0FBSEQsTUFBSSxFQUFDLFFBR0o7QUFIYSxXQUFNLGlEQUduQjtBQUhxRSxrQkFBYSxPQUdsRjtBQUZMLGdCQUFXO0FBRU4sQ0FIVCxFLGNBRUksaURBQXNFLEtBQXRFLEVBQXNFO0FBQWpFLEtBQUcsRUFBQyxnQkFBNkQ7QUFBNUMsS0FBRyxFQUFDLFlBQXdDO0FBQTNCLE9BQTBCLEVBQTFCO0FBQUE7QUFBQTtBQUEyQixDQUF0RSxDLENBRkosQ0FGK0QsQ0FBbkUsRTs7QUFBQSxDOzs7QUFPSyxXQUFNOzs7QUFDRixXQUFNOzs7QUFDRixXQUFNOzs7OEJBS2YsaURBQXFDLEtBQXJDLEVBQXFDO0FBQWhDLElBQUUsRUFBQyxVQUE2QjtBQUFsQixXQUFNO0FBQVksQ0FBckMsRSxJQUFBLEU7O0FBQUEsQzs7Ozs7MkRBakJoQixpREFxQk0sS0FyQk4sRUFxQk07QUFyQkQsYUFBTSw0Q0FxQkw7QUFyQm1ELE1BQUUsRUFBRSxPQXFCdkQ7QUFyQjJELFlBQVEsRUFBQyxJQXFCcEU7QUFyQnlFLFFBQUksRUFBQyxRQXFCOUU7QUFyQnVGLGtCQUFXO0FBcUJsRyxHQXJCTixFLENBQ0ksaURBbUJNLEtBbkJOLGNBbUJNLENBbEJGLGlEQWlCTSxLQWpCTixjQWlCTSxDQWhCRixVQWdCRSxFQVRGLGlEQVFNLEtBUk4sY0FRTSxDQVBGLGlEQUtNLEtBTE4sY0FLTSxDQUpGLGlEQUdNLEtBSE4sY0FHTSxFLHNEQUZGLGlEQUM0Ryx5Q0FENUcsRUFDNEcsSUFENUcsRUFDNEcsZ0RBQWhGLGFBQVEsS0FBd0UsRUFBbkUsVUFBN0IsSUFBNkIsRUFBdkIsS0FBdUIsRUFBbEI7NkRBRHZCLGlEQUM0RyxRQUQ1RyxFQUM0RztBQURwRyxVQUFJLEVBQUMsUUFDK0Y7QUFEdEYsZUFBTSxrREFDZ0Y7QUFBaEUsU0FBRyxpQkFBVSxLQUFWLENBQTZEO0FBQXpDLGFBQUs7QUFBQSxlQUFFLGVBQVUsSUFBVixDQUFGO0FBQUE7QUFBb0MsS0FENUcsRSxxREFDNkYsSSxDQUQ3RixFQUNpRztBQUFBO0FBRGpHLE1BQ2lHLFdBRGpHLEM7R0FDNEcsQ0FENUcsRTs7QUFBQSxHQUVFLEVBSE4sQ0FJRSxDQUxOLENBT0UsRUFERixVQUNFLENBUk4sQ0FTRSxDQWpCTixDQWtCRSxDQW5CTixDLENBREosRTs7QUFBQSxJLE1BQUEsQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC90ZW1wbGF0ZUxvYWRlci5qcz8/cnVsZVNldFsxXS5ydWxlc1syXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcGF0aWVudC90ZXN0L3Rlc3RGaWxlTW9kYWwvUGF0aWVudFRlc3RGaWxlTW9kYWxDb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTYwMmE2YmVhJnNjb3BlZD10cnVlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiPHRlbXBsYXRlPlxyXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWluZm8tY29uZmlybWVkIG1vZGFsIGZhZGUgc2hvdyB3LTEwMFwiIDppZD1cImlkXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJkaWFsb2dcIiBhcmlhLW1vZGFsPVwidHJ1ZVwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1kaWFsb2cgbW9kYWwtZGlhbG9nLWNlbnRlcmVkIHJvdW5kZWQtYm90dG9tXCIgcm9sZT1cImRvY3VtZW50XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50IHJvdW5kZWQtYm90dG9tXCI+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyIGUtaW5mby1oZWFkZXIgYmctcHJpbWFyeSB0ZXh0LWNlbnRlciBweS0yXCI+XHJcbiAgICAgICAgICAgICAgICAgICAgPGg2IGNsYXNzPVwibW9kYWwtdGl0bGUgZS1pbmZvLXRpdGxlIHRleHQtd2hpdGVcIj5SZXN1bHRhZG9zPC9oNj5cclxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4taWNvbiBidG4tY2lyY2xlIGJ0bi1vdXRsaW5lLXByaW1hcnkgcC0wXCIgZGF0YS1kaXNtaXNzPVwibW9kYWxcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmlhLWxhYmVsPVwiQ2xvc2VcIj5cclxuICAgICAgICAgICAgICAgICAgICAgICAgPGltZyBzcmM9XCIvc3ZnL2Nsb3NlLnN2Z1wiIGFsdD1cIkFsZXJ0IGxvZ29cIiBzdHlsZT1cImZpbHRlcjogaW52ZXJ0KDEpO1wiPlxyXG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keSBwLTBcIj5cclxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHgtM1wiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwIGF0YmQtYnV0dG9uLWdyb3VwIGJ0bi1ncm91cC1ub3JtYWwgbXktMiBiZy13aGl0ZVwiPlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgYnRuLXNxdWFyZWQgYnRuLW91dGxpbmUtcHJpbWFyeSBcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtZm9yPVwiKGZpbGUsIGluZGV4KSBpbiByZXN1bHRzLmZpbGVzXCIgOmtleT1cImBwdGZtYyR7aW5kZXh9YFwiIEBjbGljaz1cInNlbGVjdFBERihmaWxlKVwiPnt7ZmlsZX19PC9idXR0b24+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgaWQ9XCJleGFtcGxlMVwiIGNsYXNzPVwicGRmXCI+PC9kaXY+XHJcbiAgICAgICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuPC90ZW1wbGF0ZT5cclxuXHJcbjxzY3JpcHQgbGFuZz1cInRzXCIgc3JjPVwiLi9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC50c1wiPjwvc2NyaXB0PlxyXG5cclxuPHN0eWxlIHNjb3BlZD5cclxuICAgIEBpbXBvcnQgJy4vUGF0aWVudFRlc3RGaWxlTW9kYWxDb21wb25lbnQuc2Nzcyc7XHJcblxyXG48L3N0eWxlPlxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true\n");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzFmYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Jhc2U2NC1qcy9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = __webpack_require__.g.TYPED_ARRAY_SUPPORT !== undefined\n  ? __webpack_require__.g.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzP2I2MzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLG9EQUFXO0FBQ2hDLGNBQWMsbUJBQU8sQ0FBQyxnREFBUztBQUMvQixjQUFjLG1CQUFPLENBQUMsZ0RBQVM7O0FBRS9CLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxQkFBTTtBQUNuQyxJQUFJLHFCQUFNO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css":
/*!********************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css ***!
  \********************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\n@-webkit-keyframes resizeSensorVisibility {\\nfrom { top: 0;\\n}\\n}\\n@keyframes resizeSensorVisibility {\\nfrom { top: 0;\\n}\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./node_modules/vue3-resize-sensor/src/resize-sensor.vue\"],\"names\":[],\"mappings\":\";AACA;AACC,OAAO,MAAM;AAAE;AAChB;AAFA;AACC,OAAO,MAAM;AAAE;AAChB\",\"sourcesContent\":[\"<style>\\r\\n@keyframes resizeSensorVisibility {\\r\\n\\tfrom { top: 0; }\\r\\n}\\r\\n</style>\\r\\n\\r\\n<script>\\r\\n\\\"use strict\\\";\\r\\nimport { h } from 'vue'\\r\\n\\r\\nexport default {\\r\\n\\r\\n\\t// thanks to https://github.com/marcj/css-element-queries\\r\\n\\tprops: {\\r\\n\\t\\tinitial: {\\r\\n\\t\\t\\ttype: Boolean,\\r\\n\\t\\t\\tdefault: false,\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tdata: function() {\\r\\n\\t\\treturn {\\r\\n\\t\\t\\tsize: {\\r\\n\\t\\t\\t\\twidth: -1,\\r\\n\\t\\t\\t\\theight: -1\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\tmethods: {\\r\\n\\t\\treset: function() {\\r\\n\\r\\n\\t\\t\\tvar expand = this.$el.firstChild;\\r\\n\\t\\t\\tvar shrink = this.$el.lastChild;\\r\\n\\t\\t\\texpand.scrollLeft = 100000;\\r\\n\\t\\t\\texpand.scrollTop = 100000;\\r\\n\\t\\t\\tshrink.scrollLeft = 100000;\\r\\n\\t\\t\\tshrink.scrollTop = 100000;\\r\\n\\t\\t},\\r\\n\\t\\tupdate: function() {\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.size.width = this.$el.offsetWidth;\\r\\n\\t\\t\\tthis.size.height = this.$el.offsetHeight;\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\twatch: {\\r\\n\\t\\tsize: {\\r\\n\\t\\t\\tdeep: true,\\r\\n\\t\\t\\thandler: function(size) {\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis.reset();\\r\\n\\t\\t\\t\\tthis.$emit('resize', { width: this.size.width, height: this.size.height });\\r\\n\\t\\t\\t}\\r\\n\\t\\t}\\r\\n\\t},\\r\\n\\trender: function() {\\r\\n\\t\\t\\r\\n\\t\\tvar style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\\r\\n\\t\\tvar styleChild = 'position: absolute; left: 0; top: 0;';\\r\\n\\r\\n\\t\\treturn h('div', {\\r\\n\\t\\t\\tstyle: style + 'animation-name: resizeSensorVisibility;',\\r\\n\\t\\t\\tonAnimationStart: this.update\\r\\n\\t\\t},[\\r\\n\\t\\t\\th('div', {\\r\\n\\t\\t\\t\\tstyle: style,\\r\\n\\t\\t\\t\\tonScroll: this.update\\r\\n\\t\\t\\t}, [\\r\\n\\t\\t\\t\\th('div', {\\r\\n\\t\\t\\t\\t\\tstyle: styleChild + 'width: 100000px; height: 100000px;'\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t]),\\r\\n\\t\\t\\th('div', {\\r\\n\\t\\t\\t\\tstyle: style,\\r\\n\\t\\t\\t\\tonScroll: this.update\\r\\n\\t\\t\\t}, [\\r\\n\\t\\t\\t\\th('div', {\\r\\n\\t\\t\\t\\t\\tstyle: styleChild + 'width: 200%; height: 200%;'\\r\\n\\t\\t\\t\\t})\\r\\n\\t\\t\\t]),\\r\\n\\t\\t]);\\r\\n\\t},\\r\\n\\tbeforeUnmount: function() {\\r\\n\\t\\t\\r\\n\\t\\tthis.$emit('resize', { width: 0, height: 0 });\\r\\n\\t\\tthis.$emit('resizeSensorBeforeDestroy');\\r\\n\\t},\\r\\n\\tmounted: function() {\\r\\n\\r\\n\\t\\tif ( this.initial === true )\\r\\n\\t\\t\\tthis.$nextTick(this.update);\\r\\n\\t\\t\\r\\n\\t\\tif ( this.$el.offsetParent !== this.$el.parentNode )\\r\\n\\t\\t\\tthis.$el.parentNode.style.position = 'relative';\\r\\n\\r\\n\\t\\tif ( 'attachEvent' in this.$el && !('AnimationEvent' in window) ) {\\r\\n\\r\\n\\t\\t\\tvar onresizeHandler = function() {\\r\\n\\r\\n\\t\\t\\t\\tthis.update();\\r\\n\\t\\t\\t\\tremoveOnresizeEvent();\\r\\n\\t\\t\\t}.bind(this);\\r\\n\\t\\t\\r\\n\\t\\t\\tvar removeOnresizeEvent = function() {\\r\\n\\t\\t\\t\\t\\r\\n\\t\\t\\t\\tthis.$el.detachEvent('onresize', onresizeHandler);\\r\\n\\t\\t\\t\\tthis.$off('resizeSensorBeforeDestroy', removeOnresizeEvent);\\r\\n\\t\\t\\t}.bind(this);\\r\\n\\t\\t\\t\\r\\n\\t\\t\\tthis.$el.attachEvent('onresize', onresizeHandler);\\r\\n\\t\\t\\tthis.$on('resizeSensorBeforeDestroy', removeOnresizeEvent);\\r\\n\\t\\t\\tthis.reset();\\r\\n\\t\\t}\\r\\n\\t}\\r\\n}\\r\\n\\r\\n</script>\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZT8xNzUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDNEc7QUFDN0I7QUFDL0UsOEJBQThCLHNFQUEyQixDQUFDLDJGQUFxQztBQUMvRjtBQUNBLHVGQUF1RixRQUFRLFFBQVEsR0FBRyxHQUFHLHFDQUFxQyxRQUFRLFFBQVEsR0FBRyxHQUFHLFdBQVcsb0hBQW9ILEtBQUssZUFBZSxLQUFLLE1BQU0sS0FBSyxlQUFlLEtBQUssd0VBQXdFLFlBQVksUUFBUSxFQUFFLEtBQUssK0NBQStDLFlBQVksSUFBSSxtQ0FBbUMsaUZBQWlGLGtCQUFrQiwwREFBMEQsT0FBTyx5QkFBeUIsZ0JBQWdCLGlCQUFpQix1REFBdUQsU0FBUyxPQUFPLGlCQUFpQiwyQkFBMkIsK0NBQStDLDBDQUEwQyxxQ0FBcUMsb0NBQW9DLHFDQUFxQyxvQ0FBb0MsU0FBUyw2QkFBNkIsMkRBQTJELG1EQUFtRCxTQUFTLE9BQU8sZUFBZSxlQUFlLHdEQUF3RCxxQ0FBcUMsa0NBQWtDLG1EQUFtRCxFQUFFLFdBQVcsU0FBUyxPQUFPLDJCQUEyQixnREFBZ0QsU0FBUyxRQUFRLFVBQVUsV0FBVyxrQkFBa0IsYUFBYSxvQkFBb0IsRUFBRSw2Q0FBNkMsU0FBUyxRQUFRLEVBQUUsNkJBQTZCLGlFQUFpRSxrREFBa0Qsc0JBQXNCLHFFQUFxRSx5QkFBeUIsbURBQW1ELGtCQUFrQixjQUFjLGtDQUFrQyxxRUFBcUUseUJBQXlCLCtDQUErQyxjQUFjLGNBQWMseUJBQXlCLE9BQU8sa0NBQWtDLHNDQUFzQyxzQkFBc0IsRUFBRSxnREFBZ0QsT0FBTyw0QkFBNEIsOEVBQThFLDhIQUE4SCwrRUFBK0UsZ0RBQWdELDhCQUE4QixrQ0FBa0MsV0FBVyxZQUFZLHdEQUF3RCwwRUFBMEUsd0VBQXdFLFdBQVcsWUFBWSxzRUFBc0UscUVBQXFFLHVCQUF1QixTQUFTLE9BQU8sS0FBSyx3Q0FBd0M7QUFDOXlHO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTA3ZjRiMDEzJmxhbmc9Y3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2Nzc1dpdGhNYXBwaW5nVG9TdHJpbmcuanNcIjtcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uLy4uL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuQC13ZWJraXQta2V5ZnJhbWVzIHJlc2l6ZVNlbnNvclZpc2liaWxpdHkge1xcbmZyb20geyB0b3A6IDA7XFxufVxcbn1cXG5Aa2V5ZnJhbWVzIHJlc2l6ZVNlbnNvclZpc2liaWxpdHkge1xcbmZyb20geyB0b3A6IDA7XFxufVxcbn1cXHJcXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBQ0E7QUFDQyxPQUFPLE1BQU07QUFBRTtBQUNoQjtBQUZBO0FBQ0MsT0FBTyxNQUFNO0FBQUU7QUFDaEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHN0eWxlPlxcclxcbkBrZXlmcmFtZXMgcmVzaXplU2Vuc29yVmlzaWJpbGl0eSB7XFxyXFxuXFx0ZnJvbSB7IHRvcDogMDsgfVxcclxcbn1cXHJcXG48L3N0eWxlPlxcclxcblxcclxcbjxzY3JpcHQ+XFxyXFxuXFxcInVzZSBzdHJpY3RcXFwiO1xcclxcbmltcG9ydCB7IGggfSBmcm9tICd2dWUnXFxyXFxuXFxyXFxuZXhwb3J0IGRlZmF1bHQge1xcclxcblxcclxcblxcdC8vIHRoYW5rcyB0byBodHRwczovL2dpdGh1Yi5jb20vbWFyY2ovY3NzLWVsZW1lbnQtcXVlcmllc1xcclxcblxcdHByb3BzOiB7XFxyXFxuXFx0XFx0aW5pdGlhbDoge1xcclxcblxcdFxcdFxcdHR5cGU6IEJvb2xlYW4sXFxyXFxuXFx0XFx0XFx0ZGVmYXVsdDogZmFsc2UsXFxyXFxuXFx0XFx0fVxcclxcblxcdH0sXFxyXFxuXFx0ZGF0YTogZnVuY3Rpb24oKSB7XFxyXFxuXFx0XFx0cmV0dXJuIHtcXHJcXG5cXHRcXHRcXHRzaXplOiB7XFxyXFxuXFx0XFx0XFx0XFx0d2lkdGg6IC0xLFxcclxcblxcdFxcdFxcdFxcdGhlaWdodDogLTFcXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fVxcclxcblxcdH0sXFxyXFxuXFx0bWV0aG9kczoge1xcclxcblxcdFxcdHJlc2V0OiBmdW5jdGlvbigpIHtcXHJcXG5cXHJcXG5cXHRcXHRcXHR2YXIgZXhwYW5kID0gdGhpcy4kZWwuZmlyc3RDaGlsZDtcXHJcXG5cXHRcXHRcXHR2YXIgc2hyaW5rID0gdGhpcy4kZWwubGFzdENoaWxkO1xcclxcblxcdFxcdFxcdGV4cGFuZC5zY3JvbGxMZWZ0ID0gMTAwMDAwO1xcclxcblxcdFxcdFxcdGV4cGFuZC5zY3JvbGxUb3AgPSAxMDAwMDA7XFxyXFxuXFx0XFx0XFx0c2hyaW5rLnNjcm9sbExlZnQgPSAxMDAwMDA7XFxyXFxuXFx0XFx0XFx0c2hyaW5rLnNjcm9sbFRvcCA9IDEwMDAwMDtcXHJcXG5cXHRcXHR9LFxcclxcblxcdFxcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XFxyXFxuXFx0XFx0XFx0XFxyXFxuXFx0XFx0XFx0dGhpcy5zaXplLndpZHRoID0gdGhpcy4kZWwub2Zmc2V0V2lkdGg7XFxyXFxuXFx0XFx0XFx0dGhpcy5zaXplLmhlaWdodCA9IHRoaXMuJGVsLm9mZnNldEhlaWdodDtcXHJcXG5cXHRcXHR9XFxyXFxuXFx0fSxcXHJcXG5cXHR3YXRjaDoge1xcclxcblxcdFxcdHNpemU6IHtcXHJcXG5cXHRcXHRcXHRkZWVwOiB0cnVlLFxcclxcblxcdFxcdFxcdGhhbmRsZXI6IGZ1bmN0aW9uKHNpemUpIHtcXHJcXG5cXHRcXHRcXHRcXHRcXHJcXG5cXHRcXHRcXHRcXHR0aGlzLnJlc2V0KCk7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy4kZW1pdCgncmVzaXplJywgeyB3aWR0aDogdGhpcy5zaXplLndpZHRoLCBoZWlnaHQ6IHRoaXMuc2l6ZS5oZWlnaHQgfSk7XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHR9LFxcclxcblxcdHJlbmRlcjogZnVuY3Rpb24oKSB7XFxyXFxuXFx0XFx0XFxyXFxuXFx0XFx0dmFyIHN0eWxlID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyc7XFxyXFxuXFx0XFx0dmFyIHN0eWxlQ2hpbGQgPSAncG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiAwOyB0b3A6IDA7JztcXHJcXG5cXHJcXG5cXHRcXHRyZXR1cm4gaCgnZGl2Jywge1xcclxcblxcdFxcdFxcdHN0eWxlOiBzdHlsZSArICdhbmltYXRpb24tbmFtZTogcmVzaXplU2Vuc29yVmlzaWJpbGl0eTsnLFxcclxcblxcdFxcdFxcdG9uQW5pbWF0aW9uU3RhcnQ6IHRoaXMudXBkYXRlXFxyXFxuXFx0XFx0fSxbXFxyXFxuXFx0XFx0XFx0aCgnZGl2Jywge1xcclxcblxcdFxcdFxcdFxcdHN0eWxlOiBzdHlsZSxcXHJcXG5cXHRcXHRcXHRcXHRvblNjcm9sbDogdGhpcy51cGRhdGVcXHJcXG5cXHRcXHRcXHR9LCBbXFxyXFxuXFx0XFx0XFx0XFx0aCgnZGl2Jywge1xcclxcblxcdFxcdFxcdFxcdFxcdHN0eWxlOiBzdHlsZUNoaWxkICsgJ3dpZHRoOiAxMDAwMDBweDsgaGVpZ2h0OiAxMDAwMDBweDsnXFxyXFxuXFx0XFx0XFx0XFx0fSlcXHJcXG5cXHRcXHRcXHRdKSxcXHJcXG5cXHRcXHRcXHRoKCdkaXYnLCB7XFxyXFxuXFx0XFx0XFx0XFx0c3R5bGU6IHN0eWxlLFxcclxcblxcdFxcdFxcdFxcdG9uU2Nyb2xsOiB0aGlzLnVwZGF0ZVxcclxcblxcdFxcdFxcdH0sIFtcXHJcXG5cXHRcXHRcXHRcXHRoKCdkaXYnLCB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0c3R5bGU6IHN0eWxlQ2hpbGQgKyAnd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJTsnXFxyXFxuXFx0XFx0XFx0XFx0fSlcXHJcXG5cXHRcXHRcXHRdKSxcXHJcXG5cXHRcXHRdKTtcXHJcXG5cXHR9LFxcclxcblxcdGJlZm9yZVVubW91bnQ6IGZ1bmN0aW9uKCkge1xcclxcblxcdFxcdFxcclxcblxcdFxcdHRoaXMuJGVtaXQoJ3Jlc2l6ZScsIHsgd2lkdGg6IDAsIGhlaWdodDogMCB9KTtcXHJcXG5cXHRcXHR0aGlzLiRlbWl0KCdyZXNpemVTZW5zb3JCZWZvcmVEZXN0cm95Jyk7XFxyXFxuXFx0fSxcXHJcXG5cXHRtb3VudGVkOiBmdW5jdGlvbigpIHtcXHJcXG5cXHJcXG5cXHRcXHRpZiAoIHRoaXMuaW5pdGlhbCA9PT0gdHJ1ZSApXFxyXFxuXFx0XFx0XFx0dGhpcy4kbmV4dFRpY2sodGhpcy51cGRhdGUpO1xcclxcblxcdFxcdFxcclxcblxcdFxcdGlmICggdGhpcy4kZWwub2Zmc2V0UGFyZW50ICE9PSB0aGlzLiRlbC5wYXJlbnROb2RlIClcXHJcXG5cXHRcXHRcXHR0aGlzLiRlbC5wYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcXHJcXG5cXHJcXG5cXHRcXHRpZiAoICdhdHRhY2hFdmVudCcgaW4gdGhpcy4kZWwgJiYgISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykgKSB7XFxyXFxuXFxyXFxuXFx0XFx0XFx0dmFyIG9ucmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uKCkge1xcclxcblxcclxcblxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxyXFxuXFx0XFx0XFx0XFx0cmVtb3ZlT25yZXNpemVFdmVudCgpO1xcclxcblxcdFxcdFxcdH0uYmluZCh0aGlzKTtcXHJcXG5cXHRcXHRcXHJcXG5cXHRcXHRcXHR2YXIgcmVtb3ZlT25yZXNpemVFdmVudCA9IGZ1bmN0aW9uKCkge1xcclxcblxcdFxcdFxcdFxcdFxcclxcblxcdFxcdFxcdFxcdHRoaXMuJGVsLmRldGFjaEV2ZW50KCdvbnJlc2l6ZScsIG9ucmVzaXplSGFuZGxlcik7XFxyXFxuXFx0XFx0XFx0XFx0dGhpcy4kb2ZmKCdyZXNpemVTZW5zb3JCZWZvcmVEZXN0cm95JywgcmVtb3ZlT25yZXNpemVFdmVudCk7XFxyXFxuXFx0XFx0XFx0fS5iaW5kKHRoaXMpO1xcclxcblxcdFxcdFxcdFxcclxcblxcdFxcdFxcdHRoaXMuJGVsLmF0dGFjaEV2ZW50KCdvbnJlc2l6ZScsIG9ucmVzaXplSGFuZGxlcik7XFxyXFxuXFx0XFx0XFx0dGhpcy4kb24oJ3Jlc2l6ZVNlbnNvckJlZm9yZURlc3Ryb3knLCByZW1vdmVPbnJlc2l6ZUV2ZW50KTtcXHJcXG5cXHRcXHRcXHR0aGlzLnJlc2V0KCk7XFxyXFxuXFx0XFx0fVxcclxcblxcdH1cXHJcXG59XFxyXFxuXFxyXFxuPC9zY3JpcHQ+XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css":
/*!***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css ***!
  \***************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_PatientTestFileModalComponent_scss__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! -!../../../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./PatientTestFileModalComponent.scss */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.scss\");\n// Imports\n\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n___CSS_LOADER_EXPORT___.i(_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_PatientTestFileModalComponent_scss__WEBPACK_IMPORTED_MODULE_2__.default);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"\\r\\n\\r\\n\", \"\",{\"version\":3,\"sources\":[],\"names\":[],\"mappings\":\"\",\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC52dWU/MDU2NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNxSTtBQUM3QjtBQUM2RDtBQUNySyw4QkFBOEIsbUZBQTJCLENBQUMsd0dBQXFDO0FBQy9GLDBCQUEwQixrSUFBaUM7QUFDM0Q7QUFDQSx5REFBeUQsa0VBQWtFO0FBQzNIO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD02MDJhNmJlYSZzY29wZWQ9dHJ1ZSZsYW5nPWNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVRfUlVMRV9JTVBPUlRfMF9fXyBmcm9tIFwiLSEuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuL1BhdGllbnRUZXN0RmlsZU1vZGFsQ29tcG9uZW50LnNjc3NcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyhfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fKTtcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLmkoX19fQ1NTX0xPQURFUl9BVF9SVUxFX0lNUE9SVF8wX19fKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIlxcclxcblxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJcIixcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css":
/*!*************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css ***!
  \*************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/* see https://github.com/mozilla/pdf.js/blob/55a853b6678cf3d05681ffbb521e5228e607b5d2/test/annotation_layer_test.css */\\n.annotationLayer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tbottom: 0;\\n}\\n.annotationLayer section {\\r\\n\\tposition: absolute;\\n}\\n.annotationLayer .linkAnnotation > a {\\r\\n\\tposition: absolute;\\r\\n\\tfont-size: 1em;\\r\\n\\ttop: 0;\\r\\n\\tleft: 0;\\r\\n\\twidth: 100%;\\r\\n\\theight: 100%;\\n}\\n.annotationLayer .linkAnnotation > a /* -ms-a */  {\\r\\n\\tbackground: url(\\\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\\\") 0 0 repeat;\\n}\\n.annotationLayer .linkAnnotation > a:hover {\\r\\n\\topacity: 0.2;\\r\\n\\tbackground: #ff0;\\r\\n\\tbox-shadow: 0px 2px 10px #ff0;\\n}\\n.annotationLayer .textAnnotation img {\\r\\n\\tposition: absolute;\\r\\n\\tcursor: pointer;\\n}\\n.annotationLayer .textWidgetAnnotation input,\\r\\n.annotationLayer .textWidgetAnnotation textarea,\\r\\n.annotationLayer .choiceWidgetAnnotation select,\\r\\n.annotationLayer .buttonWidgetAnnotation.checkBox input,\\r\\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\\r\\n\\tbackground-color: rgba(0, 54, 255, 0.13);\\r\\n\\tborder: 1px solid transparent;\\r\\n\\tbox-sizing: border-box;\\r\\n\\tfont-size: 9px;\\r\\n\\theight: 100%;\\r\\n\\tpadding: 0 3px;\\r\\n\\tvertical-align: top;\\r\\n\\twidth: 100%;\\n}\\n.annotationLayer .textWidgetAnnotation textarea {\\r\\n\\tfont: message-box;\\r\\n\\tfont-size: 9px;\\r\\n\\tresize: none;\\n}\\n.annotationLayer .textWidgetAnnotation input[disabled],\\r\\n.annotationLayer .textWidgetAnnotation textarea[disabled],\\r\\n.annotationLayer .choiceWidgetAnnotation select[disabled],\\r\\n.annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],\\r\\n.annotationLayer .buttonWidgetAnnotation.radioButton input[disabled] {\\r\\n\\tbackground: none;\\r\\n\\tborder: 1px solid transparent;\\r\\n\\tcursor: not-allowed;\\n}\\n.annotationLayer .textWidgetAnnotation input:hover,\\r\\n.annotationLayer .textWidgetAnnotation textarea:hover,\\r\\n.annotationLayer .choiceWidgetAnnotation select:hover,\\r\\n.annotationLayer .buttonWidgetAnnotation.checkBox input:hover,\\r\\n.annotationLayer .buttonWidgetAnnotation.radioButton input:hover {\\r\\n\\tborder: 1px solid #000;\\n}\\n.annotationLayer .textWidgetAnnotation input:focus,\\r\\n.annotationLayer .textWidgetAnnotation textarea:focus,\\r\\n.annotationLayer .choiceWidgetAnnotation select:focus {\\r\\n\\tbackground: none;\\r\\n\\tborder: 1px solid transparent;\\n}\\n.annotationLayer .textWidgetAnnotation input.comb {\\r\\n\\tfont-family: monospace;\\r\\n\\tpadding-left: 2px;\\r\\n\\tpadding-right: 0;\\n}\\n.annotationLayer .textWidgetAnnotation input.comb:focus {\\r\\n\\t/*\\r\\n\\t * Letter spacing is placed on the right side of each character. Hence, the\\r\\n\\t * letter spacing of the last character may be placed outside the visible\\r\\n\\t * area, causing horizontal scrolling. We avoid this by extending the width\\r\\n\\t * when the element has focus and revert this when it loses focus.\\r\\n\\t */\\r\\n\\twidth: 115%;\\n}\\n.annotationLayer .buttonWidgetAnnotation.checkBox input,\\r\\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\\r\\n\\t-webkit-appearance: none;\\r\\n\\t-moz-appearance: none;\\r\\n\\tappearance: none;\\n}\\n.annotationLayer .popupWrapper {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 20em;\\n}\\n.annotationLayer .popup {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 200;\\r\\n\\tmax-width: 20em;\\r\\n\\tbackground-color: #FFFF99;\\r\\n\\tbox-shadow: 0px 2px 5px #333;\\r\\n\\tborder-radius: 2px;\\r\\n\\tpadding: 0.6em;\\r\\n\\tmargin-left: 5px;\\r\\n\\tcursor: pointer;\\r\\n\\tword-wrap: break-word;\\n}\\n.annotationLayer .popup h1 {\\r\\n\\tfont-size: 1em;\\r\\n\\tborder-bottom: 1px solid #000000;\\r\\n\\tpadding-bottom: 0.2em;\\n}\\n.annotationLayer .popup p {\\r\\n\\tpadding-top: 0.2em;\\n}\\n.annotationLayer .highlightAnnotation,\\r\\n.annotationLayer .underlineAnnotation,\\r\\n.annotationLayer .squigglyAnnotation,\\r\\n.annotationLayer .strikeoutAnnotation,\\r\\n.annotationLayer .lineAnnotation svg line,\\r\\n.annotationLayer .fileAttachmentAnnotation {\\r\\n\\tcursor: pointer;\\n}\\r\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://./node_modules/vue3-pdf/src/annotationLayer.css\"],\"names\":[],\"mappings\":\"AAAA,uHAAuH;AAEvH;CACC,kBAAkB;CAClB,OAAO;CACP,MAAM;CACN,QAAQ;CACR,SAAS;AACV;AAEA;CACC,kBAAkB;AACnB;AAEA;CACC,kBAAkB;CAClB,cAAc;CACd,MAAM;CACN,OAAO;CACP,WAAW;CACX,YAAY;AACb;AAEA;CACC,4GAA4G;AAC7G;AAEA;CACC,YAAY;CACZ,gBAAgB;CAChB,6BAA6B;AAC9B;AAEA;CACC,kBAAkB;CAClB,eAAe;AAChB;AAEA;;;;;CAKC,wCAAwC;CACxC,6BAA6B;CAC7B,sBAAsB;CACtB,cAAc;CACd,YAAY;CACZ,cAAc;CACd,mBAAmB;CACnB,WAAW;AACZ;AAEA;CACC,iBAAiB;CACjB,cAAc;CACd,YAAY;AACb;AAEA;;;;;CAKC,gBAAgB;CAChB,6BAA6B;CAC7B,mBAAmB;AACpB;AAEA;;;;;CAKC,sBAAsB;AACvB;AAEA;;;CAGC,gBAAgB;CAChB,6BAA6B;AAC9B;AAEA;CACC,sBAAsB;CACtB,iBAAiB;CACjB,gBAAgB;AACjB;AAEA;CACC;;;;;GAKE;CACF,WAAW;AACZ;AAEA;;CAEC,wBAAwB;CACxB,qBAAqB;CAErB,gBAAgB;AACjB;AAEA;CACC,kBAAkB;CAClB,WAAW;AACZ;AAEA;CACC,kBAAkB;CAClB,YAAY;CACZ,eAAe;CACf,yBAAyB;CACzB,4BAA4B;CAC5B,kBAAkB;CAClB,cAAc;CACd,gBAAgB;CAChB,eAAe;CACf,qBAAqB;AACtB;AAEA;CACC,cAAc;CACd,gCAAgC;CAChC,qBAAqB;AACtB;AAEA;CACC,kBAAkB;AACnB;AAEA;;;;;;CAMC,eAAe;AAChB\",\"sourcesContent\":[\"/* see https://github.com/mozilla/pdf.js/blob/55a853b6678cf3d05681ffbb521e5228e607b5d2/test/annotation_layer_test.css */\\r\\n\\r\\n.annotationLayer {\\r\\n\\tposition: absolute;\\r\\n\\tleft: 0;\\r\\n\\ttop: 0;\\r\\n\\tright: 0;\\r\\n\\tbottom: 0;\\r\\n}\\r\\n\\r\\n.annotationLayer section {\\r\\n\\tposition: absolute;\\r\\n}\\r\\n\\r\\n.annotationLayer .linkAnnotation > a {\\r\\n\\tposition: absolute;\\r\\n\\tfont-size: 1em;\\r\\n\\ttop: 0;\\r\\n\\tleft: 0;\\r\\n\\twidth: 100%;\\r\\n\\theight: 100%;\\r\\n}\\r\\n\\r\\n.annotationLayer .linkAnnotation > a /* -ms-a */  {\\r\\n\\tbackground: url(\\\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\\\") 0 0 repeat;\\r\\n}\\r\\n\\r\\n.annotationLayer .linkAnnotation > a:hover {\\r\\n\\topacity: 0.2;\\r\\n\\tbackground: #ff0;\\r\\n\\tbox-shadow: 0px 2px 10px #ff0;\\r\\n}\\r\\n\\r\\n.annotationLayer .textAnnotation img {\\r\\n\\tposition: absolute;\\r\\n\\tcursor: pointer;\\r\\n}\\r\\n\\r\\n.annotationLayer .textWidgetAnnotation input,\\r\\n.annotationLayer .textWidgetAnnotation textarea,\\r\\n.annotationLayer .choiceWidgetAnnotation select,\\r\\n.annotationLayer .buttonWidgetAnnotation.checkBox input,\\r\\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\\r\\n\\tbackground-color: rgba(0, 54, 255, 0.13);\\r\\n\\tborder: 1px solid transparent;\\r\\n\\tbox-sizing: border-box;\\r\\n\\tfont-size: 9px;\\r\\n\\theight: 100%;\\r\\n\\tpadding: 0 3px;\\r\\n\\tvertical-align: top;\\r\\n\\twidth: 100%;\\r\\n}\\r\\n\\r\\n.annotationLayer .textWidgetAnnotation textarea {\\r\\n\\tfont: message-box;\\r\\n\\tfont-size: 9px;\\r\\n\\tresize: none;\\r\\n}\\r\\n\\r\\n.annotationLayer .textWidgetAnnotation input[disabled],\\r\\n.annotationLayer .textWidgetAnnotation textarea[disabled],\\r\\n.annotationLayer .choiceWidgetAnnotation select[disabled],\\r\\n.annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],\\r\\n.annotationLayer .buttonWidgetAnnotation.radioButton input[disabled] {\\r\\n\\tbackground: none;\\r\\n\\tborder: 1px solid transparent;\\r\\n\\tcursor: not-allowed;\\r\\n}\\r\\n\\r\\n.annotationLayer .textWidgetAnnotation input:hover,\\r\\n.annotationLayer .textWidgetAnnotation textarea:hover,\\r\\n.annotationLayer .choiceWidgetAnnotation select:hover,\\r\\n.annotationLayer .buttonWidgetAnnotation.checkBox input:hover,\\r\\n.annotationLayer .buttonWidgetAnnotation.radioButton input:hover {\\r\\n\\tborder: 1px solid #000;\\r\\n}\\r\\n\\r\\n.annotationLayer .textWidgetAnnotation input:focus,\\r\\n.annotationLayer .textWidgetAnnotation textarea:focus,\\r\\n.annotationLayer .choiceWidgetAnnotation select:focus {\\r\\n\\tbackground: none;\\r\\n\\tborder: 1px solid transparent;\\r\\n}\\r\\n\\r\\n.annotationLayer .textWidgetAnnotation input.comb {\\r\\n\\tfont-family: monospace;\\r\\n\\tpadding-left: 2px;\\r\\n\\tpadding-right: 0;\\r\\n}\\r\\n\\r\\n.annotationLayer .textWidgetAnnotation input.comb:focus {\\r\\n\\t/*\\r\\n\\t * Letter spacing is placed on the right side of each character. Hence, the\\r\\n\\t * letter spacing of the last character may be placed outside the visible\\r\\n\\t * area, causing horizontal scrolling. We avoid this by extending the width\\r\\n\\t * when the element has focus and revert this when it loses focus.\\r\\n\\t */\\r\\n\\twidth: 115%;\\r\\n}\\r\\n\\r\\n.annotationLayer .buttonWidgetAnnotation.checkBox input,\\r\\n.annotationLayer .buttonWidgetAnnotation.radioButton input {\\r\\n\\t-webkit-appearance: none;\\r\\n\\t-moz-appearance: none;\\r\\n\\t-ms-appearance: none;\\r\\n\\tappearance: none;\\r\\n}\\r\\n\\r\\n.annotationLayer .popupWrapper {\\r\\n\\tposition: absolute;\\r\\n\\twidth: 20em;\\r\\n}\\r\\n\\r\\n.annotationLayer .popup {\\r\\n\\tposition: absolute;\\r\\n\\tz-index: 200;\\r\\n\\tmax-width: 20em;\\r\\n\\tbackground-color: #FFFF99;\\r\\n\\tbox-shadow: 0px 2px 5px #333;\\r\\n\\tborder-radius: 2px;\\r\\n\\tpadding: 0.6em;\\r\\n\\tmargin-left: 5px;\\r\\n\\tcursor: pointer;\\r\\n\\tword-wrap: break-word;\\r\\n}\\r\\n\\r\\n.annotationLayer .popup h1 {\\r\\n\\tfont-size: 1em;\\r\\n\\tborder-bottom: 1px solid #000000;\\r\\n\\tpadding-bottom: 0.2em;\\r\\n}\\r\\n\\r\\n.annotationLayer .popup p {\\r\\n\\tpadding-top: 0.2em;\\r\\n}\\r\\n\\r\\n.annotationLayer .highlightAnnotation,\\r\\n.annotationLayer .underlineAnnotation,\\r\\n.annotationLayer .squigglyAnnotation,\\r\\n.annotationLayer .strikeoutAnnotation,\\r\\n.annotationLayer .lineAnnotation svg line,\\r\\n.annotationLayer .fileAttachmentAnnotation {\\r\\n\\tcursor: pointer;\\r\\n}\\r\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL2Fubm90YXRpb25MYXllci5jc3M/ZWE4NCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzRHO0FBQzdCO0FBQy9FLDhCQUE4QixzRUFBMkIsQ0FBQywyRkFBcUM7QUFDL0Y7QUFDQSxzTEFBc0wseUJBQXlCLGNBQWMsYUFBYSxlQUFlLGdCQUFnQixHQUFHLDRCQUE0Qix5QkFBeUIsR0FBRyx3Q0FBd0MseUJBQXlCLHFCQUFxQixhQUFhLGNBQWMsa0JBQWtCLG1CQUFtQixHQUFHLHFEQUFxRCx1Q0FBdUMsOEVBQThFLEdBQUcsOENBQThDLG1CQUFtQix1QkFBdUIsb0NBQW9DLEdBQUcsd0NBQXdDLHlCQUF5QixzQkFBc0IsR0FBRyxtUkFBbVIsK0NBQStDLG9DQUFvQyw2QkFBNkIscUJBQXFCLG1CQUFtQixxQkFBcUIsMEJBQTBCLGtCQUFrQixHQUFHLG1EQUFtRCx3QkFBd0IscUJBQXFCLG1CQUFtQixHQUFHLHFVQUFxVSx1QkFBdUIsb0NBQW9DLDBCQUEwQixHQUFHLGlUQUFpVCw2QkFBNkIsR0FBRywwS0FBMEssdUJBQXVCLG9DQUFvQyxHQUFHLHFEQUFxRCw2QkFBNkIsd0JBQXdCLHVCQUF1QixHQUFHLDJEQUEyRCw0VkFBNFYsR0FBRywwSEFBMEgsK0JBQStCLDRCQUE0Qix1QkFBdUIsR0FBRyxrQ0FBa0MseUJBQXlCLGtCQUFrQixHQUFHLDJCQUEyQix5QkFBeUIsbUJBQW1CLHNCQUFzQixnQ0FBZ0MsbUNBQW1DLHlCQUF5QixxQkFBcUIsdUJBQXVCLHNCQUFzQiw0QkFBNEIsR0FBRyw4QkFBOEIscUJBQXFCLHVDQUF1Qyw0QkFBNEIsR0FBRyw2QkFBNkIseUJBQXlCLEdBQUcsbVFBQW1RLHNCQUFzQixHQUFHLFdBQVcsdUhBQXVILE1BQU0sWUFBWSxXQUFXLFVBQVUsVUFBVSxVQUFVLEtBQUssS0FBSyxZQUFZLE1BQU0sS0FBSyxZQUFZLFdBQVcsVUFBVSxVQUFVLFVBQVUsVUFBVSxLQUFLLEtBQUssWUFBWSxNQUFNLEtBQUssVUFBVSxZQUFZLGFBQWEsTUFBTSxLQUFLLFlBQVksV0FBVyxNQUFNLFNBQVMsWUFBWSxhQUFhLGFBQWEsV0FBVyxVQUFVLFVBQVUsWUFBWSxXQUFXLEtBQUssS0FBSyxZQUFZLFdBQVcsVUFBVSxLQUFLLFNBQVMsWUFBWSxhQUFhLGFBQWEsTUFBTSxTQUFTLFlBQVksTUFBTSxPQUFPLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxhQUFhLGFBQWEsTUFBTSxLQUFLLFNBQVMsS0FBSyxVQUFVLEtBQUssTUFBTSxZQUFZLGFBQWEsYUFBYSxNQUFNLEtBQUssWUFBWSxXQUFXLEtBQUssS0FBSyxZQUFZLFdBQVcsVUFBVSxZQUFZLGFBQWEsYUFBYSxXQUFXLFlBQVksV0FBVyxZQUFZLE1BQU0sS0FBSyxVQUFVLFlBQVksYUFBYSxNQUFNLEtBQUssWUFBWSxNQUFNLFVBQVUsVUFBVSw0S0FBNEsseUJBQXlCLGNBQWMsYUFBYSxlQUFlLGdCQUFnQixLQUFLLGtDQUFrQyx5QkFBeUIsS0FBSyw4Q0FBOEMseUJBQXlCLHFCQUFxQixhQUFhLGNBQWMsa0JBQWtCLG1CQUFtQixLQUFLLDJEQUEyRCx1Q0FBdUMsOEVBQThFLEtBQUssb0RBQW9ELG1CQUFtQix1QkFBdUIsb0NBQW9DLEtBQUssOENBQThDLHlCQUF5QixzQkFBc0IsS0FBSyx5UkFBeVIsK0NBQStDLG9DQUFvQyw2QkFBNkIscUJBQXFCLG1CQUFtQixxQkFBcUIsMEJBQTBCLGtCQUFrQixLQUFLLHlEQUF5RCx3QkFBd0IscUJBQXFCLG1CQUFtQixLQUFLLDJVQUEyVSx1QkFBdUIsb0NBQW9DLDBCQUEwQixLQUFLLHVUQUF1VCw2QkFBNkIsS0FBSyxnTEFBZ0wsdUJBQXVCLG9DQUFvQyxLQUFLLDJEQUEyRCw2QkFBNkIsd0JBQXdCLHVCQUF1QixLQUFLLGlFQUFpRSw0VkFBNFYsS0FBSyxnSUFBZ0ksK0JBQStCLDRCQUE0QiwyQkFBMkIsdUJBQXVCLEtBQUssd0NBQXdDLHlCQUF5QixrQkFBa0IsS0FBSyxpQ0FBaUMseUJBQXlCLG1CQUFtQixzQkFBc0IsZ0NBQWdDLG1DQUFtQyx5QkFBeUIscUJBQXFCLHVCQUF1QixzQkFBc0IsNEJBQTRCLEtBQUssb0NBQW9DLHFCQUFxQix1Q0FBdUMsNEJBQTRCLEtBQUssbUNBQW1DLHlCQUF5QixLQUFLLHlRQUF5USxzQkFBc0IsS0FBSyx1QkFBdUI7QUFDbmxTO0FBQ0EsaUVBQWUsdUJBQXVCLEVBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzJdIS4vbm9kZV9tb2R1bGVzL3Z1ZTMtcGRmL3NyYy9hbm5vdGF0aW9uTGF5ZXIuY3NzP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmbGFuZz1jc3MuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnRzXG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvY3NzV2l0aE1hcHBpbmdUb1N0cmluZy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vLi4vY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIvKiBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcGRmLmpzL2Jsb2IvNTVhODUzYjY2NzhjZjNkMDU2ODFmZmJiNTIxZTUyMjhlNjA3YjVkMi90ZXN0L2Fubm90YXRpb25fbGF5ZXJfdGVzdC5jc3MgKi9cXG4uYW5ub3RhdGlvbkxheWVyIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0bGVmdDogMDtcXHJcXG5cXHR0b3A6IDA7XFxyXFxuXFx0cmlnaHQ6IDA7XFxyXFxuXFx0Ym90dG9tOiAwO1xcbn1cXG4uYW5ub3RhdGlvbkxheWVyIHNlY3Rpb24ge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLmFubm90YXRpb25MYXllciAubGlua0Fubm90YXRpb24gPiBhIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0Zm9udC1zaXplOiAxZW07XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0d2lkdGg6IDEwMCU7XFxyXFxuXFx0aGVpZ2h0OiAxMDAlO1xcbn1cXG4uYW5ub3RhdGlvbkxheWVyIC5saW5rQW5ub3RhdGlvbiA+IGEgLyogLW1zLWEgKi8gIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiB1cmwoXFxcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBSUFBQUFBQUFQLy8veUg1QkFFQUFBQUFMQUFBQUFBQkFBRUFBQUlCUkFBN1xcXCIpIDAgMCByZXBlYXQ7XFxufVxcbi5hbm5vdGF0aW9uTGF5ZXIgLmxpbmtBbm5vdGF0aW9uID4gYTpob3ZlciB7XFxyXFxuXFx0b3BhY2l0eTogMC4yO1xcclxcblxcdGJhY2tncm91bmQ6ICNmZjA7XFxyXFxuXFx0Ym94LXNoYWRvdzogMHB4IDJweCAxMHB4ICNmZjA7XFxufVxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRBbm5vdGF0aW9uIGltZyB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXG59XFxuLmFubm90YXRpb25MYXllciAudGV4dFdpZGdldEFubm90YXRpb24gaW5wdXQsXFxyXFxuLmFubm90YXRpb25MYXllciAudGV4dFdpZGdldEFubm90YXRpb24gdGV4dGFyZWEsXFxyXFxuLmFubm90YXRpb25MYXllciAuY2hvaWNlV2lkZ2V0QW5ub3RhdGlvbiBzZWxlY3QsXFxyXFxuLmFubm90YXRpb25MYXllciAuYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbi5jaGVja0JveCBpbnB1dCxcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5idXR0b25XaWRnZXRBbm5vdGF0aW9uLnJhZGlvQnV0dG9uIGlucHV0IHtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDAsIDU0LCAyNTUsIDAuMTMpO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcblxcdGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxyXFxuXFx0Zm9udC1zaXplOiA5cHg7XFxyXFxuXFx0aGVpZ2h0OiAxMDAlO1xcclxcblxcdHBhZGRpbmc6IDAgM3B4O1xcclxcblxcdHZlcnRpY2FsLWFsaWduOiB0b3A7XFxyXFxuXFx0d2lkdGg6IDEwMCU7XFxufVxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIHRleHRhcmVhIHtcXHJcXG5cXHRmb250OiBtZXNzYWdlLWJveDtcXHJcXG5cXHRmb250LXNpemU6IDlweDtcXHJcXG5cXHRyZXNpemU6IG5vbmU7XFxufVxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIGlucHV0W2Rpc2FibGVkXSxcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC50ZXh0V2lkZ2V0QW5ub3RhdGlvbiB0ZXh0YXJlYVtkaXNhYmxlZF0sXFxyXFxuLmFubm90YXRpb25MYXllciAuY2hvaWNlV2lkZ2V0QW5ub3RhdGlvbiBzZWxlY3RbZGlzYWJsZWRdLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmJ1dHRvbldpZGdldEFubm90YXRpb24uY2hlY2tCb3ggaW5wdXRbZGlzYWJsZWRdLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmJ1dHRvbldpZGdldEFubm90YXRpb24ucmFkaW9CdXR0b24gaW5wdXRbZGlzYWJsZWRdIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiBub25lO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcblxcdGN1cnNvcjogbm90LWFsbG93ZWQ7XFxufVxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIGlucHV0OmhvdmVyLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIHRleHRhcmVhOmhvdmVyLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmNob2ljZVdpZGdldEFubm90YXRpb24gc2VsZWN0OmhvdmVyLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmJ1dHRvbldpZGdldEFubm90YXRpb24uY2hlY2tCb3ggaW5wdXQ6aG92ZXIsXFxyXFxuLmFubm90YXRpb25MYXllciAuYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbi5yYWRpb0J1dHRvbiBpbnB1dDpob3ZlciB7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgIzAwMDtcXG59XFxuLmFubm90YXRpb25MYXllciAudGV4dFdpZGdldEFubm90YXRpb24gaW5wdXQ6Zm9jdXMsXFxyXFxuLmFubm90YXRpb25MYXllciAudGV4dFdpZGdldEFubm90YXRpb24gdGV4dGFyZWE6Zm9jdXMsXFxyXFxuLmFubm90YXRpb25MYXllciAuY2hvaWNlV2lkZ2V0QW5ub3RhdGlvbiBzZWxlY3Q6Zm9jdXMge1xcclxcblxcdGJhY2tncm91bmQ6IG5vbmU7XFxyXFxuXFx0Ym9yZGVyOiAxcHggc29saWQgdHJhbnNwYXJlbnQ7XFxufVxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIGlucHV0LmNvbWIge1xcclxcblxcdGZvbnQtZmFtaWx5OiBtb25vc3BhY2U7XFxyXFxuXFx0cGFkZGluZy1sZWZ0OiAycHg7XFxyXFxuXFx0cGFkZGluZy1yaWdodDogMDtcXG59XFxuLmFubm90YXRpb25MYXllciAudGV4dFdpZGdldEFubm90YXRpb24gaW5wdXQuY29tYjpmb2N1cyB7XFxyXFxuXFx0LypcXHJcXG5cXHQgKiBMZXR0ZXIgc3BhY2luZyBpcyBwbGFjZWQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgZWFjaCBjaGFyYWN0ZXIuIEhlbmNlLCB0aGVcXHJcXG5cXHQgKiBsZXR0ZXIgc3BhY2luZyBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgbWF5IGJlIHBsYWNlZCBvdXRzaWRlIHRoZSB2aXNpYmxlXFxyXFxuXFx0ICogYXJlYSwgY2F1c2luZyBob3Jpem9udGFsIHNjcm9sbGluZy4gV2UgYXZvaWQgdGhpcyBieSBleHRlbmRpbmcgdGhlIHdpZHRoXFxyXFxuXFx0ICogd2hlbiB0aGUgZWxlbWVudCBoYXMgZm9jdXMgYW5kIHJldmVydCB0aGlzIHdoZW4gaXQgbG9zZXMgZm9jdXMuXFxyXFxuXFx0ICovXFxyXFxuXFx0d2lkdGg6IDExNSU7XFxufVxcbi5hbm5vdGF0aW9uTGF5ZXIgLmJ1dHRvbldpZGdldEFubm90YXRpb24uY2hlY2tCb3ggaW5wdXQsXFxyXFxuLmFubm90YXRpb25MYXllciAuYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbi5yYWRpb0J1dHRvbiBpbnB1dCB7XFxyXFxuXFx0LXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcclxcblxcdC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXHJcXG5cXHRhcHBlYXJhbmNlOiBub25lO1xcbn1cXG4uYW5ub3RhdGlvbkxheWVyIC5wb3B1cFdyYXBwZXIge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR3aWR0aDogMjBlbTtcXG59XFxuLmFubm90YXRpb25MYXllciAucG9wdXAge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHR6LWluZGV4OiAyMDA7XFxyXFxuXFx0bWF4LXdpZHRoOiAyMGVtO1xcclxcblxcdGJhY2tncm91bmQtY29sb3I6ICNGRkZGOTk7XFxyXFxuXFx0Ym94LXNoYWRvdzogMHB4IDJweCA1cHggIzMzMztcXHJcXG5cXHRib3JkZXItcmFkaXVzOiAycHg7XFxyXFxuXFx0cGFkZGluZzogMC42ZW07XFxyXFxuXFx0bWFyZ2luLWxlZnQ6IDVweDtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxuXFx0d29yZC13cmFwOiBicmVhay13b3JkO1xcbn1cXG4uYW5ub3RhdGlvbkxheWVyIC5wb3B1cCBoMSB7XFxyXFxuXFx0Zm9udC1zaXplOiAxZW07XFxyXFxuXFx0Ym9yZGVyLWJvdHRvbTogMXB4IHNvbGlkICMwMDAwMDA7XFxyXFxuXFx0cGFkZGluZy1ib3R0b206IDAuMmVtO1xcbn1cXG4uYW5ub3RhdGlvbkxheWVyIC5wb3B1cCBwIHtcXHJcXG5cXHRwYWRkaW5nLXRvcDogMC4yZW07XFxufVxcbi5hbm5vdGF0aW9uTGF5ZXIgLmhpZ2hsaWdodEFubm90YXRpb24sXFxyXFxuLmFubm90YXRpb25MYXllciAudW5kZXJsaW5lQW5ub3RhdGlvbixcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5zcXVpZ2dseUFubm90YXRpb24sXFxyXFxuLmFubm90YXRpb25MYXllciAuc3RyaWtlb3V0QW5ub3RhdGlvbixcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5saW5lQW5ub3RhdGlvbiBzdmcgbGluZSxcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5maWxlQXR0YWNobWVudEFubm90YXRpb24ge1xcclxcblxcdGN1cnNvcjogcG9pbnRlcjtcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovLy4vbm9kZV9tb2R1bGVzL3Z1ZTMtcGRmL3NyYy9hbm5vdGF0aW9uTGF5ZXIuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBLHVIQUF1SDtBQUV2SDtDQUNDLGtCQUFrQjtDQUNsQixPQUFPO0NBQ1AsTUFBTTtDQUNOLFFBQVE7Q0FDUixTQUFTO0FBQ1Y7QUFFQTtDQUNDLGtCQUFrQjtBQUNuQjtBQUVBO0NBQ0Msa0JBQWtCO0NBQ2xCLGNBQWM7Q0FDZCxNQUFNO0NBQ04sT0FBTztDQUNQLFdBQVc7Q0FDWCxZQUFZO0FBQ2I7QUFFQTtDQUNDLDRHQUE0RztBQUM3RztBQUVBO0NBQ0MsWUFBWTtDQUNaLGdCQUFnQjtDQUNoQiw2QkFBNkI7QUFDOUI7QUFFQTtDQUNDLGtCQUFrQjtDQUNsQixlQUFlO0FBQ2hCO0FBRUE7Ozs7O0NBS0Msd0NBQXdDO0NBQ3hDLDZCQUE2QjtDQUM3QixzQkFBc0I7Q0FDdEIsY0FBYztDQUNkLFlBQVk7Q0FDWixjQUFjO0NBQ2QsbUJBQW1CO0NBQ25CLFdBQVc7QUFDWjtBQUVBO0NBQ0MsaUJBQWlCO0NBQ2pCLGNBQWM7Q0FDZCxZQUFZO0FBQ2I7QUFFQTs7Ozs7Q0FLQyxnQkFBZ0I7Q0FDaEIsNkJBQTZCO0NBQzdCLG1CQUFtQjtBQUNwQjtBQUVBOzs7OztDQUtDLHNCQUFzQjtBQUN2QjtBQUVBOzs7Q0FHQyxnQkFBZ0I7Q0FDaEIsNkJBQTZCO0FBQzlCO0FBRUE7Q0FDQyxzQkFBc0I7Q0FDdEIsaUJBQWlCO0NBQ2pCLGdCQUFnQjtBQUNqQjtBQUVBO0NBQ0M7Ozs7O0dBS0U7Q0FDRixXQUFXO0FBQ1o7QUFFQTs7Q0FFQyx3QkFBd0I7Q0FDeEIscUJBQXFCO0NBRXJCLGdCQUFnQjtBQUNqQjtBQUVBO0NBQ0Msa0JBQWtCO0NBQ2xCLFdBQVc7QUFDWjtBQUVBO0NBQ0Msa0JBQWtCO0NBQ2xCLFlBQVk7Q0FDWixlQUFlO0NBQ2YseUJBQXlCO0NBQ3pCLDRCQUE0QjtDQUM1QixrQkFBa0I7Q0FDbEIsY0FBYztDQUNkLGdCQUFnQjtDQUNoQixlQUFlO0NBQ2YscUJBQXFCO0FBQ3RCO0FBRUE7Q0FDQyxjQUFjO0NBQ2QsZ0NBQWdDO0NBQ2hDLHFCQUFxQjtBQUN0QjtBQUVBO0NBQ0Msa0JBQWtCO0FBQ25CO0FBRUE7Ozs7OztDQU1DLGVBQWU7QUFDaEJcIixcInNvdXJjZXNDb250ZW50XCI6W1wiLyogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL3BkZi5qcy9ibG9iLzU1YTg1M2I2Njc4Y2YzZDA1NjgxZmZiYjUyMWU1MjI4ZTYwN2I1ZDIvdGVzdC9hbm5vdGF0aW9uX2xheWVyX3Rlc3QuY3NzICovXFxyXFxuXFxyXFxuLmFubm90YXRpb25MYXllciB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdGxlZnQ6IDA7XFxyXFxuXFx0dG9wOiAwO1xcclxcblxcdHJpZ2h0OiAwO1xcclxcblxcdGJvdHRvbTogMDtcXHJcXG59XFxyXFxuXFxyXFxuLmFubm90YXRpb25MYXllciBzZWN0aW9uIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxufVxcclxcblxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmxpbmtBbm5vdGF0aW9uID4gYSB7XFxyXFxuXFx0cG9zaXRpb246IGFic29sdXRlO1xcclxcblxcdGZvbnQtc2l6ZTogMWVtO1xcclxcblxcdHRvcDogMDtcXHJcXG5cXHRsZWZ0OiAwO1xcclxcblxcdHdpZHRoOiAxMDAlO1xcclxcblxcdGhlaWdodDogMTAwJTtcXHJcXG59XFxyXFxuXFxyXFxuLmFubm90YXRpb25MYXllciAubGlua0Fubm90YXRpb24gPiBhIC8qIC1tcy1hICovICB7XFxyXFxuXFx0YmFja2dyb3VuZDogdXJsKFxcXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsUjBsR09EbGhBUUFCQUlBQUFBQUFBUC8vL3lINUJBRUFBQUFBTEFBQUFBQUJBQUVBQUFJQlJBQTdcXFwiKSAwIDAgcmVwZWF0O1xcclxcbn1cXHJcXG5cXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5saW5rQW5ub3RhdGlvbiA+IGE6aG92ZXIge1xcclxcblxcdG9wYWNpdHk6IDAuMjtcXHJcXG5cXHRiYWNrZ3JvdW5kOiAjZmYwO1xcclxcblxcdGJveC1zaGFkb3c6IDBweCAycHggMTBweCAjZmYwO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5ub3RhdGlvbkxheWVyIC50ZXh0QW5ub3RhdGlvbiBpbWcge1xcclxcblxcdHBvc2l0aW9uOiBhYnNvbHV0ZTtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIGlucHV0LFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIHRleHRhcmVhLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmNob2ljZVdpZGdldEFubm90YXRpb24gc2VsZWN0LFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmJ1dHRvbldpZGdldEFubm90YXRpb24uY2hlY2tCb3ggaW5wdXQsXFxyXFxuLmFubm90YXRpb25MYXllciAuYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbi5yYWRpb0J1dHRvbiBpbnB1dCB7XFxyXFxuXFx0YmFja2dyb3VuZC1jb2xvcjogcmdiYSgwLCA1NCwgMjU1LCAwLjEzKTtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG5cXHRib3gtc2l6aW5nOiBib3JkZXItYm94O1xcclxcblxcdGZvbnQtc2l6ZTogOXB4O1xcclxcblxcdGhlaWdodDogMTAwJTtcXHJcXG5cXHRwYWRkaW5nOiAwIDNweDtcXHJcXG5cXHR2ZXJ0aWNhbC1hbGlnbjogdG9wO1xcclxcblxcdHdpZHRoOiAxMDAlO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5ub3RhdGlvbkxheWVyIC50ZXh0V2lkZ2V0QW5ub3RhdGlvbiB0ZXh0YXJlYSB7XFxyXFxuXFx0Zm9udDogbWVzc2FnZS1ib3g7XFxyXFxuXFx0Zm9udC1zaXplOiA5cHg7XFxyXFxuXFx0cmVzaXplOiBub25lO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5ub3RhdGlvbkxheWVyIC50ZXh0V2lkZ2V0QW5ub3RhdGlvbiBpbnB1dFtkaXNhYmxlZF0sXFxyXFxuLmFubm90YXRpb25MYXllciAudGV4dFdpZGdldEFubm90YXRpb24gdGV4dGFyZWFbZGlzYWJsZWRdLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmNob2ljZVdpZGdldEFubm90YXRpb24gc2VsZWN0W2Rpc2FibGVkXSxcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5idXR0b25XaWRnZXRBbm5vdGF0aW9uLmNoZWNrQm94IGlucHV0W2Rpc2FibGVkXSxcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5idXR0b25XaWRnZXRBbm5vdGF0aW9uLnJhZGlvQnV0dG9uIGlucHV0W2Rpc2FibGVkXSB7XFxyXFxuXFx0YmFja2dyb3VuZDogbm9uZTtcXHJcXG5cXHRib3JkZXI6IDFweCBzb2xpZCB0cmFuc3BhcmVudDtcXHJcXG5cXHRjdXJzb3I6IG5vdC1hbGxvd2VkO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5ub3RhdGlvbkxheWVyIC50ZXh0V2lkZ2V0QW5ub3RhdGlvbiBpbnB1dDpob3ZlcixcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC50ZXh0V2lkZ2V0QW5ub3RhdGlvbiB0ZXh0YXJlYTpob3ZlcixcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5jaG9pY2VXaWRnZXRBbm5vdGF0aW9uIHNlbGVjdDpob3ZlcixcXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5idXR0b25XaWRnZXRBbm5vdGF0aW9uLmNoZWNrQm94IGlucHV0OmhvdmVyLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmJ1dHRvbldpZGdldEFubm90YXRpb24ucmFkaW9CdXR0b24gaW5wdXQ6aG92ZXIge1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkICMwMDA7XFxyXFxufVxcclxcblxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIGlucHV0OmZvY3VzLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIHRleHRhcmVhOmZvY3VzLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmNob2ljZVdpZGdldEFubm90YXRpb24gc2VsZWN0OmZvY3VzIHtcXHJcXG5cXHRiYWNrZ3JvdW5kOiBub25lO1xcclxcblxcdGJvcmRlcjogMXB4IHNvbGlkIHRyYW5zcGFyZW50O1xcclxcbn1cXHJcXG5cXHJcXG4uYW5ub3RhdGlvbkxheWVyIC50ZXh0V2lkZ2V0QW5ub3RhdGlvbiBpbnB1dC5jb21iIHtcXHJcXG5cXHRmb250LWZhbWlseTogbW9ub3NwYWNlO1xcclxcblxcdHBhZGRpbmctbGVmdDogMnB4O1xcclxcblxcdHBhZGRpbmctcmlnaHQ6IDA7XFxyXFxufVxcclxcblxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnRleHRXaWRnZXRBbm5vdGF0aW9uIGlucHV0LmNvbWI6Zm9jdXMge1xcclxcblxcdC8qXFxyXFxuXFx0ICogTGV0dGVyIHNwYWNpbmcgaXMgcGxhY2VkIG9uIHRoZSByaWdodCBzaWRlIG9mIGVhY2ggY2hhcmFjdGVyLiBIZW5jZSwgdGhlXFxyXFxuXFx0ICogbGV0dGVyIHNwYWNpbmcgb2YgdGhlIGxhc3QgY2hhcmFjdGVyIG1heSBiZSBwbGFjZWQgb3V0c2lkZSB0aGUgdmlzaWJsZVxcclxcblxcdCAqIGFyZWEsIGNhdXNpbmcgaG9yaXpvbnRhbCBzY3JvbGxpbmcuIFdlIGF2b2lkIHRoaXMgYnkgZXh0ZW5kaW5nIHRoZSB3aWR0aFxcclxcblxcdCAqIHdoZW4gdGhlIGVsZW1lbnQgaGFzIGZvY3VzIGFuZCByZXZlcnQgdGhpcyB3aGVuIGl0IGxvc2VzIGZvY3VzLlxcclxcblxcdCAqL1xcclxcblxcdHdpZHRoOiAxMTUlO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5idXR0b25XaWRnZXRBbm5vdGF0aW9uLmNoZWNrQm94IGlucHV0LFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLmJ1dHRvbldpZGdldEFubm90YXRpb24ucmFkaW9CdXR0b24gaW5wdXQge1xcclxcblxcdC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXHJcXG5cXHQtbW96LWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxuXFx0LW1zLWFwcGVhcmFuY2U6IG5vbmU7XFxyXFxuXFx0YXBwZWFyYW5jZTogbm9uZTtcXHJcXG59XFxyXFxuXFxyXFxuLmFubm90YXRpb25MYXllciAucG9wdXBXcmFwcGVyIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0d2lkdGg6IDIwZW07XFxyXFxufVxcclxcblxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnBvcHVwIHtcXHJcXG5cXHRwb3NpdGlvbjogYWJzb2x1dGU7XFxyXFxuXFx0ei1pbmRleDogMjAwO1xcclxcblxcdG1heC13aWR0aDogMjBlbTtcXHJcXG5cXHRiYWNrZ3JvdW5kLWNvbG9yOiAjRkZGRjk5O1xcclxcblxcdGJveC1zaGFkb3c6IDBweCAycHggNXB4ICMzMzM7XFxyXFxuXFx0Ym9yZGVyLXJhZGl1czogMnB4O1xcclxcblxcdHBhZGRpbmc6IDAuNmVtO1xcclxcblxcdG1hcmdpbi1sZWZ0OiA1cHg7XFxyXFxuXFx0Y3Vyc29yOiBwb2ludGVyO1xcclxcblxcdHdvcmQtd3JhcDogYnJlYWstd29yZDtcXHJcXG59XFxyXFxuXFxyXFxuLmFubm90YXRpb25MYXllciAucG9wdXAgaDEge1xcclxcblxcdGZvbnQtc2l6ZTogMWVtO1xcclxcblxcdGJvcmRlci1ib3R0b206IDFweCBzb2xpZCAjMDAwMDAwO1xcclxcblxcdHBhZGRpbmctYm90dG9tOiAwLjJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmFubm90YXRpb25MYXllciAucG9wdXAgcCB7XFxyXFxuXFx0cGFkZGluZy10b3A6IDAuMmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uYW5ub3RhdGlvbkxheWVyIC5oaWdobGlnaHRBbm5vdGF0aW9uLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnVuZGVybGluZUFubm90YXRpb24sXFxyXFxuLmFubm90YXRpb25MYXllciAuc3F1aWdnbHlBbm5vdGF0aW9uLFxcclxcbi5hbm5vdGF0aW9uTGF5ZXIgLnN0cmlrZW91dEFubm90YXRpb24sXFxyXFxuLmFubm90YXRpb25MYXllciAubGluZUFubm90YXRpb24gc3ZnIGxpbmUsXFxyXFxuLmFubm90YXRpb25MYXllciAuZmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uIHtcXHJcXG5cXHRjdXJzb3I6IHBvaW50ZXI7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css\n");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.scss":
/*!*************************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.scss ***!
  \*************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/cssWithMappingToString.js */ \"./node_modules/css-loader/dist/runtime/cssWithMappingToString.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);\n// Imports\n\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_cssWithMappingToString_js__WEBPACK_IMPORTED_MODULE_0___default()));\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".modal-dialog\\r\\n{\\r\\n    width: 80% !important;\\r\\n    min-width: 80% !important;\\r\\n    max-width: 80% !important;\\r\\n}\\r\\n\\r\\n.modal-content\\r\\n{\\r\\n    height: 90vh !important;\\r\\n}\\r\\n\\r\\n.button-pdf\\r\\n{\\r\\n    height: calc(5%);\\r\\n}\\r\\n\\r\\n.pdf\\r\\n{\\r\\n    height: calc(95%);\\r\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.scss\"],\"names\":[],\"mappings\":\"AAAA;;IAEI,qBAAqB;IACrB,yBAAyB;IACzB,yBAAyB;AAC7B;;AAEA;;IAEI,uBAAuB;AAC3B;;AAEA;;IAEI,gBAAgB;AACpB;;AAEA;;IAEI,iBAAiB;AACrB\",\"sourcesContent\":[\".modal-dialog\\r\\n{\\r\\n    width: 80% !important;\\r\\n    min-width: 80% !important;\\r\\n    max-width: 80% !important;\\r\\n}\\r\\n\\r\\n.modal-content\\r\\n{\\r\\n    height: 90vh !important;\\r\\n}\\r\\n\\r\\n.button-pdf\\r\\n{\\r\\n    height: calc(5%);\\r\\n}\\r\\n\\r\\n.pdf\\r\\n{\\r\\n    height: calc(95%);\\r\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC5zY3NzP2FlMDgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNxSTtBQUM3QjtBQUN4Ryw4QkFBOEIsbUZBQTJCLENBQUMsd0dBQXFDO0FBQy9GO0FBQ0EsNERBQTRELDhCQUE4QixrQ0FBa0Msa0NBQWtDLEtBQUssMkJBQTJCLGdDQUFnQyxLQUFLLHdCQUF3Qix5QkFBeUIsS0FBSyxpQkFBaUIsMEJBQTBCLEtBQUssT0FBTyx5SkFBeUosWUFBWSxhQUFhLGFBQWEsT0FBTyxNQUFNLFlBQVksT0FBTyxNQUFNLFlBQVksT0FBTyxNQUFNLFlBQVksNENBQTRDLDhCQUE4QixrQ0FBa0Msa0NBQWtDLEtBQUssMkJBQTJCLGdDQUFnQyxLQUFLLHdCQUF3Qix5QkFBeUIsS0FBSyxpQkFBaUIsMEJBQTBCLEtBQUssbUJBQW1CO0FBQ3Q2QjtBQUNBLGlFQUFlLHVCQUF1QixFQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOS51c2VbMV0hLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gSW1wb3J0c1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18gZnJvbSBcIi4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9jc3NXaXRoTWFwcGluZ1RvU3RyaW5nLmpzXCI7XG5pbXBvcnQgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fIGZyb20gXCIuLi8uLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzXCI7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18oX19fQ1NTX0xPQURFUl9BUElfU09VUkNFTUFQX0lNUE9SVF9fXyk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIubW9kYWwtZGlhbG9nXFxyXFxue1xcclxcbiAgICB3aWR0aDogODAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIG1pbi13aWR0aDogODAlICFpbXBvcnRhbnQ7XFxyXFxuICAgIG1heC13aWR0aDogODAlICFpbXBvcnRhbnQ7XFxyXFxufVxcclxcblxcclxcbi5tb2RhbC1jb250ZW50XFxyXFxue1xcclxcbiAgICBoZWlnaHQ6IDkwdmggIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1dHRvbi1wZGZcXHJcXG57XFxyXFxuICAgIGhlaWdodDogY2FsYyg1JSk7XFxyXFxufVxcclxcblxcclxcbi5wZGZcXHJcXG57XFxyXFxuICAgIGhlaWdodDogY2FsYyg5NSUpO1xcclxcbn1cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC5zY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOztJQUVJLHFCQUFxQjtJQUNyQix5QkFBeUI7SUFDekIseUJBQXlCO0FBQzdCOztBQUVBOztJQUVJLHVCQUF1QjtBQUMzQjs7QUFFQTs7SUFFSSxnQkFBZ0I7QUFDcEI7O0FBRUE7O0lBRUksaUJBQWlCO0FBQ3JCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5tb2RhbC1kaWFsb2dcXHJcXG57XFxyXFxuICAgIHdpZHRoOiA4MCUgIWltcG9ydGFudDtcXHJcXG4gICAgbWluLXdpZHRoOiA4MCUgIWltcG9ydGFudDtcXHJcXG4gICAgbWF4LXdpZHRoOiA4MCUgIWltcG9ydGFudDtcXHJcXG59XFxyXFxuXFxyXFxuLm1vZGFsLWNvbnRlbnRcXHJcXG57XFxyXFxuICAgIGhlaWdodDogOTB2aCAhaW1wb3J0YW50O1xcclxcbn1cXHJcXG5cXHJcXG4uYnV0dG9uLXBkZlxcclxcbntcXHJcXG4gICAgaGVpZ2h0OiBjYWxjKDUlKTtcXHJcXG59XFxyXFxuXFxyXFxuLnBkZlxcclxcbntcXHJcXG4gICAgaGVpZ2h0OiBjYWxjKDk1JSk7XFxyXFxufVwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.scss\n");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz85MTUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/***/ ((module) => {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcz9lM2RiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/isarray/index.js\n");

/***/ }),

/***/ "./node_modules/mitt/dist/mitt.es.js":
/*!*******************************************!*\
  !*** ./node_modules/mitt/dist/mitt.es.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i&&i.push(e)||n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&i.splice(i.indexOf(e)>>>0,1)},emit:function(t,e){(n.get(t)||[]).slice().map(function(n){n(e)}),(n.get(\"*\")||[]).slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWl0dC9kaXN0L21pdHQuZXMuanM/MTRiNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsNkJBQWUsb0NBQVMsR0FBRyxPQUFPLGtDQUFrQyxlQUFlLDJCQUEyQixtQkFBbUIsZUFBZSxnQ0FBZ0Msb0JBQW9CLHVDQUF1QyxLQUFLLDJDQUEyQyxPQUFPO0FBQ2xTIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL21pdHQvZGlzdC9taXR0LmVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obil7cmV0dXJue2FsbDpuPW58fG5ldyBNYXAsb246ZnVuY3Rpb24odCxlKXt2YXIgaT1uLmdldCh0KTtpJiZpLnB1c2goZSl8fG4uc2V0KHQsW2VdKX0sb2ZmOmZ1bmN0aW9uKHQsZSl7dmFyIGk9bi5nZXQodCk7aSYmaS5zcGxpY2UoaS5pbmRleE9mKGUpPj4+MCwxKX0sZW1pdDpmdW5jdGlvbih0LGUpeyhuLmdldCh0KXx8W10pLnNsaWNlKCkubWFwKGZ1bmN0aW9uKG4pe24oZSl9KSwobi5nZXQoXCIqXCIpfHxbXSkuc2xpY2UoKS5tYXAoZnVuY3Rpb24obil7bih0LGUpfSl9fX1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1pdHQuZXMuanMubWFwXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mitt/dist/mitt.es.js\n");

/***/ }),

/***/ "./node_modules/pdfjs-dist-sig/es5/build/pdf.js":
/*!******************************************************!*\
  !*** ./node_modules/pdfjs-dist-sig/es5/build/pdf.js ***!
  \******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n/**\n * @licstart The following is the entire license notice for the\n * Javascript code in this page\n *\n * Copyright 2020 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * Javascript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__w_pdfjs_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__w_pdfjs_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__w_pdfjs_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__w_pdfjs_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__w_pdfjs_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__w_pdfjs_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __w_pdfjs_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__w_pdfjs_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __w_pdfjs_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__w_pdfjs_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__w_pdfjs_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__w_pdfjs_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __w_pdfjs_require__(__w_pdfjs_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"addLinkAttributes\", {\n  enumerable: true,\n  get: function get() {\n    return _display_utils.addLinkAttributes;\n  }\n});\nObject.defineProperty(exports, \"getFilenameFromUrl\", {\n  enumerable: true,\n  get: function get() {\n    return _display_utils.getFilenameFromUrl;\n  }\n});\nObject.defineProperty(exports, \"LinkTarget\", {\n  enumerable: true,\n  get: function get() {\n    return _display_utils.LinkTarget;\n  }\n});\nObject.defineProperty(exports, \"loadScript\", {\n  enumerable: true,\n  get: function get() {\n    return _display_utils.loadScript;\n  }\n});\nObject.defineProperty(exports, \"PDFDateString\", {\n  enumerable: true,\n  get: function get() {\n    return _display_utils.PDFDateString;\n  }\n});\nObject.defineProperty(exports, \"RenderingCancelledException\", {\n  enumerable: true,\n  get: function get() {\n    return _display_utils.RenderingCancelledException;\n  }\n});\nObject.defineProperty(exports, \"build\", {\n  enumerable: true,\n  get: function get() {\n    return _api.build;\n  }\n});\nObject.defineProperty(exports, \"getDocument\", {\n  enumerable: true,\n  get: function get() {\n    return _api.getDocument;\n  }\n});\nObject.defineProperty(exports, \"LoopbackPort\", {\n  enumerable: true,\n  get: function get() {\n    return _api.LoopbackPort;\n  }\n});\nObject.defineProperty(exports, \"PDFDataRangeTransport\", {\n  enumerable: true,\n  get: function get() {\n    return _api.PDFDataRangeTransport;\n  }\n});\nObject.defineProperty(exports, \"PDFWorker\", {\n  enumerable: true,\n  get: function get() {\n    return _api.PDFWorker;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function get() {\n    return _api.version;\n  }\n});\nObject.defineProperty(exports, \"CMapCompressionType\", {\n  enumerable: true,\n  get: function get() {\n    return _util.CMapCompressionType;\n  }\n});\nObject.defineProperty(exports, \"createObjectURL\", {\n  enumerable: true,\n  get: function get() {\n    return _util.createObjectURL;\n  }\n});\nObject.defineProperty(exports, \"createPromiseCapability\", {\n  enumerable: true,\n  get: function get() {\n    return _util.createPromiseCapability;\n  }\n});\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", {\n  enumerable: true,\n  get: function get() {\n    return _util.createValidAbsoluteUrl;\n  }\n});\nObject.defineProperty(exports, \"InvalidPDFException\", {\n  enumerable: true,\n  get: function get() {\n    return _util.InvalidPDFException;\n  }\n});\nObject.defineProperty(exports, \"MissingPDFException\", {\n  enumerable: true,\n  get: function get() {\n    return _util.MissingPDFException;\n  }\n});\nObject.defineProperty(exports, \"OPS\", {\n  enumerable: true,\n  get: function get() {\n    return _util.OPS;\n  }\n});\nObject.defineProperty(exports, \"PasswordResponses\", {\n  enumerable: true,\n  get: function get() {\n    return _util.PasswordResponses;\n  }\n});\nObject.defineProperty(exports, \"PermissionFlag\", {\n  enumerable: true,\n  get: function get() {\n    return _util.PermissionFlag;\n  }\n});\nObject.defineProperty(exports, \"removeNullCharacters\", {\n  enumerable: true,\n  get: function get() {\n    return _util.removeNullCharacters;\n  }\n});\nObject.defineProperty(exports, \"shadow\", {\n  enumerable: true,\n  get: function get() {\n    return _util.shadow;\n  }\n});\nObject.defineProperty(exports, \"UnexpectedResponseException\", {\n  enumerable: true,\n  get: function get() {\n    return _util.UnexpectedResponseException;\n  }\n});\nObject.defineProperty(exports, \"UNSUPPORTED_FEATURES\", {\n  enumerable: true,\n  get: function get() {\n    return _util.UNSUPPORTED_FEATURES;\n  }\n});\nObject.defineProperty(exports, \"Util\", {\n  enumerable: true,\n  get: function get() {\n    return _util.Util;\n  }\n});\nObject.defineProperty(exports, \"VerbosityLevel\", {\n  enumerable: true,\n  get: function get() {\n    return _util.VerbosityLevel;\n  }\n});\nObject.defineProperty(exports, \"AnnotationLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _annotation_layer.AnnotationLayer;\n  }\n});\nObject.defineProperty(exports, \"apiCompatibilityParams\", {\n  enumerable: true,\n  get: function get() {\n    return _api_compatibility.apiCompatibilityParams;\n  }\n});\nObject.defineProperty(exports, \"GlobalWorkerOptions\", {\n  enumerable: true,\n  get: function get() {\n    return _worker_options.GlobalWorkerOptions;\n  }\n});\nObject.defineProperty(exports, \"renderTextLayer\", {\n  enumerable: true,\n  get: function get() {\n    return _text_layer.renderTextLayer;\n  }\n});\nObject.defineProperty(exports, \"SVGGraphics\", {\n  enumerable: true,\n  get: function get() {\n    return _svg.SVGGraphics;\n  }\n});\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _api = __w_pdfjs_require__(202);\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _annotation_layer = __w_pdfjs_require__(216);\n\nvar _api_compatibility = __w_pdfjs_require__(206);\n\nvar _worker_options = __w_pdfjs_require__(209);\n\nvar _text_layer = __w_pdfjs_require__(217);\n\nvar _svg = __w_pdfjs_require__(218);\n\nvar pdfjsVersion = '2.6.347';\nvar pdfjsBuild = '3be9c65f';\n{\n  var _require = __w_pdfjs_require__(7),\n      isNodeJS = _require.isNodeJS;\n\n  if (isNodeJS) {\n    var PDFNodeStream = __w_pdfjs_require__(219).PDFNodeStream;\n\n    (0, _api.setPDFNetworkStreamFactory)(function (params) {\n      return new PDFNodeStream(params);\n    });\n  } else {\n    var PDFNetworkStream = __w_pdfjs_require__(222).PDFNetworkStream;\n\n    var PDFFetchStream;\n\n    if ((0, _display_utils.isFetchSupported)()) {\n      PDFFetchStream = __w_pdfjs_require__(223).PDFFetchStream;\n    }\n\n    (0, _api.setPDFNetworkStreamFactory)(function (params) {\n      if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) {\n        return new PDFFetchStream(params);\n      }\n\n      return new PDFNetworkStream(params);\n    });\n  }\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.addLinkAttributes = addLinkAttributes;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.isFetchSupported = isFetchSupported;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\nexports.deprecated = deprecated;\nexports.PDFDateString = exports.StatTimer = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.BaseCMapReaderFactory = exports.DOMCanvasFactory = exports.BaseCanvasFactory = exports.DEFAULT_LINK_REL = exports.LinkTarget = exports.RenderingCancelledException = exports.PageViewport = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(5);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULT_LINK_REL = \"noopener noreferrer nofollow\";\nexports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;\nvar SVG_NS = \"http://www.w3.org/2000/svg\";\n\nvar BaseCanvasFactory = /*#__PURE__*/function () {\n  function BaseCanvasFactory() {\n    _classCallCheck(this, BaseCanvasFactory);\n\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n\n  _createClass(BaseCanvasFactory, [{\n    key: \"create\",\n    value: function create(width, height) {\n      (0, _util.unreachable)(\"Abstract method `create` called.\");\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(canvasAndContext, width, height) {\n      if (!canvasAndContext.canvas) {\n        throw new Error(\"Canvas is not specified\");\n      }\n\n      if (width <= 0 || height <= 0) {\n        throw new Error(\"Invalid canvas size\");\n      }\n\n      canvasAndContext.canvas.width = width;\n      canvasAndContext.canvas.height = height;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy(canvasAndContext) {\n      if (!canvasAndContext.canvas) {\n        throw new Error(\"Canvas is not specified\");\n      }\n\n      canvasAndContext.canvas.width = 0;\n      canvasAndContext.canvas.height = 0;\n      canvasAndContext.canvas = null;\n      canvasAndContext.context = null;\n    }\n  }]);\n\n  return BaseCanvasFactory;\n}();\n\nexports.BaseCanvasFactory = BaseCanvasFactory;\n\nvar DOMCanvasFactory = /*#__PURE__*/function (_BaseCanvasFactory) {\n  _inherits(DOMCanvasFactory, _BaseCanvasFactory);\n\n  var _super = _createSuper(DOMCanvasFactory);\n\n  function DOMCanvasFactory() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$ownerDocument = _ref.ownerDocument,\n        ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;\n\n    _classCallCheck(this, DOMCanvasFactory);\n\n    _this = _super.call(this);\n    _this._document = ownerDocument;\n    return _this;\n  }\n\n  _createClass(DOMCanvasFactory, [{\n    key: \"create\",\n    value: function create(width, height) {\n      if (width <= 0 || height <= 0) {\n        throw new Error(\"Invalid canvas size\");\n      }\n\n      var canvas = this._document.createElement(\"canvas\");\n\n      var context = canvas.getContext(\"2d\");\n      canvas.width = width;\n      canvas.height = height;\n      return {\n        canvas: canvas,\n        context: context\n      };\n    }\n  }]);\n\n  return DOMCanvasFactory;\n}(BaseCanvasFactory);\n\nexports.DOMCanvasFactory = DOMCanvasFactory;\n\nvar BaseCMapReaderFactory = /*#__PURE__*/function () {\n  function BaseCMapReaderFactory(_ref2) {\n    var _ref2$baseUrl = _ref2.baseUrl,\n        baseUrl = _ref2$baseUrl === void 0 ? null : _ref2$baseUrl,\n        _ref2$isCompressed = _ref2.isCompressed,\n        isCompressed = _ref2$isCompressed === void 0 ? false : _ref2$isCompressed;\n\n    _classCallCheck(this, BaseCMapReaderFactory);\n\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n\n  _createClass(BaseCMapReaderFactory, [{\n    key: \"fetch\",\n    value: function () {\n      var _fetch = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(_ref3) {\n        var _this2 = this;\n\n        var name, url, compressionType;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                name = _ref3.name;\n\n                if (this.baseUrl) {\n                  _context.next = 3;\n                  break;\n                }\n\n                throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n\n              case 3:\n                if (name) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"CMap name must be specified.\");\n\n              case 5:\n                url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n                compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n                return _context.abrupt(\"return\", this._fetchData(url, compressionType)[\"catch\"](function (reason) {\n                  throw new Error(\"Unable to load \".concat(_this2.isCompressed ? \"binary \" : \"\", \"CMap at: \").concat(url));\n                }));\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function fetch(_x) {\n        return _fetch.apply(this, arguments);\n      }\n\n      return fetch;\n    }()\n  }, {\n    key: \"_fetchData\",\n    value: function _fetchData(url, compressionType) {\n      (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n    }\n  }]);\n\n  return BaseCMapReaderFactory;\n}();\n\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\n\nvar DOMCMapReaderFactory = /*#__PURE__*/function (_BaseCMapReaderFactor) {\n  _inherits(DOMCMapReaderFactory, _BaseCMapReaderFactor);\n\n  var _super2 = _createSuper(DOMCMapReaderFactory);\n\n  function DOMCMapReaderFactory() {\n    _classCallCheck(this, DOMCMapReaderFactory);\n\n    return _super2.apply(this, arguments);\n  }\n\n  _createClass(DOMCMapReaderFactory, [{\n    key: \"_fetchData\",\n    value: function _fetchData(url, compressionType) {\n      var _this3 = this;\n\n      if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) {\n        return fetch(url).then( /*#__PURE__*/function () {\n          var _ref4 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(response) {\n            var cMapData;\n            return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    if (response.ok) {\n                      _context2.next = 2;\n                      break;\n                    }\n\n                    throw new Error(response.statusText);\n\n                  case 2:\n                    if (!_this3.isCompressed) {\n                      _context2.next = 10;\n                      break;\n                    }\n\n                    _context2.t0 = Uint8Array;\n                    _context2.next = 6;\n                    return response.arrayBuffer();\n\n                  case 6:\n                    _context2.t1 = _context2.sent;\n                    cMapData = new _context2.t0(_context2.t1);\n                    _context2.next = 15;\n                    break;\n\n                  case 10:\n                    _context2.t2 = _util.stringToBytes;\n                    _context2.next = 13;\n                    return response.text();\n\n                  case 13:\n                    _context2.t3 = _context2.sent;\n                    cMapData = (0, _context2.t2)(_context2.t3);\n\n                  case 15:\n                    return _context2.abrupt(\"return\", {\n                      cMapData: cMapData,\n                      compressionType: compressionType\n                    });\n\n                  case 16:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2);\n          }));\n\n          return function (_x2) {\n            return _ref4.apply(this, arguments);\n          };\n        }());\n      }\n\n      return new Promise(function (resolve, reject) {\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", url, true);\n\n        if (_this3.isCompressed) {\n          request.responseType = \"arraybuffer\";\n        }\n\n        request.onreadystatechange = function () {\n          if (request.readyState !== XMLHttpRequest.DONE) {\n            return;\n          }\n\n          if (request.status === 200 || request.status === 0) {\n            var cMapData;\n\n            if (_this3.isCompressed && request.response) {\n              cMapData = new Uint8Array(request.response);\n            } else if (!_this3.isCompressed && request.responseText) {\n              cMapData = (0, _util.stringToBytes)(request.responseText);\n            }\n\n            if (cMapData) {\n              resolve({\n                cMapData: cMapData,\n                compressionType: compressionType\n              });\n              return;\n            }\n          }\n\n          reject(new Error(request.statusText));\n        };\n\n        request.send(null);\n      });\n    }\n  }]);\n\n  return DOMCMapReaderFactory;\n}(BaseCMapReaderFactory);\n\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\n\nvar DOMSVGFactory = /*#__PURE__*/function () {\n  function DOMSVGFactory() {\n    _classCallCheck(this, DOMSVGFactory);\n  }\n\n  _createClass(DOMSVGFactory, [{\n    key: \"create\",\n    value: function create(width, height) {\n      (0, _util.assert)(width > 0 && height > 0, \"Invalid SVG dimensions\");\n      var svg = document.createElementNS(SVG_NS, \"svg:svg\");\n      svg.setAttribute(\"version\", \"1.1\");\n      svg.setAttribute(\"width\", width + \"px\");\n      svg.setAttribute(\"height\", height + \"px\");\n      svg.setAttribute(\"preserveAspectRatio\", \"none\");\n      svg.setAttribute(\"viewBox\", \"0 0 \" + width + \" \" + height);\n      return svg;\n    }\n  }, {\n    key: \"createElement\",\n    value: function createElement(type) {\n      (0, _util.assert)(typeof type === \"string\", \"Invalid SVG element type\");\n      return document.createElementNS(SVG_NS, type);\n    }\n  }]);\n\n  return DOMSVGFactory;\n}();\n\nexports.DOMSVGFactory = DOMSVGFactory;\n\nvar PageViewport = /*#__PURE__*/function () {\n  function PageViewport(_ref5) {\n    var viewBox = _ref5.viewBox,\n        scale = _ref5.scale,\n        rotation = _ref5.rotation,\n        _ref5$offsetX = _ref5.offsetX,\n        offsetX = _ref5$offsetX === void 0 ? 0 : _ref5$offsetX,\n        _ref5$offsetY = _ref5.offsetY,\n        offsetY = _ref5$offsetY === void 0 ? 0 : _ref5$offsetY,\n        _ref5$dontFlip = _ref5.dontFlip,\n        dontFlip = _ref5$dontFlip === void 0 ? false : _ref5$dontFlip;\n\n    _classCallCheck(this, PageViewport);\n\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    var centerX = (viewBox[2] + viewBox[0]) / 2;\n    var centerY = (viewBox[3] + viewBox[1]) / 2;\n    var rotateA, rotateB, rotateC, rotateD;\n    rotation = rotation % 360;\n    rotation = rotation < 0 ? rotation + 360 : rotation;\n\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n\n    var offsetCanvasX, offsetCanvasY;\n    var width, height;\n\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n\n  _createClass(PageViewport, [{\n    key: \"clone\",\n    value: function clone() {\n      var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref6$scale = _ref6.scale,\n          scale = _ref6$scale === void 0 ? this.scale : _ref6$scale,\n          _ref6$rotation = _ref6.rotation,\n          rotation = _ref6$rotation === void 0 ? this.rotation : _ref6$rotation,\n          _ref6$offsetX = _ref6.offsetX,\n          offsetX = _ref6$offsetX === void 0 ? this.offsetX : _ref6$offsetX,\n          _ref6$offsetY = _ref6.offsetY,\n          offsetY = _ref6$offsetY === void 0 ? this.offsetY : _ref6$offsetY,\n          _ref6$dontFlip = _ref6.dontFlip,\n          dontFlip = _ref6$dontFlip === void 0 ? false : _ref6$dontFlip;\n\n      return new PageViewport({\n        viewBox: this.viewBox.slice(),\n        scale: scale,\n        rotation: rotation,\n        offsetX: offsetX,\n        offsetY: offsetY,\n        dontFlip: dontFlip\n      });\n    }\n  }, {\n    key: \"convertToViewportPoint\",\n    value: function convertToViewportPoint(x, y) {\n      return _util.Util.applyTransform([x, y], this.transform);\n    }\n  }, {\n    key: \"convertToViewportRectangle\",\n    value: function convertToViewportRectangle(rect) {\n      var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n\n      var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n\n      return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n    }\n  }, {\n    key: \"convertToPdfPoint\",\n    value: function convertToPdfPoint(x, y) {\n      return _util.Util.applyInverseTransform([x, y], this.transform);\n    }\n  }]);\n\n  return PageViewport;\n}();\n\nexports.PageViewport = PageViewport;\n\nvar RenderingCancelledException = /*#__PURE__*/function (_BaseException) {\n  _inherits(RenderingCancelledException, _BaseException);\n\n  var _super3 = _createSuper(RenderingCancelledException);\n\n  function RenderingCancelledException(msg, type) {\n    var _this4;\n\n    _classCallCheck(this, RenderingCancelledException);\n\n    _this4 = _super3.call(this, msg);\n    _this4.type = type;\n    return _this4;\n  }\n\n  return RenderingCancelledException;\n}(_util.BaseException);\n\nexports.RenderingCancelledException = RenderingCancelledException;\nvar LinkTarget = {\n  NONE: 0,\n  SELF: 1,\n  BLANK: 2,\n  PARENT: 3,\n  TOP: 4\n};\nexports.LinkTarget = LinkTarget;\n\nfunction addLinkAttributes(link) {\n  var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      url = _ref7.url,\n      target = _ref7.target,\n      rel = _ref7.rel,\n      _ref7$enabled = _ref7.enabled,\n      enabled = _ref7$enabled === void 0 ? true : _ref7$enabled;\n\n  (0, _util.assert)(url && typeof url === \"string\", 'addLinkAttributes: A valid \"url\" parameter must provided.');\n  var urlNullRemoved = (0, _util.removeNullCharacters)(url);\n\n  if (enabled) {\n    link.href = link.title = urlNullRemoved;\n  } else {\n    link.href = \"\";\n    link.title = \"Disabled: \".concat(urlNullRemoved);\n\n    link.onclick = function () {\n      return false;\n    };\n  }\n\n  var targetStr = \"\";\n\n  switch (target) {\n    case LinkTarget.NONE:\n      break;\n\n    case LinkTarget.SELF:\n      targetStr = \"_self\";\n      break;\n\n    case LinkTarget.BLANK:\n      targetStr = \"_blank\";\n      break;\n\n    case LinkTarget.PARENT:\n      targetStr = \"_parent\";\n      break;\n\n    case LinkTarget.TOP:\n      targetStr = \"_top\";\n      break;\n  }\n\n  link.target = targetStr;\n  link.rel = typeof rel === \"string\" ? rel : DEFAULT_LINK_REL;\n}\n\nfunction getFilenameFromUrl(url) {\n  var anchor = url.indexOf(\"#\");\n  var query = url.indexOf(\"?\");\n  var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);\n  return url.substring(url.lastIndexOf(\"/\", end) + 1, end);\n}\n\nvar StatTimer = /*#__PURE__*/function () {\n  function StatTimer() {\n    _classCallCheck(this, StatTimer);\n\n    this.started = Object.create(null);\n    this.times = [];\n  }\n\n  _createClass(StatTimer, [{\n    key: \"time\",\n    value: function time(name) {\n      if (name in this.started) {\n        (0, _util.warn)(\"Timer is already running for \".concat(name));\n      }\n\n      this.started[name] = Date.now();\n    }\n  }, {\n    key: \"timeEnd\",\n    value: function timeEnd(name) {\n      if (!(name in this.started)) {\n        (0, _util.warn)(\"Timer has not been started for \".concat(name));\n      }\n\n      this.times.push({\n        name: name,\n        start: this.started[name],\n        end: Date.now()\n      });\n      delete this.started[name];\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var outBuf = [];\n      var longest = 0;\n\n      var _iterator = _createForOfIteratorHelper(this.times),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var time = _step.value;\n          var name = time.name;\n\n          if (name.length > longest) {\n            longest = name.length;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.times),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _time = _step2.value;\n          var duration = _time.end - _time.start;\n          outBuf.push(\"\".concat(_time.name.padEnd(longest), \" \").concat(duration, \"ms\\n\"));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return outBuf.join(\"\");\n    }\n  }]);\n\n  return StatTimer;\n}();\n\nexports.StatTimer = StatTimer;\n\nfunction isFetchSupported() {\n  return typeof fetch !== \"undefined\" && typeof Response !== \"undefined\" && \"body\" in Response.prototype && typeof ReadableStream !== \"undefined\";\n}\n\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    var _ref8 = baseUrl ? new URL(url, baseUrl) : new URL(url),\n        protocol = _ref8.protocol;\n\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch (ex) {\n    return false;\n  }\n}\n\nfunction loadScript(src) {\n  return new Promise(function (resolve, reject) {\n    var script = document.createElement(\"script\");\n    script.src = src;\n    script.onload = resolve;\n\n    script.onerror = function () {\n      reject(new Error(\"Cannot load script at: \".concat(script.src)));\n    };\n\n    (document.head || document.documentElement).appendChild(script);\n  });\n}\n\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\n\nvar pdfDateStringRegex;\n\nvar PDFDateString = /*#__PURE__*/function () {\n  function PDFDateString() {\n    _classCallCheck(this, PDFDateString);\n  }\n\n  _createClass(PDFDateString, null, [{\n    key: \"toDateObject\",\n    value: function toDateObject(input) {\n      if (!input || !(0, _util.isString)(input)) {\n        return null;\n      }\n\n      if (!pdfDateStringRegex) {\n        pdfDateStringRegex = new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n      }\n\n      var matches = pdfDateStringRegex.exec(input);\n\n      if (!matches) {\n        return null;\n      }\n\n      var year = parseInt(matches[1], 10);\n      var month = parseInt(matches[2], 10);\n      month = month >= 1 && month <= 12 ? month - 1 : 0;\n      var day = parseInt(matches[3], 10);\n      day = day >= 1 && day <= 31 ? day : 1;\n      var hour = parseInt(matches[4], 10);\n      hour = hour >= 0 && hour <= 23 ? hour : 0;\n      var minute = parseInt(matches[5], 10);\n      minute = minute >= 0 && minute <= 59 ? minute : 0;\n      var second = parseInt(matches[6], 10);\n      second = second >= 0 && second <= 59 ? second : 0;\n      var universalTimeRelation = matches[7] || \"Z\";\n      var offsetHour = parseInt(matches[8], 10);\n      offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n      var offsetMinute = parseInt(matches[9], 10) || 0;\n      offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n\n      if (universalTimeRelation === \"-\") {\n        hour += offsetHour;\n        minute += offsetMinute;\n      } else if (universalTimeRelation === \"+\") {\n        hour -= offsetHour;\n        minute -= offsetMinute;\n      }\n\n      return new Date(Date.UTC(year, month, day, hour, minute, second));\n    }\n  }]);\n\n  return PDFDateString;\n}();\n\nexports.PDFDateString = PDFDateString;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __w_pdfjs_require__(3);\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(module) {\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined;\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap;\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && _typeof(value) === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    }\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n\n  exports.AsyncIterator = AsyncIterator;\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator[\"return\"]) {\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      context[delegate.resultName] = info.value;\n      context.next = delegate.nextLoc;\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      return info;\n    }\n\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse();\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function stop() {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n  return exports;\n}((  false ? 0 : _typeof(module)) === \"object\" ? module.exports : {});\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n/* WEBPACK VAR INJECTION */}.call(this, __w_pdfjs_require__(4)(module)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = [];\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.arrayByteLength = arrayByteLength;\nexports.arraysToBytes = arraysToBytes;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createPromiseCapability = createPromiseCapability;\nexports.escapeString = escapeString;\nexports.getModificationDate = getModificationDate;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isBool = isBool;\nexports.isNum = isNum;\nexports.isString = isString;\nexports.isSameOrigin = isSameOrigin;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.removeNullCharacters = removeNullCharacters;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\nexports.unreachable = unreachable;\nexports.IsEvalSupportedCached = exports.IsLittleEndianCached = exports.createObjectURL = exports.FormatError = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.MissingPDFException = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VerbosityLevel = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = exports.BaseException = void 0;\n\n__w_pdfjs_require__(6);\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nvar FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nvar PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nvar TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nvar ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nvar AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nvar AnnotationStateModelType = {\n  MARKED: \"Marked\",\n  REVIEW: \"Review\"\n};\nexports.AnnotationStateModelType = AnnotationStateModelType;\nvar AnnotationMarkedState = {\n  MARKED: \"Marked\",\n  UNMARKED: \"Unmarked\"\n};\nexports.AnnotationMarkedState = AnnotationMarkedState;\nvar AnnotationReviewState = {\n  ACCEPTED: \"Accepted\",\n  REJECTED: \"Rejected\",\n  CANCELLED: \"Cancelled\",\n  COMPLETED: \"Completed\",\n  NONE: \"None\"\n};\nexports.AnnotationReviewState = AnnotationReviewState;\nvar AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nvar AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nvar AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nvar AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nvar StreamType = {\n  UNKNOWN: \"UNKNOWN\",\n  FLATE: \"FLATE\",\n  LZW: \"LZW\",\n  DCT: \"DCT\",\n  JPX: \"JPX\",\n  JBIG: \"JBIG\",\n  A85: \"A85\",\n  AHX: \"AHX\",\n  CCF: \"CCF\",\n  RLX: \"RLX\"\n};\nexports.StreamType = StreamType;\nvar FontType = {\n  UNKNOWN: \"UNKNOWN\",\n  TYPE1: \"TYPE1\",\n  TYPE1C: \"TYPE1C\",\n  CIDFONTTYPE0: \"CIDFONTTYPE0\",\n  CIDFONTTYPE0C: \"CIDFONTTYPE0C\",\n  TRUETYPE: \"TRUETYPE\",\n  CIDFONTTYPE2: \"CIDFONTTYPE2\",\n  TYPE3: \"TYPE3\",\n  OPENTYPE: \"OPENTYPE\",\n  TYPE0: \"TYPE0\",\n  MMTYPE1: \"MMTYPE1\"\n};\nexports.FontType = FontType;\nvar VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nvar CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1,\n  STREAM: 2\n};\nexports.CMapCompressionType = CMapCompressionType;\nvar OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nvar UNSUPPORTED_FEATURES = {\n  unknown: \"unknown\",\n  forms: \"forms\",\n  javaScript: \"javaScript\",\n  smask: \"smask\",\n  shadingPattern: \"shadingPattern\",\n  font: \"font\",\n  errorTilingPattern: \"errorTilingPattern\",\n  errorExtGState: \"errorExtGState\",\n  errorXObject: \"errorXObject\",\n  errorFontLoadType3: \"errorFontLoadType3\",\n  errorFontState: \"errorFontState\",\n  errorFontMissing: \"errorFontMissing\",\n  errorFontTranslate: \"errorFontTranslate\",\n  errorColorSpace: \"errorColorSpace\",\n  errorOperatorList: \"errorOperatorList\",\n  errorFontToUnicode: \"errorFontToUnicode\",\n  errorFontLoadNative: \"errorFontLoadNative\",\n  errorFontGetPath: \"errorFontGetPath\",\n  errorMarkedContent: \"errorMarkedContent\"\n};\nexports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES;\nvar PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nvar verbosity = VerbosityLevel.WARNINGS;\n\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\n\nfunction getVerbosityLevel() {\n  return verbosity;\n}\n\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(\"Info: \".concat(msg));\n  }\n}\n\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(\"Warning: \".concat(msg));\n  }\n}\n\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\n\nfunction isSameOrigin(baseUrl, otherUrl) {\n  var base;\n\n  try {\n    base = new URL(baseUrl);\n\n    if (!base.origin || base.origin === \"null\") {\n      return false;\n    }\n  } catch (e) {\n    return false;\n  }\n\n  var other = new URL(otherUrl, base);\n  return base.origin === other.origin;\n}\n\nfunction _isValidProtocol(url) {\n  if (!url) {\n    return false;\n  }\n\n  switch (url.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction createValidAbsoluteUrl(url, baseUrl) {\n  if (!url) {\n    return null;\n  }\n\n  try {\n    var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch (ex) {}\n\n  return null;\n}\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, {\n    value: value,\n    enumerable: true,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\n\nvar BaseException = function BaseExceptionClosure() {\n  function BaseException(message) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n\n    this.message = message;\n    this.name = this.constructor.name;\n  }\n\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\n\nexports.BaseException = BaseException;\n\nvar PasswordException = /*#__PURE__*/function (_BaseException) {\n  _inherits(PasswordException, _BaseException);\n\n  var _super = _createSuper(PasswordException);\n\n  function PasswordException(msg, code) {\n    var _this;\n\n    _classCallCheck(this, PasswordException);\n\n    _this = _super.call(this, msg);\n    _this.code = code;\n    return _this;\n  }\n\n  return PasswordException;\n}(BaseException);\n\nexports.PasswordException = PasswordException;\n\nvar UnknownErrorException = /*#__PURE__*/function (_BaseException2) {\n  _inherits(UnknownErrorException, _BaseException2);\n\n  var _super2 = _createSuper(UnknownErrorException);\n\n  function UnknownErrorException(msg, details) {\n    var _this2;\n\n    _classCallCheck(this, UnknownErrorException);\n\n    _this2 = _super2.call(this, msg);\n    _this2.details = details;\n    return _this2;\n  }\n\n  return UnknownErrorException;\n}(BaseException);\n\nexports.UnknownErrorException = UnknownErrorException;\n\nvar InvalidPDFException = /*#__PURE__*/function (_BaseException3) {\n  _inherits(InvalidPDFException, _BaseException3);\n\n  var _super3 = _createSuper(InvalidPDFException);\n\n  function InvalidPDFException() {\n    _classCallCheck(this, InvalidPDFException);\n\n    return _super3.apply(this, arguments);\n  }\n\n  return InvalidPDFException;\n}(BaseException);\n\nexports.InvalidPDFException = InvalidPDFException;\n\nvar MissingPDFException = /*#__PURE__*/function (_BaseException4) {\n  _inherits(MissingPDFException, _BaseException4);\n\n  var _super4 = _createSuper(MissingPDFException);\n\n  function MissingPDFException() {\n    _classCallCheck(this, MissingPDFException);\n\n    return _super4.apply(this, arguments);\n  }\n\n  return MissingPDFException;\n}(BaseException);\n\nexports.MissingPDFException = MissingPDFException;\n\nvar UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {\n  _inherits(UnexpectedResponseException, _BaseException5);\n\n  var _super5 = _createSuper(UnexpectedResponseException);\n\n  function UnexpectedResponseException(msg, status) {\n    var _this3;\n\n    _classCallCheck(this, UnexpectedResponseException);\n\n    _this3 = _super5.call(this, msg);\n    _this3.status = status;\n    return _this3;\n  }\n\n  return UnexpectedResponseException;\n}(BaseException);\n\nexports.UnexpectedResponseException = UnexpectedResponseException;\n\nvar FormatError = /*#__PURE__*/function (_BaseException6) {\n  _inherits(FormatError, _BaseException6);\n\n  var _super6 = _createSuper(FormatError);\n\n  function FormatError() {\n    _classCallCheck(this, FormatError);\n\n    return _super6.apply(this, arguments);\n  }\n\n  return FormatError;\n}(BaseException);\n\nexports.FormatError = FormatError;\n\nvar AbortException = /*#__PURE__*/function (_BaseException7) {\n  _inherits(AbortException, _BaseException7);\n\n  var _super7 = _createSuper(AbortException);\n\n  function AbortException() {\n    _classCallCheck(this, AbortException);\n\n    return _super7.apply(this, arguments);\n  }\n\n  return AbortException;\n}(BaseException);\n\nexports.AbortException = AbortException;\nvar NullCharactersRegExp = /\\x00/g;\n\nfunction removeNullCharacters(str) {\n  if (typeof str !== \"string\") {\n    warn(\"The argument for removeNullCharacters must be a string.\");\n    return str;\n  }\n\n  return str.replace(NullCharactersRegExp, \"\");\n}\n\nfunction bytesToString(bytes) {\n  assert(bytes !== null && _typeof(bytes) === \"object\" && bytes.length !== undefined, \"Invalid argument for bytesToString\");\n  var length = bytes.length;\n  var MAX_ARGUMENT_COUNT = 8192;\n\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n\n  var strBuf = [];\n\n  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    var chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction stringToBytes(str) {\n  assert(typeof str === \"string\", \"Invalid argument for stringToBytes\");\n  var length = str.length;\n  var bytes = new Uint8Array(length);\n\n  for (var i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n\n  return bytes;\n}\n\nfunction arrayByteLength(arr) {\n  if (arr.length !== undefined) {\n    return arr.length;\n  }\n\n  assert(arr.byteLength !== undefined, \"arrayByteLength - invalid argument.\");\n  return arr.byteLength;\n}\n\nfunction arraysToBytes(arr) {\n  var length = arr.length;\n\n  if (length === 1 && arr[0] instanceof Uint8Array) {\n    return arr[0];\n  }\n\n  var resultLength = 0;\n\n  for (var i = 0; i < length; i++) {\n    resultLength += arrayByteLength(arr[i]);\n  }\n\n  var pos = 0;\n  var data = new Uint8Array(resultLength);\n\n  for (var _i = 0; _i < length; _i++) {\n    var item = arr[_i];\n\n    if (!(item instanceof Uint8Array)) {\n      if (typeof item === \"string\") {\n        item = stringToBytes(item);\n      } else {\n        item = new Uint8Array(item);\n      }\n    }\n\n    var itemLength = item.byteLength;\n    data.set(item, pos);\n    pos += itemLength;\n  }\n\n  return data;\n}\n\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\n\nfunction isLittleEndian() {\n  var buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  var view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\n\nvar IsLittleEndianCached = {\n  get value() {\n    return shadow(this, \"value\", isLittleEndian());\n  }\n\n};\nexports.IsLittleEndianCached = IsLittleEndianCached;\n\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar IsEvalSupportedCached = {\n  get value() {\n    return shadow(this, \"value\", isEvalSupported());\n  }\n\n};\nexports.IsEvalSupportedCached = IsEvalSupportedCached;\nvar rgbBuf = [\"rgb(\", 0, \",\", 0, \",\", 0, \")\"];\n\nvar Util = /*#__PURE__*/function () {\n  function Util() {\n    _classCallCheck(this, Util);\n  }\n\n  _createClass(Util, null, [{\n    key: \"makeCssRgb\",\n    value: function makeCssRgb(r, g, b) {\n      rgbBuf[1] = r;\n      rgbBuf[3] = g;\n      rgbBuf[5] = b;\n      return rgbBuf.join(\"\");\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(m1, m2) {\n      return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n    }\n  }, {\n    key: \"applyTransform\",\n    value: function applyTransform(p, m) {\n      var xt = p[0] * m[0] + p[1] * m[2] + m[4];\n      var yt = p[0] * m[1] + p[1] * m[3] + m[5];\n      return [xt, yt];\n    }\n  }, {\n    key: \"applyInverseTransform\",\n    value: function applyInverseTransform(p, m) {\n      var d = m[0] * m[3] - m[1] * m[2];\n      var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n      var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n      return [xt, yt];\n    }\n  }, {\n    key: \"getAxialAlignedBoundingBox\",\n    value: function getAxialAlignedBoundingBox(r, m) {\n      var p1 = Util.applyTransform(r, m);\n      var p2 = Util.applyTransform(r.slice(2, 4), m);\n      var p3 = Util.applyTransform([r[0], r[3]], m);\n      var p4 = Util.applyTransform([r[2], r[1]], m);\n      return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n    }\n  }, {\n    key: \"inverseTransform\",\n    value: function inverseTransform(m) {\n      var d = m[0] * m[3] - m[1] * m[2];\n      return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n    }\n  }, {\n    key: \"apply3dTransform\",\n    value: function apply3dTransform(m, v) {\n      return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]];\n    }\n  }, {\n    key: \"singularValueDecompose2dScale\",\n    value: function singularValueDecompose2dScale(m) {\n      var transpose = [m[0], m[2], m[1], m[3]];\n      var a = m[0] * transpose[0] + m[1] * transpose[2];\n      var b = m[0] * transpose[1] + m[1] * transpose[3];\n      var c = m[2] * transpose[0] + m[3] * transpose[2];\n      var d = m[2] * transpose[1] + m[3] * transpose[3];\n      var first = (a + d) / 2;\n      var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;\n      var sx = first + second || 1;\n      var sy = first - second || 1;\n      return [Math.sqrt(sx), Math.sqrt(sy)];\n    }\n  }, {\n    key: \"normalizeRect\",\n    value: function normalizeRect(rect) {\n      var r = rect.slice(0);\n\n      if (rect[0] > rect[2]) {\n        r[0] = rect[2];\n        r[2] = rect[0];\n      }\n\n      if (rect[1] > rect[3]) {\n        r[1] = rect[3];\n        r[3] = rect[1];\n      }\n\n      return r;\n    }\n  }, {\n    key: \"intersect\",\n    value: function intersect(rect1, rect2) {\n      function compare(a, b) {\n        return a - b;\n      }\n\n      var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare);\n      var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare);\n      var result = [];\n      rect1 = Util.normalizeRect(rect1);\n      rect2 = Util.normalizeRect(rect2);\n\n      if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) {\n        result[0] = orderedX[1];\n        result[2] = orderedX[2];\n      } else {\n        return null;\n      }\n\n      if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) {\n        result[1] = orderedY[1];\n        result[3] = orderedY[2];\n      } else {\n        return null;\n      }\n\n      return result;\n    }\n  }]);\n\n  return Util;\n}();\n\nexports.Util = Util;\nvar PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];\n\nfunction stringToPDFString(str) {\n  var length = str.length,\n      strBuf = [];\n\n  if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n    for (var i = 2; i < length; i += 2) {\n      strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1)));\n    }\n  } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n    for (var _i2 = 2; _i2 < length; _i2 += 2) {\n      strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2)));\n    }\n  } else {\n    for (var _i3 = 0; _i3 < length; ++_i3) {\n      var code = PDFStringTranslateTable[str.charCodeAt(_i3)];\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3));\n    }\n  }\n\n  return strBuf.join(\"\");\n}\n\nfunction escapeString(str) {\n  return str.replace(/([\\(\\)\\\\])/g, \"\\\\$1\");\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\n\nfunction isBool(v) {\n  return typeof v === \"boolean\";\n}\n\nfunction isNum(v) {\n  return typeof v === \"number\";\n}\n\nfunction isString(v) {\n  return typeof v === \"string\";\n}\n\nfunction isArrayBuffer(v) {\n  return _typeof(v) === \"object\" && v !== null && v.byteLength !== undefined;\n}\n\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  return arr1.every(function (element, index) {\n    return element === arr2[index];\n  });\n}\n\nfunction getModificationDate() {\n  var date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date(Date.now());\n  var buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), (date.getUTCDate() + 1).toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\n\nfunction createPromiseCapability() {\n  var capability = Object.create(null);\n  var isSettled = false;\n  Object.defineProperty(capability, \"settled\", {\n    get: function get() {\n      return isSettled;\n    }\n  });\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = function (data) {\n      isSettled = true;\n      resolve(data);\n    };\n\n    capability.reject = function (reason) {\n      isSettled = true;\n      reject(reason);\n    };\n  });\n  return capability;\n}\n\nvar createObjectURL = function createObjectURLClosure() {\n  var digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  return function createObjectURL(data, contentType) {\n    var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!forceDataSchema && URL.createObjectURL) {\n      var blob = new Blob([data], {\n        type: contentType\n      });\n      return URL.createObjectURL(blob);\n    }\n\n    var buffer = \"data:\".concat(contentType, \";base64,\");\n\n    for (var i = 0, ii = data.length; i < ii; i += 3) {\n      var b1 = data[i] & 0xff;\n      var b2 = data[i + 1] & 0xff;\n      var b3 = data[i + 2] & 0xff;\n      var d1 = b1 >> 2,\n          d2 = (b1 & 3) << 4 | b2 >> 4;\n      var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n      var d4 = i + 2 < ii ? b3 & 0x3f : 64;\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n    }\n\n    return buffer;\n  };\n}();\n\nexports.createObjectURL = createObjectURL;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nvar _is_node = __w_pdfjs_require__(7);\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nif (typeof globalThis === \"undefined\" || !globalThis._pdfjsCompatibilityChecked) {\n  if (typeof globalThis === \"undefined\" || globalThis.Math !== Math) {\n    globalThis = __w_pdfjs_require__(8);\n  }\n\n  globalThis._pdfjsCompatibilityChecked = true;\n  var hasDOM = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\" && (typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) === \"object\";\n  var userAgent = typeof navigator !== \"undefined\" && navigator.userAgent || \"\";\n  var isIE = /Trident/.test(userAgent);\n\n  (function checkNodeBtoa() {\n    if (globalThis.btoa || !_is_node.isNodeJS) {\n      return;\n    }\n\n    globalThis.btoa = function (chars) {\n      return Buffer.from(chars, \"binary\").toString(\"base64\");\n    };\n  })();\n\n  (function checkNodeAtob() {\n    if (globalThis.atob || !_is_node.isNodeJS) {\n      return;\n    }\n\n    globalThis.atob = function (input) {\n      return Buffer.from(input, \"base64\").toString(\"binary\");\n    };\n  })();\n\n  (function checkChildNodeRemove() {\n    if (!hasDOM) {\n      return;\n    }\n\n    if (typeof Element.prototype.remove !== \"undefined\") {\n      return;\n    }\n\n    Element.prototype.remove = function () {\n      if (this.parentNode) {\n        this.parentNode.removeChild(this);\n      }\n    };\n  })();\n\n  (function checkDOMTokenListAddRemove() {\n    if (!hasDOM || _is_node.isNodeJS) {\n      return;\n    }\n\n    var div = document.createElement(\"div\");\n    div.classList.add(\"testOne\", \"testTwo\");\n\n    if (div.classList.contains(\"testOne\") === true && div.classList.contains(\"testTwo\") === true) {\n      return;\n    }\n\n    var OriginalDOMTokenListAdd = DOMTokenList.prototype.add;\n    var OriginalDOMTokenListRemove = DOMTokenList.prototype.remove;\n\n    DOMTokenList.prototype.add = function () {\n      for (var _len = arguments.length, tokens = new Array(_len), _key = 0; _key < _len; _key++) {\n        tokens[_key] = arguments[_key];\n      }\n\n      for (var _i = 0, _tokens = tokens; _i < _tokens.length; _i++) {\n        var token = _tokens[_i];\n        OriginalDOMTokenListAdd.call(this, token);\n      }\n    };\n\n    DOMTokenList.prototype.remove = function () {\n      for (var _len2 = arguments.length, tokens = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        tokens[_key2] = arguments[_key2];\n      }\n\n      for (var _i2 = 0, _tokens2 = tokens; _i2 < _tokens2.length; _i2++) {\n        var token = _tokens2[_i2];\n        OriginalDOMTokenListRemove.call(this, token);\n      }\n    };\n  })();\n\n  (function checkDOMTokenListToggle() {\n    if (!hasDOM || _is_node.isNodeJS) {\n      return;\n    }\n\n    var div = document.createElement(\"div\");\n\n    if (div.classList.toggle(\"test\", 0) === false) {\n      return;\n    }\n\n    DOMTokenList.prototype.toggle = function (token) {\n      var force = arguments.length > 1 ? !!arguments[1] : !this.contains(token);\n      return this[force ? \"add\" : \"remove\"](token), force;\n    };\n  })();\n\n  (function checkWindowHistoryPushStateReplaceState() {\n    if (!hasDOM || !isIE) {\n      return;\n    }\n\n    var OriginalPushState = window.history.pushState;\n    var OriginalReplaceState = window.history.replaceState;\n\n    window.history.pushState = function (state, title, url) {\n      var args = url === undefined ? [state, title] : [state, title, url];\n      OriginalPushState.apply(this, args);\n    };\n\n    window.history.replaceState = function (state, title, url) {\n      var args = url === undefined ? [state, title] : [state, title, url];\n      OriginalReplaceState.apply(this, args);\n    };\n  })();\n\n  (function checkStringStartsWith() {\n    if (String.prototype.startsWith) {\n      return;\n    }\n\n    __w_pdfjs_require__(53);\n  })();\n\n  (function checkStringEndsWith() {\n    if (String.prototype.endsWith) {\n      return;\n    }\n\n    __w_pdfjs_require__(64);\n  })();\n\n  (function checkStringIncludes() {\n    if (String.prototype.includes) {\n      return;\n    }\n\n    __w_pdfjs_require__(66);\n  })();\n\n  (function checkArrayIncludes() {\n    if (Array.prototype.includes) {\n      return;\n    }\n\n    __w_pdfjs_require__(68);\n  })();\n\n  (function checkArrayFrom() {\n    if (Array.from) {\n      return;\n    }\n\n    __w_pdfjs_require__(76);\n  })();\n\n  (function checkObjectAssign() {\n    if (Object.assign) {\n      return;\n    }\n\n    __w_pdfjs_require__(98);\n  })();\n\n  (function checkObjectFromEntries() {\n    if (Object.fromEntries) {\n      return;\n    }\n\n    __w_pdfjs_require__(101);\n  })();\n\n  (function checkMathLog2() {\n    if (Math.log2) {\n      return;\n    }\n\n    Math.log2 = __w_pdfjs_require__(105);\n  })();\n\n  (function checkNumberIsNaN() {\n    if (Number.isNaN) {\n      return;\n    }\n\n    Number.isNaN = __w_pdfjs_require__(107);\n  })();\n\n  (function checkNumberIsInteger() {\n    if (Number.isInteger) {\n      return;\n    }\n\n    Number.isInteger = __w_pdfjs_require__(109);\n  })();\n\n  (function checkTypedArraySlice() {\n    if (Uint8Array.prototype.slice) {\n      return;\n    }\n\n    __w_pdfjs_require__(112);\n  })();\n\n  (function checkPromise() {\n    if (globalThis.Promise && globalThis.Promise.allSettled) {\n      return;\n    }\n\n    globalThis.Promise = __w_pdfjs_require__(117);\n  })();\n\n  (function checkURL() {\n    globalThis.URL = __w_pdfjs_require__(138);\n  })();\n\n  (function checkReadableStream() {\n    var isReadableStreamSupported = false;\n\n    if (typeof ReadableStream !== \"undefined\") {\n      try {\n        new ReadableStream({\n          start: function start(controller) {\n            controller.close();\n          }\n        });\n        isReadableStreamSupported = true;\n      } catch (e) {}\n    }\n\n    if (isReadableStreamSupported) {\n      return;\n    }\n\n    globalThis.ReadableStream = __w_pdfjs_require__(145).ReadableStream;\n  })();\n\n  (function checkMapEntries() {\n    if (globalThis.Map && globalThis.Map.prototype.entries) {\n      return;\n    }\n\n    globalThis.Map = __w_pdfjs_require__(146);\n  })();\n\n  (function checkSetEntries() {\n    if (globalThis.Set && globalThis.Set.prototype.entries) {\n      return;\n    }\n\n    globalThis.Set = __w_pdfjs_require__(153);\n  })();\n\n  (function checkWeakMap() {\n    if (globalThis.WeakMap) {\n      return;\n    }\n\n    globalThis.WeakMap = __w_pdfjs_require__(155);\n  })();\n\n  (function checkWeakSet() {\n    if (globalThis.WeakSet) {\n      return;\n    }\n\n    globalThis.WeakSet = __w_pdfjs_require__(161);\n  })();\n\n  (function checkStringCodePointAt() {\n    if (String.prototype.codePointAt) {\n      return;\n    }\n\n    __w_pdfjs_require__(163);\n  })();\n\n  (function checkStringFromCodePoint() {\n    if (String.fromCodePoint) {\n      return;\n    }\n\n    String.fromCodePoint = __w_pdfjs_require__(165);\n  })();\n\n  (function checkSymbol() {\n    if (globalThis.Symbol) {\n      return;\n    }\n\n    __w_pdfjs_require__(167);\n  })();\n\n  (function checkStringPadStart() {\n    if (String.prototype.padStart) {\n      return;\n    }\n\n    __w_pdfjs_require__(190);\n  })();\n\n  (function checkStringPadEnd() {\n    if (String.prototype.padEnd) {\n      return;\n    }\n\n    __w_pdfjs_require__(195);\n  })();\n\n  (function checkObjectValues() {\n    if (Object.values) {\n      return;\n    }\n\n    Object.values = __w_pdfjs_require__(197);\n  })();\n\n  (function checkObjectEntries() {\n    if (Object.entries) {\n      return;\n    }\n\n    Object.entries = __w_pdfjs_require__(200);\n  })();\n}\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNodeJS = void 0;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar isNodeJS = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nexports.isNodeJS = isNodeJS;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(9);\nmodule.exports = __w_pdfjs_require__(11);\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar global = __w_pdfjs_require__(11);\n$({ global: true }, { globalThis: global });\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar getOwnPropertyDescriptor = __w_pdfjs_require__(12).f;\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nvar redefine = __w_pdfjs_require__(29);\nvar setGlobal = __w_pdfjs_require__(30);\nvar copyConstructorProperties = __w_pdfjs_require__(40);\nvar isForced = __w_pdfjs_require__(52);\nmodule.exports = function (options, source) {\n var TARGET = options.target;\n var GLOBAL = options.global;\n var STATIC = options.stat;\n var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n if (GLOBAL) {\n  target = global;\n } else if (STATIC) {\n  target = global[TARGET] || setGlobal(TARGET, {});\n } else {\n  target = (global[TARGET] || {}).prototype;\n }\n if (target)\n  for (key in source) {\n   sourceProperty = source[key];\n   if (options.noTargetGet) {\n    descriptor = getOwnPropertyDescriptor(target, key);\n    targetProperty = descriptor && descriptor.value;\n   } else\n    targetProperty = target[key];\n   FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n   if (!FORCED && targetProperty !== undefined) {\n    if (typeof sourceProperty === typeof targetProperty)\n     continue;\n    copyConstructorProperties(sourceProperty, targetProperty);\n   }\n   if (options.sham || targetProperty && targetProperty.sham) {\n    createNonEnumerableProperty(sourceProperty, 'sham', true);\n   }\n   redefine(target, key, sourceProperty, options);\n  }\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\nvar check = function (it) {\n return it && it.Math == Math && it;\n};\nmodule.exports = check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof __webpack_require__.g == 'object' && __webpack_require__.g) || Function('return this')();\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar propertyIsEnumerableModule = __w_pdfjs_require__(15);\nvar createPropertyDescriptor = __w_pdfjs_require__(16);\nvar toIndexedObject = __w_pdfjs_require__(17);\nvar toPrimitive = __w_pdfjs_require__(21);\nvar has = __w_pdfjs_require__(23);\nvar IE8_DOM_DEFINE = __w_pdfjs_require__(24);\nvar nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nexports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n O = toIndexedObject(O);\n P = toPrimitive(P, true);\n if (IE8_DOM_DEFINE)\n  try {\n   return nativeGetOwnPropertyDescriptor(O, P);\n  } catch (error) {\n  }\n if (has(O, P))\n  return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);\n};\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(14);\nmodule.exports = !fails(function () {\n return Object.defineProperty({}, 1, {\n  get: function () {\n   return 7;\n  }\n })[1] != 7;\n});\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n try {\n  return !!exec();\n } catch (error) {\n  return true;\n }\n};\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar nativePropertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n var descriptor = getOwnPropertyDescriptor(this, V);\n return !!descriptor && descriptor.enumerable;\n} : nativePropertyIsEnumerable;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (bitmap, value) {\n return {\n  enumerable: !(bitmap & 1),\n  configurable: !(bitmap & 2),\n  writable: !(bitmap & 4),\n  value: value\n };\n};\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar IndexedObject = __w_pdfjs_require__(18);\nvar requireObjectCoercible = __w_pdfjs_require__(20);\nmodule.exports = function (it) {\n return IndexedObject(requireObjectCoercible(it));\n};\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(14);\nvar classof = __w_pdfjs_require__(19);\nvar split = ''.split;\nmodule.exports = fails(function () {\n return !Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n return classof(it) == 'String' ? split.call(it, '') : Object(it);\n} : Object;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\nmodule.exports = function (it) {\n return toString.call(it).slice(8, -1);\n};\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n if (it == undefined)\n  throw TypeError(\"Can't call method on \" + it);\n return it;\n};\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(22);\nmodule.exports = function (input, PREFERRED_STRING) {\n if (!isObject(input))\n  return input;\n var fn, val;\n if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input)))\n  return val;\n if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input)))\n  return val;\n if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input)))\n  return val;\n throw TypeError(\"Can't convert object to primitive value\");\n};\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports) {\n\nvar hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n return hasOwnProperty.call(it, key);\n};\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar fails = __w_pdfjs_require__(14);\nvar createElement = __w_pdfjs_require__(25);\nmodule.exports = !DESCRIPTORS && !fails(function () {\n return Object.defineProperty(createElement('div'), 'a', {\n  get: function () {\n   return 7;\n  }\n }).a != 7;\n});\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar isObject = __w_pdfjs_require__(22);\nvar document = global.document;\nvar EXISTS = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n return EXISTS ? document.createElement(it) : {};\n};\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar definePropertyModule = __w_pdfjs_require__(27);\nvar createPropertyDescriptor = __w_pdfjs_require__(16);\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n object[key] = value;\n return object;\n};\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar IE8_DOM_DEFINE = __w_pdfjs_require__(24);\nvar anObject = __w_pdfjs_require__(28);\nvar toPrimitive = __w_pdfjs_require__(21);\nvar nativeDefineProperty = Object.defineProperty;\nexports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {\n anObject(O);\n P = toPrimitive(P, true);\n anObject(Attributes);\n if (IE8_DOM_DEFINE)\n  try {\n   return nativeDefineProperty(O, P, Attributes);\n  } catch (error) {\n  }\n if ('get' in Attributes || 'set' in Attributes)\n  throw TypeError('Accessors not supported');\n if ('value' in Attributes)\n  O[P] = Attributes.value;\n return O;\n};\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(22);\nmodule.exports = function (it) {\n if (!isObject(it)) {\n  throw TypeError(String(it) + ' is not an object');\n }\n return it;\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nvar has = __w_pdfjs_require__(23);\nvar setGlobal = __w_pdfjs_require__(30);\nvar inspectSource = __w_pdfjs_require__(31);\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar getInternalState = InternalStateModule.get;\nvar enforceInternalState = InternalStateModule.enforce;\nvar TEMPLATE = String(String).split('String');\n(module.exports = function (O, key, value, options) {\n var unsafe = options ? !!options.unsafe : false;\n var simple = options ? !!options.enumerable : false;\n var noTargetGet = options ? !!options.noTargetGet : false;\n if (typeof value == 'function') {\n  if (typeof key == 'string' && !has(value, 'name'))\n   createNonEnumerableProperty(value, 'name', key);\n  enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');\n }\n if (O === global) {\n  if (simple)\n   O[key] = value;\n  else\n   setGlobal(key, value);\n  return;\n } else if (!unsafe) {\n  delete O[key];\n } else if (!noTargetGet && O[key]) {\n  simple = true;\n }\n if (simple)\n  O[key] = value;\n else\n  createNonEnumerableProperty(O, key, value);\n})(Function.prototype, 'toString', function toString() {\n return typeof this == 'function' && getInternalState(this).source || inspectSource(this);\n});\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nmodule.exports = function (key, value) {\n try {\n  createNonEnumerableProperty(global, key, value);\n } catch (error) {\n  global[key] = value;\n }\n return value;\n};\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar store = __w_pdfjs_require__(32);\nvar functionToString = Function.toString;\nif (typeof store.inspectSource != 'function') {\n store.inspectSource = function (it) {\n  return functionToString.call(it);\n };\n}\nmodule.exports = store.inspectSource;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar setGlobal = __w_pdfjs_require__(30);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || setGlobal(SHARED, {});\nmodule.exports = store;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar NATIVE_WEAK_MAP = __w_pdfjs_require__(34);\nvar global = __w_pdfjs_require__(11);\nvar isObject = __w_pdfjs_require__(22);\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nvar objectHas = __w_pdfjs_require__(23);\nvar sharedKey = __w_pdfjs_require__(35);\nvar hiddenKeys = __w_pdfjs_require__(39);\nvar WeakMap = global.WeakMap;\nvar set, get, has;\nvar enforce = function (it) {\n return has(it) ? get(it) : set(it, {});\n};\nvar getterFor = function (TYPE) {\n return function (it) {\n  var state;\n  if (!isObject(it) || (state = get(it)).type !== TYPE) {\n   throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n  }\n  return state;\n };\n};\nif (NATIVE_WEAK_MAP) {\n var store = new WeakMap();\n var wmget = store.get;\n var wmhas = store.has;\n var wmset = store.set;\n set = function (it, metadata) {\n  wmset.call(store, it, metadata);\n  return metadata;\n };\n get = function (it) {\n  return wmget.call(store, it) || {};\n };\n has = function (it) {\n  return wmhas.call(store, it);\n };\n} else {\n var STATE = sharedKey('state');\n hiddenKeys[STATE] = true;\n set = function (it, metadata) {\n  createNonEnumerableProperty(it, STATE, metadata);\n  return metadata;\n };\n get = function (it) {\n  return objectHas(it, STATE) ? it[STATE] : {};\n };\n has = function (it) {\n  return objectHas(it, STATE);\n };\n}\nmodule.exports = {\n set: set,\n get: get,\n has: has,\n enforce: enforce,\n getterFor: getterFor\n};\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar inspectSource = __w_pdfjs_require__(31);\nvar WeakMap = global.WeakMap;\nmodule.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar shared = __w_pdfjs_require__(36);\nvar uid = __w_pdfjs_require__(38);\nvar keys = shared('keys');\nmodule.exports = function (key) {\n return keys[key] || (keys[key] = uid(key));\n};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar IS_PURE = __w_pdfjs_require__(37);\nvar store = __w_pdfjs_require__(32);\n(module.exports = function (key, value) {\n return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n version: '3.6.5',\n mode: IS_PURE ? 'pure' : 'global',\n copyright: '© 2020 Denis Pushkarev (zloirock.ru)'\n});\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports) {\n\nmodule.exports = false;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports) {\n\nvar id = 0;\nvar postfix = Math.random();\nmodule.exports = function (key) {\n return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);\n};\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar has = __w_pdfjs_require__(23);\nvar ownKeys = __w_pdfjs_require__(41);\nvar getOwnPropertyDescriptorModule = __w_pdfjs_require__(12);\nvar definePropertyModule = __w_pdfjs_require__(27);\nmodule.exports = function (target, source) {\n var keys = ownKeys(source);\n var defineProperty = definePropertyModule.f;\n var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n for (var i = 0; i < keys.length; i++) {\n  var key = keys[i];\n  if (!has(target, key))\n   defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n }\n};\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar getBuiltIn = __w_pdfjs_require__(42);\nvar getOwnPropertyNamesModule = __w_pdfjs_require__(44);\nvar getOwnPropertySymbolsModule = __w_pdfjs_require__(51);\nvar anObject = __w_pdfjs_require__(28);\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n var keys = getOwnPropertyNamesModule.f(anObject(it));\n var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;\n};\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar path = __w_pdfjs_require__(43);\nvar global = __w_pdfjs_require__(11);\nvar aFunction = function (variable) {\n return typeof variable == 'function' ? variable : undefined;\n};\nmodule.exports = function (namespace, method) {\n return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];\n};\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nmodule.exports = global;\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar internalObjectKeys = __w_pdfjs_require__(45);\nvar enumBugKeys = __w_pdfjs_require__(50);\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n return internalObjectKeys(O, hiddenKeys);\n};\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar has = __w_pdfjs_require__(23);\nvar toIndexedObject = __w_pdfjs_require__(17);\nvar indexOf = __w_pdfjs_require__(46).indexOf;\nvar hiddenKeys = __w_pdfjs_require__(39);\nmodule.exports = function (object, names) {\n var O = toIndexedObject(object);\n var i = 0;\n var result = [];\n var key;\n for (key in O)\n  !has(hiddenKeys, key) && has(O, key) && result.push(key);\n while (names.length > i)\n  if (has(O, key = names[i++])) {\n   ~indexOf(result, key) || result.push(key);\n  }\n return result;\n};\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar toIndexedObject = __w_pdfjs_require__(17);\nvar toLength = __w_pdfjs_require__(47);\nvar toAbsoluteIndex = __w_pdfjs_require__(49);\nvar createMethod = function (IS_INCLUDES) {\n return function ($this, el, fromIndex) {\n  var O = toIndexedObject($this);\n  var length = toLength(O.length);\n  var index = toAbsoluteIndex(fromIndex, length);\n  var value;\n  if (IS_INCLUDES && el != el)\n   while (length > index) {\n    value = O[index++];\n    if (value != value)\n     return true;\n   }\n  else\n   for (; length > index; index++) {\n    if ((IS_INCLUDES || index in O) && O[index] === el)\n     return IS_INCLUDES || index || 0;\n   }\n  return !IS_INCLUDES && -1;\n };\n};\nmodule.exports = {\n includes: createMethod(true),\n indexOf: createMethod(false)\n};\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar toInteger = __w_pdfjs_require__(48);\nvar min = Math.min;\nmodule.exports = function (argument) {\n return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0;\n};\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports) {\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (argument) {\n return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);\n};\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar toInteger = __w_pdfjs_require__(48);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n var integer = toInteger(index);\n return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports) {\n\nmodule.exports = [\n 'constructor',\n 'hasOwnProperty',\n 'isPrototypeOf',\n 'propertyIsEnumerable',\n 'toLocaleString',\n 'toString',\n 'valueOf'\n];\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\nexports.f = Object.getOwnPropertySymbols;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(14);\nvar replacement = /#|\\.prototype\\./;\nvar isForced = function (feature, detection) {\n var value = data[normalize(feature)];\n return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection;\n};\nvar normalize = isForced.normalize = function (string) {\n return String(string).replace(replacement, '.').toLowerCase();\n};\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\nmodule.exports = isForced;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(54);\nvar entryUnbind = __w_pdfjs_require__(61);\nmodule.exports = entryUnbind('String', 'startsWith');\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar getOwnPropertyDescriptor = __w_pdfjs_require__(12).f;\nvar toLength = __w_pdfjs_require__(47);\nvar notARegExp = __w_pdfjs_require__(55);\nvar requireObjectCoercible = __w_pdfjs_require__(20);\nvar correctIsRegExpLogic = __w_pdfjs_require__(60);\nvar IS_PURE = __w_pdfjs_require__(37);\nvar nativeStartsWith = ''.startsWith;\nvar min = Math.min;\nvar CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');\nvar MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');\n return descriptor && !descriptor.writable;\n}();\n$({\n target: 'String',\n proto: true,\n forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC\n}, {\n startsWith: function startsWith(searchString) {\n  var that = String(requireObjectCoercible(this));\n  notARegExp(searchString);\n  var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));\n  var search = String(searchString);\n  return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search;\n }\n});\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar isRegExp = __w_pdfjs_require__(56);\nmodule.exports = function (it) {\n if (isRegExp(it)) {\n  throw TypeError(\"The method doesn't accept regular expressions\");\n }\n return it;\n};\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(22);\nvar classof = __w_pdfjs_require__(19);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar MATCH = wellKnownSymbol('match');\nmodule.exports = function (it) {\n var isRegExp;\n return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');\n};\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar shared = __w_pdfjs_require__(36);\nvar has = __w_pdfjs_require__(23);\nvar uid = __w_pdfjs_require__(38);\nvar NATIVE_SYMBOL = __w_pdfjs_require__(58);\nvar USE_SYMBOL_AS_UID = __w_pdfjs_require__(59);\nvar WellKnownSymbolsStore = shared('wks');\nvar Symbol = global.Symbol;\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;\nmodule.exports = function (name) {\n if (!has(WellKnownSymbolsStore, name)) {\n  if (NATIVE_SYMBOL && has(Symbol, name))\n   WellKnownSymbolsStore[name] = Symbol[name];\n  else\n   WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);\n }\n return WellKnownSymbolsStore[name];\n};\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(14);\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n return !String(Symbol());\n});\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar NATIVE_SYMBOL = __w_pdfjs_require__(58);\nmodule.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar MATCH = wellKnownSymbol('match');\nmodule.exports = function (METHOD_NAME) {\n var regexp = /./;\n try {\n  '/./'[METHOD_NAME](regexp);\n } catch (e) {\n  try {\n   regexp[MATCH] = false;\n   return '/./'[METHOD_NAME](regexp);\n  } catch (f) {\n  }\n }\n return false;\n};\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar bind = __w_pdfjs_require__(62);\nvar call = Function.call;\nmodule.exports = function (CONSTRUCTOR, METHOD, length) {\n return bind(call, global[CONSTRUCTOR].prototype[METHOD], length);\n};\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar aFunction = __w_pdfjs_require__(63);\nmodule.exports = function (fn, that, length) {\n aFunction(fn);\n if (that === undefined)\n  return fn;\n switch (length) {\n case 0:\n  return function () {\n   return fn.call(that);\n  };\n case 1:\n  return function (a) {\n   return fn.call(that, a);\n  };\n case 2:\n  return function (a, b) {\n   return fn.call(that, a, b);\n  };\n case 3:\n  return function (a, b, c) {\n   return fn.call(that, a, b, c);\n  };\n }\n return function () {\n  return fn.apply(that, arguments);\n };\n};\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it) {\n if (typeof it != 'function') {\n  throw TypeError(String(it) + ' is not a function');\n }\n return it;\n};\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(65);\nvar entryUnbind = __w_pdfjs_require__(61);\nmodule.exports = entryUnbind('String', 'endsWith');\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar getOwnPropertyDescriptor = __w_pdfjs_require__(12).f;\nvar toLength = __w_pdfjs_require__(47);\nvar notARegExp = __w_pdfjs_require__(55);\nvar requireObjectCoercible = __w_pdfjs_require__(20);\nvar correctIsRegExpLogic = __w_pdfjs_require__(60);\nvar IS_PURE = __w_pdfjs_require__(37);\nvar nativeEndsWith = ''.endsWith;\nvar min = Math.min;\nvar CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');\nvar MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {\n var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');\n return descriptor && !descriptor.writable;\n}();\n$({\n target: 'String',\n proto: true,\n forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC\n}, {\n endsWith: function endsWith(searchString) {\n  var that = String(requireObjectCoercible(this));\n  notARegExp(searchString);\n  var endPosition = arguments.length > 1 ? arguments[1] : undefined;\n  var len = toLength(that.length);\n  var end = endPosition === undefined ? len : min(toLength(endPosition), len);\n  var search = String(searchString);\n  return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search;\n }\n});\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(67);\nvar entryUnbind = __w_pdfjs_require__(61);\nmodule.exports = entryUnbind('String', 'includes');\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar notARegExp = __w_pdfjs_require__(55);\nvar requireObjectCoercible = __w_pdfjs_require__(20);\nvar correctIsRegExpLogic = __w_pdfjs_require__(60);\n$({\n target: 'String',\n proto: true,\n forced: !correctIsRegExpLogic('includes')\n}, {\n includes: function includes(searchString) {\n  return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);\n }\n});\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(69);\nvar entryUnbind = __w_pdfjs_require__(61);\nmodule.exports = entryUnbind('Array', 'includes');\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar $includes = __w_pdfjs_require__(46).includes;\nvar addToUnscopables = __w_pdfjs_require__(70);\nvar arrayMethodUsesToLength = __w_pdfjs_require__(75);\nvar USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', {\n ACCESSORS: true,\n 1: 0\n});\n$({\n target: 'Array',\n proto: true,\n forced: !USES_TO_LENGTH\n}, {\n includes: function includes(el) {\n  return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n }\n});\naddToUnscopables('includes');\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar create = __w_pdfjs_require__(71);\nvar definePropertyModule = __w_pdfjs_require__(27);\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\nif (ArrayPrototype[UNSCOPABLES] == undefined) {\n definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {\n  configurable: true,\n  value: create(null)\n });\n}\nmodule.exports = function (key) {\n ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(28);\nvar defineProperties = __w_pdfjs_require__(72);\nvar enumBugKeys = __w_pdfjs_require__(50);\nvar hiddenKeys = __w_pdfjs_require__(39);\nvar html = __w_pdfjs_require__(74);\nvar documentCreateElement = __w_pdfjs_require__(25);\nvar sharedKey = __w_pdfjs_require__(35);\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar EmptyConstructor = function () {\n};\nvar scriptTag = function (content) {\n return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n activeXDocument.write(scriptTag(''));\n activeXDocument.close();\n var temp = activeXDocument.parentWindow.Object;\n activeXDocument = null;\n return temp;\n};\nvar NullProtoObjectViaIFrame = function () {\n var iframe = documentCreateElement('iframe');\n var JS = 'java' + SCRIPT + ':';\n var iframeDocument;\n iframe.style.display = 'none';\n html.appendChild(iframe);\n iframe.src = String(JS);\n iframeDocument = iframe.contentWindow.document;\n iframeDocument.open();\n iframeDocument.write(scriptTag('document.F=Object'));\n iframeDocument.close();\n return iframeDocument.F;\n};\nvar activeXDocument;\nvar NullProtoObject = function () {\n try {\n  activeXDocument = document.domain && new ActiveXObject('htmlfile');\n } catch (error) {\n }\n NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();\n var length = enumBugKeys.length;\n while (length--)\n  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n return NullProtoObject();\n};\nhiddenKeys[IE_PROTO] = true;\nmodule.exports = Object.create || function create(O, Properties) {\n var result;\n if (O !== null) {\n  EmptyConstructor[PROTOTYPE] = anObject(O);\n  result = new EmptyConstructor();\n  EmptyConstructor[PROTOTYPE] = null;\n  result[IE_PROTO] = O;\n } else\n  result = NullProtoObject();\n return Properties === undefined ? result : defineProperties(result, Properties);\n};\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar definePropertyModule = __w_pdfjs_require__(27);\nvar anObject = __w_pdfjs_require__(28);\nvar objectKeys = __w_pdfjs_require__(73);\nmodule.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {\n anObject(O);\n var keys = objectKeys(Properties);\n var length = keys.length;\n var index = 0;\n var key;\n while (length > index)\n  definePropertyModule.f(O, key = keys[index++], Properties[key]);\n return O;\n};\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar internalObjectKeys = __w_pdfjs_require__(45);\nvar enumBugKeys = __w_pdfjs_require__(50);\nmodule.exports = Object.keys || function keys(O) {\n return internalObjectKeys(O, enumBugKeys);\n};\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar getBuiltIn = __w_pdfjs_require__(42);\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar fails = __w_pdfjs_require__(14);\nvar has = __w_pdfjs_require__(23);\nvar defineProperty = Object.defineProperty;\nvar cache = {};\nvar thrower = function (it) {\n throw it;\n};\nmodule.exports = function (METHOD_NAME, options) {\n if (has(cache, METHOD_NAME))\n  return cache[METHOD_NAME];\n if (!options)\n  options = {};\n var method = [][METHOD_NAME];\n var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;\n var argument0 = has(options, 0) ? options[0] : thrower;\n var argument1 = has(options, 1) ? options[1] : undefined;\n return cache[METHOD_NAME] = !!method && !fails(function () {\n  if (ACCESSORS && !DESCRIPTORS)\n   return true;\n  var O = { length: -1 };\n  if (ACCESSORS)\n   defineProperty(O, 1, {\n    enumerable: true,\n    get: thrower\n   });\n  else\n   O[1] = 1;\n  method.call(O, argument0, argument1);\n });\n};\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(77);\n__w_pdfjs_require__(89);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Array.from;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar charAt = __w_pdfjs_require__(78).charAt;\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar defineIterator = __w_pdfjs_require__(79);\nvar STRING_ITERATOR = 'String Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);\ndefineIterator(String, 'String', function (iterated) {\n setInternalState(this, {\n  type: STRING_ITERATOR,\n  string: String(iterated),\n  index: 0\n });\n}, function next() {\n var state = getInternalState(this);\n var string = state.string;\n var index = state.index;\n var point;\n if (index >= string.length)\n  return {\n   value: undefined,\n   done: true\n  };\n point = charAt(string, index);\n state.index += point.length;\n return {\n  value: point,\n  done: false\n };\n});\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar toInteger = __w_pdfjs_require__(48);\nvar requireObjectCoercible = __w_pdfjs_require__(20);\nvar createMethod = function (CONVERT_TO_STRING) {\n return function ($this, pos) {\n  var S = String(requireObjectCoercible($this));\n  var position = toInteger(pos);\n  var size = S.length;\n  var first, second;\n  if (position < 0 || position >= size)\n   return CONVERT_TO_STRING ? '' : undefined;\n  first = S.charCodeAt(position);\n  return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n };\n};\nmodule.exports = {\n codeAt: createMethod(false),\n charAt: createMethod(true)\n};\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar createIteratorConstructor = __w_pdfjs_require__(80);\nvar getPrototypeOf = __w_pdfjs_require__(82);\nvar setPrototypeOf = __w_pdfjs_require__(87);\nvar setToStringTag = __w_pdfjs_require__(85);\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nvar redefine = __w_pdfjs_require__(29);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar IS_PURE = __w_pdfjs_require__(37);\nvar Iterators = __w_pdfjs_require__(86);\nvar IteratorsCore = __w_pdfjs_require__(81);\nvar IteratorPrototype = IteratorsCore.IteratorPrototype;\nvar BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;\nvar ITERATOR = wellKnownSymbol('iterator');\nvar KEYS = 'keys';\nvar VALUES = 'values';\nvar ENTRIES = 'entries';\nvar returnThis = function () {\n return this;\n};\nmodule.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {\n createIteratorConstructor(IteratorConstructor, NAME, next);\n var getIterationMethod = function (KIND) {\n  if (KIND === DEFAULT && defaultIterator)\n   return defaultIterator;\n  if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)\n   return IterablePrototype[KIND];\n  switch (KIND) {\n  case KEYS:\n   return function keys() {\n    return new IteratorConstructor(this, KIND);\n   };\n  case VALUES:\n   return function values() {\n    return new IteratorConstructor(this, KIND);\n   };\n  case ENTRIES:\n   return function entries() {\n    return new IteratorConstructor(this, KIND);\n   };\n  }\n  return function () {\n   return new IteratorConstructor(this);\n  };\n };\n var TO_STRING_TAG = NAME + ' Iterator';\n var INCORRECT_VALUES_NAME = false;\n var IterablePrototype = Iterable.prototype;\n var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT];\n var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);\n var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;\n var CurrentIteratorPrototype, methods, KEY;\n if (anyNativeIterator) {\n  CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));\n  if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {\n   if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {\n    if (setPrototypeOf) {\n     setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);\n    } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {\n     createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);\n    }\n   }\n   setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);\n   if (IS_PURE)\n    Iterators[TO_STRING_TAG] = returnThis;\n  }\n }\n if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {\n  INCORRECT_VALUES_NAME = true;\n  defaultIterator = function values() {\n   return nativeIterator.call(this);\n  };\n }\n if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {\n  createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);\n }\n Iterators[NAME] = defaultIterator;\n if (DEFAULT) {\n  methods = {\n   values: getIterationMethod(VALUES),\n   keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),\n   entries: getIterationMethod(ENTRIES)\n  };\n  if (FORCED)\n   for (KEY in methods) {\n    if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {\n     redefine(IterablePrototype, KEY, methods[KEY]);\n    }\n   }\n  else\n   $({\n    target: NAME,\n    proto: true,\n    forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME\n   }, methods);\n }\n return methods;\n};\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar IteratorPrototype = __w_pdfjs_require__(81).IteratorPrototype;\nvar create = __w_pdfjs_require__(71);\nvar createPropertyDescriptor = __w_pdfjs_require__(16);\nvar setToStringTag = __w_pdfjs_require__(85);\nvar Iterators = __w_pdfjs_require__(86);\nvar returnThis = function () {\n return this;\n};\nmodule.exports = function (IteratorConstructor, NAME, next) {\n var TO_STRING_TAG = NAME + ' Iterator';\n IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });\n setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);\n Iterators[TO_STRING_TAG] = returnThis;\n return IteratorConstructor;\n};\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar getPrototypeOf = __w_pdfjs_require__(82);\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nvar has = __w_pdfjs_require__(23);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar IS_PURE = __w_pdfjs_require__(37);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar BUGGY_SAFARI_ITERATORS = false;\nvar returnThis = function () {\n return this;\n};\nvar IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;\nif ([].keys) {\n arrayIterator = [].keys();\n if (!('next' in arrayIterator))\n  BUGGY_SAFARI_ITERATORS = true;\n else {\n  PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));\n  if (PrototypeOfArrayIteratorPrototype !== Object.prototype)\n   IteratorPrototype = PrototypeOfArrayIteratorPrototype;\n }\n}\nif (IteratorPrototype == undefined)\n IteratorPrototype = {};\nif (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {\n createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);\n}\nmodule.exports = {\n IteratorPrototype: IteratorPrototype,\n BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS\n};\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar has = __w_pdfjs_require__(23);\nvar toObject = __w_pdfjs_require__(83);\nvar sharedKey = __w_pdfjs_require__(35);\nvar CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__(84);\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar ObjectPrototype = Object.prototype;\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {\n O = toObject(O);\n if (has(O, IE_PROTO))\n  return O[IE_PROTO];\n if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n  return O.constructor.prototype;\n }\n return O instanceof Object ? ObjectPrototype : null;\n};\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar requireObjectCoercible = __w_pdfjs_require__(20);\nmodule.exports = function (argument) {\n return Object(requireObjectCoercible(argument));\n};\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(14);\nmodule.exports = !fails(function () {\n function F() {\n }\n F.prototype.constructor = null;\n return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineProperty = __w_pdfjs_require__(27).f;\nvar has = __w_pdfjs_require__(23);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nmodule.exports = function (it, TAG, STATIC) {\n if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {\n  defineProperty(it, TO_STRING_TAG, {\n   configurable: true,\n   value: TAG\n  });\n }\n};\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports) {\n\nmodule.exports = {};\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(28);\nvar aPossiblePrototype = __w_pdfjs_require__(88);\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {\n var CORRECT_SETTER = false;\n var test = {};\n var setter;\n try {\n  setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;\n  setter.call(test, []);\n  CORRECT_SETTER = test instanceof Array;\n } catch (error) {\n }\n return function setPrototypeOf(O, proto) {\n  anObject(O);\n  aPossiblePrototype(proto);\n  if (CORRECT_SETTER)\n   setter.call(O, proto);\n  else\n   O.__proto__ = proto;\n  return O;\n };\n}() : undefined);\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(22);\nmodule.exports = function (it) {\n if (!isObject(it) && it !== null) {\n  throw TypeError(\"Can't set \" + String(it) + ' as a prototype');\n }\n return it;\n};\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar from = __w_pdfjs_require__(90);\nvar checkCorrectnessOfIteration = __w_pdfjs_require__(97);\nvar INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {\n Array.from(iterable);\n});\n$({\n target: 'Array',\n stat: true,\n forced: INCORRECT_ITERATION\n}, { from: from });\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar bind = __w_pdfjs_require__(62);\nvar toObject = __w_pdfjs_require__(83);\nvar callWithSafeIterationClosing = __w_pdfjs_require__(91);\nvar isArrayIteratorMethod = __w_pdfjs_require__(92);\nvar toLength = __w_pdfjs_require__(47);\nvar createProperty = __w_pdfjs_require__(93);\nvar getIteratorMethod = __w_pdfjs_require__(94);\nmodule.exports = function from(arrayLike) {\n var O = toObject(arrayLike);\n var C = typeof this == 'function' ? this : Array;\n var argumentsLength = arguments.length;\n var mapfn = argumentsLength > 1 ? arguments[1] : undefined;\n var mapping = mapfn !== undefined;\n var iteratorMethod = getIteratorMethod(O);\n var index = 0;\n var length, result, step, iterator, next, value;\n if (mapping)\n  mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);\n if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {\n  iterator = iteratorMethod.call(O);\n  next = iterator.next;\n  result = new C();\n  for (; !(step = next.call(iterator)).done; index++) {\n   value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [\n    step.value,\n    index\n   ], true) : step.value;\n   createProperty(result, index, value);\n  }\n } else {\n  length = toLength(O.length);\n  result = new C(length);\n  for (; length > index; index++) {\n   value = mapping ? mapfn(O[index], index) : O[index];\n   createProperty(result, index, value);\n  }\n }\n result.length = index;\n return result;\n};\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(28);\nmodule.exports = function (iterator, fn, value, ENTRIES) {\n try {\n  return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);\n } catch (error) {\n  var returnMethod = iterator['return'];\n  if (returnMethod !== undefined)\n   anObject(returnMethod.call(iterator));\n  throw error;\n }\n};\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar Iterators = __w_pdfjs_require__(86);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar ArrayPrototype = Array.prototype;\nmodule.exports = function (it) {\n return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar toPrimitive = __w_pdfjs_require__(21);\nvar definePropertyModule = __w_pdfjs_require__(27);\nvar createPropertyDescriptor = __w_pdfjs_require__(16);\nmodule.exports = function (object, key, value) {\n var propertyKey = toPrimitive(key);\n if (propertyKey in object)\n  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n else\n  object[propertyKey] = value;\n};\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar classof = __w_pdfjs_require__(95);\nvar Iterators = __w_pdfjs_require__(86);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar ITERATOR = wellKnownSymbol('iterator');\nmodule.exports = function (it) {\n if (it != undefined)\n  return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];\n};\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(96);\nvar classofRaw = __w_pdfjs_require__(19);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar CORRECT_ARGUMENTS = classofRaw(function () {\n return arguments;\n}()) == 'Arguments';\nvar tryGet = function (it, key) {\n try {\n  return it[key];\n } catch (error) {\n }\n};\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n var O, tag, result;\n return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;\n};\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\ntest[TO_STRING_TAG] = 'z';\nmodule.exports = String(test) === '[object z]';\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar SAFE_CLOSING = false;\ntry {\n var called = 0;\n var iteratorWithReturn = {\n  next: function () {\n   return { done: !!called++ };\n  },\n  'return': function () {\n   SAFE_CLOSING = true;\n  }\n };\n iteratorWithReturn[ITERATOR] = function () {\n  return this;\n };\n Array.from(iteratorWithReturn, function () {\n  throw 2;\n });\n} catch (error) {\n}\nmodule.exports = function (exec, SKIP_CLOSING) {\n if (!SKIP_CLOSING && !SAFE_CLOSING)\n  return false;\n var ITERATION_SUPPORT = false;\n try {\n  var object = {};\n  object[ITERATOR] = function () {\n   return {\n    next: function () {\n     return { done: ITERATION_SUPPORT = true };\n    }\n   };\n  };\n  exec(object);\n } catch (error) {\n }\n return ITERATION_SUPPORT;\n};\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(99);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Object.assign;\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar assign = __w_pdfjs_require__(100);\n$({\n target: 'Object',\n stat: true,\n forced: Object.assign !== assign\n}, { assign: assign });\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar fails = __w_pdfjs_require__(14);\nvar objectKeys = __w_pdfjs_require__(73);\nvar getOwnPropertySymbolsModule = __w_pdfjs_require__(51);\nvar propertyIsEnumerableModule = __w_pdfjs_require__(15);\nvar toObject = __w_pdfjs_require__(83);\nvar IndexedObject = __w_pdfjs_require__(18);\nvar nativeAssign = Object.assign;\nvar defineProperty = Object.defineProperty;\nmodule.exports = !nativeAssign || fails(function () {\n if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {\n   enumerable: true,\n   get: function () {\n    defineProperty(this, 'b', {\n     value: 3,\n     enumerable: false\n    });\n   }\n  }), { b: 2 })).b !== 1)\n  return true;\n var A = {};\n var B = {};\n var symbol = Symbol();\n var alphabet = 'abcdefghijklmnopqrst';\n A[symbol] = 7;\n alphabet.split('').forEach(function (chr) {\n  B[chr] = chr;\n });\n return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;\n}) ? function assign(target, source) {\n var T = toObject(target);\n var argumentsLength = arguments.length;\n var index = 1;\n var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n var propertyIsEnumerable = propertyIsEnumerableModule.f;\n while (argumentsLength > index) {\n  var S = IndexedObject(arguments[index++]);\n  var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);\n  var length = keys.length;\n  var j = 0;\n  var key;\n  while (length > j) {\n   key = keys[j++];\n   if (!DESCRIPTORS || propertyIsEnumerable.call(S, key))\n    T[key] = S[key];\n  }\n }\n return T;\n} : nativeAssign;\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(103);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Object.fromEntries;\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar toIndexedObject = __w_pdfjs_require__(17);\nvar addToUnscopables = __w_pdfjs_require__(70);\nvar Iterators = __w_pdfjs_require__(86);\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar defineIterator = __w_pdfjs_require__(79);\nvar ARRAY_ITERATOR = 'Array Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);\nmodule.exports = defineIterator(Array, 'Array', function (iterated, kind) {\n setInternalState(this, {\n  type: ARRAY_ITERATOR,\n  target: toIndexedObject(iterated),\n  index: 0,\n  kind: kind\n });\n}, function () {\n var state = getInternalState(this);\n var target = state.target;\n var kind = state.kind;\n var index = state.index++;\n if (!target || index >= target.length) {\n  state.target = undefined;\n  return {\n   value: undefined,\n   done: true\n  };\n }\n if (kind == 'keys')\n  return {\n   value: index,\n   done: false\n  };\n if (kind == 'values')\n  return {\n   value: target[index],\n   done: false\n  };\n return {\n  value: [\n   index,\n   target[index]\n  ],\n  done: false\n };\n}, 'values');\nIterators.Arguments = Iterators.Array;\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar iterate = __w_pdfjs_require__(104);\nvar createProperty = __w_pdfjs_require__(93);\n$({\n target: 'Object',\n stat: true\n}, {\n fromEntries: function fromEntries(iterable) {\n  var obj = {};\n  iterate(iterable, function (k, v) {\n   createProperty(obj, k, v);\n  }, undefined, true);\n  return obj;\n }\n});\n\n/***/ }),\n/* 104 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(28);\nvar isArrayIteratorMethod = __w_pdfjs_require__(92);\nvar toLength = __w_pdfjs_require__(47);\nvar bind = __w_pdfjs_require__(62);\nvar getIteratorMethod = __w_pdfjs_require__(94);\nvar callWithSafeIterationClosing = __w_pdfjs_require__(91);\nvar Result = function (stopped, result) {\n this.stopped = stopped;\n this.result = result;\n};\nvar iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {\n var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);\n var iterator, iterFn, index, length, result, next, step;\n if (IS_ITERATOR) {\n  iterator = iterable;\n } else {\n  iterFn = getIteratorMethod(iterable);\n  if (typeof iterFn != 'function')\n   throw TypeError('Target is not iterable');\n  if (isArrayIteratorMethod(iterFn)) {\n   for (index = 0, length = toLength(iterable.length); length > index; index++) {\n    result = AS_ENTRIES ? boundFunction(anObject(step = iterable[index])[0], step[1]) : boundFunction(iterable[index]);\n    if (result && result instanceof Result)\n     return result;\n   }\n   return new Result(false);\n  }\n  iterator = iterFn.call(iterable);\n }\n next = iterator.next;\n while (!(step = next.call(iterator)).done) {\n  result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);\n  if (typeof result == 'object' && result && result instanceof Result)\n   return result;\n }\n return new Result(false);\n};\niterate.stop = function (result) {\n return new Result(true, result);\n};\n\n/***/ }),\n/* 105 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(106);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Math.log2;\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar log = Math.log;\nvar LN2 = Math.LN2;\n$({\n target: 'Math',\n stat: true\n}, {\n log2: function log2(x) {\n  return log(x) / LN2;\n }\n});\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(108);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Number.isNaN;\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\n$({\n target: 'Number',\n stat: true\n}, {\n isNaN: function isNaN(number) {\n  return number != number;\n }\n});\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(110);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Number.isInteger;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar isInteger = __w_pdfjs_require__(111);\n$({\n target: 'Number',\n stat: true\n}, { isInteger: isInteger });\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(22);\nvar floor = Math.floor;\nmodule.exports = function isInteger(it) {\n return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(113);\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar ArrayBufferViewCore = __w_pdfjs_require__(114);\nvar speciesConstructor = __w_pdfjs_require__(116);\nvar fails = __w_pdfjs_require__(14);\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar $slice = [].slice;\nvar FORCED = fails(function () {\n new Int8Array(1).slice();\n});\nexportTypedArrayMethod('slice', function slice(start, end) {\n var list = $slice.call(aTypedArray(this), start, end);\n var C = speciesConstructor(this, this.constructor);\n var index = 0;\n var length = list.length;\n var result = new (aTypedArrayConstructor(C))(length);\n while (length > index)\n  result[index] = list[index++];\n return result;\n}, FORCED);\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar NATIVE_ARRAY_BUFFER = __w_pdfjs_require__(115);\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar global = __w_pdfjs_require__(11);\nvar isObject = __w_pdfjs_require__(22);\nvar has = __w_pdfjs_require__(23);\nvar classof = __w_pdfjs_require__(95);\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nvar redefine = __w_pdfjs_require__(29);\nvar defineProperty = __w_pdfjs_require__(27).f;\nvar getPrototypeOf = __w_pdfjs_require__(82);\nvar setPrototypeOf = __w_pdfjs_require__(87);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar uid = __w_pdfjs_require__(38);\nvar Int8Array = global.Int8Array;\nvar Int8ArrayPrototype = Int8Array && Int8Array.prototype;\nvar Uint8ClampedArray = global.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;\nvar TypedArray = Int8Array && getPrototypeOf(Int8Array);\nvar TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\nvar ObjectPrototype = Object.prototype;\nvar isPrototypeOf = ObjectPrototype.isPrototypeOf;\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');\nvar NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQIRED = false;\nvar NAME;\nvar TypedArrayConstructorsList = {\n Int8Array: 1,\n Uint8Array: 1,\n Uint8ClampedArray: 1,\n Int16Array: 2,\n Uint16Array: 2,\n Int32Array: 4,\n Uint32Array: 4,\n Float32Array: 4,\n Float64Array: 8\n};\nvar isView = function isView(it) {\n var klass = classof(it);\n return klass === 'DataView' || has(TypedArrayConstructorsList, klass);\n};\nvar isTypedArray = function (it) {\n return isObject(it) && has(TypedArrayConstructorsList, classof(it));\n};\nvar aTypedArray = function (it) {\n if (isTypedArray(it))\n  return it;\n throw TypeError('Target is not a typed array');\n};\nvar aTypedArrayConstructor = function (C) {\n if (setPrototypeOf) {\n  if (isPrototypeOf.call(TypedArray, C))\n   return C;\n } else\n  for (var ARRAY in TypedArrayConstructorsList)\n   if (has(TypedArrayConstructorsList, NAME)) {\n    var TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {\n     return C;\n    }\n   }\n throw TypeError('Target is not a typed array constructor');\n};\nvar exportTypedArrayMethod = function (KEY, property, forced) {\n if (!DESCRIPTORS)\n  return;\n if (forced)\n  for (var ARRAY in TypedArrayConstructorsList) {\n   var TypedArrayConstructor = global[ARRAY];\n   if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {\n    delete TypedArrayConstructor.prototype[KEY];\n   }\n  }\n if (!TypedArrayPrototype[KEY] || forced) {\n  redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);\n }\n};\nvar exportTypedArrayStaticMethod = function (KEY, property, forced) {\n var ARRAY, TypedArrayConstructor;\n if (!DESCRIPTORS)\n  return;\n if (setPrototypeOf) {\n  if (forced)\n   for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {\n     delete TypedArrayConstructor[KEY];\n    }\n   }\n  if (!TypedArray[KEY] || forced) {\n   try {\n    return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);\n   } catch (error) {\n   }\n  } else\n   return;\n }\n for (ARRAY in TypedArrayConstructorsList) {\n  TypedArrayConstructor = global[ARRAY];\n  if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n   redefine(TypedArrayConstructor, KEY, property);\n  }\n }\n};\nfor (NAME in TypedArrayConstructorsList) {\n if (!global[NAME])\n  NATIVE_ARRAY_BUFFER_VIEWS = false;\n}\nif (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {\n TypedArray = function TypedArray() {\n  throw TypeError('Incorrect invocation');\n };\n if (NATIVE_ARRAY_BUFFER_VIEWS)\n  for (NAME in TypedArrayConstructorsList) {\n   if (global[NAME])\n    setPrototypeOf(global[NAME], TypedArray);\n  }\n}\nif (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\n TypedArrayPrototype = TypedArray.prototype;\n if (NATIVE_ARRAY_BUFFER_VIEWS)\n  for (NAME in TypedArrayConstructorsList) {\n   if (global[NAME])\n    setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);\n  }\n}\nif (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n}\nif (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {\n TYPED_ARRAY_TAG_REQIRED = true;\n defineProperty(TypedArrayPrototype, TO_STRING_TAG, {\n  get: function () {\n   return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\n  }\n });\n for (NAME in TypedArrayConstructorsList)\n  if (global[NAME]) {\n   createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);\n  }\n}\nmodule.exports = {\n NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\n TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,\n aTypedArray: aTypedArray,\n aTypedArrayConstructor: aTypedArrayConstructor,\n exportTypedArrayMethod: exportTypedArrayMethod,\n exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,\n isView: isView,\n isTypedArray: isTypedArray,\n TypedArray: TypedArray,\n TypedArrayPrototype: TypedArrayPrototype\n};\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports) {\n\nmodule.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(28);\nvar aFunction = __w_pdfjs_require__(63);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar SPECIES = wellKnownSymbol('species');\nmodule.exports = function (O, defaultConstructor) {\n var C = anObject(O).constructor;\n var S;\n return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);\n};\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(118);\n__w_pdfjs_require__(77);\n__w_pdfjs_require__(120);\n__w_pdfjs_require__(122);\n__w_pdfjs_require__(136);\n__w_pdfjs_require__(137);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Promise;\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(96);\nvar redefine = __w_pdfjs_require__(29);\nvar toString = __w_pdfjs_require__(119);\nif (!TO_STRING_TAG_SUPPORT) {\n redefine(Object.prototype, 'toString', toString, { unsafe: true });\n}\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(96);\nvar classof = __w_pdfjs_require__(95);\nmodule.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {\n return '[object ' + classof(this) + ']';\n};\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar DOMIterables = __w_pdfjs_require__(121);\nvar ArrayIteratorMethods = __w_pdfjs_require__(102);\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar ArrayValues = ArrayIteratorMethods.values;\nfor (var COLLECTION_NAME in DOMIterables) {\n var Collection = global[COLLECTION_NAME];\n var CollectionPrototype = Collection && Collection.prototype;\n if (CollectionPrototype) {\n  if (CollectionPrototype[ITERATOR] !== ArrayValues)\n   try {\n    createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);\n   } catch (error) {\n    CollectionPrototype[ITERATOR] = ArrayValues;\n   }\n  if (!CollectionPrototype[TO_STRING_TAG]) {\n   createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);\n  }\n  if (DOMIterables[COLLECTION_NAME])\n   for (var METHOD_NAME in ArrayIteratorMethods) {\n    if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME])\n     try {\n      createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);\n     } catch (error) {\n      CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];\n     }\n   }\n }\n}\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n CSSRuleList: 0,\n CSSStyleDeclaration: 0,\n CSSValueList: 0,\n ClientRectList: 0,\n DOMRectList: 0,\n DOMStringList: 0,\n DOMTokenList: 1,\n DataTransferItemList: 0,\n FileList: 0,\n HTMLAllCollection: 0,\n HTMLCollection: 0,\n HTMLFormElement: 0,\n HTMLSelectElement: 0,\n MediaList: 0,\n MimeTypeArray: 0,\n NamedNodeMap: 0,\n NodeList: 1,\n PaintRequestList: 0,\n Plugin: 0,\n PluginArray: 0,\n SVGLengthList: 0,\n SVGNumberList: 0,\n SVGPathSegList: 0,\n SVGPointList: 0,\n SVGStringList: 0,\n SVGTransformList: 0,\n SourceBufferList: 0,\n StyleSheetList: 0,\n TextTrackCueList: 0,\n TextTrackList: 0,\n TouchList: 0\n};\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar IS_PURE = __w_pdfjs_require__(37);\nvar global = __w_pdfjs_require__(11);\nvar getBuiltIn = __w_pdfjs_require__(42);\nvar NativePromise = __w_pdfjs_require__(123);\nvar redefine = __w_pdfjs_require__(29);\nvar redefineAll = __w_pdfjs_require__(124);\nvar setToStringTag = __w_pdfjs_require__(85);\nvar setSpecies = __w_pdfjs_require__(125);\nvar isObject = __w_pdfjs_require__(22);\nvar aFunction = __w_pdfjs_require__(63);\nvar anInstance = __w_pdfjs_require__(126);\nvar classof = __w_pdfjs_require__(19);\nvar inspectSource = __w_pdfjs_require__(31);\nvar iterate = __w_pdfjs_require__(104);\nvar checkCorrectnessOfIteration = __w_pdfjs_require__(97);\nvar speciesConstructor = __w_pdfjs_require__(116);\nvar task = __w_pdfjs_require__(127).set;\nvar microtask = __w_pdfjs_require__(130);\nvar promiseResolve = __w_pdfjs_require__(131);\nvar hostReportErrors = __w_pdfjs_require__(133);\nvar newPromiseCapabilityModule = __w_pdfjs_require__(132);\nvar perform = __w_pdfjs_require__(134);\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar isForced = __w_pdfjs_require__(52);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar V8_VERSION = __w_pdfjs_require__(135);\nvar SPECIES = wellKnownSymbol('species');\nvar PROMISE = 'Promise';\nvar getInternalState = InternalStateModule.get;\nvar setInternalState = InternalStateModule.set;\nvar getInternalPromiseState = InternalStateModule.getterFor(PROMISE);\nvar PromiseConstructor = NativePromise;\nvar TypeError = global.TypeError;\nvar document = global.document;\nvar process = global.process;\nvar $fetch = getBuiltIn('fetch');\nvar newPromiseCapability = newPromiseCapabilityModule.f;\nvar newGenericPromiseCapability = newPromiseCapability;\nvar IS_NODE = classof(process) == 'process';\nvar DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);\nvar UNHANDLED_REJECTION = 'unhandledrejection';\nvar REJECTION_HANDLED = 'rejectionhandled';\nvar PENDING = 0;\nvar FULFILLED = 1;\nvar REJECTED = 2;\nvar HANDLED = 1;\nvar UNHANDLED = 2;\nvar Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;\nvar FORCED = isForced(PROMISE, function () {\n var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);\n if (!GLOBAL_CORE_JS_PROMISE) {\n  if (V8_VERSION === 66)\n   return true;\n  if (!IS_NODE && typeof PromiseRejectionEvent != 'function')\n   return true;\n }\n if (IS_PURE && !PromiseConstructor.prototype['finally'])\n  return true;\n if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor))\n  return false;\n var promise = PromiseConstructor.resolve(1);\n var FakePromise = function (exec) {\n  exec(function () {\n  }, function () {\n  });\n };\n var constructor = promise.constructor = {};\n constructor[SPECIES] = FakePromise;\n return !(promise.then(function () {\n }) instanceof FakePromise);\n});\nvar INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {\n PromiseConstructor.all(iterable)['catch'](function () {\n });\n});\nvar isThenable = function (it) {\n var then;\n return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar notify = function (promise, state, isReject) {\n if (state.notified)\n  return;\n state.notified = true;\n var chain = state.reactions;\n microtask(function () {\n  var value = state.value;\n  var ok = state.state == FULFILLED;\n  var index = 0;\n  while (chain.length > index) {\n   var reaction = chain[index++];\n   var handler = ok ? reaction.ok : reaction.fail;\n   var resolve = reaction.resolve;\n   var reject = reaction.reject;\n   var domain = reaction.domain;\n   var result, then, exited;\n   try {\n    if (handler) {\n     if (!ok) {\n      if (state.rejection === UNHANDLED)\n       onHandleUnhandled(promise, state);\n      state.rejection = HANDLED;\n     }\n     if (handler === true)\n      result = value;\n     else {\n      if (domain)\n       domain.enter();\n      result = handler(value);\n      if (domain) {\n       domain.exit();\n       exited = true;\n      }\n     }\n     if (result === reaction.promise) {\n      reject(TypeError('Promise-chain cycle'));\n     } else if (then = isThenable(result)) {\n      then.call(result, resolve, reject);\n     } else\n      resolve(result);\n    } else\n     reject(value);\n   } catch (error) {\n    if (domain && !exited)\n     domain.exit();\n    reject(error);\n   }\n  }\n  state.reactions = [];\n  state.notified = false;\n  if (isReject && !state.rejection)\n   onUnhandled(promise, state);\n });\n};\nvar dispatchEvent = function (name, promise, reason) {\n var event, handler;\n if (DISPATCH_EVENT) {\n  event = document.createEvent('Event');\n  event.promise = promise;\n  event.reason = reason;\n  event.initEvent(name, false, true);\n  global.dispatchEvent(event);\n } else\n  event = {\n   promise: promise,\n   reason: reason\n  };\n if (handler = global['on' + name])\n  handler(event);\n else if (name === UNHANDLED_REJECTION)\n  hostReportErrors('Unhandled promise rejection', reason);\n};\nvar onUnhandled = function (promise, state) {\n task.call(global, function () {\n  var value = state.value;\n  var IS_UNHANDLED = isUnhandled(state);\n  var result;\n  if (IS_UNHANDLED) {\n   result = perform(function () {\n    if (IS_NODE) {\n     process.emit('unhandledRejection', value, promise);\n    } else\n     dispatchEvent(UNHANDLED_REJECTION, promise, value);\n   });\n   state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;\n   if (result.error)\n    throw result.value;\n  }\n });\n};\nvar isUnhandled = function (state) {\n return state.rejection !== HANDLED && !state.parent;\n};\nvar onHandleUnhandled = function (promise, state) {\n task.call(global, function () {\n  if (IS_NODE) {\n   process.emit('rejectionHandled', promise);\n  } else\n   dispatchEvent(REJECTION_HANDLED, promise, state.value);\n });\n};\nvar bind = function (fn, promise, state, unwrap) {\n return function (value) {\n  fn(promise, state, value, unwrap);\n };\n};\nvar internalReject = function (promise, state, value, unwrap) {\n if (state.done)\n  return;\n state.done = true;\n if (unwrap)\n  state = unwrap;\n state.value = value;\n state.state = REJECTED;\n notify(promise, state, true);\n};\nvar internalResolve = function (promise, state, value, unwrap) {\n if (state.done)\n  return;\n state.done = true;\n if (unwrap)\n  state = unwrap;\n try {\n  if (promise === value)\n   throw TypeError(\"Promise can't be resolved itself\");\n  var then = isThenable(value);\n  if (then) {\n   microtask(function () {\n    var wrapper = { done: false };\n    try {\n     then.call(value, bind(internalResolve, promise, wrapper, state), bind(internalReject, promise, wrapper, state));\n    } catch (error) {\n     internalReject(promise, wrapper, error, state);\n    }\n   });\n  } else {\n   state.value = value;\n   state.state = FULFILLED;\n   notify(promise, state, false);\n  }\n } catch (error) {\n  internalReject(promise, { done: false }, error, state);\n }\n};\nif (FORCED) {\n PromiseConstructor = function Promise(executor) {\n  anInstance(this, PromiseConstructor, PROMISE);\n  aFunction(executor);\n  Internal.call(this);\n  var state = getInternalState(this);\n  try {\n   executor(bind(internalResolve, this, state), bind(internalReject, this, state));\n  } catch (error) {\n   internalReject(this, state, error);\n  }\n };\n Internal = function Promise(executor) {\n  setInternalState(this, {\n   type: PROMISE,\n   done: false,\n   notified: false,\n   parent: false,\n   reactions: [],\n   rejection: false,\n   state: PENDING,\n   value: undefined\n  });\n };\n Internal.prototype = redefineAll(PromiseConstructor.prototype, {\n  then: function then(onFulfilled, onRejected) {\n   var state = getInternalPromiseState(this);\n   var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));\n   reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;\n   reaction.fail = typeof onRejected == 'function' && onRejected;\n   reaction.domain = IS_NODE ? process.domain : undefined;\n   state.parent = true;\n   state.reactions.push(reaction);\n   if (state.state != PENDING)\n    notify(this, state, false);\n   return reaction.promise;\n  },\n  'catch': function (onRejected) {\n   return this.then(undefined, onRejected);\n  }\n });\n OwnPromiseCapability = function () {\n  var promise = new Internal();\n  var state = getInternalState(promise);\n  this.promise = promise;\n  this.resolve = bind(internalResolve, promise, state);\n  this.reject = bind(internalReject, promise, state);\n };\n newPromiseCapabilityModule.f = newPromiseCapability = function (C) {\n  return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);\n };\n if (!IS_PURE && typeof NativePromise == 'function') {\n  nativeThen = NativePromise.prototype.then;\n  redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {\n   var that = this;\n   return new PromiseConstructor(function (resolve, reject) {\n    nativeThen.call(that, resolve, reject);\n   }).then(onFulfilled, onRejected);\n  }, { unsafe: true });\n  if (typeof $fetch == 'function')\n   $({\n    global: true,\n    enumerable: true,\n    forced: true\n   }, {\n    fetch: function fetch(input) {\n     return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));\n    }\n   });\n }\n}\n$({\n global: true,\n wrap: true,\n forced: FORCED\n}, { Promise: PromiseConstructor });\nsetToStringTag(PromiseConstructor, PROMISE, false, true);\nsetSpecies(PROMISE);\nPromiseWrapper = getBuiltIn(PROMISE);\n$({\n target: PROMISE,\n stat: true,\n forced: FORCED\n}, {\n reject: function reject(r) {\n  var capability = newPromiseCapability(this);\n  capability.reject.call(undefined, r);\n  return capability.promise;\n }\n});\n$({\n target: PROMISE,\n stat: true,\n forced: IS_PURE || FORCED\n}, {\n resolve: function resolve(x) {\n  return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);\n }\n});\n$({\n target: PROMISE,\n stat: true,\n forced: INCORRECT_ITERATION\n}, {\n all: function all(iterable) {\n  var C = this;\n  var capability = newPromiseCapability(C);\n  var resolve = capability.resolve;\n  var reject = capability.reject;\n  var result = perform(function () {\n   var $promiseResolve = aFunction(C.resolve);\n   var values = [];\n   var counter = 0;\n   var remaining = 1;\n   iterate(iterable, function (promise) {\n    var index = counter++;\n    var alreadyCalled = false;\n    values.push(undefined);\n    remaining++;\n    $promiseResolve.call(C, promise).then(function (value) {\n     if (alreadyCalled)\n      return;\n     alreadyCalled = true;\n     values[index] = value;\n     --remaining || resolve(values);\n    }, reject);\n   });\n   --remaining || resolve(values);\n  });\n  if (result.error)\n   reject(result.value);\n  return capability.promise;\n },\n race: function race(iterable) {\n  var C = this;\n  var capability = newPromiseCapability(C);\n  var reject = capability.reject;\n  var result = perform(function () {\n   var $promiseResolve = aFunction(C.resolve);\n   iterate(iterable, function (promise) {\n    $promiseResolve.call(C, promise).then(capability.resolve, reject);\n   });\n  });\n  if (result.error)\n   reject(result.value);\n  return capability.promise;\n }\n});\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nmodule.exports = global.Promise;\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar redefine = __w_pdfjs_require__(29);\nmodule.exports = function (target, src, options) {\n for (var key in src)\n  redefine(target, key, src[key], options);\n return target;\n};\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar getBuiltIn = __w_pdfjs_require__(42);\nvar definePropertyModule = __w_pdfjs_require__(27);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar SPECIES = wellKnownSymbol('species');\nmodule.exports = function (CONSTRUCTOR_NAME) {\n var Constructor = getBuiltIn(CONSTRUCTOR_NAME);\n var defineProperty = definePropertyModule.f;\n if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {\n  defineProperty(Constructor, SPECIES, {\n   configurable: true,\n   get: function () {\n    return this;\n   }\n  });\n }\n};\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (it, Constructor, name) {\n if (!(it instanceof Constructor)) {\n  throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');\n }\n return it;\n};\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar fails = __w_pdfjs_require__(14);\nvar classof = __w_pdfjs_require__(19);\nvar bind = __w_pdfjs_require__(62);\nvar html = __w_pdfjs_require__(74);\nvar createElement = __w_pdfjs_require__(25);\nvar IS_IOS = __w_pdfjs_require__(128);\nvar location = global.location;\nvar set = global.setImmediate;\nvar clear = global.clearImmediate;\nvar process = global.process;\nvar MessageChannel = global.MessageChannel;\nvar Dispatch = global.Dispatch;\nvar counter = 0;\nvar queue = {};\nvar ONREADYSTATECHANGE = 'onreadystatechange';\nvar defer, channel, port;\nvar run = function (id) {\n if (queue.hasOwnProperty(id)) {\n  var fn = queue[id];\n  delete queue[id];\n  fn();\n }\n};\nvar runner = function (id) {\n return function () {\n  run(id);\n };\n};\nvar listener = function (event) {\n run(event.data);\n};\nvar post = function (id) {\n global.postMessage(id + '', location.protocol + '//' + location.host);\n};\nif (!set || !clear) {\n set = function setImmediate(fn) {\n  var args = [];\n  var i = 1;\n  while (arguments.length > i)\n   args.push(arguments[i++]);\n  queue[++counter] = function () {\n   (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);\n  };\n  defer(counter);\n  return counter;\n };\n clear = function clearImmediate(id) {\n  delete queue[id];\n };\n if (classof(process) == 'process') {\n  defer = function (id) {\n   process.nextTick(runner(id));\n  };\n } else if (Dispatch && Dispatch.now) {\n  defer = function (id) {\n   Dispatch.now(runner(id));\n  };\n } else if (MessageChannel && !IS_IOS) {\n  channel = new MessageChannel();\n  port = channel.port2;\n  channel.port1.onmessage = listener;\n  defer = bind(port.postMessage, port, 1);\n } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && !fails(post) && location.protocol !== 'file:') {\n  defer = post;\n  global.addEventListener('message', listener, false);\n } else if (ONREADYSTATECHANGE in createElement('script')) {\n  defer = function (id) {\n   html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {\n    html.removeChild(this);\n    run(id);\n   };\n  };\n } else {\n  defer = function (id) {\n   setTimeout(runner(id), 0);\n  };\n }\n}\nmodule.exports = {\n set: set,\n clear: clear\n};\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar userAgent = __w_pdfjs_require__(129);\nmodule.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar getBuiltIn = __w_pdfjs_require__(42);\nmodule.exports = getBuiltIn('navigator', 'userAgent') || '';\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar getOwnPropertyDescriptor = __w_pdfjs_require__(12).f;\nvar classof = __w_pdfjs_require__(19);\nvar macrotask = __w_pdfjs_require__(127).set;\nvar IS_IOS = __w_pdfjs_require__(128);\nvar MutationObserver = global.MutationObserver || global.WebKitMutationObserver;\nvar process = global.process;\nvar Promise = global.Promise;\nvar IS_NODE = classof(process) == 'process';\nvar queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');\nvar queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;\nvar flush, head, last, notify, toggle, node, promise, then;\nif (!queueMicrotask) {\n flush = function () {\n  var parent, fn;\n  if (IS_NODE && (parent = process.domain))\n   parent.exit();\n  while (head) {\n   fn = head.fn;\n   head = head.next;\n   try {\n    fn();\n   } catch (error) {\n    if (head)\n     notify();\n    else\n     last = undefined;\n    throw error;\n   }\n  }\n  last = undefined;\n  if (parent)\n   parent.enter();\n };\n if (IS_NODE) {\n  notify = function () {\n   process.nextTick(flush);\n  };\n } else if (MutationObserver && !IS_IOS) {\n  toggle = true;\n  node = document.createTextNode('');\n  new MutationObserver(flush).observe(node, { characterData: true });\n  notify = function () {\n   node.data = toggle = !toggle;\n  };\n } else if (Promise && Promise.resolve) {\n  promise = Promise.resolve(undefined);\n  then = promise.then;\n  notify = function () {\n   then.call(promise, flush);\n  };\n } else {\n  notify = function () {\n   macrotask.call(global, flush);\n  };\n }\n}\nmodule.exports = queueMicrotask || function (fn) {\n var task = {\n  fn: fn,\n  next: undefined\n };\n if (last)\n  last.next = task;\n if (!head) {\n  head = task;\n  notify();\n }\n last = task;\n};\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(28);\nvar isObject = __w_pdfjs_require__(22);\nvar newPromiseCapability = __w_pdfjs_require__(132);\nmodule.exports = function (C, x) {\n anObject(C);\n if (isObject(x) && x.constructor === C)\n  return x;\n var promiseCapability = newPromiseCapability.f(C);\n var resolve = promiseCapability.resolve;\n resolve(x);\n return promiseCapability.promise;\n};\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar aFunction = __w_pdfjs_require__(63);\nvar PromiseCapability = function (C) {\n var resolve, reject;\n this.promise = new C(function ($$resolve, $$reject) {\n  if (resolve !== undefined || reject !== undefined)\n   throw TypeError('Bad Promise constructor');\n  resolve = $$resolve;\n  reject = $$reject;\n });\n this.resolve = aFunction(resolve);\n this.reject = aFunction(reject);\n};\nmodule.exports.f = function (C) {\n return new PromiseCapability(C);\n};\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nmodule.exports = function (a, b) {\n var console = global.console;\n if (console && console.error) {\n  arguments.length === 1 ? console.error(a) : console.error(a, b);\n }\n};\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports) {\n\nmodule.exports = function (exec) {\n try {\n  return {\n   error: false,\n   value: exec()\n  };\n } catch (error) {\n  return {\n   error: true,\n   value: error\n  };\n }\n};\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar userAgent = __w_pdfjs_require__(129);\nvar process = global.process;\nvar versions = process && process.versions;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n match = v8.split('.');\n version = match[0] + match[1];\n} else if (userAgent) {\n match = userAgent.match(/Edge\\/(\\d+)/);\n if (!match || match[1] >= 74) {\n  match = userAgent.match(/Chrome\\/(\\d+)/);\n  if (match)\n   version = match[1];\n }\n}\nmodule.exports = version && +version;\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar aFunction = __w_pdfjs_require__(63);\nvar newPromiseCapabilityModule = __w_pdfjs_require__(132);\nvar perform = __w_pdfjs_require__(134);\nvar iterate = __w_pdfjs_require__(104);\n$({\n target: 'Promise',\n stat: true\n}, {\n allSettled: function allSettled(iterable) {\n  var C = this;\n  var capability = newPromiseCapabilityModule.f(C);\n  var resolve = capability.resolve;\n  var reject = capability.reject;\n  var result = perform(function () {\n   var promiseResolve = aFunction(C.resolve);\n   var values = [];\n   var counter = 0;\n   var remaining = 1;\n   iterate(iterable, function (promise) {\n    var index = counter++;\n    var alreadyCalled = false;\n    values.push(undefined);\n    remaining++;\n    promiseResolve.call(C, promise).then(function (value) {\n     if (alreadyCalled)\n      return;\n     alreadyCalled = true;\n     values[index] = {\n      status: 'fulfilled',\n      value: value\n     };\n     --remaining || resolve(values);\n    }, function (e) {\n     if (alreadyCalled)\n      return;\n     alreadyCalled = true;\n     values[index] = {\n      status: 'rejected',\n      reason: e\n     };\n     --remaining || resolve(values);\n    });\n   });\n   --remaining || resolve(values);\n  });\n  if (result.error)\n   reject(result.value);\n  return capability.promise;\n }\n});\n\n/***/ }),\n/* 137 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar IS_PURE = __w_pdfjs_require__(37);\nvar NativePromise = __w_pdfjs_require__(123);\nvar fails = __w_pdfjs_require__(14);\nvar getBuiltIn = __w_pdfjs_require__(42);\nvar speciesConstructor = __w_pdfjs_require__(116);\nvar promiseResolve = __w_pdfjs_require__(131);\nvar redefine = __w_pdfjs_require__(29);\nvar NON_GENERIC = !!NativePromise && fails(function () {\n NativePromise.prototype['finally'].call({\n  then: function () {\n  }\n }, function () {\n });\n});\n$({\n target: 'Promise',\n proto: true,\n real: true,\n forced: NON_GENERIC\n}, {\n 'finally': function (onFinally) {\n  var C = speciesConstructor(this, getBuiltIn('Promise'));\n  var isFunction = typeof onFinally == 'function';\n  return this.then(isFunction ? function (x) {\n   return promiseResolve(C, onFinally()).then(function () {\n    return x;\n   });\n  } : onFinally, isFunction ? function (e) {\n   return promiseResolve(C, onFinally()).then(function () {\n    throw e;\n   });\n  } : onFinally);\n }\n});\nif (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) {\n redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']);\n}\n\n/***/ }),\n/* 138 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(139);\n__w_pdfjs_require__(144);\n__w_pdfjs_require__(142);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.URL;\n\n/***/ }),\n/* 139 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n__w_pdfjs_require__(77);\nvar $ = __w_pdfjs_require__(10);\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar USE_NATIVE_URL = __w_pdfjs_require__(140);\nvar global = __w_pdfjs_require__(11);\nvar defineProperties = __w_pdfjs_require__(72);\nvar redefine = __w_pdfjs_require__(29);\nvar anInstance = __w_pdfjs_require__(126);\nvar has = __w_pdfjs_require__(23);\nvar assign = __w_pdfjs_require__(100);\nvar arrayFrom = __w_pdfjs_require__(90);\nvar codeAt = __w_pdfjs_require__(78).codeAt;\nvar toASCII = __w_pdfjs_require__(141);\nvar setToStringTag = __w_pdfjs_require__(85);\nvar URLSearchParamsModule = __w_pdfjs_require__(142);\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar NativeURL = global.URL;\nvar URLSearchParams = URLSearchParamsModule.URLSearchParams;\nvar getInternalSearchParamsState = URLSearchParamsModule.getState;\nvar setInternalState = InternalStateModule.set;\nvar getInternalURLState = InternalStateModule.getterFor('URL');\nvar floor = Math.floor;\nvar pow = Math.pow;\nvar INVALID_AUTHORITY = 'Invalid authority';\nvar INVALID_SCHEME = 'Invalid scheme';\nvar INVALID_HOST = 'Invalid host';\nvar INVALID_PORT = 'Invalid port';\nvar ALPHA = /[A-Za-z]/;\nvar ALPHANUMERIC = /[\\d+-.A-Za-z]/;\nvar DIGIT = /\\d/;\nvar HEX_START = /^(0x|0X)/;\nvar OCT = /^[0-7]+$/;\nvar DEC = /^\\d+$/;\nvar HEX = /^[\\dA-Fa-f]+$/;\nvar FORBIDDEN_HOST_CODE_POINT = /[\\u0000\\u0009\\u000A\\u000D #%/:?@[\\\\]]/;\nvar FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\\u0000\\u0009\\u000A\\u000D #/:?@[\\\\]]/;\nvar LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\\u0000-\\u001F ]+|[\\u0000-\\u001F ]+$/g;\nvar TAB_AND_NEW_LINE = /[\\u0009\\u000A\\u000D]/g;\nvar EOF;\nvar parseHost = function (url, input) {\n var result, codePoints, index;\n if (input.charAt(0) == '[') {\n  if (input.charAt(input.length - 1) != ']')\n   return INVALID_HOST;\n  result = parseIPv6(input.slice(1, -1));\n  if (!result)\n   return INVALID_HOST;\n  url.host = result;\n } else if (!isSpecial(url)) {\n  if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input))\n   return INVALID_HOST;\n  result = '';\n  codePoints = arrayFrom(input);\n  for (index = 0; index < codePoints.length; index++) {\n   result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);\n  }\n  url.host = result;\n } else {\n  input = toASCII(input);\n  if (FORBIDDEN_HOST_CODE_POINT.test(input))\n   return INVALID_HOST;\n  result = parseIPv4(input);\n  if (result === null)\n   return INVALID_HOST;\n  url.host = result;\n }\n};\nvar parseIPv4 = function (input) {\n var parts = input.split('.');\n var partsLength, numbers, index, part, radix, number, ipv4;\n if (parts.length && parts[parts.length - 1] == '') {\n  parts.pop();\n }\n partsLength = parts.length;\n if (partsLength > 4)\n  return input;\n numbers = [];\n for (index = 0; index < partsLength; index++) {\n  part = parts[index];\n  if (part == '')\n   return input;\n  radix = 10;\n  if (part.length > 1 && part.charAt(0) == '0') {\n   radix = HEX_START.test(part) ? 16 : 8;\n   part = part.slice(radix == 8 ? 1 : 2);\n  }\n  if (part === '') {\n   number = 0;\n  } else {\n   if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part))\n    return input;\n   number = parseInt(part, radix);\n  }\n  numbers.push(number);\n }\n for (index = 0; index < partsLength; index++) {\n  number = numbers[index];\n  if (index == partsLength - 1) {\n   if (number >= pow(256, 5 - partsLength))\n    return null;\n  } else if (number > 255)\n   return null;\n }\n ipv4 = numbers.pop();\n for (index = 0; index < numbers.length; index++) {\n  ipv4 += numbers[index] * pow(256, 3 - index);\n }\n return ipv4;\n};\nvar parseIPv6 = function (input) {\n var address = [\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0\n ];\n var pieceIndex = 0;\n var compress = null;\n var pointer = 0;\n var value, length, numbersSeen, ipv4Piece, number, swaps, swap;\n var char = function () {\n  return input.charAt(pointer);\n };\n if (char() == ':') {\n  if (input.charAt(1) != ':')\n   return;\n  pointer += 2;\n  pieceIndex++;\n  compress = pieceIndex;\n }\n while (char()) {\n  if (pieceIndex == 8)\n   return;\n  if (char() == ':') {\n   if (compress !== null)\n    return;\n   pointer++;\n   pieceIndex++;\n   compress = pieceIndex;\n   continue;\n  }\n  value = length = 0;\n  while (length < 4 && HEX.test(char())) {\n   value = value * 16 + parseInt(char(), 16);\n   pointer++;\n   length++;\n  }\n  if (char() == '.') {\n   if (length == 0)\n    return;\n   pointer -= length;\n   if (pieceIndex > 6)\n    return;\n   numbersSeen = 0;\n   while (char()) {\n    ipv4Piece = null;\n    if (numbersSeen > 0) {\n     if (char() == '.' && numbersSeen < 4)\n      pointer++;\n     else\n      return;\n    }\n    if (!DIGIT.test(char()))\n     return;\n    while (DIGIT.test(char())) {\n     number = parseInt(char(), 10);\n     if (ipv4Piece === null)\n      ipv4Piece = number;\n     else if (ipv4Piece == 0)\n      return;\n     else\n      ipv4Piece = ipv4Piece * 10 + number;\n     if (ipv4Piece > 255)\n      return;\n     pointer++;\n    }\n    address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;\n    numbersSeen++;\n    if (numbersSeen == 2 || numbersSeen == 4)\n     pieceIndex++;\n   }\n   if (numbersSeen != 4)\n    return;\n   break;\n  } else if (char() == ':') {\n   pointer++;\n   if (!char())\n    return;\n  } else if (char())\n   return;\n  address[pieceIndex++] = value;\n }\n if (compress !== null) {\n  swaps = pieceIndex - compress;\n  pieceIndex = 7;\n  while (pieceIndex != 0 && swaps > 0) {\n   swap = address[pieceIndex];\n   address[pieceIndex--] = address[compress + swaps - 1];\n   address[compress + --swaps] = swap;\n  }\n } else if (pieceIndex != 8)\n  return;\n return address;\n};\nvar findLongestZeroSequence = function (ipv6) {\n var maxIndex = null;\n var maxLength = 1;\n var currStart = null;\n var currLength = 0;\n var index = 0;\n for (; index < 8; index++) {\n  if (ipv6[index] !== 0) {\n   if (currLength > maxLength) {\n    maxIndex = currStart;\n    maxLength = currLength;\n   }\n   currStart = null;\n   currLength = 0;\n  } else {\n   if (currStart === null)\n    currStart = index;\n   ++currLength;\n  }\n }\n if (currLength > maxLength) {\n  maxIndex = currStart;\n  maxLength = currLength;\n }\n return maxIndex;\n};\nvar serializeHost = function (host) {\n var result, index, compress, ignore0;\n if (typeof host == 'number') {\n  result = [];\n  for (index = 0; index < 4; index++) {\n   result.unshift(host % 256);\n   host = floor(host / 256);\n  }\n  return result.join('.');\n } else if (typeof host == 'object') {\n  result = '';\n  compress = findLongestZeroSequence(host);\n  for (index = 0; index < 8; index++) {\n   if (ignore0 && host[index] === 0)\n    continue;\n   if (ignore0)\n    ignore0 = false;\n   if (compress === index) {\n    result += index ? ':' : '::';\n    ignore0 = true;\n   } else {\n    result += host[index].toString(16);\n    if (index < 7)\n     result += ':';\n   }\n  }\n  return '[' + result + ']';\n }\n return host;\n};\nvar C0ControlPercentEncodeSet = {};\nvar fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {\n ' ': 1,\n '\"': 1,\n '<': 1,\n '>': 1,\n '`': 1\n});\nvar pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {\n '#': 1,\n '?': 1,\n '{': 1,\n '}': 1\n});\nvar userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {\n '/': 1,\n ':': 1,\n ';': 1,\n '=': 1,\n '@': 1,\n '[': 1,\n '\\\\': 1,\n ']': 1,\n '^': 1,\n '|': 1\n});\nvar percentEncode = function (char, set) {\n var code = codeAt(char, 0);\n return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);\n};\nvar specialSchemes = {\n ftp: 21,\n file: null,\n http: 80,\n https: 443,\n ws: 80,\n wss: 443\n};\nvar isSpecial = function (url) {\n return has(specialSchemes, url.scheme);\n};\nvar includesCredentials = function (url) {\n return url.username != '' || url.password != '';\n};\nvar cannotHaveUsernamePasswordPort = function (url) {\n return !url.host || url.cannotBeABaseURL || url.scheme == 'file';\n};\nvar isWindowsDriveLetter = function (string, normalized) {\n var second;\n return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|');\n};\nvar startsWithWindowsDriveLetter = function (string) {\n var third;\n return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || ((third = string.charAt(2)) === '/' || third === '\\\\' || third === '?' || third === '#'));\n};\nvar shortenURLsPath = function (url) {\n var path = url.path;\n var pathSize = path.length;\n if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {\n  path.pop();\n }\n};\nvar isSingleDot = function (segment) {\n return segment === '.' || segment.toLowerCase() === '%2e';\n};\nvar isDoubleDot = function (segment) {\n segment = segment.toLowerCase();\n return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';\n};\nvar SCHEME_START = {};\nvar SCHEME = {};\nvar NO_SCHEME = {};\nvar SPECIAL_RELATIVE_OR_AUTHORITY = {};\nvar PATH_OR_AUTHORITY = {};\nvar RELATIVE = {};\nvar RELATIVE_SLASH = {};\nvar SPECIAL_AUTHORITY_SLASHES = {};\nvar SPECIAL_AUTHORITY_IGNORE_SLASHES = {};\nvar AUTHORITY = {};\nvar HOST = {};\nvar HOSTNAME = {};\nvar PORT = {};\nvar FILE = {};\nvar FILE_SLASH = {};\nvar FILE_HOST = {};\nvar PATH_START = {};\nvar PATH = {};\nvar CANNOT_BE_A_BASE_URL_PATH = {};\nvar QUERY = {};\nvar FRAGMENT = {};\nvar parseURL = function (url, input, stateOverride, base) {\n var state = stateOverride || SCHEME_START;\n var pointer = 0;\n var buffer = '';\n var seenAt = false;\n var seenBracket = false;\n var seenPasswordToken = false;\n var codePoints, char, bufferCodePoints, failure;\n if (!stateOverride) {\n  url.scheme = '';\n  url.username = '';\n  url.password = '';\n  url.host = null;\n  url.port = null;\n  url.path = [];\n  url.query = null;\n  url.fragment = null;\n  url.cannotBeABaseURL = false;\n  input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');\n }\n input = input.replace(TAB_AND_NEW_LINE, '');\n codePoints = arrayFrom(input);\n while (pointer <= codePoints.length) {\n  char = codePoints[pointer];\n  switch (state) {\n  case SCHEME_START:\n   if (char && ALPHA.test(char)) {\n    buffer += char.toLowerCase();\n    state = SCHEME;\n   } else if (!stateOverride) {\n    state = NO_SCHEME;\n    continue;\n   } else\n    return INVALID_SCHEME;\n   break;\n  case SCHEME:\n   if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {\n    buffer += char.toLowerCase();\n   } else if (char == ':') {\n    if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host))\n     return;\n    url.scheme = buffer;\n    if (stateOverride) {\n     if (isSpecial(url) && specialSchemes[url.scheme] == url.port)\n      url.port = null;\n     return;\n    }\n    buffer = '';\n    if (url.scheme == 'file') {\n     state = FILE;\n    } else if (isSpecial(url) && base && base.scheme == url.scheme) {\n     state = SPECIAL_RELATIVE_OR_AUTHORITY;\n    } else if (isSpecial(url)) {\n     state = SPECIAL_AUTHORITY_SLASHES;\n    } else if (codePoints[pointer + 1] == '/') {\n     state = PATH_OR_AUTHORITY;\n     pointer++;\n    } else {\n     url.cannotBeABaseURL = true;\n     url.path.push('');\n     state = CANNOT_BE_A_BASE_URL_PATH;\n    }\n   } else if (!stateOverride) {\n    buffer = '';\n    state = NO_SCHEME;\n    pointer = 0;\n    continue;\n   } else\n    return INVALID_SCHEME;\n   break;\n  case NO_SCHEME:\n   if (!base || base.cannotBeABaseURL && char != '#')\n    return INVALID_SCHEME;\n   if (base.cannotBeABaseURL && char == '#') {\n    url.scheme = base.scheme;\n    url.path = base.path.slice();\n    url.query = base.query;\n    url.fragment = '';\n    url.cannotBeABaseURL = true;\n    state = FRAGMENT;\n    break;\n   }\n   state = base.scheme == 'file' ? FILE : RELATIVE;\n   continue;\n  case SPECIAL_RELATIVE_OR_AUTHORITY:\n   if (char == '/' && codePoints[pointer + 1] == '/') {\n    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n    pointer++;\n   } else {\n    state = RELATIVE;\n    continue;\n   }\n   break;\n  case PATH_OR_AUTHORITY:\n   if (char == '/') {\n    state = AUTHORITY;\n    break;\n   } else {\n    state = PATH;\n    continue;\n   }\n  case RELATIVE:\n   url.scheme = base.scheme;\n   if (char == EOF) {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    url.path = base.path.slice();\n    url.query = base.query;\n   } else if (char == '/' || char == '\\\\' && isSpecial(url)) {\n    state = RELATIVE_SLASH;\n   } else if (char == '?') {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    url.path = base.path.slice();\n    url.query = '';\n    state = QUERY;\n   } else if (char == '#') {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    url.path = base.path.slice();\n    url.query = base.query;\n    url.fragment = '';\n    state = FRAGMENT;\n   } else {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    url.path = base.path.slice();\n    url.path.pop();\n    state = PATH;\n    continue;\n   }\n   break;\n  case RELATIVE_SLASH:\n   if (isSpecial(url) && (char == '/' || char == '\\\\')) {\n    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n   } else if (char == '/') {\n    state = AUTHORITY;\n   } else {\n    url.username = base.username;\n    url.password = base.password;\n    url.host = base.host;\n    url.port = base.port;\n    state = PATH;\n    continue;\n   }\n   break;\n  case SPECIAL_AUTHORITY_SLASHES:\n   state = SPECIAL_AUTHORITY_IGNORE_SLASHES;\n   if (char != '/' || buffer.charAt(pointer + 1) != '/')\n    continue;\n   pointer++;\n   break;\n  case SPECIAL_AUTHORITY_IGNORE_SLASHES:\n   if (char != '/' && char != '\\\\') {\n    state = AUTHORITY;\n    continue;\n   }\n   break;\n  case AUTHORITY:\n   if (char == '@') {\n    if (seenAt)\n     buffer = '%40' + buffer;\n    seenAt = true;\n    bufferCodePoints = arrayFrom(buffer);\n    for (var i = 0; i < bufferCodePoints.length; i++) {\n     var codePoint = bufferCodePoints[i];\n     if (codePoint == ':' && !seenPasswordToken) {\n      seenPasswordToken = true;\n      continue;\n     }\n     var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);\n     if (seenPasswordToken)\n      url.password += encodedCodePoints;\n     else\n      url.username += encodedCodePoints;\n    }\n    buffer = '';\n   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\\\' && isSpecial(url)) {\n    if (seenAt && buffer == '')\n     return INVALID_AUTHORITY;\n    pointer -= arrayFrom(buffer).length + 1;\n    buffer = '';\n    state = HOST;\n   } else\n    buffer += char;\n   break;\n  case HOST:\n  case HOSTNAME:\n   if (stateOverride && url.scheme == 'file') {\n    state = FILE_HOST;\n    continue;\n   } else if (char == ':' && !seenBracket) {\n    if (buffer == '')\n     return INVALID_HOST;\n    failure = parseHost(url, buffer);\n    if (failure)\n     return failure;\n    buffer = '';\n    state = PORT;\n    if (stateOverride == HOSTNAME)\n     return;\n   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\\\' && isSpecial(url)) {\n    if (isSpecial(url) && buffer == '')\n     return INVALID_HOST;\n    if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null))\n     return;\n    failure = parseHost(url, buffer);\n    if (failure)\n     return failure;\n    buffer = '';\n    state = PATH_START;\n    if (stateOverride)\n     return;\n    continue;\n   } else {\n    if (char == '[')\n     seenBracket = true;\n    else if (char == ']')\n     seenBracket = false;\n    buffer += char;\n   }\n   break;\n  case PORT:\n   if (DIGIT.test(char)) {\n    buffer += char;\n   } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\\\' && isSpecial(url) || stateOverride) {\n    if (buffer != '') {\n     var port = parseInt(buffer, 10);\n     if (port > 0xFFFF)\n      return INVALID_PORT;\n     url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;\n     buffer = '';\n    }\n    if (stateOverride)\n     return;\n    state = PATH_START;\n    continue;\n   } else\n    return INVALID_PORT;\n   break;\n  case FILE:\n   url.scheme = 'file';\n   if (char == '/' || char == '\\\\')\n    state = FILE_SLASH;\n   else if (base && base.scheme == 'file') {\n    if (char == EOF) {\n     url.host = base.host;\n     url.path = base.path.slice();\n     url.query = base.query;\n    } else if (char == '?') {\n     url.host = base.host;\n     url.path = base.path.slice();\n     url.query = '';\n     state = QUERY;\n    } else if (char == '#') {\n     url.host = base.host;\n     url.path = base.path.slice();\n     url.query = base.query;\n     url.fragment = '';\n     state = FRAGMENT;\n    } else {\n     if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {\n      url.host = base.host;\n      url.path = base.path.slice();\n      shortenURLsPath(url);\n     }\n     state = PATH;\n     continue;\n    }\n   } else {\n    state = PATH;\n    continue;\n   }\n   break;\n  case FILE_SLASH:\n   if (char == '/' || char == '\\\\') {\n    state = FILE_HOST;\n    break;\n   }\n   if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {\n    if (isWindowsDriveLetter(base.path[0], true))\n     url.path.push(base.path[0]);\n    else\n     url.host = base.host;\n   }\n   state = PATH;\n   continue;\n  case FILE_HOST:\n   if (char == EOF || char == '/' || char == '\\\\' || char == '?' || char == '#') {\n    if (!stateOverride && isWindowsDriveLetter(buffer)) {\n     state = PATH;\n    } else if (buffer == '') {\n     url.host = '';\n     if (stateOverride)\n      return;\n     state = PATH_START;\n    } else {\n     failure = parseHost(url, buffer);\n     if (failure)\n      return failure;\n     if (url.host == 'localhost')\n      url.host = '';\n     if (stateOverride)\n      return;\n     buffer = '';\n     state = PATH_START;\n    }\n    continue;\n   } else\n    buffer += char;\n   break;\n  case PATH_START:\n   if (isSpecial(url)) {\n    state = PATH;\n    if (char != '/' && char != '\\\\')\n     continue;\n   } else if (!stateOverride && char == '?') {\n    url.query = '';\n    state = QUERY;\n   } else if (!stateOverride && char == '#') {\n    url.fragment = '';\n    state = FRAGMENT;\n   } else if (char != EOF) {\n    state = PATH;\n    if (char != '/')\n     continue;\n   }\n   break;\n  case PATH:\n   if (char == EOF || char == '/' || char == '\\\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) {\n    if (isDoubleDot(buffer)) {\n     shortenURLsPath(url);\n     if (char != '/' && !(char == '\\\\' && isSpecial(url))) {\n      url.path.push('');\n     }\n    } else if (isSingleDot(buffer)) {\n     if (char != '/' && !(char == '\\\\' && isSpecial(url))) {\n      url.path.push('');\n     }\n    } else {\n     if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {\n      if (url.host)\n       url.host = '';\n      buffer = buffer.charAt(0) + ':';\n     }\n     url.path.push(buffer);\n    }\n    buffer = '';\n    if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {\n     while (url.path.length > 1 && url.path[0] === '') {\n      url.path.shift();\n     }\n    }\n    if (char == '?') {\n     url.query = '';\n     state = QUERY;\n    } else if (char == '#') {\n     url.fragment = '';\n     state = FRAGMENT;\n    }\n   } else {\n    buffer += percentEncode(char, pathPercentEncodeSet);\n   }\n   break;\n  case CANNOT_BE_A_BASE_URL_PATH:\n   if (char == '?') {\n    url.query = '';\n    state = QUERY;\n   } else if (char == '#') {\n    url.fragment = '';\n    state = FRAGMENT;\n   } else if (char != EOF) {\n    url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);\n   }\n   break;\n  case QUERY:\n   if (!stateOverride && char == '#') {\n    url.fragment = '';\n    state = FRAGMENT;\n   } else if (char != EOF) {\n    if (char == \"'\" && isSpecial(url))\n     url.query += '%27';\n    else if (char == '#')\n     url.query += '%23';\n    else\n     url.query += percentEncode(char, C0ControlPercentEncodeSet);\n   }\n   break;\n  case FRAGMENT:\n   if (char != EOF)\n    url.fragment += percentEncode(char, fragmentPercentEncodeSet);\n   break;\n  }\n  pointer++;\n }\n};\nvar URLConstructor = function URL(url) {\n var that = anInstance(this, URLConstructor, 'URL');\n var base = arguments.length > 1 ? arguments[1] : undefined;\n var urlString = String(url);\n var state = setInternalState(that, { type: 'URL' });\n var baseState, failure;\n if (base !== undefined) {\n  if (base instanceof URLConstructor)\n   baseState = getInternalURLState(base);\n  else {\n   failure = parseURL(baseState = {}, String(base));\n   if (failure)\n    throw TypeError(failure);\n  }\n }\n failure = parseURL(state, urlString, null, baseState);\n if (failure)\n  throw TypeError(failure);\n var searchParams = state.searchParams = new URLSearchParams();\n var searchParamsState = getInternalSearchParamsState(searchParams);\n searchParamsState.updateSearchParams(state.query);\n searchParamsState.updateURL = function () {\n  state.query = String(searchParams) || null;\n };\n if (!DESCRIPTORS) {\n  that.href = serializeURL.call(that);\n  that.origin = getOrigin.call(that);\n  that.protocol = getProtocol.call(that);\n  that.username = getUsername.call(that);\n  that.password = getPassword.call(that);\n  that.host = getHost.call(that);\n  that.hostname = getHostname.call(that);\n  that.port = getPort.call(that);\n  that.pathname = getPathname.call(that);\n  that.search = getSearch.call(that);\n  that.searchParams = getSearchParams.call(that);\n  that.hash = getHash.call(that);\n }\n};\nvar URLPrototype = URLConstructor.prototype;\nvar serializeURL = function () {\n var url = getInternalURLState(this);\n var scheme = url.scheme;\n var username = url.username;\n var password = url.password;\n var host = url.host;\n var port = url.port;\n var path = url.path;\n var query = url.query;\n var fragment = url.fragment;\n var output = scheme + ':';\n if (host !== null) {\n  output += '//';\n  if (includesCredentials(url)) {\n   output += username + (password ? ':' + password : '') + '@';\n  }\n  output += serializeHost(host);\n  if (port !== null)\n   output += ':' + port;\n } else if (scheme == 'file')\n  output += '//';\n output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';\n if (query !== null)\n  output += '?' + query;\n if (fragment !== null)\n  output += '#' + fragment;\n return output;\n};\nvar getOrigin = function () {\n var url = getInternalURLState(this);\n var scheme = url.scheme;\n var port = url.port;\n if (scheme == 'blob')\n  try {\n   return new URL(scheme.path[0]).origin;\n  } catch (error) {\n   return 'null';\n  }\n if (scheme == 'file' || !isSpecial(url))\n  return 'null';\n return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');\n};\nvar getProtocol = function () {\n return getInternalURLState(this).scheme + ':';\n};\nvar getUsername = function () {\n return getInternalURLState(this).username;\n};\nvar getPassword = function () {\n return getInternalURLState(this).password;\n};\nvar getHost = function () {\n var url = getInternalURLState(this);\n var host = url.host;\n var port = url.port;\n return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port;\n};\nvar getHostname = function () {\n var host = getInternalURLState(this).host;\n return host === null ? '' : serializeHost(host);\n};\nvar getPort = function () {\n var port = getInternalURLState(this).port;\n return port === null ? '' : String(port);\n};\nvar getPathname = function () {\n var url = getInternalURLState(this);\n var path = url.path;\n return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';\n};\nvar getSearch = function () {\n var query = getInternalURLState(this).query;\n return query ? '?' + query : '';\n};\nvar getSearchParams = function () {\n return getInternalURLState(this).searchParams;\n};\nvar getHash = function () {\n var fragment = getInternalURLState(this).fragment;\n return fragment ? '#' + fragment : '';\n};\nvar accessorDescriptor = function (getter, setter) {\n return {\n  get: getter,\n  set: setter,\n  configurable: true,\n  enumerable: true\n };\n};\nif (DESCRIPTORS) {\n defineProperties(URLPrototype, {\n  href: accessorDescriptor(serializeURL, function (href) {\n   var url = getInternalURLState(this);\n   var urlString = String(href);\n   var failure = parseURL(url, urlString);\n   if (failure)\n    throw TypeError(failure);\n   getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);\n  }),\n  origin: accessorDescriptor(getOrigin),\n  protocol: accessorDescriptor(getProtocol, function (protocol) {\n   var url = getInternalURLState(this);\n   parseURL(url, String(protocol) + ':', SCHEME_START);\n  }),\n  username: accessorDescriptor(getUsername, function (username) {\n   var url = getInternalURLState(this);\n   var codePoints = arrayFrom(String(username));\n   if (cannotHaveUsernamePasswordPort(url))\n    return;\n   url.username = '';\n   for (var i = 0; i < codePoints.length; i++) {\n    url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n   }\n  }),\n  password: accessorDescriptor(getPassword, function (password) {\n   var url = getInternalURLState(this);\n   var codePoints = arrayFrom(String(password));\n   if (cannotHaveUsernamePasswordPort(url))\n    return;\n   url.password = '';\n   for (var i = 0; i < codePoints.length; i++) {\n    url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);\n   }\n  }),\n  host: accessorDescriptor(getHost, function (host) {\n   var url = getInternalURLState(this);\n   if (url.cannotBeABaseURL)\n    return;\n   parseURL(url, String(host), HOST);\n  }),\n  hostname: accessorDescriptor(getHostname, function (hostname) {\n   var url = getInternalURLState(this);\n   if (url.cannotBeABaseURL)\n    return;\n   parseURL(url, String(hostname), HOSTNAME);\n  }),\n  port: accessorDescriptor(getPort, function (port) {\n   var url = getInternalURLState(this);\n   if (cannotHaveUsernamePasswordPort(url))\n    return;\n   port = String(port);\n   if (port == '')\n    url.port = null;\n   else\n    parseURL(url, port, PORT);\n  }),\n  pathname: accessorDescriptor(getPathname, function (pathname) {\n   var url = getInternalURLState(this);\n   if (url.cannotBeABaseURL)\n    return;\n   url.path = [];\n   parseURL(url, pathname + '', PATH_START);\n  }),\n  search: accessorDescriptor(getSearch, function (search) {\n   var url = getInternalURLState(this);\n   search = String(search);\n   if (search == '') {\n    url.query = null;\n   } else {\n    if ('?' == search.charAt(0))\n     search = search.slice(1);\n    url.query = '';\n    parseURL(url, search, QUERY);\n   }\n   getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);\n  }),\n  searchParams: accessorDescriptor(getSearchParams),\n  hash: accessorDescriptor(getHash, function (hash) {\n   var url = getInternalURLState(this);\n   hash = String(hash);\n   if (hash == '') {\n    url.fragment = null;\n    return;\n   }\n   if ('#' == hash.charAt(0))\n    hash = hash.slice(1);\n   url.fragment = '';\n   parseURL(url, hash, FRAGMENT);\n  })\n });\n}\nredefine(URLPrototype, 'toJSON', function toJSON() {\n return serializeURL.call(this);\n}, { enumerable: true });\nredefine(URLPrototype, 'toString', function toString() {\n return serializeURL.call(this);\n}, { enumerable: true });\nif (NativeURL) {\n var nativeCreateObjectURL = NativeURL.createObjectURL;\n var nativeRevokeObjectURL = NativeURL.revokeObjectURL;\n if (nativeCreateObjectURL)\n  redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {\n   return nativeCreateObjectURL.apply(NativeURL, arguments);\n  });\n if (nativeRevokeObjectURL)\n  redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {\n   return nativeRevokeObjectURL.apply(NativeURL, arguments);\n  });\n}\nsetToStringTag(URLConstructor, 'URL');\n$({\n global: true,\n forced: !USE_NATIVE_URL,\n sham: !DESCRIPTORS\n}, { URL: URLConstructor });\n\n/***/ }),\n/* 140 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(14);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar IS_PURE = __w_pdfjs_require__(37);\nvar ITERATOR = wellKnownSymbol('iterator');\nmodule.exports = !fails(function () {\n var url = new URL('b?a=1&b=2&c=3', 'http://a');\n var searchParams = url.searchParams;\n var result = '';\n url.pathname = 'c%20d';\n searchParams.forEach(function (value, key) {\n  searchParams['delete']('b');\n  result += key + value;\n });\n return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR] || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' || new URL('http://тест').host !== 'xn--e1aybc' || new URL('http://a#б').hash !== '#%D0%B1' || result !== 'a1c3' || new URL('http://x', undefined).host !== 'x';\n});\n\n/***/ }),\n/* 141 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar maxInt = 2147483647;\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128;\nvar delimiter = '-';\nvar regexNonASCII = /[^\\0-\\u007E]/;\nvar regexSeparators = /[.\\u3002\\uFF0E\\uFF61]/g;\nvar OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\nvar ucs2decode = function (string) {\n var output = [];\n var counter = 0;\n var length = string.length;\n while (counter < length) {\n  var value = string.charCodeAt(counter++);\n  if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n   var extra = string.charCodeAt(counter++);\n   if ((extra & 0xFC00) == 0xDC00) {\n    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n   } else {\n    output.push(value);\n    counter--;\n   }\n  } else {\n   output.push(value);\n  }\n }\n return output;\n};\nvar digitToBasic = function (digit) {\n return digit + 22 + 75 * (digit < 26);\n};\nvar adapt = function (delta, numPoints, firstTime) {\n var k = 0;\n delta = firstTime ? floor(delta / damp) : delta >> 1;\n delta += floor(delta / numPoints);\n for (; delta > baseMinusTMin * tMax >> 1; k += base) {\n  delta = floor(delta / baseMinusTMin);\n }\n return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\nvar encode = function (input) {\n var output = [];\n input = ucs2decode(input);\n var inputLength = input.length;\n var n = initialN;\n var delta = 0;\n var bias = initialBias;\n var i, currentValue;\n for (i = 0; i < input.length; i++) {\n  currentValue = input[i];\n  if (currentValue < 0x80) {\n   output.push(stringFromCharCode(currentValue));\n  }\n }\n var basicLength = output.length;\n var handledCPCount = basicLength;\n if (basicLength) {\n  output.push(delimiter);\n }\n while (handledCPCount < inputLength) {\n  var m = maxInt;\n  for (i = 0; i < input.length; i++) {\n   currentValue = input[i];\n   if (currentValue >= n && currentValue < m) {\n    m = currentValue;\n   }\n  }\n  var handledCPCountPlusOne = handledCPCount + 1;\n  if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n   throw RangeError(OVERFLOW_ERROR);\n  }\n  delta += (m - n) * handledCPCountPlusOne;\n  n = m;\n  for (i = 0; i < input.length; i++) {\n   currentValue = input[i];\n   if (currentValue < n && ++delta > maxInt) {\n    throw RangeError(OVERFLOW_ERROR);\n   }\n   if (currentValue == n) {\n    var q = delta;\n    for (var k = base;; k += base) {\n     var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n     if (q < t)\n      break;\n     var qMinusT = q - t;\n     var baseMinusT = base - t;\n     output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));\n     q = floor(qMinusT / baseMinusT);\n    }\n    output.push(stringFromCharCode(digitToBasic(q)));\n    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n    delta = 0;\n    ++handledCPCount;\n   }\n  }\n  ++delta;\n  ++n;\n }\n return output.join('');\n};\nmodule.exports = function (input) {\n var encoded = [];\n var labels = input.toLowerCase().replace(regexSeparators, '\\u002E').split('.');\n var i, label;\n for (i = 0; i < labels.length; i++) {\n  label = labels[i];\n  encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);\n }\n return encoded.join('.');\n};\n\n/***/ }),\n/* 142 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n__w_pdfjs_require__(102);\nvar $ = __w_pdfjs_require__(10);\nvar getBuiltIn = __w_pdfjs_require__(42);\nvar USE_NATIVE_URL = __w_pdfjs_require__(140);\nvar redefine = __w_pdfjs_require__(29);\nvar redefineAll = __w_pdfjs_require__(124);\nvar setToStringTag = __w_pdfjs_require__(85);\nvar createIteratorConstructor = __w_pdfjs_require__(80);\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar anInstance = __w_pdfjs_require__(126);\nvar hasOwn = __w_pdfjs_require__(23);\nvar bind = __w_pdfjs_require__(62);\nvar classof = __w_pdfjs_require__(95);\nvar anObject = __w_pdfjs_require__(28);\nvar isObject = __w_pdfjs_require__(22);\nvar create = __w_pdfjs_require__(71);\nvar createPropertyDescriptor = __w_pdfjs_require__(16);\nvar getIterator = __w_pdfjs_require__(143);\nvar getIteratorMethod = __w_pdfjs_require__(94);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar $fetch = getBuiltIn('fetch');\nvar Headers = getBuiltIn('Headers');\nvar ITERATOR = wellKnownSymbol('iterator');\nvar URL_SEARCH_PARAMS = 'URLSearchParams';\nvar URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';\nvar setInternalState = InternalStateModule.set;\nvar getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);\nvar getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);\nvar plus = /\\+/g;\nvar sequences = Array(4);\nvar percentSequence = function (bytes) {\n return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\\\da-f]{2}){' + bytes + '})', 'gi'));\n};\nvar percentDecode = function (sequence) {\n try {\n  return decodeURIComponent(sequence);\n } catch (error) {\n  return sequence;\n }\n};\nvar deserialize = function (it) {\n var result = it.replace(plus, ' ');\n var bytes = 4;\n try {\n  return decodeURIComponent(result);\n } catch (error) {\n  while (bytes) {\n   result = result.replace(percentSequence(bytes--), percentDecode);\n  }\n  return result;\n }\n};\nvar find = /[!'()~]|%20/g;\nvar replace = {\n '!': '%21',\n \"'\": '%27',\n '(': '%28',\n ')': '%29',\n '~': '%7E',\n '%20': '+'\n};\nvar replacer = function (match) {\n return replace[match];\n};\nvar serialize = function (it) {\n return encodeURIComponent(it).replace(find, replacer);\n};\nvar parseSearchParams = function (result, query) {\n if (query) {\n  var attributes = query.split('&');\n  var index = 0;\n  var attribute, entry;\n  while (index < attributes.length) {\n   attribute = attributes[index++];\n   if (attribute.length) {\n    entry = attribute.split('=');\n    result.push({\n     key: deserialize(entry.shift()),\n     value: deserialize(entry.join('='))\n    });\n   }\n  }\n }\n};\nvar updateSearchParams = function (query) {\n this.entries.length = 0;\n parseSearchParams(this.entries, query);\n};\nvar validateArgumentsLength = function (passed, required) {\n if (passed < required)\n  throw TypeError('Not enough arguments');\n};\nvar URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {\n setInternalState(this, {\n  type: URL_SEARCH_PARAMS_ITERATOR,\n  iterator: getIterator(getInternalParamsState(params).entries),\n  kind: kind\n });\n}, 'Iterator', function next() {\n var state = getInternalIteratorState(this);\n var kind = state.kind;\n var step = state.iterator.next();\n var entry = step.value;\n if (!step.done) {\n  step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [\n   entry.key,\n   entry.value\n  ];\n }\n return step;\n});\nvar URLSearchParamsConstructor = function URLSearchParams() {\n anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n var init = arguments.length > 0 ? arguments[0] : undefined;\n var that = this;\n var entries = [];\n var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;\n setInternalState(that, {\n  type: URL_SEARCH_PARAMS,\n  entries: entries,\n  updateURL: function () {\n  },\n  updateSearchParams: updateSearchParams\n });\n if (init !== undefined) {\n  if (isObject(init)) {\n   iteratorMethod = getIteratorMethod(init);\n   if (typeof iteratorMethod === 'function') {\n    iterator = iteratorMethod.call(init);\n    next = iterator.next;\n    while (!(step = next.call(iterator)).done) {\n     entryIterator = getIterator(anObject(step.value));\n     entryNext = entryIterator.next;\n     if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done)\n      throw TypeError('Expected sequence with length 2');\n     entries.push({\n      key: first.value + '',\n      value: second.value + ''\n     });\n    }\n   } else\n    for (key in init)\n     if (hasOwn(init, key))\n      entries.push({\n       key: key,\n       value: init[key] + ''\n      });\n  } else {\n   parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');\n  }\n }\n};\nvar URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;\nredefineAll(URLSearchParamsPrototype, {\n append: function append(name, value) {\n  validateArgumentsLength(arguments.length, 2);\n  var state = getInternalParamsState(this);\n  state.entries.push({\n   key: name + '',\n   value: value + ''\n  });\n  state.updateURL();\n },\n 'delete': function (name) {\n  validateArgumentsLength(arguments.length, 1);\n  var state = getInternalParamsState(this);\n  var entries = state.entries;\n  var key = name + '';\n  var index = 0;\n  while (index < entries.length) {\n   if (entries[index].key === key)\n    entries.splice(index, 1);\n   else\n    index++;\n  }\n  state.updateURL();\n },\n get: function get(name) {\n  validateArgumentsLength(arguments.length, 1);\n  var entries = getInternalParamsState(this).entries;\n  var key = name + '';\n  var index = 0;\n  for (; index < entries.length; index++) {\n   if (entries[index].key === key)\n    return entries[index].value;\n  }\n  return null;\n },\n getAll: function getAll(name) {\n  validateArgumentsLength(arguments.length, 1);\n  var entries = getInternalParamsState(this).entries;\n  var key = name + '';\n  var result = [];\n  var index = 0;\n  for (; index < entries.length; index++) {\n   if (entries[index].key === key)\n    result.push(entries[index].value);\n  }\n  return result;\n },\n has: function has(name) {\n  validateArgumentsLength(arguments.length, 1);\n  var entries = getInternalParamsState(this).entries;\n  var key = name + '';\n  var index = 0;\n  while (index < entries.length) {\n   if (entries[index++].key === key)\n    return true;\n  }\n  return false;\n },\n set: function set(name, value) {\n  validateArgumentsLength(arguments.length, 1);\n  var state = getInternalParamsState(this);\n  var entries = state.entries;\n  var found = false;\n  var key = name + '';\n  var val = value + '';\n  var index = 0;\n  var entry;\n  for (; index < entries.length; index++) {\n   entry = entries[index];\n   if (entry.key === key) {\n    if (found)\n     entries.splice(index--, 1);\n    else {\n     found = true;\n     entry.value = val;\n    }\n   }\n  }\n  if (!found)\n   entries.push({\n    key: key,\n    value: val\n   });\n  state.updateURL();\n },\n sort: function sort() {\n  var state = getInternalParamsState(this);\n  var entries = state.entries;\n  var slice = entries.slice();\n  var entry, entriesIndex, sliceIndex;\n  entries.length = 0;\n  for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {\n   entry = slice[sliceIndex];\n   for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {\n    if (entries[entriesIndex].key > entry.key) {\n     entries.splice(entriesIndex, 0, entry);\n     break;\n    }\n   }\n   if (entriesIndex === sliceIndex)\n    entries.push(entry);\n  }\n  state.updateURL();\n },\n forEach: function forEach(callback) {\n  var entries = getInternalParamsState(this).entries;\n  var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);\n  var index = 0;\n  var entry;\n  while (index < entries.length) {\n   entry = entries[index++];\n   boundFunction(entry.value, entry.key, this);\n  }\n },\n keys: function keys() {\n  return new URLSearchParamsIterator(this, 'keys');\n },\n values: function values() {\n  return new URLSearchParamsIterator(this, 'values');\n },\n entries: function entries() {\n  return new URLSearchParamsIterator(this, 'entries');\n }\n}, { enumerable: true });\nredefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);\nredefine(URLSearchParamsPrototype, 'toString', function toString() {\n var entries = getInternalParamsState(this).entries;\n var result = [];\n var index = 0;\n var entry;\n while (index < entries.length) {\n  entry = entries[index++];\n  result.push(serialize(entry.key) + '=' + serialize(entry.value));\n }\n return result.join('&');\n}, { enumerable: true });\nsetToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);\n$({\n global: true,\n forced: !USE_NATIVE_URL\n}, { URLSearchParams: URLSearchParamsConstructor });\nif (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') {\n $({\n  global: true,\n  enumerable: true,\n  forced: true\n }, {\n  fetch: function fetch(input) {\n   var args = [input];\n   var init, body, headers;\n   if (arguments.length > 1) {\n    init = arguments[1];\n    if (isObject(init)) {\n     body = init.body;\n     if (classof(body) === URL_SEARCH_PARAMS) {\n      headers = init.headers ? new Headers(init.headers) : new Headers();\n      if (!headers.has('content-type')) {\n       headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n      }\n      init = create(init, {\n       body: createPropertyDescriptor(0, String(body)),\n       headers: createPropertyDescriptor(0, headers)\n      });\n     }\n    }\n    args.push(init);\n   }\n   return $fetch.apply(this, args);\n  }\n });\n}\nmodule.exports = {\n URLSearchParams: URLSearchParamsConstructor,\n getState: getInternalParamsState\n};\n\n/***/ }),\n/* 143 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar anObject = __w_pdfjs_require__(28);\nvar getIteratorMethod = __w_pdfjs_require__(94);\nmodule.exports = function (it) {\n var iteratorMethod = getIteratorMethod(it);\n if (typeof iteratorMethod != 'function') {\n  throw TypeError(String(it) + ' is not iterable');\n }\n return anObject(iteratorMethod.call(it));\n};\n\n/***/ }),\n/* 144 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\n$({\n target: 'URL',\n proto: true,\n enumerable: true\n}, {\n toJSON: function toJSON() {\n  return URL.prototype.toString.call(this);\n }\n});\n\n/***/ }),\n/* 145 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n(function (global, factory) {\n   true ? factory(exports) : 0;\n}(this, function (exports) {\n 'use strict';\n var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {\n  return \"Symbol(\" + description + \")\";\n };\n function noop() {\n }\n var NumberIsNaN = Number.isNaN || function (x) {\n  return x !== x;\n };\n var rethrowAssertionErrorRejection = noop;\n function typeIsObject(x) {\n  return typeof x === 'object' && x !== null || typeof x === 'function';\n }\n function createArrayFromList(elements) {\n  return elements.slice();\n }\n function ArrayBufferCopy(dest, destOffset, src, srcOffset, n) {\n  new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n }\n function IsFiniteNonNegativeNumber(v) {\n  if (IsNonNegativeNumber(v) === false) {\n   return false;\n  }\n  if (v === Infinity) {\n   return false;\n  }\n  return true;\n }\n function IsNonNegativeNumber(v) {\n  if (typeof v !== 'number') {\n   return false;\n  }\n  if (NumberIsNaN(v)) {\n   return false;\n  }\n  if (v < 0) {\n   return false;\n  }\n  return true;\n }\n function Call(F, V, args) {\n  if (typeof F !== 'function') {\n   throw new TypeError('Argument is not a function');\n  }\n  return Function.prototype.apply.call(F, V, args);\n }\n function CreateAlgorithmFromUnderlyingMethod(underlyingObject, methodName, algoArgCount, extraArgs) {\n  var method = underlyingObject[methodName];\n  if (method !== undefined) {\n   if (typeof method !== 'function') {\n    throw new TypeError(method + \" is not a method\");\n   }\n   switch (algoArgCount) {\n   case 0: {\n     return function () {\n      return PromiseCall(method, underlyingObject, extraArgs);\n     };\n    }\n   case 1: {\n     return function (arg) {\n      var fullArgs = [arg].concat(extraArgs);\n      return PromiseCall(method, underlyingObject, fullArgs);\n     };\n    }\n   }\n  }\n  return function () {\n   return promiseResolvedWith(undefined);\n  };\n }\n function InvokeOrNoop(O, P, args) {\n  var method = O[P];\n  if (method === undefined) {\n   return undefined;\n  }\n  return Call(method, O, args);\n }\n function PromiseCall(F, V, args) {\n  try {\n   return promiseResolvedWith(Call(F, V, args));\n  } catch (value) {\n   return promiseRejectedWith(value);\n  }\n }\n function TransferArrayBuffer(O) {\n  return O;\n }\n function IsDetachedBuffer(O) {\n  return false;\n }\n function ValidateAndNormalizeHighWaterMark(highWaterMark) {\n  highWaterMark = Number(highWaterMark);\n  if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n   throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN');\n  }\n  return highWaterMark;\n }\n function MakeSizeAlgorithmFromSizeFunction(size) {\n  if (size === undefined) {\n   return function () {\n    return 1;\n   };\n  }\n  if (typeof size !== 'function') {\n   throw new TypeError('size property of a queuing strategy must be a function');\n  }\n  return function (chunk) {\n   return size(chunk);\n  };\n }\n var originalPromise = Promise;\n var originalPromiseThen = Promise.prototype.then;\n var originalPromiseResolve = Promise.resolve.bind(originalPromise);\n var originalPromiseReject = Promise.reject.bind(originalPromise);\n function newPromise(executor) {\n  return new originalPromise(executor);\n }\n function promiseResolvedWith(value) {\n  return originalPromiseResolve(value);\n }\n function promiseRejectedWith(reason) {\n  return originalPromiseReject(reason);\n }\n function PerformPromiseThen(promise, onFulfilled, onRejected) {\n  return originalPromiseThen.call(promise, onFulfilled, onRejected);\n }\n function uponPromise(promise, onFulfilled, onRejected) {\n  PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n }\n function uponFulfillment(promise, onFulfilled) {\n  uponPromise(promise, onFulfilled);\n }\n function uponRejection(promise, onRejected) {\n  uponPromise(promise, undefined, onRejected);\n }\n function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n  return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n }\n function setPromiseIsHandledToTrue(promise) {\n  PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n }\n var QUEUE_MAX_ARRAY_SIZE = 16384;\n var SimpleQueue = function () {\n  function SimpleQueue() {\n   this._cursor = 0;\n   this._size = 0;\n   this._front = {\n    _elements: [],\n    _next: undefined\n   };\n   this._back = this._front;\n   this._cursor = 0;\n   this._size = 0;\n  }\n  Object.defineProperty(SimpleQueue.prototype, \"length\", {\n   get: function () {\n    return this._size;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  SimpleQueue.prototype.push = function (element) {\n   var oldBack = this._back;\n   var newBack = oldBack;\n   if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n    newBack = {\n     _elements: [],\n     _next: undefined\n    };\n   }\n   oldBack._elements.push(element);\n   if (newBack !== oldBack) {\n    this._back = newBack;\n    oldBack._next = newBack;\n   }\n   ++this._size;\n  };\n  SimpleQueue.prototype.shift = function () {\n   var oldFront = this._front;\n   var newFront = oldFront;\n   var oldCursor = this._cursor;\n   var newCursor = oldCursor + 1;\n   var elements = oldFront._elements;\n   var element = elements[oldCursor];\n   if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n    newFront = oldFront._next;\n    newCursor = 0;\n   }\n   --this._size;\n   this._cursor = newCursor;\n   if (oldFront !== newFront) {\n    this._front = newFront;\n   }\n   elements[oldCursor] = undefined;\n   return element;\n  };\n  SimpleQueue.prototype.forEach = function (callback) {\n   var i = this._cursor;\n   var node = this._front;\n   var elements = node._elements;\n   while (i !== elements.length || node._next !== undefined) {\n    if (i === elements.length) {\n     node = node._next;\n     elements = node._elements;\n     i = 0;\n     if (elements.length === 0) {\n      break;\n     }\n    }\n    callback(elements[i]);\n    ++i;\n   }\n  };\n  SimpleQueue.prototype.peek = function () {\n   var front = this._front;\n   var cursor = this._cursor;\n   return front._elements[cursor];\n  };\n  return SimpleQueue;\n }();\n function ReadableStreamCreateReadResult(value, done, forAuthorCode) {\n  var prototype = null;\n  if (forAuthorCode === true) {\n   prototype = Object.prototype;\n  }\n  var obj = Object.create(prototype);\n  obj.value = value;\n  obj.done = done;\n  return obj;\n }\n function ReadableStreamReaderGenericInitialize(reader, stream) {\n  reader._forAuthorCode = true;\n  reader._ownerReadableStream = stream;\n  stream._reader = reader;\n  if (stream._state === 'readable') {\n   defaultReaderClosedPromiseInitialize(reader);\n  } else if (stream._state === 'closed') {\n   defaultReaderClosedPromiseInitializeAsResolved(reader);\n  } else {\n   defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n  }\n }\n function ReadableStreamReaderGenericCancel(reader, reason) {\n  var stream = reader._ownerReadableStream;\n  return ReadableStreamCancel(stream, reason);\n }\n function ReadableStreamReaderGenericRelease(reader) {\n  if (reader._ownerReadableStream._state === 'readable') {\n   defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  } else {\n   defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\\'s closedness'));\n  }\n  reader._ownerReadableStream._reader = undefined;\n  reader._ownerReadableStream = undefined;\n }\n function readerLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released reader');\n }\n function defaultReaderClosedPromiseInitialize(reader) {\n  reader._closedPromise = newPromise(function (resolve, reject) {\n   reader._closedPromise_resolve = resolve;\n   reader._closedPromise_reject = reject;\n  });\n }\n function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseReject(reader, reason);\n }\n function defaultReaderClosedPromiseInitializeAsResolved(reader) {\n  defaultReaderClosedPromiseInitialize(reader);\n  defaultReaderClosedPromiseResolve(reader);\n }\n function defaultReaderClosedPromiseReject(reader, reason) {\n  setPromiseIsHandledToTrue(reader._closedPromise);\n  reader._closedPromise_reject(reason);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n }\n function defaultReaderClosedPromiseResetToRejected(reader, reason) {\n  defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n }\n function defaultReaderClosedPromiseResolve(reader) {\n  reader._closedPromise_resolve(undefined);\n  reader._closedPromise_resolve = undefined;\n  reader._closedPromise_reject = undefined;\n }\n var CancelSteps = SymbolPolyfill('[[CancelSteps]]');\n var PullSteps = SymbolPolyfill('[[PullSteps]]');\n function AcquireReadableStreamDefaultReader(stream, forAuthorCode) {\n  if (forAuthorCode === void 0) {\n   forAuthorCode = false;\n  }\n  var reader = new ReadableStreamDefaultReader(stream);\n  reader._forAuthorCode = forAuthorCode;\n  return reader;\n }\n function ReadableStreamAddReadRequest(stream) {\n  var promise = newPromise(function (resolve, reject) {\n   var readRequest = {\n    _resolve: resolve,\n    _reject: reject\n   };\n   stream._reader._readRequests.push(readRequest);\n  });\n  return promise;\n }\n function ReadableStreamFulfillReadRequest(stream, chunk, done) {\n  var reader = stream._reader;\n  var readRequest = reader._readRequests.shift();\n  readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode));\n }\n function ReadableStreamGetNumReadRequests(stream) {\n  return stream._reader._readRequests.length;\n }\n function ReadableStreamHasDefaultReader(stream) {\n  var reader = stream._reader;\n  if (reader === undefined) {\n   return false;\n  }\n  if (!IsReadableStreamDefaultReader(reader)) {\n   return false;\n  }\n  return true;\n }\n var ReadableStreamDefaultReader = function () {\n  function ReadableStreamDefaultReader(stream) {\n   if (IsReadableStream(stream) === false) {\n    throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance');\n   }\n   if (IsReadableStreamLocked(stream) === true) {\n    throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n   }\n   ReadableStreamReaderGenericInitialize(this, stream);\n   this._readRequests = new SimpleQueue();\n  }\n  Object.defineProperty(ReadableStreamDefaultReader.prototype, \"closed\", {\n   get: function () {\n    if (!IsReadableStreamDefaultReader(this)) {\n     return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n    }\n    return this._closedPromise;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  ReadableStreamDefaultReader.prototype.cancel = function (reason) {\n   if (!IsReadableStreamDefaultReader(this)) {\n    return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n   }\n   if (this._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('cancel'));\n   }\n   return ReadableStreamReaderGenericCancel(this, reason);\n  };\n  ReadableStreamDefaultReader.prototype.read = function () {\n   if (!IsReadableStreamDefaultReader(this)) {\n    return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n   }\n   if (this._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('read from'));\n   }\n   return ReadableStreamDefaultReaderRead(this);\n  };\n  ReadableStreamDefaultReader.prototype.releaseLock = function () {\n   if (!IsReadableStreamDefaultReader(this)) {\n    throw defaultReaderBrandCheckException('releaseLock');\n   }\n   if (this._ownerReadableStream === undefined) {\n    return;\n   }\n   if (this._readRequests.length > 0) {\n    throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n   }\n   ReadableStreamReaderGenericRelease(this);\n  };\n  return ReadableStreamDefaultReader;\n }();\n function IsReadableStreamDefaultReader(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamDefaultReaderRead(reader) {\n  var stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n  if (stream._state === 'closed') {\n   return promiseResolvedWith(ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode));\n  }\n  if (stream._state === 'errored') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  return stream._readableStreamController[PullSteps]();\n }\n function defaultReaderBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamDefaultReader.prototype.\" + name + \" can only be used on a ReadableStreamDefaultReader\");\n }\n var _a;\n var AsyncIteratorPrototype;\n if (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n  AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function () {\n   return this;\n  }, _a);\n  Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });\n }\n var ReadableStreamAsyncIteratorPrototype = {\n  next: function () {\n   if (IsReadableStreamAsyncIterator(this) === false) {\n    return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n   }\n   var reader = this._asyncIteratorReader;\n   if (reader._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('iterate'));\n   }\n   return transformPromiseWith(ReadableStreamDefaultReaderRead(reader), function (result) {\n    var done = result.done;\n    if (done) {\n     ReadableStreamReaderGenericRelease(reader);\n    }\n    var value = result.value;\n    return ReadableStreamCreateReadResult(value, done, true);\n   });\n  },\n  return: function (value) {\n   if (IsReadableStreamAsyncIterator(this) === false) {\n    return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n   }\n   var reader = this._asyncIteratorReader;\n   if (reader._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('finish iterating'));\n   }\n   if (reader._readRequests.length > 0) {\n    return promiseRejectedWith(new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled'));\n   }\n   if (this._preventCancel === false) {\n    var result = ReadableStreamReaderGenericCancel(reader, value);\n    ReadableStreamReaderGenericRelease(reader);\n    return transformPromiseWith(result, function () {\n     return ReadableStreamCreateReadResult(value, true, true);\n    });\n   }\n   ReadableStreamReaderGenericRelease(reader);\n   return promiseResolvedWith(ReadableStreamCreateReadResult(value, true, true));\n  }\n };\n if (AsyncIteratorPrototype !== undefined) {\n  Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n }\n Object.defineProperty(ReadableStreamAsyncIteratorPrototype, 'next', { enumerable: false });\n Object.defineProperty(ReadableStreamAsyncIteratorPrototype, 'return', { enumerable: false });\n function AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n  if (preventCancel === void 0) {\n   preventCancel = false;\n  }\n  var reader = AcquireReadableStreamDefaultReader(stream);\n  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n  iterator._asyncIteratorReader = reader;\n  iterator._preventCancel = Boolean(preventCancel);\n  return iterator;\n }\n function IsReadableStreamAsyncIterator(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorReader')) {\n   return false;\n  }\n  return true;\n }\n function streamAsyncIteratorBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamAsyncIterator.\" + name + \" can only be used on a ReadableSteamAsyncIterator\");\n }\n function DequeueValue(container) {\n  var pair = container._queue.shift();\n  container._queueTotalSize -= pair.size;\n  if (container._queueTotalSize < 0) {\n   container._queueTotalSize = 0;\n  }\n  return pair.value;\n }\n function EnqueueValueWithSize(container, value, size) {\n  size = Number(size);\n  if (!IsFiniteNonNegativeNumber(size)) {\n   throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n  }\n  container._queue.push({\n   value: value,\n   size: size\n  });\n  container._queueTotalSize += size;\n }\n function PeekQueueValue(container) {\n  var pair = container._queue.peek();\n  return pair.value;\n }\n function ResetQueue(container) {\n  container._queue = new SimpleQueue();\n  container._queueTotalSize = 0;\n }\n var AbortSteps = SymbolPolyfill('[[AbortSteps]]');\n var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\n var WritableStream = function () {\n  function WritableStream(underlyingSink, strategy) {\n   if (underlyingSink === void 0) {\n    underlyingSink = {};\n   }\n   if (strategy === void 0) {\n    strategy = {};\n   }\n   InitializeWritableStream(this);\n   var size = strategy.size;\n   var highWaterMark = strategy.highWaterMark;\n   var type = underlyingSink.type;\n   if (type !== undefined) {\n    throw new RangeError('Invalid type is specified');\n   }\n   var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n   if (highWaterMark === undefined) {\n    highWaterMark = 1;\n   }\n   highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n   SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n  }\n  Object.defineProperty(WritableStream.prototype, \"locked\", {\n   get: function () {\n    if (IsWritableStream(this) === false) {\n     throw streamBrandCheckException('locked');\n    }\n    return IsWritableStreamLocked(this);\n   },\n   enumerable: true,\n   configurable: true\n  });\n  WritableStream.prototype.abort = function (reason) {\n   if (IsWritableStream(this) === false) {\n    return promiseRejectedWith(streamBrandCheckException('abort'));\n   }\n   if (IsWritableStreamLocked(this) === true) {\n    return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n   }\n   return WritableStreamAbort(this, reason);\n  };\n  WritableStream.prototype.close = function () {\n   if (IsWritableStream(this) === false) {\n    return promiseRejectedWith(streamBrandCheckException('close'));\n   }\n   if (IsWritableStreamLocked(this) === true) {\n    return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n   }\n   if (WritableStreamCloseQueuedOrInFlight(this) === true) {\n    return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n   }\n   return WritableStreamClose(this);\n  };\n  WritableStream.prototype.getWriter = function () {\n   if (IsWritableStream(this) === false) {\n    throw streamBrandCheckException('getWriter');\n   }\n   return AcquireWritableStreamDefaultWriter(this);\n  };\n  return WritableStream;\n }();\n function AcquireWritableStreamDefaultWriter(stream) {\n  return new WritableStreamDefaultWriter(stream);\n }\n function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  if (highWaterMark === void 0) {\n   highWaterMark = 1;\n  }\n  if (sizeAlgorithm === void 0) {\n   sizeAlgorithm = function () {\n    return 1;\n   };\n  }\n  var stream = Object.create(WritableStream.prototype);\n  InitializeWritableStream(stream);\n  var controller = Object.create(WritableStreamDefaultController.prototype);\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n }\n function InitializeWritableStream(stream) {\n  stream._state = 'writable';\n  stream._storedError = undefined;\n  stream._writer = undefined;\n  stream._writableStreamController = undefined;\n  stream._writeRequests = new SimpleQueue();\n  stream._inFlightWriteRequest = undefined;\n  stream._closeRequest = undefined;\n  stream._inFlightCloseRequest = undefined;\n  stream._pendingAbortRequest = undefined;\n  stream._backpressure = false;\n }\n function IsWritableStream(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n   return false;\n  }\n  return true;\n }\n function IsWritableStreamLocked(stream) {\n  if (stream._writer === undefined) {\n   return false;\n  }\n  return true;\n }\n function WritableStreamAbort(stream, reason) {\n  var state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n   return promiseResolvedWith(undefined);\n  }\n  if (stream._pendingAbortRequest !== undefined) {\n   return stream._pendingAbortRequest._promise;\n  }\n  var wasAlreadyErroring = false;\n  if (state === 'erroring') {\n   wasAlreadyErroring = true;\n   reason = undefined;\n  }\n  var promise = newPromise(function (resolve, reject) {\n   stream._pendingAbortRequest = {\n    _promise: undefined,\n    _resolve: resolve,\n    _reject: reject,\n    _reason: reason,\n    _wasAlreadyErroring: wasAlreadyErroring\n   };\n  });\n  stream._pendingAbortRequest._promise = promise;\n  if (wasAlreadyErroring === false) {\n   WritableStreamStartErroring(stream, reason);\n  }\n  return promise;\n }\n function WritableStreamClose(stream) {\n  var state = stream._state;\n  if (state === 'closed' || state === 'errored') {\n   return promiseRejectedWith(new TypeError(\"The stream (in \" + state + \" state) is not in the writable state and cannot be closed\"));\n  }\n  var promise = newPromise(function (resolve, reject) {\n   var closeRequest = {\n    _resolve: resolve,\n    _reject: reject\n   };\n   stream._closeRequest = closeRequest;\n  });\n  var writer = stream._writer;\n  if (writer !== undefined && stream._backpressure === true && state === 'writable') {\n   defaultWriterReadyPromiseResolve(writer);\n  }\n  WritableStreamDefaultControllerClose(stream._writableStreamController);\n  return promise;\n }\n function WritableStreamAddWriteRequest(stream) {\n  var promise = newPromise(function (resolve, reject) {\n   var writeRequest = {\n    _resolve: resolve,\n    _reject: reject\n   };\n   stream._writeRequests.push(writeRequest);\n  });\n  return promise;\n }\n function WritableStreamDealWithRejection(stream, error) {\n  var state = stream._state;\n  if (state === 'writable') {\n   WritableStreamStartErroring(stream, error);\n   return;\n  }\n  WritableStreamFinishErroring(stream);\n }\n function WritableStreamStartErroring(stream, reason) {\n  var controller = stream._writableStreamController;\n  stream._state = 'erroring';\n  stream._storedError = reason;\n  var writer = stream._writer;\n  if (writer !== undefined) {\n   WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n  }\n  if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) {\n   WritableStreamFinishErroring(stream);\n  }\n }\n function WritableStreamFinishErroring(stream) {\n  stream._state = 'errored';\n  stream._writableStreamController[ErrorSteps]();\n  var storedError = stream._storedError;\n  stream._writeRequests.forEach(function (writeRequest) {\n   writeRequest._reject(storedError);\n  });\n  stream._writeRequests = new SimpleQueue();\n  if (stream._pendingAbortRequest === undefined) {\n   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n   return;\n  }\n  var abortRequest = stream._pendingAbortRequest;\n  stream._pendingAbortRequest = undefined;\n  if (abortRequest._wasAlreadyErroring === true) {\n   abortRequest._reject(storedError);\n   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n   return;\n  }\n  var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n  uponPromise(promise, function () {\n   abortRequest._resolve();\n   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  }, function (reason) {\n   abortRequest._reject(reason);\n   WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n  });\n }\n function WritableStreamFinishInFlightWrite(stream) {\n  stream._inFlightWriteRequest._resolve(undefined);\n  stream._inFlightWriteRequest = undefined;\n }\n function WritableStreamFinishInFlightWriteWithError(stream, error) {\n  stream._inFlightWriteRequest._reject(error);\n  stream._inFlightWriteRequest = undefined;\n  WritableStreamDealWithRejection(stream, error);\n }\n function WritableStreamFinishInFlightClose(stream) {\n  stream._inFlightCloseRequest._resolve(undefined);\n  stream._inFlightCloseRequest = undefined;\n  var state = stream._state;\n  if (state === 'erroring') {\n   stream._storedError = undefined;\n   if (stream._pendingAbortRequest !== undefined) {\n    stream._pendingAbortRequest._resolve();\n    stream._pendingAbortRequest = undefined;\n   }\n  }\n  stream._state = 'closed';\n  var writer = stream._writer;\n  if (writer !== undefined) {\n   defaultWriterClosedPromiseResolve(writer);\n  }\n }\n function WritableStreamFinishInFlightCloseWithError(stream, error) {\n  stream._inFlightCloseRequest._reject(error);\n  stream._inFlightCloseRequest = undefined;\n  if (stream._pendingAbortRequest !== undefined) {\n   stream._pendingAbortRequest._reject(error);\n   stream._pendingAbortRequest = undefined;\n  }\n  WritableStreamDealWithRejection(stream, error);\n }\n function WritableStreamCloseQueuedOrInFlight(stream) {\n  if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n   return false;\n  }\n  return true;\n }\n function WritableStreamHasOperationMarkedInFlight(stream) {\n  if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n   return false;\n  }\n  return true;\n }\n function WritableStreamMarkCloseRequestInFlight(stream) {\n  stream._inFlightCloseRequest = stream._closeRequest;\n  stream._closeRequest = undefined;\n }\n function WritableStreamMarkFirstWriteRequestInFlight(stream) {\n  stream._inFlightWriteRequest = stream._writeRequests.shift();\n }\n function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n  if (stream._closeRequest !== undefined) {\n   stream._closeRequest._reject(stream._storedError);\n   stream._closeRequest = undefined;\n  }\n  var writer = stream._writer;\n  if (writer !== undefined) {\n   defaultWriterClosedPromiseReject(writer, stream._storedError);\n  }\n }\n function WritableStreamUpdateBackpressure(stream, backpressure) {\n  var writer = stream._writer;\n  if (writer !== undefined && backpressure !== stream._backpressure) {\n   if (backpressure === true) {\n    defaultWriterReadyPromiseReset(writer);\n   } else {\n    defaultWriterReadyPromiseResolve(writer);\n   }\n  }\n  stream._backpressure = backpressure;\n }\n var WritableStreamDefaultWriter = function () {\n  function WritableStreamDefaultWriter(stream) {\n   if (IsWritableStream(stream) === false) {\n    throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance');\n   }\n   if (IsWritableStreamLocked(stream) === true) {\n    throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n   }\n   this._ownerWritableStream = stream;\n   stream._writer = this;\n   var state = stream._state;\n   if (state === 'writable') {\n    if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) {\n     defaultWriterReadyPromiseInitialize(this);\n    } else {\n     defaultWriterReadyPromiseInitializeAsResolved(this);\n    }\n    defaultWriterClosedPromiseInitialize(this);\n   } else if (state === 'erroring') {\n    defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n    defaultWriterClosedPromiseInitialize(this);\n   } else if (state === 'closed') {\n    defaultWriterReadyPromiseInitializeAsResolved(this);\n    defaultWriterClosedPromiseInitializeAsResolved(this);\n   } else {\n    var storedError = stream._storedError;\n    defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n    defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n   }\n  }\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, \"closed\", {\n   get: function () {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n     return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n    }\n    return this._closedPromise;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, \"desiredSize\", {\n   get: function () {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n     throw defaultWriterBrandCheckException('desiredSize');\n    }\n    if (this._ownerWritableStream === undefined) {\n     throw defaultWriterLockException('desiredSize');\n    }\n    return WritableStreamDefaultWriterGetDesiredSize(this);\n   },\n   enumerable: true,\n   configurable: true\n  });\n  Object.defineProperty(WritableStreamDefaultWriter.prototype, \"ready\", {\n   get: function () {\n    if (IsWritableStreamDefaultWriter(this) === false) {\n     return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n    }\n    return this._readyPromise;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  WritableStreamDefaultWriter.prototype.abort = function (reason) {\n   if (IsWritableStreamDefaultWriter(this) === false) {\n    return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n   }\n   if (this._ownerWritableStream === undefined) {\n    return promiseRejectedWith(defaultWriterLockException('abort'));\n   }\n   return WritableStreamDefaultWriterAbort(this, reason);\n  };\n  WritableStreamDefaultWriter.prototype.close = function () {\n   if (IsWritableStreamDefaultWriter(this) === false) {\n    return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n   }\n   var stream = this._ownerWritableStream;\n   if (stream === undefined) {\n    return promiseRejectedWith(defaultWriterLockException('close'));\n   }\n   if (WritableStreamCloseQueuedOrInFlight(stream) === true) {\n    return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n   }\n   return WritableStreamDefaultWriterClose(this);\n  };\n  WritableStreamDefaultWriter.prototype.releaseLock = function () {\n   if (IsWritableStreamDefaultWriter(this) === false) {\n    throw defaultWriterBrandCheckException('releaseLock');\n   }\n   var stream = this._ownerWritableStream;\n   if (stream === undefined) {\n    return;\n   }\n   WritableStreamDefaultWriterRelease(this);\n  };\n  WritableStreamDefaultWriter.prototype.write = function (chunk) {\n   if (IsWritableStreamDefaultWriter(this) === false) {\n    return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n   }\n   if (this._ownerWritableStream === undefined) {\n    return promiseRejectedWith(defaultWriterLockException('write to'));\n   }\n   return WritableStreamDefaultWriterWrite(this, chunk);\n  };\n  return WritableStreamDefaultWriter;\n }();\n function IsWritableStreamDefaultWriter(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n   return false;\n  }\n  return true;\n }\n function WritableStreamDefaultWriterAbort(writer, reason) {\n  var stream = writer._ownerWritableStream;\n  return WritableStreamAbort(stream, reason);\n }\n function WritableStreamDefaultWriterClose(writer) {\n  var stream = writer._ownerWritableStream;\n  return WritableStreamClose(stream);\n }\n function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n   return promiseResolvedWith(undefined);\n  }\n  if (state === 'errored') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  return WritableStreamDefaultWriterClose(writer);\n }\n function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n  if (writer._closedPromiseState === 'pending') {\n   defaultWriterClosedPromiseReject(writer, error);\n  } else {\n   defaultWriterClosedPromiseResetToRejected(writer, error);\n  }\n }\n function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n  if (writer._readyPromiseState === 'pending') {\n   defaultWriterReadyPromiseReject(writer, error);\n  } else {\n   defaultWriterReadyPromiseResetToRejected(writer, error);\n  }\n }\n function WritableStreamDefaultWriterGetDesiredSize(writer) {\n  var stream = writer._ownerWritableStream;\n  var state = stream._state;\n  if (state === 'errored' || state === 'erroring') {\n   return null;\n  }\n  if (state === 'closed') {\n   return 0;\n  }\n  return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n }\n function WritableStreamDefaultWriterRelease(writer) {\n  var stream = writer._ownerWritableStream;\n  var releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\\'s closedness');\n  WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n  WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n  stream._writer = undefined;\n  writer._ownerWritableStream = undefined;\n }\n function WritableStreamDefaultWriterWrite(writer, chunk) {\n  var stream = writer._ownerWritableStream;\n  var controller = stream._writableStreamController;\n  var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n  if (stream !== writer._ownerWritableStream) {\n   return promiseRejectedWith(defaultWriterLockException('write to'));\n  }\n  var state = stream._state;\n  if (state === 'errored') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') {\n   return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n  }\n  if (state === 'erroring') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  var promise = WritableStreamAddWriteRequest(stream);\n  WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n  return promise;\n }\n var WritableStreamDefaultController = function () {\n  function WritableStreamDefaultController() {\n   throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly');\n  }\n  WritableStreamDefaultController.prototype.error = function (e) {\n   if (IsWritableStreamDefaultController(this) === false) {\n    throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n   }\n   var state = this._controlledWritableStream._state;\n   if (state !== 'writable') {\n    return;\n   }\n   WritableStreamDefaultControllerError(this, e);\n  };\n  WritableStreamDefaultController.prototype[AbortSteps] = function (reason) {\n   var result = this._abortAlgorithm(reason);\n   WritableStreamDefaultControllerClearAlgorithms(this);\n   return result;\n  };\n  WritableStreamDefaultController.prototype[ErrorSteps] = function () {\n   ResetQueue(this);\n  };\n  return WritableStreamDefaultController;\n }();\n function IsWritableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n   return false;\n  }\n  return true;\n }\n function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n  controller._controlledWritableStream = stream;\n  stream._writableStreamController = controller;\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._started = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._writeAlgorithm = writeAlgorithm;\n  controller._closeAlgorithm = closeAlgorithm;\n  controller._abortAlgorithm = abortAlgorithm;\n  var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n  WritableStreamUpdateBackpressure(stream, backpressure);\n  var startResult = startAlgorithm();\n  var startPromise = promiseResolvedWith(startResult);\n  uponPromise(startPromise, function () {\n   controller._started = true;\n   WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, function (r) {\n   controller._started = true;\n   WritableStreamDealWithRejection(stream, r);\n  });\n }\n function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n  var controller = Object.create(WritableStreamDefaultController.prototype);\n  function startAlgorithm() {\n   return InvokeOrNoop(underlyingSink, 'start', [controller]);\n  }\n  var writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]);\n  var closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []);\n  var abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []);\n  SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n }\n function WritableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._writeAlgorithm = undefined;\n  controller._closeAlgorithm = undefined;\n  controller._abortAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n }\n function WritableStreamDefaultControllerClose(controller) {\n  EnqueueValueWithSize(controller, 'close', 0);\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n }\n function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n  try {\n   return controller._strategySizeAlgorithm(chunk);\n  } catch (chunkSizeE) {\n   WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n   return 1;\n  }\n }\n function WritableStreamDefaultControllerGetDesiredSize(controller) {\n  return controller._strategyHWM - controller._queueTotalSize;\n }\n function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n  var writeRecord = { chunk: chunk };\n  try {\n   EnqueueValueWithSize(controller, writeRecord, chunkSize);\n  } catch (enqueueE) {\n   WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n   return;\n  }\n  var stream = controller._controlledWritableStream;\n  if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') {\n   var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n   WritableStreamUpdateBackpressure(stream, backpressure);\n  }\n  WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n }\n function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n  var stream = controller._controlledWritableStream;\n  if (controller._started === false) {\n   return;\n  }\n  if (stream._inFlightWriteRequest !== undefined) {\n   return;\n  }\n  var state = stream._state;\n  if (state === 'erroring') {\n   WritableStreamFinishErroring(stream);\n   return;\n  }\n  if (controller._queue.length === 0) {\n   return;\n  }\n  var writeRecord = PeekQueueValue(controller);\n  if (writeRecord === 'close') {\n   WritableStreamDefaultControllerProcessClose(controller);\n  } else {\n   WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk);\n  }\n }\n function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n  if (controller._controlledWritableStream._state === 'writable') {\n   WritableStreamDefaultControllerError(controller, error);\n  }\n }\n function WritableStreamDefaultControllerProcessClose(controller) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamMarkCloseRequestInFlight(stream);\n  DequeueValue(controller);\n  var sinkClosePromise = controller._closeAlgorithm();\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  uponPromise(sinkClosePromise, function () {\n   WritableStreamFinishInFlightClose(stream);\n  }, function (reason) {\n   WritableStreamFinishInFlightCloseWithError(stream, reason);\n  });\n }\n function WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamMarkFirstWriteRequestInFlight(stream);\n  var sinkWritePromise = controller._writeAlgorithm(chunk);\n  uponPromise(sinkWritePromise, function () {\n   WritableStreamFinishInFlightWrite(stream);\n   var state = stream._state;\n   DequeueValue(controller);\n   if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') {\n    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n   }\n   WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n  }, function (reason) {\n   if (stream._state === 'writable') {\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n   }\n   WritableStreamFinishInFlightWriteWithError(stream, reason);\n  });\n }\n function WritableStreamDefaultControllerGetBackpressure(controller) {\n  var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n  return desiredSize <= 0;\n }\n function WritableStreamDefaultControllerError(controller, error) {\n  var stream = controller._controlledWritableStream;\n  WritableStreamDefaultControllerClearAlgorithms(controller);\n  WritableStreamStartErroring(stream, error);\n }\n function streamBrandCheckException(name) {\n  return new TypeError(\"WritableStream.prototype.\" + name + \" can only be used on a WritableStream\");\n }\n function defaultWriterBrandCheckException(name) {\n  return new TypeError(\"WritableStreamDefaultWriter.prototype.\" + name + \" can only be used on a WritableStreamDefaultWriter\");\n }\n function defaultWriterLockException(name) {\n  return new TypeError('Cannot ' + name + ' a stream using a released writer');\n }\n function defaultWriterClosedPromiseInitialize(writer) {\n  writer._closedPromise = newPromise(function (resolve, reject) {\n   writer._closedPromise_resolve = resolve;\n   writer._closedPromise_reject = reject;\n   writer._closedPromiseState = 'pending';\n  });\n }\n function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseReject(writer, reason);\n }\n function defaultWriterClosedPromiseInitializeAsResolved(writer) {\n  defaultWriterClosedPromiseInitialize(writer);\n  defaultWriterClosedPromiseResolve(writer);\n }\n function defaultWriterClosedPromiseReject(writer, reason) {\n  setPromiseIsHandledToTrue(writer._closedPromise);\n  writer._closedPromise_reject(reason);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'rejected';\n }\n function defaultWriterClosedPromiseResetToRejected(writer, reason) {\n  defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n }\n function defaultWriterClosedPromiseResolve(writer) {\n  writer._closedPromise_resolve(undefined);\n  writer._closedPromise_resolve = undefined;\n  writer._closedPromise_reject = undefined;\n  writer._closedPromiseState = 'resolved';\n }\n function defaultWriterReadyPromiseInitialize(writer) {\n  writer._readyPromise = newPromise(function (resolve, reject) {\n   writer._readyPromise_resolve = resolve;\n   writer._readyPromise_reject = reject;\n  });\n  writer._readyPromiseState = 'pending';\n }\n function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseReject(writer, reason);\n }\n function defaultWriterReadyPromiseInitializeAsResolved(writer) {\n  defaultWriterReadyPromiseInitialize(writer);\n  defaultWriterReadyPromiseResolve(writer);\n }\n function defaultWriterReadyPromiseReject(writer, reason) {\n  setPromiseIsHandledToTrue(writer._readyPromise);\n  writer._readyPromise_reject(reason);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'rejected';\n }\n function defaultWriterReadyPromiseReset(writer) {\n  defaultWriterReadyPromiseInitialize(writer);\n }\n function defaultWriterReadyPromiseResetToRejected(writer, reason) {\n  defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n }\n function defaultWriterReadyPromiseResolve(writer) {\n  writer._readyPromise_resolve(undefined);\n  writer._readyPromise_resolve = undefined;\n  writer._readyPromise_reject = undefined;\n  writer._readyPromiseState = 'fulfilled';\n }\n function isAbortSignal(value) {\n  if (typeof value !== 'object' || value === null) {\n   return false;\n  }\n  try {\n   return typeof value.aborted === 'boolean';\n  } catch (_a) {\n   return false;\n  }\n }\n var NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n function isDOMExceptionConstructor(ctor) {\n  if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n   return false;\n  }\n  try {\n   new ctor();\n   return true;\n  } catch (_a) {\n   return false;\n  }\n }\n function createDOMExceptionPolyfill() {\n  var ctor = function DOMException(message, name) {\n   this.message = message || '';\n   this.name = name || 'Error';\n   if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, this.constructor);\n   }\n  };\n  ctor.prototype = Object.create(Error.prototype);\n  Object.defineProperty(ctor.prototype, 'constructor', {\n   value: ctor,\n   writable: true,\n   configurable: true\n  });\n  return ctor;\n }\n var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n  var reader = AcquireReadableStreamDefaultReader(source);\n  var writer = AcquireWritableStreamDefaultWriter(dest);\n  source._disturbed = true;\n  var shuttingDown = false;\n  var currentWrite = promiseResolvedWith(undefined);\n  return newPromise(function (resolve, reject) {\n   var abortAlgorithm;\n   if (signal !== undefined) {\n    abortAlgorithm = function () {\n     var error = new DOMException$1('Aborted', 'AbortError');\n     var actions = [];\n     if (preventAbort === false) {\n      actions.push(function () {\n       if (dest._state === 'writable') {\n        return WritableStreamAbort(dest, error);\n       }\n       return promiseResolvedWith(undefined);\n      });\n     }\n     if (preventCancel === false) {\n      actions.push(function () {\n       if (source._state === 'readable') {\n        return ReadableStreamCancel(source, error);\n       }\n       return promiseResolvedWith(undefined);\n      });\n     }\n     shutdownWithAction(function () {\n      return Promise.all(actions.map(function (action) {\n       return action();\n      }));\n     }, true, error);\n    };\n    if (signal.aborted === true) {\n     abortAlgorithm();\n     return;\n    }\n    signal.addEventListener('abort', abortAlgorithm);\n   }\n   function pipeLoop() {\n    return newPromise(function (resolveLoop, rejectLoop) {\n     function next(done) {\n      if (done) {\n       resolveLoop();\n      } else {\n       PerformPromiseThen(pipeStep(), next, rejectLoop);\n      }\n     }\n     next(false);\n    });\n   }\n   function pipeStep() {\n    if (shuttingDown === true) {\n     return promiseResolvedWith(true);\n    }\n    return PerformPromiseThen(writer._readyPromise, function () {\n     return PerformPromiseThen(ReadableStreamDefaultReaderRead(reader), function (result) {\n      if (result.done === true) {\n       return true;\n      }\n      currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, result.value), undefined, noop);\n      return false;\n     });\n    });\n   }\n   isOrBecomesErrored(source, reader._closedPromise, function (storedError) {\n    if (preventAbort === false) {\n     shutdownWithAction(function () {\n      return WritableStreamAbort(dest, storedError);\n     }, true, storedError);\n    } else {\n     shutdown(true, storedError);\n    }\n   });\n   isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {\n    if (preventCancel === false) {\n     shutdownWithAction(function () {\n      return ReadableStreamCancel(source, storedError);\n     }, true, storedError);\n    } else {\n     shutdown(true, storedError);\n    }\n   });\n   isOrBecomesClosed(source, reader._closedPromise, function () {\n    if (preventClose === false) {\n     shutdownWithAction(function () {\n      return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);\n     });\n    } else {\n     shutdown();\n    }\n   });\n   if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') {\n    var destClosed_1 = new TypeError('the destination writable stream closed before all data could be piped to it');\n    if (preventCancel === false) {\n     shutdownWithAction(function () {\n      return ReadableStreamCancel(source, destClosed_1);\n     }, true, destClosed_1);\n    } else {\n     shutdown(true, destClosed_1);\n    }\n   }\n   setPromiseIsHandledToTrue(pipeLoop());\n   function waitForWritesToFinish() {\n    var oldCurrentWrite = currentWrite;\n    return PerformPromiseThen(currentWrite, function () {\n     return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;\n    });\n   }\n   function isOrBecomesErrored(stream, promise, action) {\n    if (stream._state === 'errored') {\n     action(stream._storedError);\n    } else {\n     uponRejection(promise, action);\n    }\n   }\n   function isOrBecomesClosed(stream, promise, action) {\n    if (stream._state === 'closed') {\n     action();\n    } else {\n     uponFulfillment(promise, action);\n    }\n   }\n   function shutdownWithAction(action, originalIsError, originalError) {\n    if (shuttingDown === true) {\n     return;\n    }\n    shuttingDown = true;\n    if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n     uponFulfillment(waitForWritesToFinish(), doTheRest);\n    } else {\n     doTheRest();\n    }\n    function doTheRest() {\n     uponPromise(action(), function () {\n      return finalize(originalIsError, originalError);\n     }, function (newError) {\n      return finalize(true, newError);\n     });\n    }\n   }\n   function shutdown(isError, error) {\n    if (shuttingDown === true) {\n     return;\n    }\n    shuttingDown = true;\n    if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) {\n     uponFulfillment(waitForWritesToFinish(), function () {\n      return finalize(isError, error);\n     });\n    } else {\n     finalize(isError, error);\n    }\n   }\n   function finalize(isError, error) {\n    WritableStreamDefaultWriterRelease(writer);\n    ReadableStreamReaderGenericRelease(reader);\n    if (signal !== undefined) {\n     signal.removeEventListener('abort', abortAlgorithm);\n    }\n    if (isError) {\n     reject(error);\n    } else {\n     resolve(undefined);\n    }\n   }\n  });\n }\n var ReadableStreamDefaultController = function () {\n  function ReadableStreamDefaultController() {\n   throw new TypeError();\n  }\n  Object.defineProperty(ReadableStreamDefaultController.prototype, \"desiredSize\", {\n   get: function () {\n    if (IsReadableStreamDefaultController(this) === false) {\n     throw defaultControllerBrandCheckException('desiredSize');\n    }\n    return ReadableStreamDefaultControllerGetDesiredSize(this);\n   },\n   enumerable: true,\n   configurable: true\n  });\n  ReadableStreamDefaultController.prototype.close = function () {\n   if (IsReadableStreamDefaultController(this) === false) {\n    throw defaultControllerBrandCheckException('close');\n   }\n   if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n    throw new TypeError('The stream is not in a state that permits close');\n   }\n   ReadableStreamDefaultControllerClose(this);\n  };\n  ReadableStreamDefaultController.prototype.enqueue = function (chunk) {\n   if (IsReadableStreamDefaultController(this) === false) {\n    throw defaultControllerBrandCheckException('enqueue');\n   }\n   if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) {\n    throw new TypeError('The stream is not in a state that permits enqueue');\n   }\n   return ReadableStreamDefaultControllerEnqueue(this, chunk);\n  };\n  ReadableStreamDefaultController.prototype.error = function (e) {\n   if (IsReadableStreamDefaultController(this) === false) {\n    throw defaultControllerBrandCheckException('error');\n   }\n   ReadableStreamDefaultControllerError(this, e);\n  };\n  ReadableStreamDefaultController.prototype[CancelSteps] = function (reason) {\n   ResetQueue(this);\n   var result = this._cancelAlgorithm(reason);\n   ReadableStreamDefaultControllerClearAlgorithms(this);\n   return result;\n  };\n  ReadableStreamDefaultController.prototype[PullSteps] = function () {\n   var stream = this._controlledReadableStream;\n   if (this._queue.length > 0) {\n    var chunk = DequeueValue(this);\n    if (this._closeRequested === true && this._queue.length === 0) {\n     ReadableStreamDefaultControllerClearAlgorithms(this);\n     ReadableStreamClose(stream);\n    } else {\n     ReadableStreamDefaultControllerCallPullIfNeeded(this);\n    }\n    return promiseResolvedWith(ReadableStreamCreateReadResult(chunk, false, stream._reader._forAuthorCode));\n   }\n   var pendingPromise = ReadableStreamAddReadRequest(stream);\n   ReadableStreamDefaultControllerCallPullIfNeeded(this);\n   return pendingPromise;\n  };\n  return ReadableStreamDefaultController;\n }();\n function IsReadableStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n  var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n   return;\n  }\n  if (controller._pulling === true) {\n   controller._pullAgain = true;\n   return;\n  }\n  controller._pulling = true;\n  var pullPromise = controller._pullAlgorithm();\n  uponPromise(pullPromise, function () {\n   controller._pulling = false;\n   if (controller._pullAgain === true) {\n    controller._pullAgain = false;\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n   }\n  }, function (e) {\n   ReadableStreamDefaultControllerError(controller, e);\n  });\n }\n function ReadableStreamDefaultControllerShouldCallPull(controller) {\n  var stream = controller._controlledReadableStream;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) {\n   return false;\n  }\n  if (controller._started === false) {\n   return false;\n  }\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n   return true;\n  }\n  var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n   return true;\n  }\n  return false;\n }\n function ReadableStreamDefaultControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n  controller._strategySizeAlgorithm = undefined;\n }\n function ReadableStreamDefaultControllerClose(controller) {\n  var stream = controller._controlledReadableStream;\n  controller._closeRequested = true;\n  if (controller._queue.length === 0) {\n   ReadableStreamDefaultControllerClearAlgorithms(controller);\n   ReadableStreamClose(stream);\n  }\n }\n function ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledReadableStream;\n  if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n   ReadableStreamFulfillReadRequest(stream, chunk, false);\n  } else {\n   var chunkSize = void 0;\n   try {\n    chunkSize = controller._strategySizeAlgorithm(chunk);\n   } catch (chunkSizeE) {\n    ReadableStreamDefaultControllerError(controller, chunkSizeE);\n    throw chunkSizeE;\n   }\n   try {\n    EnqueueValueWithSize(controller, chunk, chunkSize);\n   } catch (enqueueE) {\n    ReadableStreamDefaultControllerError(controller, enqueueE);\n    throw enqueueE;\n   }\n  }\n  ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n }\n function ReadableStreamDefaultControllerError(controller, e) {\n  var stream = controller._controlledReadableStream;\n  if (stream._state !== 'readable') {\n   return;\n  }\n  ResetQueue(controller);\n  ReadableStreamDefaultControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n }\n function ReadableStreamDefaultControllerGetDesiredSize(controller) {\n  var stream = controller._controlledReadableStream;\n  var state = stream._state;\n  if (state === 'errored') {\n   return null;\n  }\n  if (state === 'closed') {\n   return 0;\n  }\n  return controller._strategyHWM - controller._queueTotalSize;\n }\n function ReadableStreamDefaultControllerHasBackpressure(controller) {\n  if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n  var state = controller._controlledReadableStream._state;\n  if (controller._closeRequested === false && state === 'readable') {\n   return true;\n  }\n  return false;\n }\n function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  controller._controlledReadableStream = stream;\n  controller._queue = undefined;\n  controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._started = false;\n  controller._closeRequested = false;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  controller._strategySizeAlgorithm = sizeAlgorithm;\n  controller._strategyHWM = highWaterMark;\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  stream._readableStreamController = controller;\n  var startResult = startAlgorithm();\n  uponPromise(promiseResolvedWith(startResult), function () {\n   controller._started = true;\n   ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n  }, function (r) {\n   ReadableStreamDefaultControllerError(controller, r);\n  });\n }\n function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n  var controller = Object.create(ReadableStreamDefaultController.prototype);\n  function startAlgorithm() {\n   return InvokeOrNoop(underlyingSource, 'start', [controller]);\n  }\n  var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]);\n  var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []);\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n }\n function defaultControllerBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamDefaultController.prototype.\" + name + \" can only be used on a ReadableStreamDefaultController\");\n }\n function ReadableStreamTee(stream, cloneForBranch2) {\n  var reader = AcquireReadableStreamDefaultReader(stream);\n  var reading = false;\n  var canceled1 = false;\n  var canceled2 = false;\n  var reason1;\n  var reason2;\n  var branch1;\n  var branch2;\n  var resolveCancelPromise;\n  var cancelPromise = newPromise(function (resolve) {\n   resolveCancelPromise = resolve;\n  });\n  function pullAlgorithm() {\n   if (reading === true) {\n    return promiseResolvedWith(undefined);\n   }\n   reading = true;\n   var readPromise = transformPromiseWith(ReadableStreamDefaultReaderRead(reader), function (result) {\n    reading = false;\n    var done = result.done;\n    if (done === true) {\n     if (canceled1 === false) {\n      ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n     }\n     if (canceled2 === false) {\n      ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n     }\n     return;\n    }\n    var value = result.value;\n    var value1 = value;\n    var value2 = value;\n    if (canceled1 === false) {\n     ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n    }\n    if (canceled2 === false) {\n     ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n    }\n   });\n   setPromiseIsHandledToTrue(readPromise);\n   return promiseResolvedWith(undefined);\n  }\n  function cancel1Algorithm(reason) {\n   canceled1 = true;\n   reason1 = reason;\n   if (canceled2 === true) {\n    var compositeReason = createArrayFromList([\n     reason1,\n     reason2\n    ]);\n    var cancelResult = ReadableStreamCancel(stream, compositeReason);\n    resolveCancelPromise(cancelResult);\n   }\n   return cancelPromise;\n  }\n  function cancel2Algorithm(reason) {\n   canceled2 = true;\n   reason2 = reason;\n   if (canceled1 === true) {\n    var compositeReason = createArrayFromList([\n     reason1,\n     reason2\n    ]);\n    var cancelResult = ReadableStreamCancel(stream, compositeReason);\n    resolveCancelPromise(cancelResult);\n   }\n   return cancelPromise;\n  }\n  function startAlgorithm() {\n  }\n  branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n  branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n  uponRejection(reader._closedPromise, function (r) {\n   ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n   ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n  });\n  return [\n   branch1,\n   branch2\n  ];\n }\n var NumberIsInteger = Number.isInteger || function (value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n };\n var ReadableStreamBYOBRequest = function () {\n  function ReadableStreamBYOBRequest() {\n   throw new TypeError('ReadableStreamBYOBRequest cannot be used directly');\n  }\n  Object.defineProperty(ReadableStreamBYOBRequest.prototype, \"view\", {\n   get: function () {\n    if (IsReadableStreamBYOBRequest(this) === false) {\n     throw byobRequestBrandCheckException('view');\n    }\n    return this._view;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  ReadableStreamBYOBRequest.prototype.respond = function (bytesWritten) {\n   if (IsReadableStreamBYOBRequest(this) === false) {\n    throw byobRequestBrandCheckException('respond');\n   }\n   if (this._associatedReadableByteStreamController === undefined) {\n    throw new TypeError('This BYOB request has been invalidated');\n   }\n   if (IsDetachedBuffer(this._view.buffer) === true);\n   ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n  };\n  ReadableStreamBYOBRequest.prototype.respondWithNewView = function (view) {\n   if (IsReadableStreamBYOBRequest(this) === false) {\n    throw byobRequestBrandCheckException('respond');\n   }\n   if (this._associatedReadableByteStreamController === undefined) {\n    throw new TypeError('This BYOB request has been invalidated');\n   }\n   if (!ArrayBuffer.isView(view)) {\n    throw new TypeError('You can only respond with array buffer views');\n   }\n   if (IsDetachedBuffer(view.buffer) === true);\n   ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n  };\n  return ReadableStreamBYOBRequest;\n }();\n var ReadableByteStreamController = function () {\n  function ReadableByteStreamController() {\n   throw new TypeError('ReadableByteStreamController constructor cannot be used directly');\n  }\n  Object.defineProperty(ReadableByteStreamController.prototype, \"byobRequest\", {\n   get: function () {\n    if (IsReadableByteStreamController(this) === false) {\n     throw byteStreamControllerBrandCheckException('byobRequest');\n    }\n    if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) {\n     var firstDescriptor = this._pendingPullIntos.peek();\n     var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n     var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n     SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n     this._byobRequest = byobRequest;\n    }\n    return this._byobRequest;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  Object.defineProperty(ReadableByteStreamController.prototype, \"desiredSize\", {\n   get: function () {\n    if (IsReadableByteStreamController(this) === false) {\n     throw byteStreamControllerBrandCheckException('desiredSize');\n    }\n    return ReadableByteStreamControllerGetDesiredSize(this);\n   },\n   enumerable: true,\n   configurable: true\n  });\n  ReadableByteStreamController.prototype.close = function () {\n   if (IsReadableByteStreamController(this) === false) {\n    throw byteStreamControllerBrandCheckException('close');\n   }\n   if (this._closeRequested === true) {\n    throw new TypeError('The stream has already been closed; do not close it again!');\n   }\n   var state = this._controlledReadableByteStream._state;\n   if (state !== 'readable') {\n    throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be closed\");\n   }\n   ReadableByteStreamControllerClose(this);\n  };\n  ReadableByteStreamController.prototype.enqueue = function (chunk) {\n   if (IsReadableByteStreamController(this) === false) {\n    throw byteStreamControllerBrandCheckException('enqueue');\n   }\n   if (this._closeRequested === true) {\n    throw new TypeError('stream is closed or draining');\n   }\n   var state = this._controlledReadableByteStream._state;\n   if (state !== 'readable') {\n    throw new TypeError(\"The stream (in \" + state + \" state) is not in the readable state and cannot be enqueued to\");\n   }\n   if (!ArrayBuffer.isView(chunk)) {\n    throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController');\n   }\n   if (IsDetachedBuffer(chunk.buffer) === true);\n   ReadableByteStreamControllerEnqueue(this, chunk);\n  };\n  ReadableByteStreamController.prototype.error = function (e) {\n   if (IsReadableByteStreamController(this) === false) {\n    throw byteStreamControllerBrandCheckException('error');\n   }\n   ReadableByteStreamControllerError(this, e);\n  };\n  ReadableByteStreamController.prototype[CancelSteps] = function (reason) {\n   if (this._pendingPullIntos.length > 0) {\n    var firstDescriptor = this._pendingPullIntos.peek();\n    firstDescriptor.bytesFilled = 0;\n   }\n   ResetQueue(this);\n   var result = this._cancelAlgorithm(reason);\n   ReadableByteStreamControllerClearAlgorithms(this);\n   return result;\n  };\n  ReadableByteStreamController.prototype[PullSteps] = function () {\n   var stream = this._controlledReadableByteStream;\n   if (this._queueTotalSize > 0) {\n    var entry = this._queue.shift();\n    this._queueTotalSize -= entry.byteLength;\n    ReadableByteStreamControllerHandleQueueDrain(this);\n    var view = void 0;\n    try {\n     view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n    } catch (viewE) {\n     return promiseRejectedWith(viewE);\n    }\n    return promiseResolvedWith(ReadableStreamCreateReadResult(view, false, stream._reader._forAuthorCode));\n   }\n   var autoAllocateChunkSize = this._autoAllocateChunkSize;\n   if (autoAllocateChunkSize !== undefined) {\n    var buffer = void 0;\n    try {\n     buffer = new ArrayBuffer(autoAllocateChunkSize);\n    } catch (bufferE) {\n     return promiseRejectedWith(bufferE);\n    }\n    var pullIntoDescriptor = {\n     buffer: buffer,\n     byteOffset: 0,\n     byteLength: autoAllocateChunkSize,\n     bytesFilled: 0,\n     elementSize: 1,\n     ctor: Uint8Array,\n     readerType: 'default'\n    };\n    this._pendingPullIntos.push(pullIntoDescriptor);\n   }\n   var promise = ReadableStreamAddReadRequest(stream);\n   ReadableByteStreamControllerCallPullIfNeeded(this);\n   return promise;\n  };\n  return ReadableByteStreamController;\n }();\n function IsReadableByteStreamController(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n   return false;\n  }\n  return true;\n }\n function IsReadableStreamBYOBRequest(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n   return false;\n  }\n  return true;\n }\n function ReadableByteStreamControllerCallPullIfNeeded(controller) {\n  var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n  if (shouldPull === false) {\n   return;\n  }\n  if (controller._pulling === true) {\n   controller._pullAgain = true;\n   return;\n  }\n  controller._pulling = true;\n  var pullPromise = controller._pullAlgorithm();\n  uponPromise(pullPromise, function () {\n   controller._pulling = false;\n   if (controller._pullAgain === true) {\n    controller._pullAgain = false;\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n   }\n  }, function (e) {\n   ReadableByteStreamControllerError(controller, e);\n  });\n }\n function ReadableByteStreamControllerClearPendingPullIntos(controller) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  controller._pendingPullIntos = new SimpleQueue();\n }\n function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n  var done = false;\n  if (stream._state === 'closed') {\n   done = true;\n  }\n  var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n  if (pullIntoDescriptor.readerType === 'default') {\n   ReadableStreamFulfillReadRequest(stream, filledView, done);\n  } else {\n   ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n  }\n }\n function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n  var bytesFilled = pullIntoDescriptor.bytesFilled;\n  var elementSize = pullIntoDescriptor.elementSize;\n  return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n }\n function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n  controller._queue.push({\n   buffer: buffer,\n   byteOffset: byteOffset,\n   byteLength: byteLength\n  });\n  controller._queueTotalSize += byteLength;\n }\n function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n  var elementSize = pullIntoDescriptor.elementSize;\n  var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n  var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n  var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n  var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n  var totalBytesToCopyRemaining = maxBytesToCopy;\n  var ready = false;\n  if (maxAlignedBytes > currentAlignedBytes) {\n   totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n   ready = true;\n  }\n  var queue = controller._queue;\n  while (totalBytesToCopyRemaining > 0) {\n   var headOfQueue = queue.peek();\n   var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n   var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n   ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n   if (headOfQueue.byteLength === bytesToCopy) {\n    queue.shift();\n   } else {\n    headOfQueue.byteOffset += bytesToCopy;\n    headOfQueue.byteLength -= bytesToCopy;\n   }\n   controller._queueTotalSize -= bytesToCopy;\n   ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n   totalBytesToCopyRemaining -= bytesToCopy;\n  }\n  return ready;\n }\n function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  pullIntoDescriptor.bytesFilled += size;\n }\n function ReadableByteStreamControllerHandleQueueDrain(controller) {\n  if (controller._queueTotalSize === 0 && controller._closeRequested === true) {\n   ReadableByteStreamControllerClearAlgorithms(controller);\n   ReadableStreamClose(controller._controlledReadableByteStream);\n  } else {\n   ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }\n }\n function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n  if (controller._byobRequest === undefined) {\n   return;\n  }\n  controller._byobRequest._associatedReadableByteStreamController = undefined;\n  controller._byobRequest._view = undefined;\n  controller._byobRequest = undefined;\n }\n function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n  while (controller._pendingPullIntos.length > 0) {\n   if (controller._queueTotalSize === 0) {\n    return;\n   }\n   var pullIntoDescriptor = controller._pendingPullIntos.peek();\n   if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n   }\n  }\n }\n function ReadableByteStreamControllerPullInto(controller, view) {\n  var stream = controller._controlledReadableByteStream;\n  var elementSize = 1;\n  if (view.constructor !== DataView) {\n   elementSize = view.constructor.BYTES_PER_ELEMENT;\n  }\n  var ctor = view.constructor;\n  var buffer = TransferArrayBuffer(view.buffer);\n  var pullIntoDescriptor = {\n   buffer: buffer,\n   byteOffset: view.byteOffset,\n   byteLength: view.byteLength,\n   bytesFilled: 0,\n   elementSize: elementSize,\n   ctor: ctor,\n   readerType: 'byob'\n  };\n  if (controller._pendingPullIntos.length > 0) {\n   controller._pendingPullIntos.push(pullIntoDescriptor);\n   return ReadableStreamAddReadIntoRequest(stream);\n  }\n  if (stream._state === 'closed') {\n   var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n   return promiseResolvedWith(ReadableStreamCreateReadResult(emptyView, true, stream._reader._forAuthorCode));\n  }\n  if (controller._queueTotalSize > 0) {\n   if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) {\n    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    ReadableByteStreamControllerHandleQueueDrain(controller);\n    return promiseResolvedWith(ReadableStreamCreateReadResult(filledView, false, stream._reader._forAuthorCode));\n   }\n   if (controller._closeRequested === true) {\n    var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n    ReadableByteStreamControllerError(controller, e);\n    return promiseRejectedWith(e);\n   }\n  }\n  controller._pendingPullIntos.push(pullIntoDescriptor);\n  var promise = ReadableStreamAddReadIntoRequest(stream);\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n  return promise;\n }\n function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n  firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n  var stream = controller._controlledReadableByteStream;\n  if (ReadableStreamHasBYOBReader(stream) === true) {\n   while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n    var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n    ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n   }\n  }\n }\n function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n  if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n   throw new RangeError('bytesWritten out of range');\n  }\n  ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n  if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n   return;\n  }\n  ReadableByteStreamControllerShiftPendingPullInto(controller);\n  var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n  if (remainderSize > 0) {\n   var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n   var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n   ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n  }\n  pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n  pullIntoDescriptor.bytesFilled -= remainderSize;\n  ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n  ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n }\n function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n  var firstDescriptor = controller._pendingPullIntos.peek();\n  var stream = controller._controlledReadableByteStream;\n  if (stream._state === 'closed') {\n   if (bytesWritten !== 0) {\n    throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n   }\n   ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n  } else {\n   ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n  }\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n }\n function ReadableByteStreamControllerShiftPendingPullInto(controller) {\n  var descriptor = controller._pendingPullIntos.shift();\n  ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n  return descriptor;\n }\n function ReadableByteStreamControllerShouldCallPull(controller) {\n  var stream = controller._controlledReadableByteStream;\n  if (stream._state !== 'readable') {\n   return false;\n  }\n  if (controller._closeRequested === true) {\n   return false;\n  }\n  if (controller._started === false) {\n   return false;\n  }\n  if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) {\n   return true;\n  }\n  if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n   return true;\n  }\n  var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n  if (desiredSize > 0) {\n   return true;\n  }\n  return false;\n }\n function ReadableByteStreamControllerClearAlgorithms(controller) {\n  controller._pullAlgorithm = undefined;\n  controller._cancelAlgorithm = undefined;\n }\n function ReadableByteStreamControllerClose(controller) {\n  var stream = controller._controlledReadableByteStream;\n  if (controller._queueTotalSize > 0) {\n   controller._closeRequested = true;\n   return;\n  }\n  if (controller._pendingPullIntos.length > 0) {\n   var firstPendingPullInto = controller._pendingPullIntos.peek();\n   if (firstPendingPullInto.bytesFilled > 0) {\n    var e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n    ReadableByteStreamControllerError(controller, e);\n    throw e;\n   }\n  }\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamClose(stream);\n }\n function ReadableByteStreamControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledReadableByteStream;\n  var buffer = chunk.buffer;\n  var byteOffset = chunk.byteOffset;\n  var byteLength = chunk.byteLength;\n  var transferredBuffer = TransferArrayBuffer(buffer);\n  if (ReadableStreamHasDefaultReader(stream) === true) {\n   if (ReadableStreamGetNumReadRequests(stream) === 0) {\n    ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n   } else {\n    var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n    ReadableStreamFulfillReadRequest(stream, transferredView, false);\n   }\n  } else if (ReadableStreamHasBYOBReader(stream) === true) {\n   ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n   ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n  } else {\n   ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n  }\n  ReadableByteStreamControllerCallPullIfNeeded(controller);\n }\n function ReadableByteStreamControllerError(controller, e) {\n  var stream = controller._controlledReadableByteStream;\n  if (stream._state !== 'readable') {\n   return;\n  }\n  ReadableByteStreamControllerClearPendingPullIntos(controller);\n  ResetQueue(controller);\n  ReadableByteStreamControllerClearAlgorithms(controller);\n  ReadableStreamError(stream, e);\n }\n function ReadableByteStreamControllerGetDesiredSize(controller) {\n  var stream = controller._controlledReadableByteStream;\n  var state = stream._state;\n  if (state === 'errored') {\n   return null;\n  }\n  if (state === 'closed') {\n   return 0;\n  }\n  return controller._strategyHWM - controller._queueTotalSize;\n }\n function ReadableByteStreamControllerRespond(controller, bytesWritten) {\n  bytesWritten = Number(bytesWritten);\n  if (IsFiniteNonNegativeNumber(bytesWritten) === false) {\n   throw new RangeError('bytesWritten must be a finite');\n  }\n  ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n }\n function ReadableByteStreamControllerRespondWithNewView(controller, view) {\n  var firstDescriptor = controller._pendingPullIntos.peek();\n  if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n   throw new RangeError('The region specified by view does not match byobRequest');\n  }\n  if (firstDescriptor.byteLength !== view.byteLength) {\n   throw new RangeError('The buffer of view has different capacity than byobRequest');\n  }\n  firstDescriptor.buffer = view.buffer;\n  ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n }\n function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n  controller._controlledReadableByteStream = stream;\n  controller._pullAgain = false;\n  controller._pulling = false;\n  controller._byobRequest = undefined;\n  controller._queue = controller._queueTotalSize = undefined;\n  ResetQueue(controller);\n  controller._closeRequested = false;\n  controller._started = false;\n  controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark);\n  controller._pullAlgorithm = pullAlgorithm;\n  controller._cancelAlgorithm = cancelAlgorithm;\n  controller._autoAllocateChunkSize = autoAllocateChunkSize;\n  controller._pendingPullIntos = new SimpleQueue();\n  stream._readableStreamController = controller;\n  var startResult = startAlgorithm();\n  uponPromise(promiseResolvedWith(startResult), function () {\n   controller._started = true;\n   ReadableByteStreamControllerCallPullIfNeeded(controller);\n  }, function (r) {\n   ReadableByteStreamControllerError(controller, r);\n  });\n }\n function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n  var controller = Object.create(ReadableByteStreamController.prototype);\n  function startAlgorithm() {\n   return InvokeOrNoop(underlyingByteSource, 'start', [controller]);\n  }\n  var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]);\n  var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []);\n  var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n  if (autoAllocateChunkSize !== undefined) {\n   autoAllocateChunkSize = Number(autoAllocateChunkSize);\n   if (NumberIsInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) {\n    throw new RangeError('autoAllocateChunkSize must be a positive integer');\n   }\n  }\n  SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n }\n function SetUpReadableStreamBYOBRequest(request, controller, view) {\n  request._associatedReadableByteStreamController = controller;\n  request._view = view;\n }\n function byobRequestBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamBYOBRequest.prototype.\" + name + \" can only be used on a ReadableStreamBYOBRequest\");\n }\n function byteStreamControllerBrandCheckException(name) {\n  return new TypeError(\"ReadableByteStreamController.prototype.\" + name + \" can only be used on a ReadableByteStreamController\");\n }\n function AcquireReadableStreamBYOBReader(stream, forAuthorCode) {\n  if (forAuthorCode === void 0) {\n   forAuthorCode = false;\n  }\n  var reader = new ReadableStreamBYOBReader(stream);\n  reader._forAuthorCode = forAuthorCode;\n  return reader;\n }\n function ReadableStreamAddReadIntoRequest(stream) {\n  var promise = newPromise(function (resolve, reject) {\n   var readIntoRequest = {\n    _resolve: resolve,\n    _reject: reject\n   };\n   stream._reader._readIntoRequests.push(readIntoRequest);\n  });\n  return promise;\n }\n function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n  var reader = stream._reader;\n  var readIntoRequest = reader._readIntoRequests.shift();\n  readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode));\n }\n function ReadableStreamGetNumReadIntoRequests(stream) {\n  return stream._reader._readIntoRequests.length;\n }\n function ReadableStreamHasBYOBReader(stream) {\n  var reader = stream._reader;\n  if (reader === undefined) {\n   return false;\n  }\n  if (!IsReadableStreamBYOBReader(reader)) {\n   return false;\n  }\n  return true;\n }\n var ReadableStreamBYOBReader = function () {\n  function ReadableStreamBYOBReader(stream) {\n   if (!IsReadableStream(stream)) {\n    throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' + 'byte source');\n   }\n   if (IsReadableByteStreamController(stream._readableStreamController) === false) {\n    throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');\n   }\n   if (IsReadableStreamLocked(stream)) {\n    throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n   }\n   ReadableStreamReaderGenericInitialize(this, stream);\n   this._readIntoRequests = new SimpleQueue();\n  }\n  Object.defineProperty(ReadableStreamBYOBReader.prototype, \"closed\", {\n   get: function () {\n    if (!IsReadableStreamBYOBReader(this)) {\n     return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n    }\n    return this._closedPromise;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  ReadableStreamBYOBReader.prototype.cancel = function (reason) {\n   if (!IsReadableStreamBYOBReader(this)) {\n    return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n   }\n   if (this._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('cancel'));\n   }\n   return ReadableStreamReaderGenericCancel(this, reason);\n  };\n  ReadableStreamBYOBReader.prototype.read = function (view) {\n   if (!IsReadableStreamBYOBReader(this)) {\n    return promiseRejectedWith(byobReaderBrandCheckException('read'));\n   }\n   if (this._ownerReadableStream === undefined) {\n    return promiseRejectedWith(readerLockException('read from'));\n   }\n   if (!ArrayBuffer.isView(view)) {\n    return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n   }\n   if (IsDetachedBuffer(view.buffer) === true);\n   if (view.byteLength === 0) {\n    return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n   }\n   return ReadableStreamBYOBReaderRead(this, view);\n  };\n  ReadableStreamBYOBReader.prototype.releaseLock = function () {\n   if (!IsReadableStreamBYOBReader(this)) {\n    throw byobReaderBrandCheckException('releaseLock');\n   }\n   if (this._ownerReadableStream === undefined) {\n    return;\n   }\n   if (this._readIntoRequests.length > 0) {\n    throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n   }\n   ReadableStreamReaderGenericRelease(this);\n  };\n  return ReadableStreamBYOBReader;\n }();\n function IsReadableStreamBYOBReader(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamBYOBReaderRead(reader, view) {\n  var stream = reader._ownerReadableStream;\n  stream._disturbed = true;\n  if (stream._state === 'errored') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  return ReadableByteStreamControllerPullInto(stream._readableStreamController, view);\n }\n function byobReaderBrandCheckException(name) {\n  return new TypeError(\"ReadableStreamBYOBReader.prototype.\" + name + \" can only be used on a ReadableStreamBYOBReader\");\n }\n var ReadableStream = function () {\n  function ReadableStream(underlyingSource, strategy) {\n   if (underlyingSource === void 0) {\n    underlyingSource = {};\n   }\n   if (strategy === void 0) {\n    strategy = {};\n   }\n   InitializeReadableStream(this);\n   var size = strategy.size;\n   var highWaterMark = strategy.highWaterMark;\n   var type = underlyingSource.type;\n   var typeString = String(type);\n   if (typeString === 'bytes') {\n    if (size !== undefined) {\n     throw new RangeError('The strategy for a byte stream cannot have a size function');\n    }\n    if (highWaterMark === undefined) {\n     highWaterMark = 0;\n    }\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n    SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n   } else if (type === undefined) {\n    var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size);\n    if (highWaterMark === undefined) {\n     highWaterMark = 1;\n    }\n    highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark);\n    SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n   } else {\n    throw new RangeError('Invalid type is specified');\n   }\n  }\n  Object.defineProperty(ReadableStream.prototype, \"locked\", {\n   get: function () {\n    if (IsReadableStream(this) === false) {\n     throw streamBrandCheckException$1('locked');\n    }\n    return IsReadableStreamLocked(this);\n   },\n   enumerable: true,\n   configurable: true\n  });\n  ReadableStream.prototype.cancel = function (reason) {\n   if (IsReadableStream(this) === false) {\n    return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n   }\n   if (IsReadableStreamLocked(this) === true) {\n    return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n   }\n   return ReadableStreamCancel(this, reason);\n  };\n  ReadableStream.prototype.getReader = function (_a) {\n   var mode = (_a === void 0 ? {} : _a).mode;\n   if (IsReadableStream(this) === false) {\n    throw streamBrandCheckException$1('getReader');\n   }\n   if (mode === undefined) {\n    return AcquireReadableStreamDefaultReader(this, true);\n   }\n   mode = String(mode);\n   if (mode === 'byob') {\n    return AcquireReadableStreamBYOBReader(this, true);\n   }\n   throw new RangeError('Invalid mode is specified');\n  };\n  ReadableStream.prototype.pipeThrough = function (_a, _b) {\n   var writable = _a.writable, readable = _a.readable;\n   var _c = _b === void 0 ? {} : _b, preventClose = _c.preventClose, preventAbort = _c.preventAbort, preventCancel = _c.preventCancel, signal = _c.signal;\n   if (IsReadableStream(this) === false) {\n    throw streamBrandCheckException$1('pipeThrough');\n   }\n   if (IsWritableStream(writable) === false) {\n    throw new TypeError('writable argument to pipeThrough must be a WritableStream');\n   }\n   if (IsReadableStream(readable) === false) {\n    throw new TypeError('readable argument to pipeThrough must be a ReadableStream');\n   }\n   preventClose = Boolean(preventClose);\n   preventAbort = Boolean(preventAbort);\n   preventCancel = Boolean(preventCancel);\n   if (signal !== undefined && !isAbortSignal(signal)) {\n    throw new TypeError('ReadableStream.prototype.pipeThrough\\'s signal option must be an AbortSignal');\n   }\n   if (IsReadableStreamLocked(this) === true) {\n    throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n   }\n   if (IsWritableStreamLocked(writable) === true) {\n    throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n   }\n   var promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal);\n   setPromiseIsHandledToTrue(promise);\n   return readable;\n  };\n  ReadableStream.prototype.pipeTo = function (dest, _a) {\n   var _b = _a === void 0 ? {} : _a, preventClose = _b.preventClose, preventAbort = _b.preventAbort, preventCancel = _b.preventCancel, signal = _b.signal;\n   if (IsReadableStream(this) === false) {\n    return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n   }\n   if (IsWritableStream(dest) === false) {\n    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo\\'s first argument must be a WritableStream'));\n   }\n   preventClose = Boolean(preventClose);\n   preventAbort = Boolean(preventAbort);\n   preventCancel = Boolean(preventCancel);\n   if (signal !== undefined && !isAbortSignal(signal)) {\n    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo\\'s signal option must be an AbortSignal'));\n   }\n   if (IsReadableStreamLocked(this) === true) {\n    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n   }\n   if (IsWritableStreamLocked(dest) === true) {\n    return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n   }\n   return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal);\n  };\n  ReadableStream.prototype.tee = function () {\n   if (IsReadableStream(this) === false) {\n    throw streamBrandCheckException$1('tee');\n   }\n   var branches = ReadableStreamTee(this);\n   return createArrayFromList(branches);\n  };\n  ReadableStream.prototype.getIterator = function (_a) {\n   var _b = (_a === void 0 ? {} : _a).preventCancel, preventCancel = _b === void 0 ? false : _b;\n   if (IsReadableStream(this) === false) {\n    throw streamBrandCheckException$1('getIterator');\n   }\n   return AcquireReadableStreamAsyncIterator(this, preventCancel);\n  };\n  return ReadableStream;\n }();\n if (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n  Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n   value: ReadableStream.prototype.getIterator,\n   enumerable: false,\n   writable: true,\n   configurable: true\n  });\n }\n function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n  if (highWaterMark === void 0) {\n   highWaterMark = 1;\n  }\n  if (sizeAlgorithm === void 0) {\n   sizeAlgorithm = function () {\n    return 1;\n   };\n  }\n  var stream = Object.create(ReadableStream.prototype);\n  InitializeReadableStream(stream);\n  var controller = Object.create(ReadableStreamDefaultController.prototype);\n  SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n  return stream;\n }\n function InitializeReadableStream(stream) {\n  stream._state = 'readable';\n  stream._reader = undefined;\n  stream._storedError = undefined;\n  stream._disturbed = false;\n }\n function IsReadableStream(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n   return false;\n  }\n  return true;\n }\n function IsReadableStreamLocked(stream) {\n  if (stream._reader === undefined) {\n   return false;\n  }\n  return true;\n }\n function ReadableStreamCancel(stream, reason) {\n  stream._disturbed = true;\n  if (stream._state === 'closed') {\n   return promiseResolvedWith(undefined);\n  }\n  if (stream._state === 'errored') {\n   return promiseRejectedWith(stream._storedError);\n  }\n  ReadableStreamClose(stream);\n  var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n  return transformPromiseWith(sourceCancelPromise, noop);\n }\n function ReadableStreamClose(stream) {\n  stream._state = 'closed';\n  var reader = stream._reader;\n  if (reader === undefined) {\n   return;\n  }\n  if (IsReadableStreamDefaultReader(reader)) {\n   reader._readRequests.forEach(function (readRequest) {\n    readRequest._resolve(ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode));\n   });\n   reader._readRequests = new SimpleQueue();\n  }\n  defaultReaderClosedPromiseResolve(reader);\n }\n function ReadableStreamError(stream, e) {\n  stream._state = 'errored';\n  stream._storedError = e;\n  var reader = stream._reader;\n  if (reader === undefined) {\n   return;\n  }\n  if (IsReadableStreamDefaultReader(reader)) {\n   reader._readRequests.forEach(function (readRequest) {\n    readRequest._reject(e);\n   });\n   reader._readRequests = new SimpleQueue();\n  } else {\n   reader._readIntoRequests.forEach(function (readIntoRequest) {\n    readIntoRequest._reject(e);\n   });\n   reader._readIntoRequests = new SimpleQueue();\n  }\n  defaultReaderClosedPromiseReject(reader, e);\n }\n function streamBrandCheckException$1(name) {\n  return new TypeError(\"ReadableStream.prototype.\" + name + \" can only be used on a ReadableStream\");\n }\n var ByteLengthQueuingStrategy = function () {\n  function ByteLengthQueuingStrategy(_a) {\n   var highWaterMark = _a.highWaterMark;\n   this.highWaterMark = highWaterMark;\n  }\n  ByteLengthQueuingStrategy.prototype.size = function (chunk) {\n   return chunk.byteLength;\n  };\n  return ByteLengthQueuingStrategy;\n }();\n var CountQueuingStrategy = function () {\n  function CountQueuingStrategy(_a) {\n   var highWaterMark = _a.highWaterMark;\n   this.highWaterMark = highWaterMark;\n  }\n  CountQueuingStrategy.prototype.size = function () {\n   return 1;\n  };\n  return CountQueuingStrategy;\n }();\n var TransformStream = function () {\n  function TransformStream(transformer, writableStrategy, readableStrategy) {\n   if (transformer === void 0) {\n    transformer = {};\n   }\n   if (writableStrategy === void 0) {\n    writableStrategy = {};\n   }\n   if (readableStrategy === void 0) {\n    readableStrategy = {};\n   }\n   var writableSizeFunction = writableStrategy.size;\n   var writableHighWaterMark = writableStrategy.highWaterMark;\n   var readableSizeFunction = readableStrategy.size;\n   var readableHighWaterMark = readableStrategy.highWaterMark;\n   var writableType = transformer.writableType;\n   if (writableType !== undefined) {\n    throw new RangeError('Invalid writable type specified');\n   }\n   var writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction);\n   if (writableHighWaterMark === undefined) {\n    writableHighWaterMark = 1;\n   }\n   writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark);\n   var readableType = transformer.readableType;\n   if (readableType !== undefined) {\n    throw new RangeError('Invalid readable type specified');\n   }\n   var readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction);\n   if (readableHighWaterMark === undefined) {\n    readableHighWaterMark = 0;\n   }\n   readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark);\n   var startPromise_resolve;\n   var startPromise = newPromise(function (resolve) {\n    startPromise_resolve = resolve;\n   });\n   InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n   SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n   var startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]);\n   startPromise_resolve(startResult);\n  }\n  Object.defineProperty(TransformStream.prototype, \"readable\", {\n   get: function () {\n    if (IsTransformStream(this) === false) {\n     throw streamBrandCheckException$2('readable');\n    }\n    return this._readable;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  Object.defineProperty(TransformStream.prototype, \"writable\", {\n   get: function () {\n    if (IsTransformStream(this) === false) {\n     throw streamBrandCheckException$2('writable');\n    }\n    return this._writable;\n   },\n   enumerable: true,\n   configurable: true\n  });\n  return TransformStream;\n }();\n function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n  function startAlgorithm() {\n   return startPromise;\n  }\n  function writeAlgorithm(chunk) {\n   return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n  }\n  function abortAlgorithm(reason) {\n   return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n  }\n  function closeAlgorithm() {\n   return TransformStreamDefaultSinkCloseAlgorithm(stream);\n  }\n  stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n  function pullAlgorithm() {\n   return TransformStreamDefaultSourcePullAlgorithm(stream);\n  }\n  function cancelAlgorithm(reason) {\n   TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n   return promiseResolvedWith(undefined);\n  }\n  stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n  stream._backpressure = undefined;\n  stream._backpressureChangePromise = undefined;\n  stream._backpressureChangePromise_resolve = undefined;\n  TransformStreamSetBackpressure(stream, true);\n  stream._transformStreamController = undefined;\n }\n function IsTransformStream(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n   return false;\n  }\n  return true;\n }\n function TransformStreamError(stream, e) {\n  ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n  TransformStreamErrorWritableAndUnblockWrite(stream, e);\n }\n function TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n  TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n  WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n  if (stream._backpressure === true) {\n   TransformStreamSetBackpressure(stream, false);\n  }\n }\n function TransformStreamSetBackpressure(stream, backpressure) {\n  if (stream._backpressureChangePromise !== undefined) {\n   stream._backpressureChangePromise_resolve();\n  }\n  stream._backpressureChangePromise = newPromise(function (resolve) {\n   stream._backpressureChangePromise_resolve = resolve;\n  });\n  stream._backpressure = backpressure;\n }\n var TransformStreamDefaultController = function () {\n  function TransformStreamDefaultController() {\n   throw new TypeError('TransformStreamDefaultController instances cannot be created directly');\n  }\n  Object.defineProperty(TransformStreamDefaultController.prototype, \"desiredSize\", {\n   get: function () {\n    if (IsTransformStreamDefaultController(this) === false) {\n     throw defaultControllerBrandCheckException$1('desiredSize');\n    }\n    var readableController = this._controlledTransformStream._readable._readableStreamController;\n    return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n   },\n   enumerable: true,\n   configurable: true\n  });\n  TransformStreamDefaultController.prototype.enqueue = function (chunk) {\n   if (IsTransformStreamDefaultController(this) === false) {\n    throw defaultControllerBrandCheckException$1('enqueue');\n   }\n   TransformStreamDefaultControllerEnqueue(this, chunk);\n  };\n  TransformStreamDefaultController.prototype.error = function (reason) {\n   if (IsTransformStreamDefaultController(this) === false) {\n    throw defaultControllerBrandCheckException$1('error');\n   }\n   TransformStreamDefaultControllerError(this, reason);\n  };\n  TransformStreamDefaultController.prototype.terminate = function () {\n   if (IsTransformStreamDefaultController(this) === false) {\n    throw defaultControllerBrandCheckException$1('terminate');\n   }\n   TransformStreamDefaultControllerTerminate(this);\n  };\n  return TransformStreamDefaultController;\n }();\n function IsTransformStreamDefaultController(x) {\n  if (!typeIsObject(x)) {\n   return false;\n  }\n  if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n   return false;\n  }\n  return true;\n }\n function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n  controller._controlledTransformStream = stream;\n  stream._transformStreamController = controller;\n  controller._transformAlgorithm = transformAlgorithm;\n  controller._flushAlgorithm = flushAlgorithm;\n }\n function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n  var controller = Object.create(TransformStreamDefaultController.prototype);\n  var transformAlgorithm = function (chunk) {\n   try {\n    TransformStreamDefaultControllerEnqueue(controller, chunk);\n    return promiseResolvedWith(undefined);\n   } catch (transformResultE) {\n    return promiseRejectedWith(transformResultE);\n   }\n  };\n  var transformMethod = transformer.transform;\n  if (transformMethod !== undefined) {\n   if (typeof transformMethod !== 'function') {\n    throw new TypeError('transform is not a method');\n   }\n   transformAlgorithm = function (chunk) {\n    return PromiseCall(transformMethod, transformer, [\n     chunk,\n     controller\n    ]);\n   };\n  }\n  var flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]);\n  SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n }\n function TransformStreamDefaultControllerClearAlgorithms(controller) {\n  controller._transformAlgorithm = undefined;\n  controller._flushAlgorithm = undefined;\n }\n function TransformStreamDefaultControllerEnqueue(controller, chunk) {\n  var stream = controller._controlledTransformStream;\n  var readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) {\n   throw new TypeError('Readable side is not in a state that permits enqueue');\n  }\n  try {\n   ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n  } catch (e) {\n   TransformStreamErrorWritableAndUnblockWrite(stream, e);\n   throw stream._readable._storedError;\n  }\n  var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n  if (backpressure !== stream._backpressure) {\n   TransformStreamSetBackpressure(stream, true);\n  }\n }\n function TransformStreamDefaultControllerError(controller, e) {\n  TransformStreamError(controller._controlledTransformStream, e);\n }\n function TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n  var transformPromise = controller._transformAlgorithm(chunk);\n  return transformPromiseWith(transformPromise, undefined, function (r) {\n   TransformStreamError(controller._controlledTransformStream, r);\n   throw r;\n  });\n }\n function TransformStreamDefaultControllerTerminate(controller) {\n  var stream = controller._controlledTransformStream;\n  var readableController = stream._readable._readableStreamController;\n  if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n   ReadableStreamDefaultControllerClose(readableController);\n  }\n  var error = new TypeError('TransformStream terminated');\n  TransformStreamErrorWritableAndUnblockWrite(stream, error);\n }\n function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n  var controller = stream._transformStreamController;\n  if (stream._backpressure === true) {\n   var backpressureChangePromise = stream._backpressureChangePromise;\n   return transformPromiseWith(backpressureChangePromise, function () {\n    var writable = stream._writable;\n    var state = writable._state;\n    if (state === 'erroring') {\n     throw writable._storedError;\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n   });\n  }\n  return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n }\n function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n  TransformStreamError(stream, reason);\n  return promiseResolvedWith(undefined);\n }\n function TransformStreamDefaultSinkCloseAlgorithm(stream) {\n  var readable = stream._readable;\n  var controller = stream._transformStreamController;\n  var flushPromise = controller._flushAlgorithm();\n  TransformStreamDefaultControllerClearAlgorithms(controller);\n  return transformPromiseWith(flushPromise, function () {\n   if (readable._state === 'errored') {\n    throw readable._storedError;\n   }\n   var readableController = readable._readableStreamController;\n   if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) {\n    ReadableStreamDefaultControllerClose(readableController);\n   }\n  }, function (r) {\n   TransformStreamError(stream, r);\n   throw readable._storedError;\n  });\n }\n function TransformStreamDefaultSourcePullAlgorithm(stream) {\n  TransformStreamSetBackpressure(stream, false);\n  return stream._backpressureChangePromise;\n }\n function defaultControllerBrandCheckException$1(name) {\n  return new TypeError(\"TransformStreamDefaultController.prototype.\" + name + \" can only be used on a TransformStreamDefaultController\");\n }\n function streamBrandCheckException$2(name) {\n  return new TypeError(\"TransformStream.prototype.\" + name + \" can only be used on a TransformStream\");\n }\n exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;\n exports.CountQueuingStrategy = CountQueuingStrategy;\n exports.ReadableStream = ReadableStream;\n exports.TransformStream = TransformStream;\n exports.WritableStream = WritableStream;\n Object.defineProperty(exports, '__esModule', { value: true });\n}));\n\n/***/ }),\n/* 146 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(147);\n__w_pdfjs_require__(118);\n__w_pdfjs_require__(77);\n__w_pdfjs_require__(120);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Map;\n\n/***/ }),\n/* 147 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar collection = __w_pdfjs_require__(148);\nvar collectionStrong = __w_pdfjs_require__(152);\nmodule.exports = collection('Map', function (init) {\n return function Map() {\n  return init(this, arguments.length ? arguments[0] : undefined);\n };\n}, collectionStrong);\n\n/***/ }),\n/* 148 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar global = __w_pdfjs_require__(11);\nvar isForced = __w_pdfjs_require__(52);\nvar redefine = __w_pdfjs_require__(29);\nvar InternalMetadataModule = __w_pdfjs_require__(149);\nvar iterate = __w_pdfjs_require__(104);\nvar anInstance = __w_pdfjs_require__(126);\nvar isObject = __w_pdfjs_require__(22);\nvar fails = __w_pdfjs_require__(14);\nvar checkCorrectnessOfIteration = __w_pdfjs_require__(97);\nvar setToStringTag = __w_pdfjs_require__(85);\nvar inheritIfRequired = __w_pdfjs_require__(151);\nmodule.exports = function (CONSTRUCTOR_NAME, wrapper, common) {\n var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;\n var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;\n var ADDER = IS_MAP ? 'set' : 'add';\n var NativeConstructor = global[CONSTRUCTOR_NAME];\n var NativePrototype = NativeConstructor && NativeConstructor.prototype;\n var Constructor = NativeConstructor;\n var exported = {};\n var fixMethod = function (KEY) {\n  var nativeMethod = NativePrototype[KEY];\n  redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) {\n   nativeMethod.call(this, value === 0 ? 0 : value);\n   return this;\n  } : KEY == 'delete' ? function (key) {\n   return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n  } : KEY == 'get' ? function get(key) {\n   return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);\n  } : KEY == 'has' ? function has(key) {\n   return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);\n  } : function set(key, value) {\n   nativeMethod.call(this, key === 0 ? 0 : key, value);\n   return this;\n  });\n };\n if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {\n   new NativeConstructor().entries().next();\n  })))) {\n  Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);\n  InternalMetadataModule.REQUIRED = true;\n } else if (isForced(CONSTRUCTOR_NAME, true)) {\n  var instance = new Constructor();\n  var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;\n  var THROWS_ON_PRIMITIVES = fails(function () {\n   instance.has(1);\n  });\n  var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) {\n   new NativeConstructor(iterable);\n  });\n  var BUGGY_ZERO = !IS_WEAK && fails(function () {\n   var $instance = new NativeConstructor();\n   var index = 5;\n   while (index--)\n    $instance[ADDER](index, index);\n   return !$instance.has(-0);\n  });\n  if (!ACCEPT_ITERABLES) {\n   Constructor = wrapper(function (dummy, iterable) {\n    anInstance(dummy, Constructor, CONSTRUCTOR_NAME);\n    var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);\n    if (iterable != undefined)\n     iterate(iterable, that[ADDER], that, IS_MAP);\n    return that;\n   });\n   Constructor.prototype = NativePrototype;\n   NativePrototype.constructor = Constructor;\n  }\n  if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {\n   fixMethod('delete');\n   fixMethod('has');\n   IS_MAP && fixMethod('get');\n  }\n  if (BUGGY_ZERO || HASNT_CHAINING)\n   fixMethod(ADDER);\n  if (IS_WEAK && NativePrototype.clear)\n   delete NativePrototype.clear;\n }\n exported[CONSTRUCTOR_NAME] = Constructor;\n $({\n  global: true,\n  forced: Constructor != NativeConstructor\n }, exported);\n setToStringTag(Constructor, CONSTRUCTOR_NAME);\n if (!IS_WEAK)\n  common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);\n return Constructor;\n};\n\n/***/ }),\n/* 149 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar hiddenKeys = __w_pdfjs_require__(39);\nvar isObject = __w_pdfjs_require__(22);\nvar has = __w_pdfjs_require__(23);\nvar defineProperty = __w_pdfjs_require__(27).f;\nvar uid = __w_pdfjs_require__(38);\nvar FREEZING = __w_pdfjs_require__(150);\nvar METADATA = uid('meta');\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n return true;\n};\nvar setMetadata = function (it) {\n defineProperty(it, METADATA, {\n  value: {\n   objectID: 'O' + ++id,\n   weakData: {}\n  }\n });\n};\nvar fastKey = function (it, create) {\n if (!isObject(it))\n  return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n if (!has(it, METADATA)) {\n  if (!isExtensible(it))\n   return 'F';\n  if (!create)\n   return 'E';\n  setMetadata(it);\n }\n return it[METADATA].objectID;\n};\nvar getWeakData = function (it, create) {\n if (!has(it, METADATA)) {\n  if (!isExtensible(it))\n   return true;\n  if (!create)\n   return false;\n  setMetadata(it);\n }\n return it[METADATA].weakData;\n};\nvar onFreeze = function (it) {\n if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA))\n  setMetadata(it);\n return it;\n};\nvar meta = module.exports = {\n REQUIRED: false,\n fastKey: fastKey,\n getWeakData: getWeakData,\n onFreeze: onFreeze\n};\nhiddenKeys[METADATA] = true;\n\n/***/ }),\n/* 150 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(14);\nmodule.exports = !fails(function () {\n return Object.isExtensible(Object.preventExtensions({}));\n});\n\n/***/ }),\n/* 151 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(22);\nvar setPrototypeOf = __w_pdfjs_require__(87);\nmodule.exports = function ($this, dummy, Wrapper) {\n var NewTarget, NewTargetPrototype;\n if (setPrototypeOf && typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)\n  setPrototypeOf($this, NewTargetPrototype);\n return $this;\n};\n\n/***/ }),\n/* 152 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar defineProperty = __w_pdfjs_require__(27).f;\nvar create = __w_pdfjs_require__(71);\nvar redefineAll = __w_pdfjs_require__(124);\nvar bind = __w_pdfjs_require__(62);\nvar anInstance = __w_pdfjs_require__(126);\nvar iterate = __w_pdfjs_require__(104);\nvar defineIterator = __w_pdfjs_require__(79);\nvar setSpecies = __w_pdfjs_require__(125);\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar fastKey = __w_pdfjs_require__(149).fastKey;\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\nmodule.exports = {\n getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n  var C = wrapper(function (that, iterable) {\n   anInstance(that, C, CONSTRUCTOR_NAME);\n   setInternalState(that, {\n    type: CONSTRUCTOR_NAME,\n    index: create(null),\n    first: undefined,\n    last: undefined,\n    size: 0\n   });\n   if (!DESCRIPTORS)\n    that.size = 0;\n   if (iterable != undefined)\n    iterate(iterable, that[ADDER], that, IS_MAP);\n  });\n  var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n  var define = function (that, key, value) {\n   var state = getInternalState(that);\n   var entry = getEntry(that, key);\n   var previous, index;\n   if (entry) {\n    entry.value = value;\n   } else {\n    state.last = entry = {\n     index: index = fastKey(key, true),\n     key: key,\n     value: value,\n     previous: previous = state.last,\n     next: undefined,\n     removed: false\n    };\n    if (!state.first)\n     state.first = entry;\n    if (previous)\n     previous.next = entry;\n    if (DESCRIPTORS)\n     state.size++;\n    else\n     that.size++;\n    if (index !== 'F')\n     state.index[index] = entry;\n   }\n   return that;\n  };\n  var getEntry = function (that, key) {\n   var state = getInternalState(that);\n   var index = fastKey(key);\n   var entry;\n   if (index !== 'F')\n    return state.index[index];\n   for (entry = state.first; entry; entry = entry.next) {\n    if (entry.key == key)\n     return entry;\n   }\n  };\n  redefineAll(C.prototype, {\n   clear: function clear() {\n    var that = this;\n    var state = getInternalState(that);\n    var data = state.index;\n    var entry = state.first;\n    while (entry) {\n     entry.removed = true;\n     if (entry.previous)\n      entry.previous = entry.previous.next = undefined;\n     delete data[entry.index];\n     entry = entry.next;\n    }\n    state.first = state.last = undefined;\n    if (DESCRIPTORS)\n     state.size = 0;\n    else\n     that.size = 0;\n   },\n   'delete': function (key) {\n    var that = this;\n    var state = getInternalState(that);\n    var entry = getEntry(that, key);\n    if (entry) {\n     var next = entry.next;\n     var prev = entry.previous;\n     delete state.index[entry.index];\n     entry.removed = true;\n     if (prev)\n      prev.next = next;\n     if (next)\n      next.previous = prev;\n     if (state.first == entry)\n      state.first = next;\n     if (state.last == entry)\n      state.last = prev;\n     if (DESCRIPTORS)\n      state.size--;\n     else\n      that.size--;\n    }\n    return !!entry;\n   },\n   forEach: function forEach(callbackfn) {\n    var state = getInternalState(this);\n    var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);\n    var entry;\n    while (entry = entry ? entry.next : state.first) {\n     boundFunction(entry.value, entry.key, this);\n     while (entry && entry.removed)\n      entry = entry.previous;\n    }\n   },\n   has: function has(key) {\n    return !!getEntry(this, key);\n   }\n  });\n  redefineAll(C.prototype, IS_MAP ? {\n   get: function get(key) {\n    var entry = getEntry(this, key);\n    return entry && entry.value;\n   },\n   set: function set(key, value) {\n    return define(this, key === 0 ? 0 : key, value);\n   }\n  } : {\n   add: function add(value) {\n    return define(this, value = value === 0 ? 0 : value, value);\n   }\n  });\n  if (DESCRIPTORS)\n   defineProperty(C.prototype, 'size', {\n    get: function () {\n     return getInternalState(this).size;\n    }\n   });\n  return C;\n },\n setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {\n  var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';\n  var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);\n  var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);\n  defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {\n   setInternalState(this, {\n    type: ITERATOR_NAME,\n    target: iterated,\n    state: getInternalCollectionState(iterated),\n    kind: kind,\n    last: undefined\n   });\n  }, function () {\n   var state = getInternalIteratorState(this);\n   var kind = state.kind;\n   var entry = state.last;\n   while (entry && entry.removed)\n    entry = entry.previous;\n   if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {\n    state.target = undefined;\n    return {\n     value: undefined,\n     done: true\n    };\n   }\n   if (kind == 'keys')\n    return {\n     value: entry.key,\n     done: false\n    };\n   if (kind == 'values')\n    return {\n     value: entry.value,\n     done: false\n    };\n   return {\n    value: [\n     entry.key,\n     entry.value\n    ],\n    done: false\n   };\n  }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);\n  setSpecies(CONSTRUCTOR_NAME);\n }\n};\n\n/***/ }),\n/* 153 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(154);\n__w_pdfjs_require__(118);\n__w_pdfjs_require__(77);\n__w_pdfjs_require__(120);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Set;\n\n/***/ }),\n/* 154 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar collection = __w_pdfjs_require__(148);\nvar collectionStrong = __w_pdfjs_require__(152);\nmodule.exports = collection('Set', function (init) {\n return function Set() {\n  return init(this, arguments.length ? arguments[0] : undefined);\n };\n}, collectionStrong);\n\n/***/ }),\n/* 155 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(118);\n__w_pdfjs_require__(156);\n__w_pdfjs_require__(120);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.WeakMap;\n\n/***/ }),\n/* 156 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar global = __w_pdfjs_require__(11);\nvar redefineAll = __w_pdfjs_require__(124);\nvar InternalMetadataModule = __w_pdfjs_require__(149);\nvar collection = __w_pdfjs_require__(148);\nvar collectionWeak = __w_pdfjs_require__(157);\nvar isObject = __w_pdfjs_require__(22);\nvar enforceIternalState = __w_pdfjs_require__(33).enforce;\nvar NATIVE_WEAK_MAP = __w_pdfjs_require__(34);\nvar IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;\nvar isExtensible = Object.isExtensible;\nvar InternalWeakMap;\nvar wrapper = function (init) {\n return function WeakMap() {\n  return init(this, arguments.length ? arguments[0] : undefined);\n };\n};\nvar $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);\nif (NATIVE_WEAK_MAP && IS_IE11) {\n InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);\n InternalMetadataModule.REQUIRED = true;\n var WeakMapPrototype = $WeakMap.prototype;\n var nativeDelete = WeakMapPrototype['delete'];\n var nativeHas = WeakMapPrototype.has;\n var nativeGet = WeakMapPrototype.get;\n var nativeSet = WeakMapPrototype.set;\n redefineAll(WeakMapPrototype, {\n  'delete': function (key) {\n   if (isObject(key) && !isExtensible(key)) {\n    var state = enforceIternalState(this);\n    if (!state.frozen)\n     state.frozen = new InternalWeakMap();\n    return nativeDelete.call(this, key) || state.frozen['delete'](key);\n   }\n   return nativeDelete.call(this, key);\n  },\n  has: function has(key) {\n   if (isObject(key) && !isExtensible(key)) {\n    var state = enforceIternalState(this);\n    if (!state.frozen)\n     state.frozen = new InternalWeakMap();\n    return nativeHas.call(this, key) || state.frozen.has(key);\n   }\n   return nativeHas.call(this, key);\n  },\n  get: function get(key) {\n   if (isObject(key) && !isExtensible(key)) {\n    var state = enforceIternalState(this);\n    if (!state.frozen)\n     state.frozen = new InternalWeakMap();\n    return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);\n   }\n   return nativeGet.call(this, key);\n  },\n  set: function set(key, value) {\n   if (isObject(key) && !isExtensible(key)) {\n    var state = enforceIternalState(this);\n    if (!state.frozen)\n     state.frozen = new InternalWeakMap();\n    nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);\n   } else\n    nativeSet.call(this, key, value);\n   return this;\n  }\n });\n}\n\n/***/ }),\n/* 157 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar redefineAll = __w_pdfjs_require__(124);\nvar getWeakData = __w_pdfjs_require__(149).getWeakData;\nvar anObject = __w_pdfjs_require__(28);\nvar isObject = __w_pdfjs_require__(22);\nvar anInstance = __w_pdfjs_require__(126);\nvar iterate = __w_pdfjs_require__(104);\nvar ArrayIterationModule = __w_pdfjs_require__(158);\nvar $has = __w_pdfjs_require__(23);\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar setInternalState = InternalStateModule.set;\nvar internalStateGetterFor = InternalStateModule.getterFor;\nvar find = ArrayIterationModule.find;\nvar findIndex = ArrayIterationModule.findIndex;\nvar id = 0;\nvar uncaughtFrozenStore = function (store) {\n return store.frozen || (store.frozen = new UncaughtFrozenStore());\n};\nvar UncaughtFrozenStore = function () {\n this.entries = [];\n};\nvar findUncaughtFrozen = function (store, key) {\n return find(store.entries, function (it) {\n  return it[0] === key;\n });\n};\nUncaughtFrozenStore.prototype = {\n get: function (key) {\n  var entry = findUncaughtFrozen(this, key);\n  if (entry)\n   return entry[1];\n },\n has: function (key) {\n  return !!findUncaughtFrozen(this, key);\n },\n set: function (key, value) {\n  var entry = findUncaughtFrozen(this, key);\n  if (entry)\n   entry[1] = value;\n  else\n   this.entries.push([\n    key,\n    value\n   ]);\n },\n 'delete': function (key) {\n  var index = findIndex(this.entries, function (it) {\n   return it[0] === key;\n  });\n  if (~index)\n   this.entries.splice(index, 1);\n  return !!~index;\n }\n};\nmodule.exports = {\n getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {\n  var C = wrapper(function (that, iterable) {\n   anInstance(that, C, CONSTRUCTOR_NAME);\n   setInternalState(that, {\n    type: CONSTRUCTOR_NAME,\n    id: id++,\n    frozen: undefined\n   });\n   if (iterable != undefined)\n    iterate(iterable, that[ADDER], that, IS_MAP);\n  });\n  var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);\n  var define = function (that, key, value) {\n   var state = getInternalState(that);\n   var data = getWeakData(anObject(key), true);\n   if (data === true)\n    uncaughtFrozenStore(state).set(key, value);\n   else\n    data[state.id] = value;\n   return that;\n  };\n  redefineAll(C.prototype, {\n   'delete': function (key) {\n    var state = getInternalState(this);\n    if (!isObject(key))\n     return false;\n    var data = getWeakData(key);\n    if (data === true)\n     return uncaughtFrozenStore(state)['delete'](key);\n    return data && $has(data, state.id) && delete data[state.id];\n   },\n   has: function has(key) {\n    var state = getInternalState(this);\n    if (!isObject(key))\n     return false;\n    var data = getWeakData(key);\n    if (data === true)\n     return uncaughtFrozenStore(state).has(key);\n    return data && $has(data, state.id);\n   }\n  });\n  redefineAll(C.prototype, IS_MAP ? {\n   get: function get(key) {\n    var state = getInternalState(this);\n    if (isObject(key)) {\n     var data = getWeakData(key);\n     if (data === true)\n      return uncaughtFrozenStore(state).get(key);\n     return data ? data[state.id] : undefined;\n    }\n   },\n   set: function set(key, value) {\n    return define(this, key, value);\n   }\n  } : {\n   add: function add(value) {\n    return define(this, value, true);\n   }\n  });\n  return C;\n }\n};\n\n/***/ }),\n/* 158 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar bind = __w_pdfjs_require__(62);\nvar IndexedObject = __w_pdfjs_require__(18);\nvar toObject = __w_pdfjs_require__(83);\nvar toLength = __w_pdfjs_require__(47);\nvar arraySpeciesCreate = __w_pdfjs_require__(159);\nvar push = [].push;\nvar createMethod = function (TYPE) {\n var IS_MAP = TYPE == 1;\n var IS_FILTER = TYPE == 2;\n var IS_SOME = TYPE == 3;\n var IS_EVERY = TYPE == 4;\n var IS_FIND_INDEX = TYPE == 6;\n var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n return function ($this, callbackfn, that, specificCreate) {\n  var O = toObject($this);\n  var self = IndexedObject(O);\n  var boundFunction = bind(callbackfn, that, 3);\n  var length = toLength(self.length);\n  var index = 0;\n  var create = specificCreate || arraySpeciesCreate;\n  var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n  var value, result;\n  for (; length > index; index++)\n   if (NO_HOLES || index in self) {\n    value = self[index];\n    result = boundFunction(value, index, O);\n    if (TYPE) {\n     if (IS_MAP)\n      target[index] = result;\n     else if (result)\n      switch (TYPE) {\n      case 3:\n       return true;\n      case 5:\n       return value;\n      case 6:\n       return index;\n      case 2:\n       push.call(target, value);\n      }\n     else if (IS_EVERY)\n      return false;\n    }\n   }\n  return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;\n };\n};\nmodule.exports = {\n forEach: createMethod(0),\n map: createMethod(1),\n filter: createMethod(2),\n some: createMethod(3),\n every: createMethod(4),\n find: createMethod(5),\n findIndex: createMethod(6)\n};\n\n/***/ }),\n/* 159 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar isObject = __w_pdfjs_require__(22);\nvar isArray = __w_pdfjs_require__(160);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar SPECIES = wellKnownSymbol('species');\nmodule.exports = function (originalArray, length) {\n var C;\n if (isArray(originalArray)) {\n  C = originalArray.constructor;\n  if (typeof C == 'function' && (C === Array || isArray(C.prototype)))\n   C = undefined;\n  else if (isObject(C)) {\n   C = C[SPECIES];\n   if (C === null)\n    C = undefined;\n  }\n }\n return new (C === undefined ? Array : C)(length === 0 ? 0 : length);\n};\n\n/***/ }),\n/* 160 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar classof = __w_pdfjs_require__(19);\nmodule.exports = Array.isArray || function isArray(arg) {\n return classof(arg) == 'Array';\n};\n\n/***/ }),\n/* 161 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(118);\n__w_pdfjs_require__(162);\n__w_pdfjs_require__(120);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.WeakSet;\n\n/***/ }),\n/* 162 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar collection = __w_pdfjs_require__(148);\nvar collectionWeak = __w_pdfjs_require__(157);\ncollection('WeakSet', function (init) {\n return function WeakSet() {\n  return init(this, arguments.length ? arguments[0] : undefined);\n };\n}, collectionWeak);\n\n/***/ }),\n/* 163 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(164);\nvar entryUnbind = __w_pdfjs_require__(61);\nmodule.exports = entryUnbind('String', 'codePointAt');\n\n/***/ }),\n/* 164 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar codeAt = __w_pdfjs_require__(78).codeAt;\n$({\n target: 'String',\n proto: true\n}, {\n codePointAt: function codePointAt(pos) {\n  return codeAt(this, pos);\n }\n});\n\n/***/ }),\n/* 165 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(166);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.String.fromCodePoint;\n\n/***/ }),\n/* 166 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar toAbsoluteIndex = __w_pdfjs_require__(49);\nvar fromCharCode = String.fromCharCode;\nvar nativeFromCodePoint = String.fromCodePoint;\nvar INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;\n$({\n target: 'String',\n stat: true,\n forced: INCORRECT_LENGTH\n}, {\n fromCodePoint: function fromCodePoint(x) {\n  var elements = [];\n  var length = arguments.length;\n  var i = 0;\n  var code;\n  while (length > i) {\n   code = +arguments[i++];\n   if (toAbsoluteIndex(code, 0x10FFFF) !== code)\n    throw RangeError(code + ' is not a valid code point');\n   elements.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00));\n  }\n  return elements.join('');\n }\n});\n\n/***/ }),\n/* 167 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(168);\n__w_pdfjs_require__(118);\n__w_pdfjs_require__(170);\n__w_pdfjs_require__(174);\n__w_pdfjs_require__(175);\n__w_pdfjs_require__(176);\n__w_pdfjs_require__(177);\n__w_pdfjs_require__(178);\n__w_pdfjs_require__(179);\n__w_pdfjs_require__(180);\n__w_pdfjs_require__(181);\n__w_pdfjs_require__(182);\n__w_pdfjs_require__(183);\n__w_pdfjs_require__(184);\n__w_pdfjs_require__(185);\n__w_pdfjs_require__(186);\n__w_pdfjs_require__(187);\n__w_pdfjs_require__(188);\n__w_pdfjs_require__(189);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Symbol;\n\n/***/ }),\n/* 168 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar fails = __w_pdfjs_require__(14);\nvar isArray = __w_pdfjs_require__(160);\nvar isObject = __w_pdfjs_require__(22);\nvar toObject = __w_pdfjs_require__(83);\nvar toLength = __w_pdfjs_require__(47);\nvar createProperty = __w_pdfjs_require__(93);\nvar arraySpeciesCreate = __w_pdfjs_require__(159);\nvar arrayMethodHasSpeciesSupport = __w_pdfjs_require__(169);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar V8_VERSION = __w_pdfjs_require__(135);\nvar IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nvar MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';\nvar IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {\n var array = [];\n array[IS_CONCAT_SPREADABLE] = false;\n return array.concat()[0] !== array;\n});\nvar SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');\nvar isConcatSpreadable = function (O) {\n if (!isObject(O))\n  return false;\n var spreadable = O[IS_CONCAT_SPREADABLE];\n return spreadable !== undefined ? !!spreadable : isArray(O);\n};\nvar FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;\n$({\n target: 'Array',\n proto: true,\n forced: FORCED\n}, {\n concat: function concat(arg) {\n  var O = toObject(this);\n  var A = arraySpeciesCreate(O, 0);\n  var n = 0;\n  var i, k, length, len, E;\n  for (i = -1, length = arguments.length; i < length; i++) {\n   E = i === -1 ? O : arguments[i];\n   if (isConcatSpreadable(E)) {\n    len = toLength(E.length);\n    if (n + len > MAX_SAFE_INTEGER)\n     throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n    for (k = 0; k < len; k++, n++)\n     if (k in E)\n      createProperty(A, n, E[k]);\n   } else {\n    if (n >= MAX_SAFE_INTEGER)\n     throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);\n    createProperty(A, n++, E);\n   }\n  }\n  A.length = n;\n  return A;\n }\n});\n\n/***/ }),\n/* 169 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar fails = __w_pdfjs_require__(14);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar V8_VERSION = __w_pdfjs_require__(135);\nvar SPECIES = wellKnownSymbol('species');\nmodule.exports = function (METHOD_NAME) {\n return V8_VERSION >= 51 || !fails(function () {\n  var array = [];\n  var constructor = array.constructor = {};\n  constructor[SPECIES] = function () {\n   return { foo: 1 };\n  };\n  return array[METHOD_NAME](Boolean).foo !== 1;\n });\n};\n\n/***/ }),\n/* 170 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar global = __w_pdfjs_require__(11);\nvar getBuiltIn = __w_pdfjs_require__(42);\nvar IS_PURE = __w_pdfjs_require__(37);\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar NATIVE_SYMBOL = __w_pdfjs_require__(58);\nvar USE_SYMBOL_AS_UID = __w_pdfjs_require__(59);\nvar fails = __w_pdfjs_require__(14);\nvar has = __w_pdfjs_require__(23);\nvar isArray = __w_pdfjs_require__(160);\nvar isObject = __w_pdfjs_require__(22);\nvar anObject = __w_pdfjs_require__(28);\nvar toObject = __w_pdfjs_require__(83);\nvar toIndexedObject = __w_pdfjs_require__(17);\nvar toPrimitive = __w_pdfjs_require__(21);\nvar createPropertyDescriptor = __w_pdfjs_require__(16);\nvar nativeObjectCreate = __w_pdfjs_require__(71);\nvar objectKeys = __w_pdfjs_require__(73);\nvar getOwnPropertyNamesModule = __w_pdfjs_require__(44);\nvar getOwnPropertyNamesExternal = __w_pdfjs_require__(171);\nvar getOwnPropertySymbolsModule = __w_pdfjs_require__(51);\nvar getOwnPropertyDescriptorModule = __w_pdfjs_require__(12);\nvar definePropertyModule = __w_pdfjs_require__(27);\nvar propertyIsEnumerableModule = __w_pdfjs_require__(15);\nvar createNonEnumerableProperty = __w_pdfjs_require__(26);\nvar redefine = __w_pdfjs_require__(29);\nvar shared = __w_pdfjs_require__(36);\nvar sharedKey = __w_pdfjs_require__(35);\nvar hiddenKeys = __w_pdfjs_require__(39);\nvar uid = __w_pdfjs_require__(38);\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nvar wrappedWellKnownSymbolModule = __w_pdfjs_require__(172);\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\nvar setToStringTag = __w_pdfjs_require__(85);\nvar InternalStateModule = __w_pdfjs_require__(33);\nvar $forEach = __w_pdfjs_require__(158).forEach;\nvar HIDDEN = sharedKey('hidden');\nvar SYMBOL = 'Symbol';\nvar PROTOTYPE = 'prototype';\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\nvar setInternalState = InternalStateModule.set;\nvar getInternalState = InternalStateModule.getterFor(SYMBOL);\nvar ObjectPrototype = Object[PROTOTYPE];\nvar $Symbol = global.Symbol;\nvar $stringify = getBuiltIn('JSON', 'stringify');\nvar nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\nvar nativeDefineProperty = definePropertyModule.f;\nvar nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;\nvar nativePropertyIsEnumerable = propertyIsEnumerableModule.f;\nvar AllSymbols = shared('symbols');\nvar ObjectPrototypeSymbols = shared('op-symbols');\nvar StringToSymbolRegistry = shared('string-to-symbol-registry');\nvar SymbolToStringRegistry = shared('symbol-to-string-registry');\nvar WellKnownSymbolsStore = shared('wks');\nvar QObject = global.QObject;\nvar USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\nvar setSymbolDescriptor = DESCRIPTORS && fails(function () {\n return nativeObjectCreate(nativeDefineProperty({}, 'a', {\n  get: function () {\n   return nativeDefineProperty(this, 'a', { value: 7 }).a;\n  }\n })).a != 7;\n}) ? function (O, P, Attributes) {\n var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);\n if (ObjectPrototypeDescriptor)\n  delete ObjectPrototype[P];\n nativeDefineProperty(O, P, Attributes);\n if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {\n  nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);\n }\n} : nativeDefineProperty;\nvar wrap = function (tag, description) {\n var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);\n setInternalState(symbol, {\n  type: SYMBOL,\n  tag: tag,\n  description: description\n });\n if (!DESCRIPTORS)\n  symbol.description = description;\n return symbol;\n};\nvar isSymbol = USE_SYMBOL_AS_UID ? function (it) {\n return typeof it == 'symbol';\n} : function (it) {\n return Object(it) instanceof $Symbol;\n};\nvar $defineProperty = function defineProperty(O, P, Attributes) {\n if (O === ObjectPrototype)\n  $defineProperty(ObjectPrototypeSymbols, P, Attributes);\n anObject(O);\n var key = toPrimitive(P, true);\n anObject(Attributes);\n if (has(AllSymbols, key)) {\n  if (!Attributes.enumerable) {\n   if (!has(O, HIDDEN))\n    nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));\n   O[HIDDEN][key] = true;\n  } else {\n   if (has(O, HIDDEN) && O[HIDDEN][key])\n    O[HIDDEN][key] = false;\n   Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });\n  }\n  return setSymbolDescriptor(O, key, Attributes);\n }\n return nativeDefineProperty(O, key, Attributes);\n};\nvar $defineProperties = function defineProperties(O, Properties) {\n anObject(O);\n var properties = toIndexedObject(Properties);\n var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));\n $forEach(keys, function (key) {\n  if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key))\n   $defineProperty(O, key, properties[key]);\n });\n return O;\n};\nvar $create = function create(O, Properties) {\n return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(V) {\n var P = toPrimitive(V, true);\n var enumerable = nativePropertyIsEnumerable.call(this, P);\n if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P))\n  return false;\n return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {\n var it = toIndexedObject(O);\n var key = toPrimitive(P, true);\n if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key))\n  return;\n var descriptor = nativeGetOwnPropertyDescriptor(it, key);\n if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {\n  descriptor.enumerable = true;\n }\n return descriptor;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(O) {\n var names = nativeGetOwnPropertyNames(toIndexedObject(O));\n var result = [];\n $forEach(names, function (key) {\n  if (!has(AllSymbols, key) && !has(hiddenKeys, key))\n   result.push(key);\n });\n return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(O) {\n var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;\n var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));\n var result = [];\n $forEach(names, function (key) {\n  if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {\n   result.push(AllSymbols[key]);\n  }\n });\n return result;\n};\nif (!NATIVE_SYMBOL) {\n $Symbol = function Symbol() {\n  if (this instanceof $Symbol)\n   throw TypeError('Symbol is not a constructor');\n  var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);\n  var tag = uid(description);\n  var setter = function (value) {\n   if (this === ObjectPrototype)\n    setter.call(ObjectPrototypeSymbols, value);\n   if (has(this, HIDDEN) && has(this[HIDDEN], tag))\n    this[HIDDEN][tag] = false;\n   setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));\n  };\n  if (DESCRIPTORS && USE_SETTER)\n   setSymbolDescriptor(ObjectPrototype, tag, {\n    configurable: true,\n    set: setter\n   });\n  return wrap(tag, description);\n };\n redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n  return getInternalState(this).tag;\n });\n redefine($Symbol, 'withoutSetter', function (description) {\n  return wrap(uid(description), description);\n });\n propertyIsEnumerableModule.f = $propertyIsEnumerable;\n definePropertyModule.f = $defineProperty;\n getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;\n getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;\n getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;\n wrappedWellKnownSymbolModule.f = function (name) {\n  return wrap(wellKnownSymbol(name), name);\n };\n if (DESCRIPTORS) {\n  nativeDefineProperty($Symbol[PROTOTYPE], 'description', {\n   configurable: true,\n   get: function description() {\n    return getInternalState(this).description;\n   }\n  });\n  if (!IS_PURE) {\n   redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });\n  }\n }\n}\n$({\n global: true,\n wrap: true,\n forced: !NATIVE_SYMBOL,\n sham: !NATIVE_SYMBOL\n}, { Symbol: $Symbol });\n$forEach(objectKeys(WellKnownSymbolsStore), function (name) {\n defineWellKnownSymbol(name);\n});\n$({\n target: SYMBOL,\n stat: true,\n forced: !NATIVE_SYMBOL\n}, {\n 'for': function (key) {\n  var string = String(key);\n  if (has(StringToSymbolRegistry, string))\n   return StringToSymbolRegistry[string];\n  var symbol = $Symbol(string);\n  StringToSymbolRegistry[string] = symbol;\n  SymbolToStringRegistry[symbol] = string;\n  return symbol;\n },\n keyFor: function keyFor(sym) {\n  if (!isSymbol(sym))\n   throw TypeError(sym + ' is not a symbol');\n  if (has(SymbolToStringRegistry, sym))\n   return SymbolToStringRegistry[sym];\n },\n useSetter: function () {\n  USE_SETTER = true;\n },\n useSimple: function () {\n  USE_SETTER = false;\n }\n});\n$({\n target: 'Object',\n stat: true,\n forced: !NATIVE_SYMBOL,\n sham: !DESCRIPTORS\n}, {\n create: $create,\n defineProperty: $defineProperty,\n defineProperties: $defineProperties,\n getOwnPropertyDescriptor: $getOwnPropertyDescriptor\n});\n$({\n target: 'Object',\n stat: true,\n forced: !NATIVE_SYMBOL\n}, {\n getOwnPropertyNames: $getOwnPropertyNames,\n getOwnPropertySymbols: $getOwnPropertySymbols\n});\n$({\n target: 'Object',\n stat: true,\n forced: fails(function () {\n  getOwnPropertySymbolsModule.f(1);\n })\n}, {\n getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n  return getOwnPropertySymbolsModule.f(toObject(it));\n }\n});\nif ($stringify) {\n var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {\n  var symbol = $Symbol();\n  return $stringify([symbol]) != '[null]' || $stringify({ a: symbol }) != '{}' || $stringify(Object(symbol)) != '{}';\n });\n $({\n  target: 'JSON',\n  stat: true,\n  forced: FORCED_JSON_STRINGIFY\n }, {\n  stringify: function stringify(it, replacer, space) {\n   var args = [it];\n   var index = 1;\n   var $replacer;\n   while (arguments.length > index)\n    args.push(arguments[index++]);\n   $replacer = replacer;\n   if (!isObject(replacer) && it === undefined || isSymbol(it))\n    return;\n   if (!isArray(replacer))\n    replacer = function (key, value) {\n     if (typeof $replacer == 'function')\n      value = $replacer.call(this, key, value);\n     if (!isSymbol(value))\n      return value;\n    };\n   args[1] = replacer;\n   return $stringify.apply(null, args);\n  }\n });\n}\nif (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {\n createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n}\nsetToStringTag($Symbol, SYMBOL);\nhiddenKeys[HIDDEN] = true;\n\n/***/ }),\n/* 171 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar toIndexedObject = __w_pdfjs_require__(17);\nvar nativeGetOwnPropertyNames = __w_pdfjs_require__(44).f;\nvar toString = {}.toString;\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];\nvar getWindowNames = function (it) {\n try {\n  return nativeGetOwnPropertyNames(it);\n } catch (error) {\n  return windowNames.slice();\n }\n};\nmodule.exports.f = function getOwnPropertyNames(it) {\n return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it));\n};\n\n/***/ }),\n/* 172 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar wellKnownSymbol = __w_pdfjs_require__(57);\nexports.f = wellKnownSymbol;\n\n/***/ }),\n/* 173 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar path = __w_pdfjs_require__(43);\nvar has = __w_pdfjs_require__(23);\nvar wrappedWellKnownSymbolModule = __w_pdfjs_require__(172);\nvar defineProperty = __w_pdfjs_require__(27).f;\nmodule.exports = function (NAME) {\n var Symbol = path.Symbol || (path.Symbol = {});\n if (!has(Symbol, NAME))\n  defineProperty(Symbol, NAME, { value: wrappedWellKnownSymbolModule.f(NAME) });\n};\n\n/***/ }),\n/* 174 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('asyncIterator');\n\n/***/ }),\n/* 175 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar global = __w_pdfjs_require__(11);\nvar has = __w_pdfjs_require__(23);\nvar isObject = __w_pdfjs_require__(22);\nvar defineProperty = __w_pdfjs_require__(27).f;\nvar copyConstructorProperties = __w_pdfjs_require__(40);\nvar NativeSymbol = global.Symbol;\nif (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || NativeSymbol().description !== undefined)) {\n var EmptyStringDescriptionStore = {};\n var SymbolWrapper = function Symbol() {\n  var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);\n  var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description);\n  if (description === '')\n   EmptyStringDescriptionStore[result] = true;\n  return result;\n };\n copyConstructorProperties(SymbolWrapper, NativeSymbol);\n var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;\n symbolPrototype.constructor = SymbolWrapper;\n var symbolToString = symbolPrototype.toString;\n var native = String(NativeSymbol('test')) == 'Symbol(test)';\n var regexp = /^Symbol\\((.*)\\)[^)]+$/;\n defineProperty(symbolPrototype, 'description', {\n  configurable: true,\n  get: function description() {\n   var symbol = isObject(this) ? this.valueOf() : this;\n   var string = symbolToString.call(symbol);\n   if (has(EmptyStringDescriptionStore, symbol))\n    return '';\n   var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');\n   return desc === '' ? undefined : desc;\n  }\n });\n $({\n  global: true,\n  forced: true\n }, { Symbol: SymbolWrapper });\n}\n\n/***/ }),\n/* 176 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('hasInstance');\n\n/***/ }),\n/* 177 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('isConcatSpreadable');\n\n/***/ }),\n/* 178 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('iterator');\n\n/***/ }),\n/* 179 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('match');\n\n/***/ }),\n/* 180 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('matchAll');\n\n/***/ }),\n/* 181 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('replace');\n\n/***/ }),\n/* 182 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('search');\n\n/***/ }),\n/* 183 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('species');\n\n/***/ }),\n/* 184 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('split');\n\n/***/ }),\n/* 185 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('toPrimitive');\n\n/***/ }),\n/* 186 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('toStringTag');\n\n/***/ }),\n/* 187 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar defineWellKnownSymbol = __w_pdfjs_require__(173);\ndefineWellKnownSymbol('unscopables');\n\n/***/ }),\n/* 188 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar setToStringTag = __w_pdfjs_require__(85);\nsetToStringTag(Math, 'Math', true);\n\n/***/ }),\n/* 189 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar global = __w_pdfjs_require__(11);\nvar setToStringTag = __w_pdfjs_require__(85);\nsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ }),\n/* 190 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(191);\nvar entryUnbind = __w_pdfjs_require__(61);\nmodule.exports = entryUnbind('String', 'padStart');\n\n/***/ }),\n/* 191 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar $padStart = __w_pdfjs_require__(192).start;\nvar WEBKIT_BUG = __w_pdfjs_require__(194);\n$({\n target: 'String',\n proto: true,\n forced: WEBKIT_BUG\n}, {\n padStart: function padStart(maxLength) {\n  return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);\n }\n});\n\n/***/ }),\n/* 192 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar toLength = __w_pdfjs_require__(47);\nvar repeat = __w_pdfjs_require__(193);\nvar requireObjectCoercible = __w_pdfjs_require__(20);\nvar ceil = Math.ceil;\nvar createMethod = function (IS_END) {\n return function ($this, maxLength, fillString) {\n  var S = String(requireObjectCoercible($this));\n  var stringLength = S.length;\n  var fillStr = fillString === undefined ? ' ' : String(fillString);\n  var intMaxLength = toLength(maxLength);\n  var fillLen, stringFiller;\n  if (intMaxLength <= stringLength || fillStr == '')\n   return S;\n  fillLen = intMaxLength - stringLength;\n  stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));\n  if (stringFiller.length > fillLen)\n   stringFiller = stringFiller.slice(0, fillLen);\n  return IS_END ? S + stringFiller : stringFiller + S;\n };\n};\nmodule.exports = {\n start: createMethod(false),\n end: createMethod(true)\n};\n\n/***/ }),\n/* 193 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar toInteger = __w_pdfjs_require__(48);\nvar requireObjectCoercible = __w_pdfjs_require__(20);\nmodule.exports = ''.repeat || function repeat(count) {\n var str = String(requireObjectCoercible(this));\n var result = '';\n var n = toInteger(count);\n if (n < 0 || n == Infinity)\n  throw RangeError('Wrong number of repetitions');\n for (; n > 0; (n >>>= 1) && (str += str))\n  if (n & 1)\n   result += str;\n return result;\n};\n\n/***/ }),\n/* 194 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar userAgent = __w_pdfjs_require__(129);\nmodule.exports = /Version\\/10\\.\\d+(\\.\\d+)?( Mobile\\/\\w+)? Safari\\//.test(userAgent);\n\n/***/ }),\n/* 195 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(196);\nvar entryUnbind = __w_pdfjs_require__(61);\nmodule.exports = entryUnbind('String', 'padEnd');\n\n/***/ }),\n/* 196 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\nvar $ = __w_pdfjs_require__(10);\nvar $padEnd = __w_pdfjs_require__(192).end;\nvar WEBKIT_BUG = __w_pdfjs_require__(194);\n$({\n target: 'String',\n proto: true,\n forced: WEBKIT_BUG\n}, {\n padEnd: function padEnd(maxLength) {\n  return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);\n }\n});\n\n/***/ }),\n/* 197 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(198);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Object.values;\n\n/***/ }),\n/* 198 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar $values = __w_pdfjs_require__(199).values;\n$({\n target: 'Object',\n stat: true\n}, {\n values: function values(O) {\n  return $values(O);\n }\n});\n\n/***/ }),\n/* 199 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar DESCRIPTORS = __w_pdfjs_require__(13);\nvar objectKeys = __w_pdfjs_require__(73);\nvar toIndexedObject = __w_pdfjs_require__(17);\nvar propertyIsEnumerable = __w_pdfjs_require__(15).f;\nvar createMethod = function (TO_ENTRIES) {\n return function (it) {\n  var O = toIndexedObject(it);\n  var keys = objectKeys(O);\n  var length = keys.length;\n  var i = 0;\n  var result = [];\n  var key;\n  while (length > i) {\n   key = keys[i++];\n   if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {\n    result.push(TO_ENTRIES ? [\n     key,\n     O[key]\n    ] : O[key]);\n   }\n  }\n  return result;\n };\n};\nmodule.exports = {\n entries: createMethod(true),\n values: createMethod(false)\n};\n\n/***/ }),\n/* 200 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n__w_pdfjs_require__(201);\nvar path = __w_pdfjs_require__(43);\nmodule.exports = path.Object.entries;\n\n/***/ }),\n/* 201 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\nvar $ = __w_pdfjs_require__(10);\nvar $entries = __w_pdfjs_require__(199).entries;\n$({\n target: 'Object',\n stat: true\n}, {\n entries: function entries(O) {\n  return $entries(O);\n }\n});\n\n/***/ }),\n/* 202 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getDocument = getDocument;\nexports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory;\nexports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _font_loader = __w_pdfjs_require__(203);\n\nvar _node_utils = __w_pdfjs_require__(204);\n\nvar _annotation_storage = __w_pdfjs_require__(205);\n\nvar _api_compatibility = __w_pdfjs_require__(206);\n\nvar _canvas = __w_pdfjs_require__(207);\n\nvar _worker_options = __w_pdfjs_require__(209);\n\nvar _is_node = __w_pdfjs_require__(7);\n\nvar _message_handler = __w_pdfjs_require__(210);\n\nvar _metadata = __w_pdfjs_require__(211);\n\nvar _optional_content_config = __w_pdfjs_require__(213);\n\nvar _transport_stream = __w_pdfjs_require__(214);\n\nvar _webgl = __w_pdfjs_require__(215);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar DEFAULT_RANGE_CHUNK_SIZE = 65536;\nvar RENDERING_CANCELLED_TIMEOUT = 100;\nvar DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\nvar DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\nvar createPDFNetworkStream;\n\nfunction setPDFNetworkStreamFactory(pdfNetworkStreamFactory) {\n  createPDFNetworkStream = pdfNetworkStreamFactory;\n}\n\nfunction getDocument(src) {\n  var task = new PDFDocumentLoadingTask();\n  var source;\n\n  if (typeof src === \"string\") {\n    source = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    source = {\n      data: src\n    };\n  } else if (src instanceof PDFDataRangeTransport) {\n    source = {\n      range: src\n    };\n  } else {\n    if (_typeof(src) !== \"object\") {\n      throw new Error(\"Invalid parameter in getDocument, \" + \"need either Uint8Array, string or a parameter object\");\n    }\n\n    if (!src.url && !src.data && !src.range) {\n      throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n    }\n\n    source = src;\n  }\n\n  var params = Object.create(null);\n  var rangeTransport = null,\n      worker = null;\n\n  for (var key in source) {\n    if (key === \"url\" && typeof window !== \"undefined\") {\n      params[key] = new URL(source[key], window.location).href;\n      continue;\n    } else if (key === \"range\") {\n      rangeTransport = source[key];\n      continue;\n    } else if (key === \"worker\") {\n      worker = source[key];\n      continue;\n    } else if (key === \"data\" && !(source[key] instanceof Uint8Array)) {\n      var pdfBytes = source[key];\n\n      if (typeof pdfBytes === \"string\") {\n        params[key] = (0, _util.stringToBytes)(pdfBytes);\n      } else if (_typeof(pdfBytes) === \"object\" && pdfBytes !== null && !isNaN(pdfBytes.length)) {\n        params[key] = new Uint8Array(pdfBytes);\n      } else if ((0, _util.isArrayBuffer)(pdfBytes)) {\n        params[key] = new Uint8Array(pdfBytes);\n      } else {\n        throw new Error(\"Invalid PDF binary data: either typed array, \" + \"string or array-like object is expected in the \" + \"data property.\");\n      }\n\n      continue;\n    }\n\n    params[key] = source[key];\n  }\n\n  params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE;\n  params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory;\n  params.ignoreErrors = params.stopAtErrors !== true;\n  params.fontExtraProperties = params.fontExtraProperties === true;\n  params.pdfBug = params.pdfBug === true;\n\n  if (!Number.isInteger(params.maxImageSize)) {\n    params.maxImageSize = -1;\n  }\n\n  if (typeof params.isEvalSupported !== \"boolean\") {\n    params.isEvalSupported = true;\n  }\n\n  if (typeof params.disableFontFace !== \"boolean\") {\n    params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false;\n  }\n\n  if (typeof params.ownerDocument === \"undefined\") {\n    params.ownerDocument = globalThis.document;\n  }\n\n  if (typeof params.disableRange !== \"boolean\") {\n    params.disableRange = false;\n  }\n\n  if (typeof params.disableStream !== \"boolean\") {\n    params.disableStream = false;\n  }\n\n  if (typeof params.disableAutoFetch !== \"boolean\") {\n    params.disableAutoFetch = false;\n  }\n\n  (0, _util.setVerbosityLevel)(params.verbosity);\n\n  if (!worker) {\n    var workerParams = {\n      verbosity: params.verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n\n  var docId = task.docId;\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n\n    var workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId);\n\n    var networkStreamPromise = new Promise(function (resolve) {\n      var networkStream;\n\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length: params.length,\n          initialData: params.initialData,\n          progressiveDone: params.progressiveDone,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        }, rangeTransport);\n      } else if (!params.data) {\n        networkStream = createPDFNetworkStream({\n          url: params.url,\n          length: params.length,\n          httpHeaders: params.httpHeaders,\n          withCredentials: params.withCredentials,\n          rangeChunkSize: params.rangeChunkSize,\n          disableRange: params.disableRange,\n          disableStream: params.disableStream\n        });\n      }\n\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          workerId = _ref2[0],\n          networkStream = _ref2[1];\n\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n\n      var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      messageHandler.postMessageTransfers = worker.postMessageTransfers;\n      var transport = new WorkerTransport(messageHandler, task, networkStream, params);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  })[\"catch\"](task._capability.reject);\n  return task;\n}\n\nfunction _fetchDocument(worker, source, pdfDataRangeTransport, docId) {\n  if (worker.destroyed) {\n    return Promise.reject(new Error(\"Worker was destroyed\"));\n  }\n\n  if (pdfDataRangeTransport) {\n    source.length = pdfDataRangeTransport.length;\n    source.initialData = pdfDataRangeTransport.initialData;\n    source.progressiveDone = pdfDataRangeTransport.progressiveDone;\n  }\n\n  return worker.messageHandler.sendWithPromise(\"GetDocRequest\", {\n    docId: docId,\n    apiVersion: '2.6.347',\n    source: {\n      data: source.data,\n      url: source.url,\n      password: source.password,\n      disableAutoFetch: source.disableAutoFetch,\n      rangeChunkSize: source.rangeChunkSize,\n      length: source.length\n    },\n    maxImageSize: source.maxImageSize,\n    disableFontFace: source.disableFontFace,\n    postMessageTransfers: worker.postMessageTransfers,\n    docBaseUrl: source.docBaseUrl,\n    ignoreErrors: source.ignoreErrors,\n    isEvalSupported: source.isEvalSupported,\n    fontExtraProperties: source.fontExtraProperties\n  }).then(function (workerId) {\n    if (worker.destroyed) {\n      throw new Error(\"Worker was destroyed\");\n    }\n\n    return workerId;\n  });\n}\n\nvar PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() {\n  var nextDocumentId = 0;\n\n  var PDFDocumentLoadingTask = /*#__PURE__*/function () {\n    function PDFDocumentLoadingTask() {\n      _classCallCheck(this, PDFDocumentLoadingTask);\n\n      this._capability = (0, _util.createPromiseCapability)();\n      this._transport = null;\n      this._worker = null;\n      this.docId = \"d\" + nextDocumentId++;\n      this.destroyed = false;\n      this.onPassword = null;\n      this.onProgress = null;\n      this.onUnsupportedFeature = null;\n    }\n\n    _createClass(PDFDocumentLoadingTask, [{\n      key: \"destroy\",\n      value: function destroy() {\n        var _this = this;\n\n        this.destroyed = true;\n        var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy();\n        return transportDestroyed.then(function () {\n          _this._transport = null;\n\n          if (_this._worker) {\n            _this._worker.destroy();\n\n            _this._worker = null;\n          }\n        });\n      }\n    }, {\n      key: \"promise\",\n      get: function get() {\n        return this._capability.promise;\n      }\n    }]);\n\n    return PDFDocumentLoadingTask;\n  }();\n\n  return PDFDocumentLoadingTask;\n}();\n\nvar PDFDataRangeTransport = /*#__PURE__*/function () {\n  function PDFDataRangeTransport(length, initialData) {\n    var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, PDFDataRangeTransport);\n\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = (0, _util.createPromiseCapability)();\n  }\n\n  _createClass(PDFDataRangeTransport, [{\n    key: \"addRangeListener\",\n    value: function addRangeListener(listener) {\n      this._rangeListeners.push(listener);\n    }\n  }, {\n    key: \"addProgressListener\",\n    value: function addProgressListener(listener) {\n      this._progressListeners.push(listener);\n    }\n  }, {\n    key: \"addProgressiveReadListener\",\n    value: function addProgressiveReadListener(listener) {\n      this._progressiveReadListeners.push(listener);\n    }\n  }, {\n    key: \"addProgressiveDoneListener\",\n    value: function addProgressiveDoneListener(listener) {\n      this._progressiveDoneListeners.push(listener);\n    }\n  }, {\n    key: \"onDataRange\",\n    value: function onDataRange(begin, chunk) {\n      var _iterator = _createForOfIteratorHelper(this._rangeListeners),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var listener = _step.value;\n          listener(begin, chunk);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"onDataProgress\",\n    value: function onDataProgress(loaded, total) {\n      var _this2 = this;\n\n      this._readyCapability.promise.then(function () {\n        var _iterator2 = _createForOfIteratorHelper(_this2._progressListeners),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var listener = _step2.value;\n            listener(loaded, total);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      });\n    }\n  }, {\n    key: \"onDataProgressiveRead\",\n    value: function onDataProgressiveRead(chunk) {\n      var _this3 = this;\n\n      this._readyCapability.promise.then(function () {\n        var _iterator3 = _createForOfIteratorHelper(_this3._progressiveReadListeners),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var listener = _step3.value;\n            listener(chunk);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      });\n    }\n  }, {\n    key: \"onDataProgressiveDone\",\n    value: function onDataProgressiveDone() {\n      var _this4 = this;\n\n      this._readyCapability.promise.then(function () {\n        var _iterator4 = _createForOfIteratorHelper(_this4._progressiveDoneListeners),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var listener = _step4.value;\n            listener();\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      });\n    }\n  }, {\n    key: \"transportReady\",\n    value: function transportReady() {\n      this._readyCapability.resolve();\n    }\n  }, {\n    key: \"requestDataRange\",\n    value: function requestDataRange(begin, end) {\n      (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n    }\n  }, {\n    key: \"abort\",\n    value: function abort() {}\n  }]);\n\n  return PDFDataRangeTransport;\n}();\n\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\n\nvar PDFDocumentProxy = /*#__PURE__*/function () {\n  function PDFDocumentProxy(pdfInfo, transport) {\n    _classCallCheck(this, PDFDocumentProxy);\n\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n  }\n\n  _createClass(PDFDocumentProxy, [{\n    key: \"getPage\",\n    value: function getPage(pageNumber) {\n      return this._transport.getPage(pageNumber);\n    }\n  }, {\n    key: \"getPageIndex\",\n    value: function getPageIndex(ref) {\n      return this._transport.getPageIndex(ref);\n    }\n  }, {\n    key: \"getDestinations\",\n    value: function getDestinations() {\n      return this._transport.getDestinations();\n    }\n  }, {\n    key: \"getDestination\",\n    value: function getDestination(id) {\n      return this._transport.getDestination(id);\n    }\n  }, {\n    key: \"getPageLabels\",\n    value: function getPageLabels() {\n      return this._transport.getPageLabels();\n    }\n  }, {\n    key: \"getPageLayout\",\n    value: function getPageLayout() {\n      return this._transport.getPageLayout();\n    }\n  }, {\n    key: \"getPageMode\",\n    value: function getPageMode() {\n      return this._transport.getPageMode();\n    }\n  }, {\n    key: \"getViewerPreferences\",\n    value: function getViewerPreferences() {\n      return this._transport.getViewerPreferences();\n    }\n  }, {\n    key: \"getOpenAction\",\n    value: function getOpenAction() {\n      return this._transport.getOpenAction();\n    }\n  }, {\n    key: \"getAttachments\",\n    value: function getAttachments() {\n      return this._transport.getAttachments();\n    }\n  }, {\n    key: \"getJavaScript\",\n    value: function getJavaScript() {\n      return this._transport.getJavaScript();\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline() {\n      return this._transport.getOutline();\n    }\n  }, {\n    key: \"getOptionalContentConfig\",\n    value: function getOptionalContentConfig() {\n      return this._transport.getOptionalContentConfig();\n    }\n  }, {\n    key: \"getPermissions\",\n    value: function getPermissions() {\n      return this._transport.getPermissions();\n    }\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata() {\n      return this._transport.getMetadata();\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this._transport.getData();\n    }\n  }, {\n    key: \"getDownloadInfo\",\n    value: function getDownloadInfo() {\n      return this._transport.downloadInfoCapability.promise;\n    }\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return this._transport.getStats();\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      return this._transport.startCleanup();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      return this.loadingTask.destroy();\n    }\n  }, {\n    key: \"saveDocument\",\n    value: function saveDocument(annotationStorage) {\n      return this._transport.saveDocument(annotationStorage);\n    }\n  }, {\n    key: \"annotationStorage\",\n    get: function get() {\n      return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n    }\n  }, {\n    key: \"numPages\",\n    get: function get() {\n      return this._pdfInfo.numPages;\n    }\n  }, {\n    key: \"fingerprint\",\n    get: function get() {\n      return this._pdfInfo.fingerprint;\n    }\n  }, {\n    key: \"loadingParams\",\n    get: function get() {\n      return this._transport.loadingParams;\n    }\n  }, {\n    key: \"loadingTask\",\n    get: function get() {\n      return this._transport.loadingTask;\n    }\n  }]);\n\n  return PDFDocumentProxy;\n}();\n\nexports.PDFDocumentProxy = PDFDocumentProxy;\n\nvar PDFPageProxy = /*#__PURE__*/function () {\n  function PDFPageProxy(pageIndex, pageInfo, transport, ownerDocument) {\n    var pdfBug = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    _classCallCheck(this, PDFPageProxy);\n\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._ownerDocument = ownerDocument;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this.cleanupAfterRender = false;\n    this.pendingCleanup = false;\n    this._intentStates = new Map();\n    this.destroyed = false;\n  }\n\n  _createClass(PDFPageProxy, [{\n    key: \"getViewport\",\n    value: function getViewport() {\n      var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          scale = _ref3.scale,\n          _ref3$rotation = _ref3.rotation,\n          rotation = _ref3$rotation === void 0 ? this.rotate : _ref3$rotation,\n          _ref3$offsetX = _ref3.offsetX,\n          offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX,\n          _ref3$offsetY = _ref3.offsetY,\n          offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY,\n          _ref3$dontFlip = _ref3.dontFlip,\n          dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip;\n\n      return new _display_utils.PageViewport({\n        viewBox: this.view,\n        scale: scale,\n        rotation: rotation,\n        offsetX: offsetX,\n        offsetY: offsetY,\n        dontFlip: dontFlip\n      });\n    }\n  }, {\n    key: \"getAnnotations\",\n    value: function getAnnotations() {\n      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref4$intent = _ref4.intent,\n          intent = _ref4$intent === void 0 ? null : _ref4$intent;\n\n      if (!this.annotationsPromise || this.annotationsIntent !== intent) {\n        this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent);\n        this.annotationsIntent = intent;\n      }\n\n      return this.annotationsPromise;\n    }\n  }, {\n    key: \"render\",\n    value: function render(_ref5) {\n      var _this5 = this;\n\n      var canvasContext = _ref5.canvasContext,\n          viewport = _ref5.viewport,\n          _ref5$intent = _ref5.intent,\n          intent = _ref5$intent === void 0 ? \"display\" : _ref5$intent,\n          _ref5$enableWebGL = _ref5.enableWebGL,\n          enableWebGL = _ref5$enableWebGL === void 0 ? false : _ref5$enableWebGL,\n          _ref5$renderInteracti = _ref5.renderInteractiveForms,\n          renderInteractiveForms = _ref5$renderInteracti === void 0 ? false : _ref5$renderInteracti,\n          _ref5$transform = _ref5.transform,\n          transform = _ref5$transform === void 0 ? null : _ref5$transform,\n          _ref5$imageLayer = _ref5.imageLayer,\n          imageLayer = _ref5$imageLayer === void 0 ? null : _ref5$imageLayer,\n          _ref5$canvasFactory = _ref5.canvasFactory,\n          canvasFactory = _ref5$canvasFactory === void 0 ? null : _ref5$canvasFactory,\n          _ref5$background = _ref5.background,\n          background = _ref5$background === void 0 ? null : _ref5$background,\n          _ref5$annotationStora = _ref5.annotationStorage,\n          annotationStorage = _ref5$annotationStora === void 0 ? null : _ref5$annotationStora,\n          _ref5$optionalContent = _ref5.optionalContentConfigPromise,\n          optionalContentConfigPromise = _ref5$optionalContent === void 0 ? null : _ref5$optionalContent;\n\n      if (this._stats) {\n        this._stats.time(\"Overall\");\n      }\n\n      var renderingIntent = intent === \"print\" ? \"print\" : \"display\";\n      this.pendingCleanup = false;\n\n      if (!optionalContentConfigPromise) {\n        optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n      }\n\n      var intentState = this._intentStates.get(renderingIntent);\n\n      if (!intentState) {\n        intentState = Object.create(null);\n\n        this._intentStates.set(renderingIntent, intentState);\n      }\n\n      if (intentState.streamReaderCancelTimeout) {\n        clearTimeout(intentState.streamReaderCancelTimeout);\n        intentState.streamReaderCancelTimeout = null;\n      }\n\n      var canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({\n        ownerDocument: this._ownerDocument\n      });\n      var webGLContext = new _webgl.WebGLContext({\n        enable: enableWebGL\n      });\n\n      if (!intentState.displayReadyCapability) {\n        intentState.displayReadyCapability = (0, _util.createPromiseCapability)();\n        intentState.operatorList = {\n          fnArray: [],\n          argsArray: [],\n          lastChunk: false\n        };\n\n        if (this._stats) {\n          this._stats.time(\"Page Request\");\n        }\n\n        this._pumpOperatorList({\n          pageIndex: this._pageIndex,\n          intent: renderingIntent,\n          renderInteractiveForms: renderInteractiveForms === true,\n          annotationStorage: annotationStorage && annotationStorage.getAll() || null\n        });\n      }\n\n      var complete = function complete(error) {\n        var i = intentState.renderTasks.indexOf(internalRenderTask);\n\n        if (i >= 0) {\n          intentState.renderTasks.splice(i, 1);\n        }\n\n        if (_this5.cleanupAfterRender || renderingIntent === \"print\") {\n          _this5.pendingCleanup = true;\n        }\n\n        _this5._tryCleanup();\n\n        if (error) {\n          internalRenderTask.capability.reject(error);\n\n          _this5._abortOperatorList({\n            intentState: intentState,\n            reason: error\n          });\n        } else {\n          internalRenderTask.capability.resolve();\n        }\n\n        if (_this5._stats) {\n          _this5._stats.timeEnd(\"Rendering\");\n\n          _this5._stats.timeEnd(\"Overall\");\n        }\n      };\n\n      var internalRenderTask = new InternalRenderTask({\n        callback: complete,\n        params: {\n          canvasContext: canvasContext,\n          viewport: viewport,\n          transform: transform,\n          imageLayer: imageLayer,\n          background: background\n        },\n        objs: this.objs,\n        commonObjs: this.commonObjs,\n        operatorList: intentState.operatorList,\n        pageIndex: this._pageIndex,\n        canvasFactory: canvasFactoryInstance,\n        webGLContext: webGLContext,\n        useRequestAnimationFrame: renderingIntent !== \"print\",\n        pdfBug: this._pdfBug\n      });\n\n      if (!intentState.renderTasks) {\n        intentState.renderTasks = [];\n      }\n\n      intentState.renderTasks.push(internalRenderTask);\n      var renderTask = internalRenderTask.task;\n      Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n            transparency = _ref7[0],\n            optionalContentConfig = _ref7[1];\n\n        if (_this5.pendingCleanup) {\n          complete();\n          return;\n        }\n\n        if (_this5._stats) {\n          _this5._stats.time(\"Rendering\");\n        }\n\n        internalRenderTask.initializeGraphics({\n          transparency: transparency,\n          optionalContentConfig: optionalContentConfig\n        });\n        internalRenderTask.operatorListChanged();\n      })[\"catch\"](complete);\n      return renderTask;\n    }\n  }, {\n    key: \"getOperatorList\",\n    value: function getOperatorList() {\n      function operatorListChanged() {\n        if (intentState.operatorList.lastChunk) {\n          intentState.opListReadCapability.resolve(intentState.operatorList);\n          var i = intentState.renderTasks.indexOf(opListTask);\n\n          if (i >= 0) {\n            intentState.renderTasks.splice(i, 1);\n          }\n        }\n      }\n\n      var renderingIntent = \"oplist\";\n\n      var intentState = this._intentStates.get(renderingIntent);\n\n      if (!intentState) {\n        intentState = Object.create(null);\n\n        this._intentStates.set(renderingIntent, intentState);\n      }\n\n      var opListTask;\n\n      if (!intentState.opListReadCapability) {\n        opListTask = Object.create(null);\n        opListTask.operatorListChanged = operatorListChanged;\n        intentState.opListReadCapability = (0, _util.createPromiseCapability)();\n        intentState.renderTasks = [];\n        intentState.renderTasks.push(opListTask);\n        intentState.operatorList = {\n          fnArray: [],\n          argsArray: [],\n          lastChunk: false\n        };\n\n        if (this._stats) {\n          this._stats.time(\"Page Request\");\n        }\n\n        this._pumpOperatorList({\n          pageIndex: this._pageIndex,\n          intent: renderingIntent\n        });\n      }\n\n      return intentState.opListReadCapability.promise;\n    }\n  }, {\n    key: \"streamTextContent\",\n    value: function streamTextContent() {\n      var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref8$normalizeWhites = _ref8.normalizeWhitespace,\n          normalizeWhitespace = _ref8$normalizeWhites === void 0 ? false : _ref8$normalizeWhites,\n          _ref8$disableCombineT = _ref8.disableCombineTextItems,\n          disableCombineTextItems = _ref8$disableCombineT === void 0 ? false : _ref8$disableCombineT;\n\n      var TEXT_CONTENT_CHUNK_SIZE = 100;\n      return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n        pageIndex: this._pageIndex,\n        normalizeWhitespace: normalizeWhitespace === true,\n        combineTextItems: disableCombineTextItems !== true\n      }, {\n        highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n        size: function size(textContent) {\n          return textContent.items.length;\n        }\n      });\n    }\n  }, {\n    key: \"getTextContent\",\n    value: function getTextContent() {\n      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var readableStream = this.streamTextContent(params);\n      return new Promise(function (resolve, reject) {\n        function pump() {\n          reader.read().then(function (_ref9) {\n            var _textContent$items;\n\n            var value = _ref9.value,\n                done = _ref9.done;\n\n            if (done) {\n              resolve(textContent);\n              return;\n            }\n\n            Object.assign(textContent.styles, value.styles);\n\n            (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items));\n\n            pump();\n          }, reject);\n        }\n\n        var reader = readableStream.getReader();\n        var textContent = {\n          items: [],\n          styles: Object.create(null)\n        };\n        pump();\n      });\n    }\n  }, {\n    key: \"_destroy\",\n    value: function _destroy() {\n      this.destroyed = true;\n      this._transport.pageCache[this._pageIndex] = null;\n      var waitOn = [];\n\n      var _iterator5 = _createForOfIteratorHelper(this._intentStates),\n          _step5;\n\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              intent = _step5$value[0],\n              intentState = _step5$value[1];\n\n          this._abortOperatorList({\n            intentState: intentState,\n            reason: new Error(\"Page was destroyed.\"),\n            force: true\n          });\n\n          if (intent === \"oplist\") {\n            continue;\n          }\n\n          var _iterator6 = _createForOfIteratorHelper(intentState.renderTasks),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var internalRenderTask = _step6.value;\n              waitOn.push(internalRenderTask.completed);\n              internalRenderTask.cancel();\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n\n      this.objs.clear();\n      this.annotationsPromise = null;\n      this.pendingCleanup = false;\n      return Promise.all(waitOn);\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      this.pendingCleanup = true;\n      return this._tryCleanup(resetStats);\n    }\n  }, {\n    key: \"_tryCleanup\",\n    value: function _tryCleanup() {\n      var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this.pendingCleanup) {\n        return false;\n      }\n\n      var _iterator7 = _createForOfIteratorHelper(this._intentStates.values()),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var _step7$value = _step7.value,\n              renderTasks = _step7$value.renderTasks,\n              operatorList = _step7$value.operatorList;\n\n          if (renderTasks.length !== 0 || !operatorList.lastChunk) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      this._intentStates.clear();\n\n      this.objs.clear();\n      this.annotationsPromise = null;\n\n      if (resetStats && this._stats) {\n        this._stats = new _display_utils.StatTimer();\n      }\n\n      this.pendingCleanup = false;\n      return true;\n    }\n  }, {\n    key: \"_startRenderPage\",\n    value: function _startRenderPage(transparency, intent) {\n      var intentState = this._intentStates.get(intent);\n\n      if (!intentState) {\n        return;\n      }\n\n      if (this._stats) {\n        this._stats.timeEnd(\"Page Request\");\n      }\n\n      if (intentState.displayReadyCapability) {\n        intentState.displayReadyCapability.resolve(transparency);\n      }\n    }\n  }, {\n    key: \"_renderPageChunk\",\n    value: function _renderPageChunk(operatorListChunk, intentState) {\n      for (var i = 0, ii = operatorListChunk.length; i < ii; i++) {\n        intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n        intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n      }\n\n      intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n\n      for (var _i2 = 0; _i2 < intentState.renderTasks.length; _i2++) {\n        intentState.renderTasks[_i2].operatorListChanged();\n      }\n\n      if (operatorListChunk.lastChunk) {\n        this._tryCleanup();\n      }\n    }\n  }, {\n    key: \"_pumpOperatorList\",\n    value: function _pumpOperatorList(args) {\n      var _this6 = this;\n\n      (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected \"intent\" argument.');\n\n      var readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", args);\n\n      var reader = readableStream.getReader();\n\n      var intentState = this._intentStates.get(args.intent);\n\n      intentState.streamReader = reader;\n\n      var pump = function pump() {\n        reader.read().then(function (_ref10) {\n          var value = _ref10.value,\n              done = _ref10.done;\n\n          if (done) {\n            intentState.streamReader = null;\n            return;\n          }\n\n          if (_this6._transport.destroyed) {\n            return;\n          }\n\n          _this6._renderPageChunk(value, intentState);\n\n          pump();\n        }, function (reason) {\n          intentState.streamReader = null;\n\n          if (_this6._transport.destroyed) {\n            return;\n          }\n\n          if (intentState.operatorList) {\n            intentState.operatorList.lastChunk = true;\n\n            for (var i = 0; i < intentState.renderTasks.length; i++) {\n              intentState.renderTasks[i].operatorListChanged();\n            }\n\n            _this6._tryCleanup();\n          }\n\n          if (intentState.displayReadyCapability) {\n            intentState.displayReadyCapability.reject(reason);\n          } else if (intentState.opListReadCapability) {\n            intentState.opListReadCapability.reject(reason);\n          } else {\n            throw reason;\n          }\n        });\n      };\n\n      pump();\n    }\n  }, {\n    key: \"_abortOperatorList\",\n    value: function _abortOperatorList(_ref11) {\n      var _this7 = this;\n\n      var intentState = _ref11.intentState,\n          reason = _ref11.reason,\n          _ref11$force = _ref11.force,\n          force = _ref11$force === void 0 ? false : _ref11$force;\n      (0, _util.assert)(reason instanceof Error || _typeof(reason) === \"object\" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected \"reason\" argument.');\n\n      if (!intentState.streamReader) {\n        return;\n      }\n\n      if (!force) {\n        if (intentState.renderTasks.length !== 0) {\n          return;\n        }\n\n        if (reason instanceof _display_utils.RenderingCancelledException) {\n          intentState.streamReaderCancelTimeout = setTimeout(function () {\n            _this7._abortOperatorList({\n              intentState: intentState,\n              reason: reason,\n              force: true\n            });\n\n            intentState.streamReaderCancelTimeout = null;\n          }, RENDERING_CANCELLED_TIMEOUT);\n          return;\n        }\n      }\n\n      intentState.streamReader.cancel(new _util.AbortException(reason && reason.message));\n      intentState.streamReader = null;\n\n      if (this._transport.destroyed) {\n        return;\n      }\n\n      var _iterator8 = _createForOfIteratorHelper(this._intentStates),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var _step8$value = _slicedToArray(_step8.value, 2),\n              intent = _step8$value[0],\n              curIntentState = _step8$value[1];\n\n          if (curIntentState === intentState) {\n            this._intentStates[\"delete\"](intent);\n\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      this.cleanup();\n    }\n  }, {\n    key: \"pageNumber\",\n    get: function get() {\n      return this._pageIndex + 1;\n    }\n  }, {\n    key: \"rotate\",\n    get: function get() {\n      return this._pageInfo.rotate;\n    }\n  }, {\n    key: \"ref\",\n    get: function get() {\n      return this._pageInfo.ref;\n    }\n  }, {\n    key: \"userUnit\",\n    get: function get() {\n      return this._pageInfo.userUnit;\n    }\n  }, {\n    key: \"view\",\n    get: function get() {\n      return this._pageInfo.view;\n    }\n  }, {\n    key: \"stats\",\n    get: function get() {\n      return this._stats;\n    }\n  }]);\n\n  return PDFPageProxy;\n}();\n\nexports.PDFPageProxy = PDFPageProxy;\n\nvar LoopbackPort = /*#__PURE__*/function () {\n  function LoopbackPort() {\n    var defer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n    _classCallCheck(this, LoopbackPort);\n\n    this._listeners = [];\n    this._defer = defer;\n    this._deferred = Promise.resolve(undefined);\n  }\n\n  _createClass(LoopbackPort, [{\n    key: \"postMessage\",\n    value: function postMessage(obj, transfers) {\n      var _this8 = this;\n\n      function cloneValue(value) {\n        if (_typeof(value) !== \"object\" || value === null) {\n          return value;\n        }\n\n        if (cloned.has(value)) {\n          return cloned.get(value);\n        }\n\n        var buffer, result;\n\n        if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) {\n          var transferable = transfers && transfers.includes(buffer);\n\n          if (transferable) {\n            result = new value.constructor(buffer, value.byteOffset, value.byteLength);\n          } else {\n            result = new value.constructor(value);\n          }\n\n          cloned.set(value, result);\n          return result;\n        }\n\n        result = Array.isArray(value) ? [] : {};\n        cloned.set(value, result);\n\n        for (var i in value) {\n          var desc = void 0,\n              p = value;\n\n          while (!(desc = Object.getOwnPropertyDescriptor(p, i))) {\n            p = Object.getPrototypeOf(p);\n          }\n\n          if (typeof desc.value === \"undefined\") {\n            continue;\n          }\n\n          if (typeof desc.value === \"function\") {\n            if (value.hasOwnProperty && value.hasOwnProperty(i)) {\n              throw new Error(\"LoopbackPort.postMessage - cannot clone: \".concat(value[i]));\n            }\n\n            continue;\n          }\n\n          result[i] = cloneValue(desc.value);\n        }\n\n        return result;\n      }\n\n      if (!this._defer) {\n        this._listeners.forEach(function (listener) {\n          listener.call(_this8, {\n            data: obj\n          });\n        });\n\n        return;\n      }\n\n      var cloned = new WeakMap();\n      var e = {\n        data: cloneValue(obj)\n      };\n\n      this._deferred.then(function () {\n        _this8._listeners.forEach(function (listener) {\n          listener.call(_this8, e);\n        });\n      });\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(name, listener) {\n      this._listeners.push(listener);\n    }\n  }, {\n    key: \"removeEventListener\",\n    value: function removeEventListener(name, listener) {\n      var i = this._listeners.indexOf(listener);\n\n      this._listeners.splice(i, 1);\n    }\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      this._listeners.length = 0;\n    }\n  }]);\n\n  return LoopbackPort;\n}();\n\nexports.LoopbackPort = LoopbackPort;\n\nvar PDFWorker = function PDFWorkerClosure() {\n  var pdfWorkerPorts = new WeakMap();\n  var isWorkerDisabled = false;\n  var fallbackWorkerSrc;\n  var nextFakeWorkerId = 0;\n  var fakeWorkerCapability;\n\n  if (_is_node.isNodeJS && \"function\" === \"function\") {\n    isWorkerDisabled = true;\n    fallbackWorkerSrc = \"./pdf.worker.js\";\n  } else if ((typeof document === \"undefined\" ? \"undefined\" : _typeof(document)) === \"object\" && \"currentScript\" in document) {\n    var pdfjsFilePath = document.currentScript && document.currentScript.src;\n\n    if (pdfjsFilePath) {\n      fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n    }\n  }\n\n  function _getWorkerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n\n    if (typeof fallbackWorkerSrc !== \"undefined\") {\n      if (!_is_node.isNodeJS) {\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n\n      return fallbackWorkerSrc;\n    }\n\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n\n  function getMainThreadWorkerMessageHandler() {\n    var mainWorkerMessageHandler;\n\n    try {\n      mainWorkerMessageHandler = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler;\n    } catch (ex) {}\n\n    return mainWorkerMessageHandler || null;\n  }\n\n  function setupFakeWorkerGlobal() {\n    if (fakeWorkerCapability) {\n      return fakeWorkerCapability.promise;\n    }\n\n    fakeWorkerCapability = (0, _util.createPromiseCapability)();\n\n    var loader = /*#__PURE__*/function () {\n      var _ref12 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var mainWorkerMessageHandler, worker;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                mainWorkerMessageHandler = getMainThreadWorkerMessageHandler();\n\n                if (!mainWorkerMessageHandler) {\n                  _context.next = 3;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", mainWorkerMessageHandler);\n\n              case 3:\n                if (!(_is_node.isNodeJS && \"function\" === \"function\")) {\n                  _context.next = 6;\n                  break;\n                }\n\n                worker = eval(\"require\")(_getWorkerSrc());\n                return _context.abrupt(\"return\", worker.WorkerMessageHandler);\n\n              case 6:\n                _context.next = 8;\n                return (0, _display_utils.loadScript)(_getWorkerSrc());\n\n              case 8:\n                return _context.abrupt(\"return\", window.pdfjsWorker.WorkerMessageHandler);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n\n      return function loader() {\n        return _ref12.apply(this, arguments);\n      };\n    }();\n\n    loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject);\n    return fakeWorkerCapability.promise;\n  }\n\n  function createCDNWrapper(url) {\n    var wrapper = \"importScripts('\" + url + \"');\";\n    return URL.createObjectURL(new Blob([wrapper]));\n  }\n\n  var PDFWorker = /*#__PURE__*/function () {\n    function PDFWorker() {\n      var _ref13 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n          _ref13$name = _ref13.name,\n          name = _ref13$name === void 0 ? null : _ref13$name,\n          _ref13$port = _ref13.port,\n          port = _ref13$port === void 0 ? null : _ref13$port,\n          _ref13$verbosity = _ref13.verbosity,\n          verbosity = _ref13$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref13$verbosity;\n\n      _classCallCheck(this, PDFWorker);\n\n      if (port && pdfWorkerPorts.has(port)) {\n        throw new Error(\"Cannot use more than one PDFWorker per port\");\n      }\n\n      this.name = name;\n      this.destroyed = false;\n      this.postMessageTransfers = true;\n      this.verbosity = verbosity;\n      this._readyCapability = (0, _util.createPromiseCapability)();\n      this._port = null;\n      this._webWorker = null;\n      this._messageHandler = null;\n\n      if (port) {\n        pdfWorkerPorts.set(port, this);\n\n        this._initializeFromPort(port);\n\n        return;\n      }\n\n      this._initialize();\n    }\n\n    _createClass(PDFWorker, [{\n      key: \"_initializeFromPort\",\n      value: function _initializeFromPort(port) {\n        this._port = port;\n        this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n\n        this._messageHandler.on(\"ready\", function () {});\n\n        this._readyCapability.resolve();\n      }\n    }, {\n      key: \"_initialize\",\n      value: function _initialize() {\n        var _this9 = this;\n\n        if (typeof Worker !== \"undefined\" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) {\n          var workerSrc = _getWorkerSrc();\n\n          try {\n            if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) {\n              workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href);\n            }\n\n            var worker = new Worker(workerSrc);\n            var messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n\n            var terminateEarly = function terminateEarly() {\n              worker.removeEventListener(\"error\", onWorkerError);\n              messageHandler.destroy();\n              worker.terminate();\n\n              if (_this9.destroyed) {\n                _this9._readyCapability.reject(new Error(\"Worker was destroyed\"));\n              } else {\n                _this9._setupFakeWorker();\n              }\n            };\n\n            var onWorkerError = function onWorkerError() {\n              if (!_this9._webWorker) {\n                terminateEarly();\n              }\n            };\n\n            worker.addEventListener(\"error\", onWorkerError);\n            messageHandler.on(\"test\", function (data) {\n              worker.removeEventListener(\"error\", onWorkerError);\n\n              if (_this9.destroyed) {\n                terminateEarly();\n                return;\n              }\n\n              if (data) {\n                _this9._messageHandler = messageHandler;\n                _this9._port = worker;\n                _this9._webWorker = worker;\n\n                if (!data.supportTransfers) {\n                  _this9.postMessageTransfers = false;\n                }\n\n                _this9._readyCapability.resolve();\n\n                messageHandler.send(\"configure\", {\n                  verbosity: _this9.verbosity\n                });\n              } else {\n                _this9._setupFakeWorker();\n\n                messageHandler.destroy();\n                worker.terminate();\n              }\n            });\n            messageHandler.on(\"ready\", function (data) {\n              worker.removeEventListener(\"error\", onWorkerError);\n\n              if (_this9.destroyed) {\n                terminateEarly();\n                return;\n              }\n\n              try {\n                sendTest();\n              } catch (e) {\n                _this9._setupFakeWorker();\n              }\n            });\n\n            var sendTest = function sendTest() {\n              var testObj = new Uint8Array([_this9.postMessageTransfers ? 255 : 0]);\n\n              try {\n                messageHandler.send(\"test\", testObj, [testObj.buffer]);\n              } catch (ex) {\n                (0, _util.warn)(\"Cannot use postMessage transfers.\");\n                testObj[0] = 0;\n                messageHandler.send(\"test\", testObj);\n              }\n            };\n\n            sendTest();\n            return;\n          } catch (e) {\n            (0, _util.info)(\"The worker has been disabled.\");\n          }\n        }\n\n        this._setupFakeWorker();\n      }\n    }, {\n      key: \"_setupFakeWorker\",\n      value: function _setupFakeWorker() {\n        var _this10 = this;\n\n        if (!isWorkerDisabled) {\n          (0, _util.warn)(\"Setting up fake worker.\");\n          isWorkerDisabled = true;\n        }\n\n        setupFakeWorkerGlobal().then(function (WorkerMessageHandler) {\n          if (_this10.destroyed) {\n            _this10._readyCapability.reject(new Error(\"Worker was destroyed\"));\n\n            return;\n          }\n\n          var port = new LoopbackPort();\n          _this10._port = port;\n          var id = \"fake\" + nextFakeWorkerId++;\n          var workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n          WorkerMessageHandler.setup(workerHandler, port);\n          var messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n          _this10._messageHandler = messageHandler;\n\n          _this10._readyCapability.resolve();\n\n          messageHandler.send(\"configure\", {\n            verbosity: _this10.verbosity\n          });\n        })[\"catch\"](function (reason) {\n          _this10._readyCapability.reject(new Error(\"Setting up fake worker failed: \\\"\".concat(reason.message, \"\\\".\")));\n        });\n      }\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        this.destroyed = true;\n\n        if (this._webWorker) {\n          this._webWorker.terminate();\n\n          this._webWorker = null;\n        }\n\n        pdfWorkerPorts[\"delete\"](this._port);\n        this._port = null;\n\n        if (this._messageHandler) {\n          this._messageHandler.destroy();\n\n          this._messageHandler = null;\n        }\n      }\n    }, {\n      key: \"promise\",\n      get: function get() {\n        return this._readyCapability.promise;\n      }\n    }, {\n      key: \"port\",\n      get: function get() {\n        return this._port;\n      }\n    }, {\n      key: \"messageHandler\",\n      get: function get() {\n        return this._messageHandler;\n      }\n    }], [{\n      key: \"fromPort\",\n      value: function fromPort(params) {\n        if (!params || !params.port) {\n          throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n        }\n\n        if (pdfWorkerPorts.has(params.port)) {\n          return pdfWorkerPorts.get(params.port);\n        }\n\n        return new PDFWorker(params);\n      }\n    }, {\n      key: \"getWorkerSrc\",\n      value: function getWorkerSrc() {\n        return _getWorkerSrc();\n      }\n    }]);\n\n    return PDFWorker;\n  }();\n\n  return PDFWorker;\n}();\n\nexports.PDFWorker = PDFWorker;\n\nvar WorkerTransport = /*#__PURE__*/function () {\n  function WorkerTransport(messageHandler, loadingTask, networkStream, params) {\n    _classCallCheck(this, WorkerTransport);\n\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      docId: loadingTask.docId,\n      onUnsupportedFeature: this._onUnsupportedFeature.bind(this),\n      ownerDocument: params.ownerDocument\n    });\n    this._params = params;\n    this.CMapReaderFactory = new params.CMapReaderFactory({\n      baseUrl: params.cMapUrl,\n      isCompressed: params.cMapPacked\n    });\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._passwordCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.pageCache = [];\n    this.pagePromises = [];\n    this.downloadInfoCapability = (0, _util.createPromiseCapability)();\n    this.setupMessageHandler();\n  }\n\n  _createClass(WorkerTransport, [{\n    key: \"destroy\",\n    value: function destroy() {\n      var _this11 = this;\n\n      if (this.destroyCapability) {\n        return this.destroyCapability.promise;\n      }\n\n      this.destroyed = true;\n      this.destroyCapability = (0, _util.createPromiseCapability)();\n\n      if (this._passwordCapability) {\n        this._passwordCapability.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n      }\n\n      var waitOn = [];\n      this.pageCache.forEach(function (page) {\n        if (page) {\n          waitOn.push(page._destroy());\n        }\n      });\n      this.pageCache.length = 0;\n      this.pagePromises.length = 0;\n      var terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n      waitOn.push(terminated);\n      Promise.all(waitOn).then(function () {\n        _this11.fontLoader.clear();\n\n        if (_this11._networkStream) {\n          _this11._networkStream.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n        }\n\n        if (_this11.messageHandler) {\n          _this11.messageHandler.destroy();\n\n          _this11.messageHandler = null;\n        }\n\n        _this11.destroyCapability.resolve();\n      }, this.destroyCapability.reject);\n      return this.destroyCapability.promise;\n    }\n  }, {\n    key: \"setupMessageHandler\",\n    value: function setupMessageHandler() {\n      var _this12 = this;\n\n      var messageHandler = this.messageHandler,\n          loadingTask = this.loadingTask;\n      messageHandler.on(\"GetReader\", function (data, sink) {\n        (0, _util.assert)(_this12._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n        _this12._fullReader = _this12._networkStream.getFullReader();\n\n        _this12._fullReader.onProgress = function (evt) {\n          _this12._lastProgress = {\n            loaded: evt.loaded,\n            total: evt.total\n          };\n        };\n\n        sink.onPull = function () {\n          _this12._fullReader.read().then(function (_ref14) {\n            var value = _ref14.value,\n                done = _ref14.done;\n\n            if (done) {\n              sink.close();\n              return;\n            }\n\n            (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetReader - expected an ArrayBuffer.\");\n            sink.enqueue(new Uint8Array(value), 1, [value]);\n          })[\"catch\"](function (reason) {\n            sink.error(reason);\n          });\n        };\n\n        sink.onCancel = function (reason) {\n          _this12._fullReader.cancel(reason);\n\n          sink.ready[\"catch\"](function (readyReason) {\n            if (_this12.destroyed) {\n              return;\n            }\n\n            throw readyReason;\n          });\n        };\n      });\n      messageHandler.on(\"ReaderHeadersReady\", function (data) {\n        var headersCapability = (0, _util.createPromiseCapability)();\n        var fullReader = _this12._fullReader;\n        fullReader.headersReady.then(function () {\n          if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n            if (_this12._lastProgress && loadingTask.onProgress) {\n              loadingTask.onProgress(_this12._lastProgress);\n            }\n\n            fullReader.onProgress = function (evt) {\n              if (loadingTask.onProgress) {\n                loadingTask.onProgress({\n                  loaded: evt.loaded,\n                  total: evt.total\n                });\n              }\n            };\n          }\n\n          headersCapability.resolve({\n            isStreamingSupported: fullReader.isStreamingSupported,\n            isRangeSupported: fullReader.isRangeSupported,\n            contentLength: fullReader.contentLength\n          });\n        }, headersCapability.reject);\n        return headersCapability.promise;\n      });\n      messageHandler.on(\"GetRangeReader\", function (data, sink) {\n        (0, _util.assert)(_this12._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n\n        var rangeReader = _this12._networkStream.getRangeReader(data.begin, data.end);\n\n        if (!rangeReader) {\n          sink.close();\n          return;\n        }\n\n        sink.onPull = function () {\n          rangeReader.read().then(function (_ref15) {\n            var value = _ref15.value,\n                done = _ref15.done;\n\n            if (done) {\n              sink.close();\n              return;\n            }\n\n            (0, _util.assert)((0, _util.isArrayBuffer)(value), \"GetRangeReader - expected an ArrayBuffer.\");\n            sink.enqueue(new Uint8Array(value), 1, [value]);\n          })[\"catch\"](function (reason) {\n            sink.error(reason);\n          });\n        };\n\n        sink.onCancel = function (reason) {\n          rangeReader.cancel(reason);\n          sink.ready[\"catch\"](function (readyReason) {\n            if (_this12.destroyed) {\n              return;\n            }\n\n            throw readyReason;\n          });\n        };\n      });\n      messageHandler.on(\"GetDoc\", function (_ref16) {\n        var pdfInfo = _ref16.pdfInfo;\n        _this12._numPages = pdfInfo.numPages;\n\n        loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this12));\n      });\n      messageHandler.on(\"DocException\", function (ex) {\n        var reason;\n\n        switch (ex.name) {\n          case \"PasswordException\":\n            reason = new _util.PasswordException(ex.message, ex.code);\n            break;\n\n          case \"InvalidPDFException\":\n            reason = new _util.InvalidPDFException(ex.message);\n            break;\n\n          case \"MissingPDFException\":\n            reason = new _util.MissingPDFException(ex.message);\n            break;\n\n          case \"UnexpectedResponseException\":\n            reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n            break;\n\n          case \"UnknownErrorException\":\n            reason = new _util.UnknownErrorException(ex.message, ex.details);\n            break;\n        }\n\n        if (!(reason instanceof Error)) {\n          var msg = \"DocException - expected a valid Error.\";\n          (0, _util.warn)(msg);\n        }\n\n        loadingTask._capability.reject(reason);\n      });\n      messageHandler.on(\"PasswordRequest\", function (exception) {\n        _this12._passwordCapability = (0, _util.createPromiseCapability)();\n\n        if (loadingTask.onPassword) {\n          var updatePassword = function updatePassword(password) {\n            _this12._passwordCapability.resolve({\n              password: password\n            });\n          };\n\n          try {\n            loadingTask.onPassword(updatePassword, exception.code);\n          } catch (ex) {\n            _this12._passwordCapability.reject(ex);\n          }\n        } else {\n          _this12._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n        }\n\n        return _this12._passwordCapability.promise;\n      });\n      messageHandler.on(\"DataLoaded\", function (data) {\n        if (loadingTask.onProgress) {\n          loadingTask.onProgress({\n            loaded: data.length,\n            total: data.length\n          });\n        }\n\n        _this12.downloadInfoCapability.resolve(data);\n      });\n      messageHandler.on(\"StartRenderPage\", function (data) {\n        if (_this12.destroyed) {\n          return;\n        }\n\n        var page = _this12.pageCache[data.pageIndex];\n\n        page._startRenderPage(data.transparency, data.intent);\n      });\n      messageHandler.on(\"commonobj\", function (data) {\n        if (_this12.destroyed) {\n          return;\n        }\n\n        var _data = _slicedToArray(data, 3),\n            id = _data[0],\n            type = _data[1],\n            exportedData = _data[2];\n\n        if (_this12.commonObjs.has(id)) {\n          return;\n        }\n\n        switch (type) {\n          case \"Font\":\n            var params = _this12._params;\n\n            if (\"error\" in exportedData) {\n              var exportedError = exportedData.error;\n              (0, _util.warn)(\"Error during font loading: \".concat(exportedError));\n\n              _this12.commonObjs.resolve(id, exportedError);\n\n              break;\n            }\n\n            var fontRegistry = null;\n\n            if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) {\n              fontRegistry = {\n                registerFont: function registerFont(font, url) {\n                  globalThis.FontInspector.fontAdded(font, url);\n                }\n              };\n            }\n\n            var font = new _font_loader.FontFaceObject(exportedData, {\n              isEvalSupported: params.isEvalSupported,\n              disableFontFace: params.disableFontFace,\n              ignoreErrors: params.ignoreErrors,\n              onUnsupportedFeature: _this12._onUnsupportedFeature.bind(_this12),\n              fontRegistry: fontRegistry\n            });\n\n            _this12.fontLoader.bind(font)[\"catch\"](function (reason) {\n              return messageHandler.sendWithPromise(\"FontFallback\", {\n                id: id\n              });\n            })[\"finally\"](function () {\n              if (!params.fontExtraProperties && font.data) {\n                font.data = null;\n              }\n\n              _this12.commonObjs.resolve(id, font);\n            });\n\n            break;\n\n          case \"FontPath\":\n          case \"Image\":\n            _this12.commonObjs.resolve(id, exportedData);\n\n            break;\n\n          default:\n            throw new Error(\"Got unknown common object type \".concat(type));\n        }\n      });\n      messageHandler.on(\"obj\", function (data) {\n        if (_this12.destroyed) {\n          return undefined;\n        }\n\n        var _data2 = _slicedToArray(data, 4),\n            id = _data2[0],\n            pageIndex = _data2[1],\n            type = _data2[2],\n            imageData = _data2[3];\n\n        var pageProxy = _this12.pageCache[pageIndex];\n\n        if (pageProxy.objs.has(id)) {\n          return undefined;\n        }\n\n        switch (type) {\n          case \"Image\":\n            pageProxy.objs.resolve(id, imageData);\n            var MAX_IMAGE_SIZE_TO_STORE = 8000000;\n\n            if (imageData && \"data\" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) {\n              pageProxy.cleanupAfterRender = true;\n            }\n\n            break;\n\n          default:\n            throw new Error(\"Got unknown object type \".concat(type));\n        }\n\n        return undefined;\n      });\n      messageHandler.on(\"DocProgress\", function (data) {\n        if (_this12.destroyed) {\n          return;\n        }\n\n        if (loadingTask.onProgress) {\n          loadingTask.onProgress({\n            loaded: data.loaded,\n            total: data.total\n          });\n        }\n      });\n      messageHandler.on(\"UnsupportedFeature\", this._onUnsupportedFeature.bind(this));\n      messageHandler.on(\"FetchBuiltInCMap\", function (data, sink) {\n        if (_this12.destroyed) {\n          sink.error(new Error(\"Worker was destroyed\"));\n          return;\n        }\n\n        var fetched = false;\n\n        sink.onPull = function () {\n          if (fetched) {\n            sink.close();\n            return;\n          }\n\n          fetched = true;\n\n          _this12.CMapReaderFactory.fetch(data).then(function (builtInCMap) {\n            sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]);\n          })[\"catch\"](function (reason) {\n            sink.error(reason);\n          });\n        };\n      });\n    }\n  }, {\n    key: \"_onUnsupportedFeature\",\n    value: function _onUnsupportedFeature(_ref17) {\n      var featureId = _ref17.featureId;\n\n      if (this.destroyed) {\n        return;\n      }\n\n      if (this.loadingTask.onUnsupportedFeature) {\n        this.loadingTask.onUnsupportedFeature(featureId);\n      }\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.messageHandler.sendWithPromise(\"GetData\", null);\n    }\n  }, {\n    key: \"getPage\",\n    value: function getPage(pageNumber) {\n      var _this13 = this;\n\n      if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n        return Promise.reject(new Error(\"Invalid page request\"));\n      }\n\n      var pageIndex = pageNumber - 1;\n\n      if (pageIndex in this.pagePromises) {\n        return this.pagePromises[pageIndex];\n      }\n\n      var promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n        pageIndex: pageIndex\n      }).then(function (pageInfo) {\n        if (_this13.destroyed) {\n          throw new Error(\"Transport destroyed\");\n        }\n\n        var page = new PDFPageProxy(pageIndex, pageInfo, _this13, _this13._params.ownerDocument, _this13._params.pdfBug);\n        _this13.pageCache[pageIndex] = page;\n        return page;\n      });\n      this.pagePromises[pageIndex] = promise;\n      return promise;\n    }\n  }, {\n    key: \"getPageIndex\",\n    value: function getPageIndex(ref) {\n      return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n        ref: ref\n      })[\"catch\"](function (reason) {\n        return Promise.reject(new Error(reason));\n      });\n    }\n  }, {\n    key: \"getAnnotations\",\n    value: function getAnnotations(pageIndex, intent) {\n      return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n        pageIndex: pageIndex,\n        intent: intent\n      });\n    }\n  }, {\n    key: \"saveDocument\",\n    value: function saveDocument(annotationStorage) {\n      return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n        numPages: this._numPages,\n        annotationStorage: annotationStorage && annotationStorage.getAll() || null,\n        filename: this._fullReader ? this._fullReader.filename : null\n      })[\"finally\"](function () {\n        if (annotationStorage) {\n          annotationStorage.resetModified();\n        }\n      });\n    }\n  }, {\n    key: \"getDestinations\",\n    value: function getDestinations() {\n      return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n    }\n  }, {\n    key: \"getDestination\",\n    value: function getDestination(id) {\n      if (typeof id !== \"string\") {\n        return Promise.reject(new Error(\"Invalid destination request.\"));\n      }\n\n      return this.messageHandler.sendWithPromise(\"GetDestination\", {\n        id: id\n      });\n    }\n  }, {\n    key: \"getPageLabels\",\n    value: function getPageLabels() {\n      return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n    }\n  }, {\n    key: \"getPageLayout\",\n    value: function getPageLayout() {\n      return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n    }\n  }, {\n    key: \"getPageMode\",\n    value: function getPageMode() {\n      return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n    }\n  }, {\n    key: \"getViewerPreferences\",\n    value: function getViewerPreferences() {\n      return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n    }\n  }, {\n    key: \"getOpenAction\",\n    value: function getOpenAction() {\n      return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n    }\n  }, {\n    key: \"getAttachments\",\n    value: function getAttachments() {\n      return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n    }\n  }, {\n    key: \"getJavaScript\",\n    value: function getJavaScript() {\n      return this.messageHandler.sendWithPromise(\"GetJavaScript\", null);\n    }\n  }, {\n    key: \"getOutline\",\n    value: function getOutline() {\n      return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n    }\n  }, {\n    key: \"getOptionalContentConfig\",\n    value: function getOptionalContentConfig() {\n      return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(function (results) {\n        return new _optional_content_config.OptionalContentConfig(results);\n      });\n    }\n  }, {\n    key: \"getPermissions\",\n    value: function getPermissions() {\n      return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n    }\n  }, {\n    key: \"getMetadata\",\n    value: function getMetadata() {\n      var _this14 = this;\n\n      return this.messageHandler.sendWithPromise(\"GetMetadata\", null).then(function (results) {\n        return {\n          info: results[0],\n          metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n          contentDispositionFilename: _this14._fullReader ? _this14._fullReader.filename : null\n        };\n      });\n    }\n  }, {\n    key: \"getStats\",\n    value: function getStats() {\n      return this.messageHandler.sendWithPromise(\"GetStats\", null);\n    }\n  }, {\n    key: \"startCleanup\",\n    value: function startCleanup() {\n      var _this15 = this;\n\n      return this.messageHandler.sendWithPromise(\"Cleanup\", null).then(function () {\n        for (var i = 0, ii = _this15.pageCache.length; i < ii; i++) {\n          var page = _this15.pageCache[i];\n\n          if (page) {\n            var cleanupSuccessful = page.cleanup();\n\n            if (!cleanupSuccessful) {\n              throw new Error(\"startCleanup: Page \".concat(i + 1, \" is currently rendering.\"));\n            }\n          }\n        }\n\n        _this15.commonObjs.clear();\n\n        _this15.fontLoader.clear();\n      });\n    }\n  }, {\n    key: \"loadingParams\",\n    get: function get() {\n      var params = this._params;\n      return (0, _util.shadow)(this, \"loadingParams\", {\n        disableAutoFetch: params.disableAutoFetch,\n        disableFontFace: params.disableFontFace\n      });\n    }\n  }]);\n\n  return WorkerTransport;\n}();\n\nvar PDFObjects = /*#__PURE__*/function () {\n  function PDFObjects() {\n    _classCallCheck(this, PDFObjects);\n\n    this._objs = Object.create(null);\n  }\n\n  _createClass(PDFObjects, [{\n    key: \"_ensureObj\",\n    value: function _ensureObj(objId) {\n      if (this._objs[objId]) {\n        return this._objs[objId];\n      }\n\n      return this._objs[objId] = {\n        capability: (0, _util.createPromiseCapability)(),\n        data: null,\n        resolved: false\n      };\n    }\n  }, {\n    key: \"get\",\n    value: function get(objId) {\n      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n      if (callback) {\n        this._ensureObj(objId).capability.promise.then(callback);\n\n        return null;\n      }\n\n      var obj = this._objs[objId];\n\n      if (!obj || !obj.resolved) {\n        throw new Error(\"Requesting object that isn't resolved yet \".concat(objId, \".\"));\n      }\n\n      return obj.data;\n    }\n  }, {\n    key: \"has\",\n    value: function has(objId) {\n      var obj = this._objs[objId];\n      return obj ? obj.resolved : false;\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(objId, data) {\n      var obj = this._ensureObj(objId);\n\n      obj.resolved = true;\n      obj.data = data;\n      obj.capability.resolve(data);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._objs = Object.create(null);\n    }\n  }]);\n\n  return PDFObjects;\n}();\n\nvar RenderTask = /*#__PURE__*/function () {\n  function RenderTask(internalRenderTask) {\n    _classCallCheck(this, RenderTask);\n\n    this._internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n\n  _createClass(RenderTask, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this._internalRenderTask.cancel();\n    }\n  }, {\n    key: \"promise\",\n    get: function get() {\n      return this._internalRenderTask.capability.promise;\n    }\n  }]);\n\n  return RenderTask;\n}();\n\nvar InternalRenderTask = function InternalRenderTaskClosure() {\n  var canvasInRendering = new WeakSet();\n\n  var InternalRenderTask = /*#__PURE__*/function () {\n    function InternalRenderTask(_ref18) {\n      var callback = _ref18.callback,\n          params = _ref18.params,\n          objs = _ref18.objs,\n          commonObjs = _ref18.commonObjs,\n          operatorList = _ref18.operatorList,\n          pageIndex = _ref18.pageIndex,\n          canvasFactory = _ref18.canvasFactory,\n          webGLContext = _ref18.webGLContext,\n          _ref18$useRequestAnim = _ref18.useRequestAnimationFrame,\n          useRequestAnimationFrame = _ref18$useRequestAnim === void 0 ? false : _ref18$useRequestAnim,\n          _ref18$pdfBug = _ref18.pdfBug,\n          pdfBug = _ref18$pdfBug === void 0 ? false : _ref18$pdfBug;\n\n      _classCallCheck(this, InternalRenderTask);\n\n      this.callback = callback;\n      this.params = params;\n      this.objs = objs;\n      this.commonObjs = commonObjs;\n      this.operatorListIdx = null;\n      this.operatorList = operatorList;\n      this._pageIndex = pageIndex;\n      this.canvasFactory = canvasFactory;\n      this.webGLContext = webGLContext;\n      this._pdfBug = pdfBug;\n      this.running = false;\n      this.graphicsReadyCallback = null;\n      this.graphicsReady = false;\n      this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n      this.cancelled = false;\n      this.capability = (0, _util.createPromiseCapability)();\n      this.task = new RenderTask(this);\n      this._continueBound = this._continue.bind(this);\n      this._scheduleNextBound = this._scheduleNext.bind(this);\n      this._nextBound = this._next.bind(this);\n      this._canvas = params.canvasContext.canvas;\n    }\n\n    _createClass(InternalRenderTask, [{\n      key: \"initializeGraphics\",\n      value: function initializeGraphics(_ref19) {\n        var _ref19$transparency = _ref19.transparency,\n            transparency = _ref19$transparency === void 0 ? false : _ref19$transparency,\n            optionalContentConfig = _ref19.optionalContentConfig;\n\n        if (this.cancelled) {\n          return;\n        }\n\n        if (this._canvas) {\n          if (canvasInRendering.has(this._canvas)) {\n            throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n          }\n\n          canvasInRendering.add(this._canvas);\n        }\n\n        if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) {\n          this.stepper = globalThis.StepperManager.create(this._pageIndex);\n          this.stepper.init(this.operatorList);\n          this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n        }\n\n        var _this$params = this.params,\n            canvasContext = _this$params.canvasContext,\n            viewport = _this$params.viewport,\n            transform = _this$params.transform,\n            imageLayer = _this$params.imageLayer,\n            background = _this$params.background;\n        this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig);\n        this.gfx.beginDrawing({\n          transform: transform,\n          viewport: viewport,\n          transparency: transparency,\n          background: background\n        });\n        this.operatorListIdx = 0;\n        this.graphicsReady = true;\n\n        if (this.graphicsReadyCallback) {\n          this.graphicsReadyCallback();\n        }\n      }\n    }, {\n      key: \"cancel\",\n      value: function cancel() {\n        var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n        this.running = false;\n        this.cancelled = true;\n\n        if (this.gfx) {\n          this.gfx.endDrawing();\n        }\n\n        if (this._canvas) {\n          canvasInRendering[\"delete\"](this._canvas);\n        }\n\n        this.callback(error || new _display_utils.RenderingCancelledException(\"Rendering cancelled, page \".concat(this._pageIndex + 1), \"canvas\"));\n      }\n    }, {\n      key: \"operatorListChanged\",\n      value: function operatorListChanged() {\n        if (!this.graphicsReady) {\n          if (!this.graphicsReadyCallback) {\n            this.graphicsReadyCallback = this._continueBound;\n          }\n\n          return;\n        }\n\n        if (this.stepper) {\n          this.stepper.updateOperatorList(this.operatorList);\n        }\n\n        if (this.running) {\n          return;\n        }\n\n        this._continue();\n      }\n    }, {\n      key: \"_continue\",\n      value: function _continue() {\n        this.running = true;\n\n        if (this.cancelled) {\n          return;\n        }\n\n        if (this.task.onContinue) {\n          this.task.onContinue(this._scheduleNextBound);\n        } else {\n          this._scheduleNext();\n        }\n      }\n    }, {\n      key: \"_scheduleNext\",\n      value: function _scheduleNext() {\n        var _this16 = this;\n\n        if (this._useRequestAnimationFrame) {\n          window.requestAnimationFrame(function () {\n            _this16._nextBound()[\"catch\"](_this16.cancel.bind(_this16));\n          });\n        } else {\n          Promise.resolve().then(this._nextBound)[\"catch\"](this.cancel.bind(this));\n        }\n      }\n    }, {\n      key: \"_next\",\n      value: function () {\n        var _next2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n          return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (!this.cancelled) {\n                    _context2.next = 2;\n                    break;\n                  }\n\n                  return _context2.abrupt(\"return\");\n\n                case 2:\n                  this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n\n                  if (this.operatorListIdx === this.operatorList.argsArray.length) {\n                    this.running = false;\n\n                    if (this.operatorList.lastChunk) {\n                      this.gfx.endDrawing();\n\n                      if (this._canvas) {\n                        canvasInRendering[\"delete\"](this._canvas);\n                      }\n\n                      this.callback();\n                    }\n                  }\n\n                case 4:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, this);\n        }));\n\n        function _next() {\n          return _next2.apply(this, arguments);\n        }\n\n        return _next;\n      }()\n    }, {\n      key: \"completed\",\n      get: function get() {\n        return this.capability.promise[\"catch\"](function () {});\n      }\n    }]);\n\n    return InternalRenderTask;\n  }();\n\n  return InternalRenderTask;\n}();\n\nvar version = '2.6.347';\nexports.version = version;\nvar build = '3be9c65f';\nexports.build = build;\n\n/***/ }),\n/* 203 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FontLoader = exports.FontFaceObject = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(5);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar BaseFontLoader = /*#__PURE__*/function () {\n  function BaseFontLoader(_ref) {\n    var docId = _ref.docId,\n        onUnsupportedFeature = _ref.onUnsupportedFeature,\n        _ref$ownerDocument = _ref.ownerDocument,\n        ownerDocument = _ref$ownerDocument === void 0 ? globalThis.document : _ref$ownerDocument;\n\n    _classCallCheck(this, BaseFontLoader);\n\n    if (this.constructor === BaseFontLoader) {\n      (0, _util.unreachable)(\"Cannot initialize BaseFontLoader.\");\n    }\n\n    this.docId = docId;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this._document = ownerDocument;\n    this.nativeFontFaces = [];\n    this.styleElement = null;\n  }\n\n  _createClass(BaseFontLoader, [{\n    key: \"addNativeFontFace\",\n    value: function addNativeFontFace(nativeFontFace) {\n      this.nativeFontFaces.push(nativeFontFace);\n\n      this._document.fonts.add(nativeFontFace);\n    }\n  }, {\n    key: \"insertRule\",\n    value: function insertRule(rule) {\n      var styleElement = this.styleElement;\n\n      if (!styleElement) {\n        styleElement = this.styleElement = this._document.createElement(\"style\");\n        styleElement.id = \"PDFJS_FONT_STYLE_TAG_\".concat(this.docId);\n\n        this._document.documentElement.getElementsByTagName(\"head\")[0].appendChild(styleElement);\n      }\n\n      var styleSheet = styleElement.sheet;\n      styleSheet.insertRule(rule, styleSheet.cssRules.length);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      this.nativeFontFaces.forEach(function (nativeFontFace) {\n        _this._document.fonts[\"delete\"](nativeFontFace);\n      });\n      this.nativeFontFaces.length = 0;\n\n      if (this.styleElement) {\n        this.styleElement.remove();\n        this.styleElement = null;\n      }\n    }\n  }, {\n    key: \"bind\",\n    value: function () {\n      var _bind = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(font) {\n        var _this2 = this;\n\n        var nativeFontFace, rule;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(font.attached || font.missingFile)) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 2:\n                font.attached = true;\n\n                if (!this.isFontLoadingAPISupported) {\n                  _context.next = 19;\n                  break;\n                }\n\n                nativeFontFace = font.createNativeFontFace();\n\n                if (!nativeFontFace) {\n                  _context.next = 18;\n                  break;\n                }\n\n                this.addNativeFontFace(nativeFontFace);\n                _context.prev = 7;\n                _context.next = 10;\n                return nativeFontFace.loaded;\n\n              case 10:\n                _context.next = 18;\n                break;\n\n              case 12:\n                _context.prev = 12;\n                _context.t0 = _context[\"catch\"](7);\n\n                this._onUnsupportedFeature({\n                  featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative\n                });\n\n                (0, _util.warn)(\"Failed to load font '\".concat(nativeFontFace.family, \"': '\").concat(_context.t0, \"'.\"));\n                font.disableFontFace = true;\n                throw _context.t0;\n\n              case 18:\n                return _context.abrupt(\"return\");\n\n              case 19:\n                rule = font.createFontFaceRule();\n\n                if (!rule) {\n                  _context.next = 26;\n                  break;\n                }\n\n                this.insertRule(rule);\n\n                if (!this.isSyncFontLoadingSupported) {\n                  _context.next = 24;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 24:\n                _context.next = 26;\n                return new Promise(function (resolve) {\n                  var request = _this2._queueLoadingCallback(resolve);\n\n                  _this2._prepareFontLoadEvent([rule], [font], request);\n                });\n\n              case 26:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[7, 12]]);\n      }));\n\n      function bind(_x) {\n        return _bind.apply(this, arguments);\n      }\n\n      return bind;\n    }()\n  }, {\n    key: \"_queueLoadingCallback\",\n    value: function _queueLoadingCallback(callback) {\n      (0, _util.unreachable)(\"Abstract method `_queueLoadingCallback`.\");\n    }\n  }, {\n    key: \"_prepareFontLoadEvent\",\n    value: function _prepareFontLoadEvent(rules, fontsToLoad, request) {\n      (0, _util.unreachable)(\"Abstract method `_prepareFontLoadEvent`.\");\n    }\n  }, {\n    key: \"isFontLoadingAPISupported\",\n    get: function get() {\n      var supported = typeof this._document !== \"undefined\" && !!this._document.fonts;\n      return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", supported);\n    }\n  }, {\n    key: \"isSyncFontLoadingSupported\",\n    get: function get() {\n      (0, _util.unreachable)(\"Abstract method `isSyncFontLoadingSupported`.\");\n    }\n  }, {\n    key: \"_loadTestFont\",\n    get: function get() {\n      (0, _util.unreachable)(\"Abstract method `_loadTestFont`.\");\n    }\n  }]);\n\n  return BaseFontLoader;\n}();\n\nvar FontLoader;\nexports.FontLoader = FontLoader;\n{\n  exports.FontLoader = FontLoader = /*#__PURE__*/function (_BaseFontLoader) {\n    _inherits(GenericFontLoader, _BaseFontLoader);\n\n    var _super = _createSuper(GenericFontLoader);\n\n    function GenericFontLoader(params) {\n      var _this3;\n\n      _classCallCheck(this, GenericFontLoader);\n\n      _this3 = _super.call(this, params);\n      _this3.loadingContext = {\n        requests: [],\n        nextRequestId: 0\n      };\n      _this3.loadTestFontId = 0;\n      return _this3;\n    }\n\n    _createClass(GenericFontLoader, [{\n      key: \"_queueLoadingCallback\",\n      value: function _queueLoadingCallback(callback) {\n        function completeRequest() {\n          (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n          request.done = true;\n\n          while (context.requests.length > 0 && context.requests[0].done) {\n            var otherRequest = context.requests.shift();\n            setTimeout(otherRequest.callback, 0);\n          }\n        }\n\n        var context = this.loadingContext;\n        var request = {\n          id: \"pdfjs-font-loading-\".concat(context.nextRequestId++),\n          done: false,\n          complete: completeRequest,\n          callback: callback\n        };\n        context.requests.push(request);\n        return request;\n      }\n    }, {\n      key: \"_prepareFontLoadEvent\",\n      value: function _prepareFontLoadEvent(rules, fonts, request) {\n        var _this4 = this;\n\n        function int32(data, offset) {\n          return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n        }\n\n        function spliceString(s, offset, remove, insert) {\n          var chunk1 = s.substring(0, offset);\n          var chunk2 = s.substring(offset + remove);\n          return chunk1 + insert + chunk2;\n        }\n\n        var i, ii;\n\n        var canvas = this._document.createElement(\"canvas\");\n\n        canvas.width = 1;\n        canvas.height = 1;\n        var ctx = canvas.getContext(\"2d\");\n        var called = 0;\n\n        function isFontReady(name, callback) {\n          called++;\n\n          if (called > 30) {\n            (0, _util.warn)(\"Load test font never loaded.\");\n            callback();\n            return;\n          }\n\n          ctx.font = \"30px \" + name;\n          ctx.fillText(\".\", 0, 20);\n          var imageData = ctx.getImageData(0, 0, 1, 1);\n\n          if (imageData.data[3] > 0) {\n            callback();\n            return;\n          }\n\n          setTimeout(isFontReady.bind(null, name, callback));\n        }\n\n        var loadTestFontId = \"lt\".concat(Date.now()).concat(this.loadTestFontId++);\n        var data = this._loadTestFont;\n        var COMMENT_OFFSET = 976;\n        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n        var CFF_CHECKSUM_OFFSET = 16;\n        var XXXX_VALUE = 0x58585858;\n        var checksum = int32(data, CFF_CHECKSUM_OFFSET);\n\n        for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n          checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n        }\n\n        if (i < loadTestFontId.length) {\n          checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n        }\n\n        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n        var url = \"url(data:font/opentype;base64,\".concat(btoa(data), \");\");\n        var rule = \"@font-face {font-family:\\\"\".concat(loadTestFontId, \"\\\";src:\").concat(url, \"}\");\n        this.insertRule(rule);\n        var names = [];\n\n        for (i = 0, ii = fonts.length; i < ii; i++) {\n          names.push(fonts[i].loadedName);\n        }\n\n        names.push(loadTestFontId);\n\n        var div = this._document.createElement(\"div\");\n\n        div.style.visibility = \"hidden\";\n        div.style.width = div.style.height = \"10px\";\n        div.style.position = \"absolute\";\n        div.style.top = div.style.left = \"0px\";\n\n        for (i = 0, ii = names.length; i < ii; ++i) {\n          var span = this._document.createElement(\"span\");\n\n          span.textContent = \"Hi\";\n          span.style.fontFamily = names[i];\n          div.appendChild(span);\n        }\n\n        this._document.body.appendChild(div);\n\n        isFontReady(loadTestFontId, function () {\n          _this4._document.body.removeChild(div);\n\n          request.complete();\n        });\n      }\n    }, {\n      key: \"isSyncFontLoadingSupported\",\n      get: function get() {\n        var supported = false;\n\n        if (typeof navigator === \"undefined\") {\n          supported = true;\n        } else {\n          var m = /Mozilla\\/5.0.*?rv:(\\d+).*? Gecko/.exec(navigator.userAgent);\n\n          if (m && m[1] >= 14) {\n            supported = true;\n          }\n        }\n\n        return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n      }\n    }, {\n      key: \"_loadTestFont\",\n      get: function get() {\n        var getLoadTestFont = function getLoadTestFont() {\n          return atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n        };\n\n        return (0, _util.shadow)(this, \"_loadTestFont\", getLoadTestFont());\n      }\n    }]);\n\n    return GenericFontLoader;\n  }(BaseFontLoader);\n}\n\nvar FontFaceObject = /*#__PURE__*/function () {\n  function FontFaceObject(translatedData, _ref2) {\n    var _ref2$isEvalSupported = _ref2.isEvalSupported,\n        isEvalSupported = _ref2$isEvalSupported === void 0 ? true : _ref2$isEvalSupported,\n        _ref2$disableFontFace = _ref2.disableFontFace,\n        disableFontFace = _ref2$disableFontFace === void 0 ? false : _ref2$disableFontFace,\n        _ref2$ignoreErrors = _ref2.ignoreErrors,\n        ignoreErrors = _ref2$ignoreErrors === void 0 ? false : _ref2$ignoreErrors,\n        _ref2$onUnsupportedFe = _ref2.onUnsupportedFeature,\n        onUnsupportedFeature = _ref2$onUnsupportedFe === void 0 ? null : _ref2$onUnsupportedFe,\n        _ref2$fontRegistry = _ref2.fontRegistry,\n        fontRegistry = _ref2$fontRegistry === void 0 ? null : _ref2$fontRegistry;\n\n    _classCallCheck(this, FontFaceObject);\n\n    this.compiledGlyphs = Object.create(null);\n\n    for (var i in translatedData) {\n      this[i] = translatedData[i];\n    }\n\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._onUnsupportedFeature = onUnsupportedFeature;\n    this.fontRegistry = fontRegistry;\n  }\n\n  _createClass(FontFaceObject, [{\n    key: \"createNativeFontFace\",\n    value: function createNativeFontFace() {\n      if (!this.data || this.disableFontFace) {\n        return null;\n      }\n\n      var nativeFontFace = new FontFace(this.loadedName, this.data, {});\n\n      if (this.fontRegistry) {\n        this.fontRegistry.registerFont(this);\n      }\n\n      return nativeFontFace;\n    }\n  }, {\n    key: \"createFontFaceRule\",\n    value: function createFontFaceRule() {\n      if (!this.data || this.disableFontFace) {\n        return null;\n      }\n\n      var data = (0, _util.bytesToString)(new Uint8Array(this.data));\n      var url = \"url(data:\".concat(this.mimetype, \";base64,\").concat(btoa(data), \");\");\n      var rule = \"@font-face {font-family:\\\"\".concat(this.loadedName, \"\\\";src:\").concat(url, \"}\");\n\n      if (this.fontRegistry) {\n        this.fontRegistry.registerFont(this, url);\n      }\n\n      return rule;\n    }\n  }, {\n    key: \"getPathGenerator\",\n    value: function getPathGenerator(objs, character) {\n      if (this.compiledGlyphs[character] !== undefined) {\n        return this.compiledGlyphs[character];\n      }\n\n      var cmds, current;\n\n      try {\n        cmds = objs.get(this.loadedName + \"_path_\" + character);\n      } catch (ex) {\n        if (!this.ignoreErrors) {\n          throw ex;\n        }\n\n        if (this._onUnsupportedFeature) {\n          this._onUnsupportedFeature({\n            featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath\n          });\n        }\n\n        (0, _util.warn)(\"getPathGenerator - ignoring character: \\\"\".concat(ex, \"\\\".\"));\n        return this.compiledGlyphs[character] = function (c, size) {};\n      }\n\n      if (this.isEvalSupported && _util.IsEvalSupportedCached.value) {\n        var args,\n            js = \"\";\n\n        for (var i = 0, ii = cmds.length; i < ii; i++) {\n          current = cmds[i];\n\n          if (current.args !== undefined) {\n            args = current.args.join(\",\");\n          } else {\n            args = \"\";\n          }\n\n          js += \"c.\" + current.cmd + \"(\" + args + \");\\n\";\n        }\n\n        return this.compiledGlyphs[character] = new Function(\"c\", \"size\", js);\n      }\n\n      return this.compiledGlyphs[character] = function (c, size) {\n        for (var _i = 0, _ii = cmds.length; _i < _ii; _i++) {\n          current = cmds[_i];\n\n          if (current.cmd === \"scale\") {\n            current.args = [size, -size];\n          }\n\n          c[current.cmd].apply(c, current.args);\n        }\n      };\n    }\n  }]);\n\n  return FontFaceObject;\n}();\n\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 204 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0;\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(7);\n\nvar _util = __w_pdfjs_require__(5);\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar NodeCanvasFactory = function NodeCanvasFactory() {\n  _classCallCheck(this, NodeCanvasFactory);\n\n  (0, _util.unreachable)(\"Not implemented: NodeCanvasFactory\");\n};\n\nexports.NodeCanvasFactory = NodeCanvasFactory;\n\nvar NodeCMapReaderFactory = function NodeCMapReaderFactory() {\n  _classCallCheck(this, NodeCMapReaderFactory);\n\n  (0, _util.unreachable)(\"Not implemented: NodeCMapReaderFactory\");\n};\n\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\n\nif (_is_node.isNodeJS) {\n  exports.NodeCanvasFactory = NodeCanvasFactory = /*#__PURE__*/function (_BaseCanvasFactory) {\n    _inherits(NodeCanvasFactory, _BaseCanvasFactory);\n\n    var _super = _createSuper(NodeCanvasFactory);\n\n    function NodeCanvasFactory() {\n      _classCallCheck(this, NodeCanvasFactory);\n\n      return _super.apply(this, arguments);\n    }\n\n    _createClass(NodeCanvasFactory, [{\n      key: \"create\",\n      value: function create(width, height) {\n        if (width <= 0 || height <= 0) {\n          throw new Error(\"Invalid canvas size\");\n        }\n\n        var Canvas = __webpack_require__(/*! canvas */ \"?b942\");\n\n        var canvas = Canvas.createCanvas(width, height);\n        return {\n          canvas: canvas,\n          context: canvas.getContext(\"2d\")\n        };\n      }\n    }]);\n\n    return NodeCanvasFactory;\n  }(_display_utils.BaseCanvasFactory);\n\n  exports.NodeCMapReaderFactory = NodeCMapReaderFactory = /*#__PURE__*/function (_BaseCMapReaderFactor) {\n    _inherits(NodeCMapReaderFactory, _BaseCMapReaderFactor);\n\n    var _super2 = _createSuper(NodeCMapReaderFactory);\n\n    function NodeCMapReaderFactory() {\n      _classCallCheck(this, NodeCMapReaderFactory);\n\n      return _super2.apply(this, arguments);\n    }\n\n    _createClass(NodeCMapReaderFactory, [{\n      key: \"_fetchData\",\n      value: function _fetchData(url, compressionType) {\n        return new Promise(function (resolve, reject) {\n          var fs = __webpack_require__(/*! fs */ \"?e97d\");\n\n          fs.readFile(url, function (error, data) {\n            if (error || !data) {\n              reject(new Error(error));\n              return;\n            }\n\n            resolve({\n              cMapData: new Uint8Array(data),\n              compressionType: compressionType\n            });\n          });\n        });\n      }\n    }]);\n\n    return NodeCMapReaderFactory;\n  }(_display_utils.BaseCMapReaderFactory);\n}\n\n/***/ }),\n/* 205 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnnotationStorage = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AnnotationStorage = /*#__PURE__*/function () {\n  function AnnotationStorage() {\n    _classCallCheck(this, AnnotationStorage);\n\n    this._storage = new Map();\n    this._modified = false;\n    this.onSetModified = null;\n    this.onResetModified = null;\n  }\n\n  _createClass(AnnotationStorage, [{\n    key: \"getOrCreateValue\",\n    value: function getOrCreateValue(key, defaultValue) {\n      if (this._storage.has(key)) {\n        return this._storage.get(key);\n      }\n\n      this._storage.set(key, defaultValue);\n\n      return defaultValue;\n    }\n  }, {\n    key: \"setValue\",\n    value: function setValue(key, value) {\n      if (this._storage.get(key) !== value) {\n        this._setModified();\n      }\n\n      this._storage.set(key, value);\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      if (this._storage.size === 0) {\n        return null;\n      }\n\n      return Object.fromEntries(this._storage);\n    }\n  }, {\n    key: \"_setModified\",\n    value: function _setModified() {\n      if (!this._modified) {\n        this._modified = true;\n\n        if (typeof this.onSetModified === \"function\") {\n          this.onSetModified();\n        }\n      }\n    }\n  }, {\n    key: \"resetModified\",\n    value: function resetModified() {\n      if (this._modified) {\n        this._modified = false;\n\n        if (typeof this.onResetModified === \"function\") {\n          this.onResetModified();\n        }\n      }\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._storage.size;\n    }\n  }]);\n\n  return AnnotationStorage;\n}();\n\nexports.AnnotationStorage = AnnotationStorage;\n\n/***/ }),\n/* 206 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.apiCompatibilityParams = void 0;\n\nvar _is_node = __w_pdfjs_require__(7);\n\nvar compatibilityParams = Object.create(null);\n{\n  (function checkFontFace() {\n    if (_is_node.isNodeJS) {\n      compatibilityParams.disableFontFace = true;\n    }\n  })();\n}\nvar apiCompatibilityParams = Object.freeze(compatibilityParams);\nexports.apiCompatibilityParams = apiCompatibilityParams;\n\n/***/ }),\n/* 207 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CanvasGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _pattern_helper = __w_pdfjs_require__(208);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar MIN_FONT_SIZE = 16;\nvar MAX_FONT_SIZE = 100;\nvar MAX_GROUP_SIZE = 4096;\nvar MIN_WIDTH_FACTOR = 0.65;\nvar COMPILE_TYPE3_GLYPHS = true;\nvar MAX_SIZE_TO_COMPILE = 1000;\nvar FULL_CHUNK_HEIGHT = 16;\n\nfunction addContextCurrentTransform(ctx) {\n  if (!ctx.mozCurrentTransform) {\n    ctx._originalSave = ctx.save;\n    ctx._originalRestore = ctx.restore;\n    ctx._originalRotate = ctx.rotate;\n    ctx._originalScale = ctx.scale;\n    ctx._originalTranslate = ctx.translate;\n    ctx._originalTransform = ctx.transform;\n    ctx._originalSetTransform = ctx.setTransform;\n    ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0];\n    ctx._transformStack = [];\n    Object.defineProperty(ctx, \"mozCurrentTransform\", {\n      get: function getCurrentTransform() {\n        return this._transformMatrix;\n      }\n    });\n    Object.defineProperty(ctx, \"mozCurrentTransformInverse\", {\n      get: function getCurrentTransformInverse() {\n        var m = this._transformMatrix;\n        var a = m[0],\n            b = m[1],\n            c = m[2],\n            d = m[3],\n            e = m[4],\n            f = m[5];\n        var ad_bc = a * d - b * c;\n        var bc_ad = b * c - a * d;\n        return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc];\n      }\n    });\n\n    ctx.save = function ctxSave() {\n      var old = this._transformMatrix;\n\n      this._transformStack.push(old);\n\n      this._transformMatrix = old.slice(0, 6);\n\n      this._originalSave();\n    };\n\n    ctx.restore = function ctxRestore() {\n      var prev = this._transformStack.pop();\n\n      if (prev) {\n        this._transformMatrix = prev;\n\n        this._originalRestore();\n      }\n    };\n\n    ctx.translate = function ctxTranslate(x, y) {\n      var m = this._transformMatrix;\n      m[4] = m[0] * x + m[2] * y + m[4];\n      m[5] = m[1] * x + m[3] * y + m[5];\n\n      this._originalTranslate(x, y);\n    };\n\n    ctx.scale = function ctxScale(x, y) {\n      var m = this._transformMatrix;\n      m[0] = m[0] * x;\n      m[1] = m[1] * x;\n      m[2] = m[2] * y;\n      m[3] = m[3] * y;\n\n      this._originalScale(x, y);\n    };\n\n    ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n      var m = this._transformMatrix;\n      this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]];\n\n      ctx._originalTransform(a, b, c, d, e, f);\n    };\n\n    ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n      this._transformMatrix = [a, b, c, d, e, f];\n\n      ctx._originalSetTransform(a, b, c, d, e, f);\n    };\n\n    ctx.rotate = function ctxRotate(angle) {\n      var cosValue = Math.cos(angle);\n      var sinValue = Math.sin(angle);\n      var m = this._transformMatrix;\n      this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]];\n\n      this._originalRotate(angle);\n    };\n  }\n}\n\nvar CachedCanvases = function CachedCanvasesClosure() {\n  function CachedCanvases(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n\n  CachedCanvases.prototype = {\n    getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) {\n      var canvasEntry;\n\n      if (this.cache[id] !== undefined) {\n        canvasEntry = this.cache[id];\n        this.canvasFactory.reset(canvasEntry, width, height);\n        canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0);\n      } else {\n        canvasEntry = this.canvasFactory.create(width, height);\n        this.cache[id] = canvasEntry;\n      }\n\n      if (trackTransform) {\n        addContextCurrentTransform(canvasEntry.context);\n      }\n\n      return canvasEntry;\n    },\n    clear: function clear() {\n      for (var id in this.cache) {\n        var canvasEntry = this.cache[id];\n        this.canvasFactory.destroy(canvasEntry);\n        delete this.cache[id];\n      }\n    }\n  };\n  return CachedCanvases;\n}();\n\nfunction compileType3Glyph(imgData) {\n  var POINT_TO_PROCESS_LIMIT = 1000;\n  var width = imgData.width,\n      height = imgData.height;\n  var i,\n      j,\n      j0,\n      width1 = width + 1;\n  var points = new Uint8Array(width1 * (height + 1));\n  var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  var lineSize = width + 7 & ~7,\n      data0 = imgData.data;\n  var data = new Uint8Array(lineSize * height),\n      pos = 0,\n      ii;\n\n  for (i = 0, ii = data0.length; i < ii; i++) {\n    var mask = 128,\n        elem = data0[i];\n\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n\n  var count = 0;\n  pos = 0;\n\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n\n    var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n\n      pos++;\n    }\n\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n\n    pos++;\n  }\n\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n\n  var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  var outlines = [];\n\n  for (i = 0; count && i <= height; i++) {\n    var p = i * width1;\n    var end = p + width;\n\n    while (p < end && !points[p]) {\n      p++;\n    }\n\n    if (p === end) {\n      continue;\n    }\n\n    var coords = [p % width1, i];\n    var type = points[p],\n        p0 = p,\n        pp;\n\n    do {\n      var step = steps[type];\n\n      do {\n        p += step;\n      } while (!points[p]);\n\n      pp = points[p];\n\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n\n      coords.push(p % width1);\n      coords.push(p / width1 | 0);\n\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n\n    outlines.push(coords);\n    --i;\n  }\n\n  var drawOutline = function drawOutline(c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.beginPath();\n\n    for (var k = 0, kk = outlines.length; k < kk; k++) {\n      var o = outlines[k];\n      c.moveTo(o[0], o[1]);\n\n      for (var l = 2, ll = o.length; l < ll; l += 2) {\n        c.lineTo(o[l], o[l + 1]);\n      }\n    }\n\n    c.fill();\n    c.beginPath();\n    c.restore();\n  };\n\n  return drawOutline;\n}\n\nvar CanvasExtraState = function CanvasExtraStateClosure() {\n  function CanvasExtraState() {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.resumeSMaskCtx = null;\n    this.transferMaps = null;\n  }\n\n  CanvasExtraState.prototype = {\n    clone: function CanvasExtraState_clone() {\n      return Object.create(this);\n    },\n    setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n  };\n  return CanvasExtraState;\n}();\n\nvar CanvasGraphics = function CanvasGraphicsClosure() {\n  var EXECUTION_TIME = 15;\n  var EXECUTION_STEPS = 10;\n\n  function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) {\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState();\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.webGLContext = webGLContext;\n    this.imageLayer = imageLayer;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.contentVisible = true;\n    this.markedContentStack = [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n\n    if (canvasCtx) {\n      addContextCurrentTransform(canvasCtx);\n    }\n\n    this._cachedGetSinglePixelWidth = null;\n  }\n\n  function putBinaryImageData(ctx, imgData) {\n    var transferMaps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n\n    if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n      ctx.putImageData(imgData, 0, 0);\n      return;\n    }\n\n    var height = imgData.height,\n        width = imgData.width;\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    var srcPos = 0,\n        destPos;\n    var src = imgData.data;\n    var dest = chunkImgData.data;\n    var i, j, thisChunkHeight, elemsInThisChunk;\n    var transferMapRed, transferMapGreen, transferMapBlue, transferMapGray;\n\n    if (transferMaps) {\n      switch (transferMaps.length) {\n        case 1:\n          transferMapRed = transferMaps[0];\n          transferMapGreen = transferMaps[0];\n          transferMapBlue = transferMaps[0];\n          transferMapGray = transferMaps[0];\n          break;\n\n        case 4:\n          transferMapRed = transferMaps[0];\n          transferMapGreen = transferMaps[1];\n          transferMapBlue = transferMaps[2];\n          transferMapGray = transferMaps[3];\n          break;\n      }\n    }\n\n    if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n      var srcLength = src.byteLength;\n      var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n      var dest32DataLength = dest32.length;\n      var fullSrcDiff = width + 7 >> 3;\n      var white = 0xffffffff;\n      var black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff;\n\n      if (transferMapGray) {\n        if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) {\n          var _ref = [black, white];\n          white = _ref[0];\n          black = _ref[1];\n        }\n      }\n\n      for (i = 0; i < totalChunks; i++) {\n        thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n        destPos = 0;\n\n        for (j = 0; j < thisChunkHeight; j++) {\n          var srcDiff = srcLength - srcPos;\n          var k = 0;\n          var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n          var kEndUnrolled = kEnd & ~7;\n          var mask = 0;\n          var srcByte = 0;\n\n          for (; k < kEndUnrolled; k += 8) {\n            srcByte = src[srcPos++];\n            dest32[destPos++] = srcByte & 128 ? white : black;\n            dest32[destPos++] = srcByte & 64 ? white : black;\n            dest32[destPos++] = srcByte & 32 ? white : black;\n            dest32[destPos++] = srcByte & 16 ? white : black;\n            dest32[destPos++] = srcByte & 8 ? white : black;\n            dest32[destPos++] = srcByte & 4 ? white : black;\n            dest32[destPos++] = srcByte & 2 ? white : black;\n            dest32[destPos++] = srcByte & 1 ? white : black;\n          }\n\n          for (; k < kEnd; k++) {\n            if (mask === 0) {\n              srcByte = src[srcPos++];\n              mask = 128;\n            }\n\n            dest32[destPos++] = srcByte & mask ? white : black;\n            mask >>= 1;\n          }\n        }\n\n        while (destPos < dest32DataLength) {\n          dest32[destPos++] = 0;\n        }\n\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n      var hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n      j = 0;\n      elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n\n      for (i = 0; i < fullChunks; i++) {\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n        srcPos += elemsInThisChunk;\n\n        if (hasTransferMaps) {\n          for (var _k = 0; _k < elemsInThisChunk; _k += 4) {\n            if (transferMapRed) {\n              dest[_k + 0] = transferMapRed[dest[_k + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[_k + 1] = transferMapGreen[dest[_k + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[_k + 2] = transferMapBlue[dest[_k + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, j);\n        j += FULL_CHUNK_HEIGHT;\n      }\n\n      if (i < totalChunks) {\n        elemsInThisChunk = width * partialChunkHeight * 4;\n        dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n\n        if (hasTransferMaps) {\n          for (var _k2 = 0; _k2 < elemsInThisChunk; _k2 += 4) {\n            if (transferMapRed) {\n              dest[_k2 + 0] = transferMapRed[dest[_k2 + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[_k2 + 1] = transferMapGreen[dest[_k2 + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[_k2 + 2] = transferMapBlue[dest[_k2 + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, j);\n      }\n    } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n      var _hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue);\n\n      thisChunkHeight = FULL_CHUNK_HEIGHT;\n      elemsInThisChunk = width * thisChunkHeight;\n\n      for (i = 0; i < totalChunks; i++) {\n        if (i >= fullChunks) {\n          thisChunkHeight = partialChunkHeight;\n          elemsInThisChunk = width * thisChunkHeight;\n        }\n\n        destPos = 0;\n\n        for (j = elemsInThisChunk; j--;) {\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = src[srcPos++];\n          dest[destPos++] = 255;\n        }\n\n        if (_hasTransferMaps) {\n          for (var _k3 = 0; _k3 < destPos; _k3 += 4) {\n            if (transferMapRed) {\n              dest[_k3 + 0] = transferMapRed[dest[_k3 + 0]];\n            }\n\n            if (transferMapGreen) {\n              dest[_k3 + 1] = transferMapGreen[dest[_k3 + 1]];\n            }\n\n            if (transferMapBlue) {\n              dest[_k3 + 2] = transferMapBlue[dest[_k3 + 2]];\n            }\n          }\n        }\n\n        ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n      }\n    } else {\n      throw new Error(\"bad image kind: \".concat(imgData.kind));\n    }\n  }\n\n  function putBinaryImageMask(ctx, imgData) {\n    var height = imgData.height,\n        width = imgData.width;\n    var partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n    var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n    var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n    var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n    var srcPos = 0;\n    var src = imgData.data;\n    var dest = chunkImgData.data;\n\n    for (var i = 0; i < totalChunks; i++) {\n      var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      var destPos = 3;\n\n      for (var j = 0; j < thisChunkHeight; j++) {\n        var mask = 0;\n\n        for (var k = 0; k < width; k++) {\n          if (!mask) {\n            var elem = src[srcPos++];\n            mask = 128;\n          }\n\n          dest[destPos] = elem & mask ? 0 : 255;\n          destPos += 4;\n          mask >>= 1;\n        }\n      }\n\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  }\n\n  function copyCtxState(sourceCtx, destCtx) {\n    var properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\"];\n\n    for (var i = 0, ii = properties.length; i < ii; i++) {\n      var property = properties[i];\n\n      if (sourceCtx[property] !== undefined) {\n        destCtx[property] = sourceCtx[property];\n      }\n    }\n\n    if (sourceCtx.setLineDash !== undefined) {\n      destCtx.setLineDash(sourceCtx.getLineDash());\n      destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n    }\n  }\n\n  function resetCtxToDefault(ctx) {\n    ctx.strokeStyle = \"#000000\";\n    ctx.fillStyle = \"#000000\";\n    ctx.fillRule = \"nonzero\";\n    ctx.globalAlpha = 1;\n    ctx.lineWidth = 1;\n    ctx.lineCap = \"butt\";\n    ctx.lineJoin = \"miter\";\n    ctx.miterLimit = 10;\n    ctx.globalCompositeOperation = \"source-over\";\n    ctx.font = \"10px sans-serif\";\n\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash([]);\n      ctx.lineDashOffset = 0;\n    }\n  }\n\n  function composeSMaskBackdrop(bytes, r0, g0, b0) {\n    var length = bytes.length;\n\n    for (var i = 3; i < length; i += 4) {\n      var alpha = bytes[i];\n\n      if (alpha === 0) {\n        bytes[i - 3] = r0;\n        bytes[i - 2] = g0;\n        bytes[i - 1] = b0;\n      } else if (alpha < 255) {\n        var alpha_ = 255 - alpha;\n        bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n        bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n        bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n      }\n    }\n  }\n\n  function composeSMaskAlpha(maskData, layerData, transferMap) {\n    var length = maskData.length;\n    var scale = 1 / 255;\n\n    for (var i = 3; i < length; i += 4) {\n      var alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n      layerData[i] = layerData[i] * alpha * scale | 0;\n    }\n  }\n\n  function composeSMaskLuminosity(maskData, layerData, transferMap) {\n    var length = maskData.length;\n\n    for (var i = 3; i < length; i += 4) {\n      var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n      layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n    }\n  }\n\n  function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) {\n    var hasBackdrop = !!backdrop;\n    var r0 = hasBackdrop ? backdrop[0] : 0;\n    var g0 = hasBackdrop ? backdrop[1] : 0;\n    var b0 = hasBackdrop ? backdrop[2] : 0;\n    var composeFn;\n\n    if (subtype === \"Luminosity\") {\n      composeFn = composeSMaskLuminosity;\n    } else {\n      composeFn = composeSMaskAlpha;\n    }\n\n    var PIXELS_TO_PROCESS = 1048576;\n    var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n\n    for (var row = 0; row < height; row += chunkSize) {\n      var chunkHeight = Math.min(chunkSize, height - row);\n      var maskData = maskCtx.getImageData(0, row, width, chunkHeight);\n      var layerData = layerCtx.getImageData(0, row, width, chunkHeight);\n\n      if (hasBackdrop) {\n        composeSMaskBackdrop(maskData.data, r0, g0, b0);\n      }\n\n      composeFn(maskData.data, layerData.data, transferMap);\n      maskCtx.putImageData(layerData, 0, row);\n    }\n  }\n\n  function composeSMask(ctx, smask, layerCtx, webGLContext) {\n    var mask = smask.canvas;\n    var maskCtx = smask.context;\n    ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY);\n    var backdrop = smask.backdrop || null;\n\n    if (!smask.transferMap && webGLContext.isEnabled) {\n      var composed = webGLContext.composeSMask({\n        layer: layerCtx.canvas,\n        mask: mask,\n        properties: {\n          subtype: smask.subtype,\n          backdrop: backdrop\n        }\n      });\n      ctx.setTransform(1, 0, 0, 1, 0, 0);\n      ctx.drawImage(composed, smask.offsetX, smask.offsetY);\n      return;\n    }\n\n    genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap);\n    ctx.drawImage(mask, 0, 0);\n  }\n\n  var LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  var LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n  var NORMAL_CLIP = {};\n  var EO_CLIP = {};\n  CanvasGraphics.prototype = {\n    beginDrawing: function beginDrawing(_ref2) {\n      var transform = _ref2.transform,\n          viewport = _ref2.viewport,\n          _ref2$transparency = _ref2.transparency,\n          transparency = _ref2$transparency === void 0 ? false : _ref2$transparency,\n          _ref2$background = _ref2.background,\n          background = _ref2$background === void 0 ? null : _ref2$background;\n      var width = this.ctx.canvas.width;\n      var height = this.ctx.canvas.height;\n      this.ctx.save();\n      this.ctx.fillStyle = background || \"rgb(255, 255, 255)\";\n      this.ctx.fillRect(0, 0, width, height);\n      this.ctx.restore();\n\n      if (transparency) {\n        var transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height, true);\n        this.compositeCtx = this.ctx;\n        this.transparentCanvas = transparentCanvas.canvas;\n        this.ctx = transparentCanvas.context;\n        this.ctx.save();\n        this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform);\n      }\n\n      this.ctx.save();\n      resetCtxToDefault(this.ctx);\n\n      if (transform) {\n        this.ctx.transform.apply(this.ctx, transform);\n      }\n\n      this.ctx.transform.apply(this.ctx, viewport.transform);\n      this.baseTransform = this.ctx.mozCurrentTransform.slice();\n\n      if (this.imageLayer) {\n        this.imageLayer.beginLayout();\n      }\n    },\n    executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n      var argsArray = operatorList.argsArray;\n      var fnArray = operatorList.fnArray;\n      var i = executionStartIdx || 0;\n      var argsArrayLen = argsArray.length;\n\n      if (argsArrayLen === i) {\n        return i;\n      }\n\n      var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n      var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n      var steps = 0;\n      var commonObjs = this.commonObjs;\n      var objs = this.objs;\n      var fnId;\n\n      while (true) {\n        if (stepper !== undefined && i === stepper.nextBreakPoint) {\n          stepper.breakIt(i, continueCallback);\n          return i;\n        }\n\n        fnId = fnArray[i];\n\n        if (fnId !== _util.OPS.dependency) {\n          this[fnId].apply(this, argsArray[i]);\n        } else {\n          var _iterator = _createForOfIteratorHelper(argsArray[i]),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var depObjId = _step.value;\n              var objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n\n              if (!objsPool.has(depObjId)) {\n                objsPool.get(depObjId, continueCallback);\n                return i;\n              }\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n\n        i++;\n\n        if (i === argsArrayLen) {\n          return i;\n        }\n\n        if (chunkOperations && ++steps > EXECUTION_STEPS) {\n          if (Date.now() > endTime) {\n            continueCallback();\n            return i;\n          }\n\n          steps = 0;\n        }\n      }\n    },\n    endDrawing: function CanvasGraphics_endDrawing() {\n      if (this.current.activeSMask !== null) {\n        this.endSMaskGroup();\n      }\n\n      this.ctx.restore();\n\n      if (this.transparentCanvas) {\n        this.ctx = this.compositeCtx;\n        this.ctx.save();\n        this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n        this.ctx.drawImage(this.transparentCanvas, 0, 0);\n        this.ctx.restore();\n        this.transparentCanvas = null;\n      }\n\n      this.cachedCanvases.clear();\n      this.webGLContext.clear();\n\n      if (this.imageLayer) {\n        this.imageLayer.endLayout();\n      }\n    },\n    setLineWidth: function CanvasGraphics_setLineWidth(width) {\n      this.current.lineWidth = width;\n      this.ctx.lineWidth = width;\n    },\n    setLineCap: function CanvasGraphics_setLineCap(style) {\n      this.ctx.lineCap = LINE_CAP_STYLES[style];\n    },\n    setLineJoin: function CanvasGraphics_setLineJoin(style) {\n      this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n    },\n    setMiterLimit: function CanvasGraphics_setMiterLimit(limit) {\n      this.ctx.miterLimit = limit;\n    },\n    setDash: function CanvasGraphics_setDash(dashArray, dashPhase) {\n      var ctx = this.ctx;\n\n      if (ctx.setLineDash !== undefined) {\n        ctx.setLineDash(dashArray);\n        ctx.lineDashOffset = dashPhase;\n      }\n    },\n    setRenderingIntent: function setRenderingIntent(intent) {},\n    setFlatness: function setFlatness(flatness) {},\n    setGState: function CanvasGraphics_setGState(states) {\n      for (var i = 0, ii = states.length; i < ii; i++) {\n        var state = states[i];\n        var key = state[0];\n        var value = state[1];\n\n        switch (key) {\n          case \"LW\":\n            this.setLineWidth(value);\n            break;\n\n          case \"LC\":\n            this.setLineCap(value);\n            break;\n\n          case \"LJ\":\n            this.setLineJoin(value);\n            break;\n\n          case \"ML\":\n            this.setMiterLimit(value);\n            break;\n\n          case \"D\":\n            this.setDash(value[0], value[1]);\n            break;\n\n          case \"RI\":\n            this.setRenderingIntent(value);\n            break;\n\n          case \"FL\":\n            this.setFlatness(value);\n            break;\n\n          case \"Font\":\n            this.setFont(value[0], value[1]);\n            break;\n\n          case \"CA\":\n            this.current.strokeAlpha = state[1];\n            break;\n\n          case \"ca\":\n            this.current.fillAlpha = state[1];\n            this.ctx.globalAlpha = state[1];\n            break;\n\n          case \"BM\":\n            this.ctx.globalCompositeOperation = value;\n            break;\n\n          case \"SMask\":\n            if (this.current.activeSMask) {\n              if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) {\n                this.suspendSMaskGroup();\n              } else {\n                this.endSMaskGroup();\n              }\n            }\n\n            this.current.activeSMask = value ? this.tempSMask : null;\n\n            if (this.current.activeSMask) {\n              this.beginSMaskGroup();\n            }\n\n            this.tempSMask = null;\n            break;\n\n          case \"TR\":\n            this.current.transferMaps = value;\n        }\n      }\n    },\n    beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() {\n      var activeSMask = this.current.activeSMask;\n      var drawnWidth = activeSMask.canvas.width;\n      var drawnHeight = activeSMask.canvas.height;\n      var cacheId = \"smaskGroupAt\" + this.groupLevel;\n      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n      var currentCtx = this.ctx;\n      var currentTransform = currentCtx.mozCurrentTransform;\n      this.ctx.save();\n      var groupCtx = scratchCanvas.context;\n      groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY);\n      groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY);\n      groupCtx.transform.apply(groupCtx, currentTransform);\n      activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse;\n      copyCtxState(currentCtx, groupCtx);\n      this.ctx = groupCtx;\n      this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n    },\n    suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.ctx;\n      this.groupLevel--;\n      this.ctx = this.groupStack.pop();\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\n      this.ctx.restore();\n      this.ctx.save();\n      copyCtxState(groupCtx, this.ctx);\n      this.current.resumeSMaskCtx = groupCtx;\n\n      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n\n      this.ctx.transform.apply(this.ctx, deltaTransform);\n      groupCtx.save();\n      groupCtx.setTransform(1, 0, 0, 1, 0, 0);\n      groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height);\n      groupCtx.restore();\n    },\n    resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.current.resumeSMaskCtx;\n      var currentCtx = this.ctx;\n      this.ctx = groupCtx;\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n    },\n    endSMaskGroup: function CanvasGraphics_endSMaskGroup() {\n      var groupCtx = this.ctx;\n      this.groupLevel--;\n      this.ctx = this.groupStack.pop();\n      composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext);\n      this.ctx.restore();\n      copyCtxState(groupCtx, this.ctx);\n\n      var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform);\n\n      this.ctx.transform.apply(this.ctx, deltaTransform);\n    },\n    save: function CanvasGraphics_save() {\n      this.ctx.save();\n      var old = this.current;\n      this.stateStack.push(old);\n      this.current = old.clone();\n      this.current.resumeSMaskCtx = null;\n    },\n    restore: function CanvasGraphics_restore() {\n      if (this.current.resumeSMaskCtx) {\n        this.resumeSMaskGroup();\n      }\n\n      if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) {\n        this.endSMaskGroup();\n      }\n\n      if (this.stateStack.length !== 0) {\n        this.current = this.stateStack.pop();\n        this.ctx.restore();\n        this.pendingClip = null;\n        this._cachedGetSinglePixelWidth = null;\n      }\n    },\n    transform: function CanvasGraphics_transform(a, b, c, d, e, f) {\n      this.ctx.transform(a, b, c, d, e, f);\n      this._cachedGetSinglePixelWidth = null;\n    },\n    constructPath: function CanvasGraphics_constructPath(ops, args) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var x = current.x,\n          y = current.y;\n\n      for (var i = 0, j = 0, ii = ops.length; i < ii; i++) {\n        switch (ops[i] | 0) {\n          case _util.OPS.rectangle:\n            x = args[j++];\n            y = args[j++];\n            var width = args[j++];\n            var height = args[j++];\n\n            if (width === 0 && ctx.lineWidth < this.getSinglePixelWidth()) {\n              width = this.getSinglePixelWidth();\n            }\n\n            if (height === 0 && ctx.lineWidth < this.getSinglePixelWidth()) {\n              height = this.getSinglePixelWidth();\n            }\n\n            var xw = x + width;\n            var yh = y + height;\n            ctx.moveTo(x, y);\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n            ctx.lineTo(x, y);\n            ctx.closePath();\n            break;\n\n          case _util.OPS.moveTo:\n            x = args[j++];\n            y = args[j++];\n            ctx.moveTo(x, y);\n            break;\n\n          case _util.OPS.lineTo:\n            x = args[j++];\n            y = args[j++];\n            ctx.lineTo(x, y);\n            break;\n\n          case _util.OPS.curveTo:\n            x = args[j + 4];\n            y = args[j + 5];\n            ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n            j += 6;\n            break;\n\n          case _util.OPS.curveTo2:\n            ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n            x = args[j + 2];\n            y = args[j + 3];\n            j += 4;\n            break;\n\n          case _util.OPS.curveTo3:\n            x = args[j + 2];\n            y = args[j + 3];\n            ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n            j += 4;\n            break;\n\n          case _util.OPS.closePath:\n            ctx.closePath();\n            break;\n        }\n      }\n\n      current.setCurrentPoint(x, y);\n    },\n    closePath: function CanvasGraphics_closePath() {\n      this.ctx.closePath();\n    },\n    stroke: function CanvasGraphics_stroke(consumePath) {\n      consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n      var ctx = this.ctx;\n      var strokeColor = this.current.strokeColor;\n      ctx.globalAlpha = this.current.strokeAlpha;\n\n      if (this.contentVisible) {\n        if (strokeColor && strokeColor.hasOwnProperty(\"type\") && strokeColor.type === \"Pattern\") {\n          ctx.save();\n          var transform = ctx.mozCurrentTransform;\n\n          var scale = _util.Util.singularValueDecompose2dScale(transform)[0];\n\n          ctx.strokeStyle = strokeColor.getPattern(ctx, this);\n          ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth * scale);\n          ctx.stroke();\n          ctx.restore();\n        } else {\n          ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth);\n          ctx.stroke();\n        }\n      }\n\n      if (consumePath) {\n        this.consumePath();\n      }\n\n      ctx.globalAlpha = this.current.fillAlpha;\n    },\n    closeStroke: function CanvasGraphics_closeStroke() {\n      this.closePath();\n      this.stroke();\n    },\n    fill: function CanvasGraphics_fill(consumePath) {\n      consumePath = typeof consumePath !== \"undefined\" ? consumePath : true;\n      var ctx = this.ctx;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var needRestore = false;\n\n      if (isPatternFill) {\n        ctx.save();\n\n        if (this.baseTransform) {\n          ctx.setTransform.apply(ctx, this.baseTransform);\n        }\n\n        ctx.fillStyle = fillColor.getPattern(ctx, this);\n        needRestore = true;\n      }\n\n      if (this.contentVisible) {\n        if (this.pendingEOFill) {\n          ctx.fill(\"evenodd\");\n          this.pendingEOFill = false;\n        } else {\n          ctx.fill();\n        }\n      }\n\n      if (needRestore) {\n        ctx.restore();\n      }\n\n      if (consumePath) {\n        this.consumePath();\n      }\n    },\n    eoFill: function CanvasGraphics_eoFill() {\n      this.pendingEOFill = true;\n      this.fill();\n    },\n    fillStroke: function CanvasGraphics_fillStroke() {\n      this.fill(false);\n      this.stroke(false);\n      this.consumePath();\n    },\n    eoFillStroke: function CanvasGraphics_eoFillStroke() {\n      this.pendingEOFill = true;\n      this.fillStroke();\n    },\n    closeFillStroke: function CanvasGraphics_closeFillStroke() {\n      this.closePath();\n      this.fillStroke();\n    },\n    closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() {\n      this.pendingEOFill = true;\n      this.closePath();\n      this.fillStroke();\n    },\n    endPath: function CanvasGraphics_endPath() {\n      this.consumePath();\n    },\n    clip: function CanvasGraphics_clip() {\n      this.pendingClip = NORMAL_CLIP;\n    },\n    eoClip: function CanvasGraphics_eoClip() {\n      this.pendingClip = EO_CLIP;\n    },\n    beginText: function CanvasGraphics_beginText() {\n      this.current.textMatrix = _util.IDENTITY_MATRIX;\n      this.current.textMatrixScale = 1;\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n    },\n    endText: function CanvasGraphics_endText() {\n      var paths = this.pendingTextPaths;\n      var ctx = this.ctx;\n\n      if (paths === undefined) {\n        ctx.beginPath();\n        return;\n      }\n\n      ctx.save();\n      ctx.beginPath();\n\n      for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n        ctx.setTransform.apply(ctx, path.transform);\n        ctx.translate(path.x, path.y);\n        path.addToPath(ctx, path.fontSize);\n      }\n\n      ctx.restore();\n      ctx.clip();\n      ctx.beginPath();\n      delete this.pendingTextPaths;\n    },\n    setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) {\n      this.current.charSpacing = spacing;\n    },\n    setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) {\n      this.current.wordSpacing = spacing;\n    },\n    setHScale: function CanvasGraphics_setHScale(scale) {\n      this.current.textHScale = scale / 100;\n    },\n    setLeading: function CanvasGraphics_setLeading(leading) {\n      this.current.leading = -leading;\n    },\n    setFont: function CanvasGraphics_setFont(fontRefName, size) {\n      var fontObj = this.commonObjs.get(fontRefName);\n      var current = this.current;\n\n      if (!fontObj) {\n        throw new Error(\"Can't find font for \".concat(fontRefName));\n      }\n\n      current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;\n\n      if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n        (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n      }\n\n      if (size < 0) {\n        size = -size;\n        current.fontDirection = -1;\n      } else {\n        current.fontDirection = 1;\n      }\n\n      this.current.font = fontObj;\n      this.current.fontSize = size;\n\n      if (fontObj.isType3Font) {\n        return;\n      }\n\n      var name = fontObj.loadedName || \"sans-serif\";\n      var bold = \"normal\";\n\n      if (fontObj.black) {\n        bold = \"900\";\n      } else if (fontObj.bold) {\n        bold = \"bold\";\n      }\n\n      var italic = fontObj.italic ? \"italic\" : \"normal\";\n      var typeface = \"\\\"\".concat(name, \"\\\", \").concat(fontObj.fallbackName);\n      var browserFontSize = size;\n\n      if (size < MIN_FONT_SIZE) {\n        browserFontSize = MIN_FONT_SIZE;\n      } else if (size > MAX_FONT_SIZE) {\n        browserFontSize = MAX_FONT_SIZE;\n      }\n\n      this.current.fontSizeScale = size / browserFontSize;\n      this.ctx.font = \"\".concat(italic, \" \").concat(bold, \" \").concat(browserFontSize, \"px \").concat(typeface);\n    },\n    setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) {\n      this.current.textRenderingMode = mode;\n    },\n    setTextRise: function CanvasGraphics_setTextRise(rise) {\n      this.current.textRise = rise;\n    },\n    moveText: function CanvasGraphics_moveText(x, y) {\n      this.current.x = this.current.lineX += x;\n      this.current.y = this.current.lineY += y;\n    },\n    setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) {\n      this.setLeading(-y);\n      this.moveText(x, y);\n    },\n    setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) {\n      this.current.textMatrix = [a, b, c, d, e, f];\n      this.current.textMatrixScale = Math.sqrt(a * a + b * b);\n      this.current.x = this.current.lineX = 0;\n      this.current.y = this.current.lineY = 0;\n    },\n    nextLine: function CanvasGraphics_nextLine() {\n      this.moveText(0, this.current.leading);\n    },\n    paintChar: function paintChar(character, x, y, patternTransform) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var font = current.font;\n      var textRenderingMode = current.textRenderingMode;\n      var fontSize = current.fontSize / current.fontSizeScale;\n      var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n      var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n      var patternFill = current.patternFill && !font.missingFile;\n      var addToPath;\n\n      if (font.disableFontFace || isAddToPathSet || patternFill) {\n        addToPath = font.getPathGenerator(this.commonObjs, character);\n      }\n\n      if (font.disableFontFace || patternFill) {\n        ctx.save();\n        ctx.translate(x, y);\n        ctx.beginPath();\n        addToPath(ctx, fontSize);\n\n        if (patternTransform) {\n          ctx.setTransform.apply(ctx, patternTransform);\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.fill();\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.stroke();\n        }\n\n        ctx.restore();\n      } else {\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.fillText(character, x, y);\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          ctx.strokeText(character, x, y);\n        }\n      }\n\n      if (isAddToPathSet) {\n        var paths = this.pendingTextPaths || (this.pendingTextPaths = []);\n        paths.push({\n          transform: ctx.mozCurrentTransform,\n          x: x,\n          y: y,\n          fontSize: fontSize,\n          addToPath: addToPath\n        });\n      }\n    },\n\n    get isFontSubpixelAAEnabled() {\n      var _this$cachedCanvases$ = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10),\n          ctx = _this$cachedCanvases$.context;\n\n      ctx.scale(1.5, 1);\n      ctx.fillText(\"I\", 0, 10);\n      var data = ctx.getImageData(0, 0, 10, 10).data;\n      var enabled = false;\n\n      for (var i = 3; i < data.length; i += 4) {\n        if (data[i] > 0 && data[i] < 255) {\n          enabled = true;\n          break;\n        }\n      }\n\n      return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n    },\n\n    showText: function CanvasGraphics_showText(glyphs) {\n      var current = this.current;\n      var font = current.font;\n\n      if (font.isType3Font) {\n        return this.showType3Text(glyphs);\n      }\n\n      var fontSize = current.fontSize;\n\n      if (fontSize === 0) {\n        return undefined;\n      }\n\n      var ctx = this.ctx;\n      var fontSizeScale = current.fontSizeScale;\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var fontDirection = current.fontDirection;\n      var textHScale = current.textHScale * fontDirection;\n      var glyphsLength = glyphs.length;\n      var vertical = font.vertical;\n      var spacingDir = vertical ? 1 : -1;\n      var defaultVMetrics = font.defaultVMetrics;\n      var widthAdvanceScale = fontSize * current.fontMatrix[0];\n      var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n      ctx.save();\n      var patternTransform;\n\n      if (current.patternFill) {\n        ctx.save();\n        var pattern = current.fillColor.getPattern(ctx, this);\n        patternTransform = ctx.mozCurrentTransform;\n        ctx.restore();\n        ctx.fillStyle = pattern;\n      }\n\n      ctx.transform.apply(ctx, current.textMatrix);\n      ctx.translate(current.x, current.y + current.textRise);\n\n      if (fontDirection > 0) {\n        ctx.scale(textHScale, -1);\n      } else {\n        ctx.scale(textHScale, 1);\n      }\n\n      var lineWidth = current.lineWidth;\n      var scale = current.textMatrixScale;\n\n      if (scale === 0 || lineWidth === 0) {\n        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          this._cachedGetSinglePixelWidth = null;\n          lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR;\n        }\n      } else {\n        lineWidth /= scale;\n      }\n\n      if (fontSizeScale !== 1.0) {\n        ctx.scale(fontSizeScale, fontSizeScale);\n        lineWidth /= fontSizeScale;\n      }\n\n      ctx.lineWidth = lineWidth;\n      var x = 0,\n          i;\n\n      for (i = 0; i < glyphsLength; ++i) {\n        var glyph = glyphs[i];\n\n        if ((0, _util.isNum)(glyph)) {\n          x += spacingDir * glyph * fontSize / 1000;\n          continue;\n        }\n\n        var restoreNeeded = false;\n        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        var character = glyph.fontChar;\n        var accent = glyph.accent;\n        var scaledX, scaledY, scaledAccentX, scaledAccentY;\n        var width = glyph.width;\n\n        if (vertical) {\n          var vmetric, vx, vy;\n          vmetric = glyph.vmetric || defaultVMetrics;\n          vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n          vx = -vx * widthAdvanceScale;\n          vy = vmetric[2] * widthAdvanceScale;\n          width = vmetric ? -vmetric[0] : width;\n          scaledX = vx / fontSizeScale;\n          scaledY = (x + vy) / fontSizeScale;\n        } else {\n          scaledX = x / fontSizeScale;\n          scaledY = 0;\n        }\n\n        if (font.remeasure && width > 0) {\n          var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n\n          if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n            var characterScaleX = width / measuredWidth;\n            restoreNeeded = true;\n            ctx.save();\n            ctx.scale(characterScaleX, 1);\n            scaledX /= characterScaleX;\n          } else if (width !== measuredWidth) {\n            scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n          }\n        }\n\n        if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n          if (simpleFillText && !accent) {\n            ctx.fillText(character, scaledX, scaledY);\n          } else {\n            this.paintChar(character, scaledX, scaledY, patternTransform);\n\n            if (accent) {\n              scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n              scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n              this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n            }\n          }\n        }\n\n        var charWidth;\n\n        if (vertical) {\n          charWidth = width * widthAdvanceScale - spacing * fontDirection;\n        } else {\n          charWidth = width * widthAdvanceScale + spacing * fontDirection;\n        }\n\n        x += charWidth;\n\n        if (restoreNeeded) {\n          ctx.restore();\n        }\n      }\n\n      if (vertical) {\n        current.y -= x;\n      } else {\n        current.x += x * textHScale;\n      }\n\n      ctx.restore();\n    },\n    showType3Text: function CanvasGraphics_showType3Text(glyphs) {\n      var ctx = this.ctx;\n      var current = this.current;\n      var font = current.font;\n      var fontSize = current.fontSize;\n      var fontDirection = current.fontDirection;\n      var spacingDir = font.vertical ? 1 : -1;\n      var charSpacing = current.charSpacing;\n      var wordSpacing = current.wordSpacing;\n      var textHScale = current.textHScale * fontDirection;\n      var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n      var glyphsLength = glyphs.length;\n      var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n      var i, glyph, width, spacingLength;\n\n      if (isTextInvisible || fontSize === 0) {\n        return;\n      }\n\n      this._cachedGetSinglePixelWidth = null;\n      ctx.save();\n      ctx.transform.apply(ctx, current.textMatrix);\n      ctx.translate(current.x, current.y);\n      ctx.scale(textHScale, fontDirection);\n\n      for (i = 0; i < glyphsLength; ++i) {\n        glyph = glyphs[i];\n\n        if ((0, _util.isNum)(glyph)) {\n          spacingLength = spacingDir * glyph * fontSize / 1000;\n          this.ctx.translate(spacingLength, 0);\n          current.x += spacingLength * textHScale;\n          continue;\n        }\n\n        var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n        var operatorList = font.charProcOperatorList[glyph.operatorListId];\n\n        if (!operatorList) {\n          (0, _util.warn)(\"Type3 character \\\"\".concat(glyph.operatorListId, \"\\\" is not available.\"));\n          continue;\n        }\n\n        if (this.contentVisible) {\n          this.processingType3 = glyph;\n          this.save();\n          ctx.scale(fontSize, fontSize);\n          ctx.transform.apply(ctx, fontMatrix);\n          this.executeOperatorList(operatorList);\n          this.restore();\n        }\n\n        var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n\n        width = transformed[0] * fontSize + spacing;\n        ctx.translate(width, 0);\n        current.x += width * textHScale;\n      }\n\n      ctx.restore();\n      this.processingType3 = null;\n    },\n    setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {},\n    setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n      this.ctx.rect(llx, lly, urx - llx, ury - lly);\n      this.clip();\n      this.endPath();\n    },\n    getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) {\n      var _this = this;\n\n      var pattern;\n\n      if (IR[0] === \"TilingPattern\") {\n        var color = IR[1];\n        var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice();\n        var canvasGraphicsFactory = {\n          createCanvasGraphics: function createCanvasGraphics(ctx) {\n            return new CanvasGraphics(ctx, _this.commonObjs, _this.objs, _this.canvasFactory, _this.webGLContext);\n          }\n        };\n        pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n      } else {\n        pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR);\n      }\n\n      return pattern;\n    },\n    setStrokeColorN: function CanvasGraphics_setStrokeColorN() {\n      this.current.strokeColor = this.getColorN_Pattern(arguments);\n    },\n    setFillColorN: function CanvasGraphics_setFillColorN() {\n      this.current.fillColor = this.getColorN_Pattern(arguments);\n      this.current.patternFill = true;\n    },\n    setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) {\n      var color = _util.Util.makeCssRgb(r, g, b);\n\n      this.ctx.strokeStyle = color;\n      this.current.strokeColor = color;\n    },\n    setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {\n      var color = _util.Util.makeCssRgb(r, g, b);\n\n      this.ctx.fillStyle = color;\n      this.current.fillColor = color;\n      this.current.patternFill = false;\n    },\n    shadingFill: function CanvasGraphics_shadingFill(patternIR) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      this.save();\n      var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR);\n      ctx.fillStyle = pattern.getPattern(ctx, this, true);\n      var inv = ctx.mozCurrentTransformInverse;\n\n      if (inv) {\n        var canvas = ctx.canvas;\n        var width = canvas.width;\n        var height = canvas.height;\n\n        var bl = _util.Util.applyTransform([0, 0], inv);\n\n        var br = _util.Util.applyTransform([0, height], inv);\n\n        var ul = _util.Util.applyTransform([width, 0], inv);\n\n        var ur = _util.Util.applyTransform([width, height], inv);\n\n        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n        this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n      } else {\n        this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n      }\n\n      this.restore();\n    },\n    beginInlineImage: function CanvasGraphics_beginInlineImage() {\n      (0, _util.unreachable)(\"Should not call beginInlineImage\");\n    },\n    beginImageData: function CanvasGraphics_beginImageData() {\n      (0, _util.unreachable)(\"Should not call beginImageData\");\n    },\n    paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.save();\n      this.baseTransformStack.push(this.baseTransform);\n\n      if (Array.isArray(matrix) && matrix.length === 6) {\n        this.transform.apply(this, matrix);\n      }\n\n      this.baseTransform = this.ctx.mozCurrentTransform;\n\n      if (bbox) {\n        var width = bbox[2] - bbox[0];\n        var height = bbox[3] - bbox[1];\n        this.ctx.rect(bbox[0], bbox[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n    },\n    paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.restore();\n      this.baseTransform = this.baseTransformStack.pop();\n    },\n    beginGroup: function CanvasGraphics_beginGroup(group) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.save();\n      var currentCtx = this.ctx;\n\n      if (!group.isolated) {\n        (0, _util.info)(\"TODO: Support non-isolated groups.\");\n      }\n\n      if (group.knockout) {\n        (0, _util.warn)(\"Knockout groups not supported.\");\n      }\n\n      var currentTransform = currentCtx.mozCurrentTransform;\n\n      if (group.matrix) {\n        currentCtx.transform.apply(currentCtx, group.matrix);\n      }\n\n      if (!group.bbox) {\n        throw new Error(\"Bounding box is required.\");\n      }\n\n      var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform);\n\n      var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n      bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n      var offsetX = Math.floor(bounds[0]);\n      var offsetY = Math.floor(bounds[1]);\n      var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n      var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n      var scaleX = 1,\n          scaleY = 1;\n\n      if (drawnWidth > MAX_GROUP_SIZE) {\n        scaleX = drawnWidth / MAX_GROUP_SIZE;\n        drawnWidth = MAX_GROUP_SIZE;\n      }\n\n      if (drawnHeight > MAX_GROUP_SIZE) {\n        scaleY = drawnHeight / MAX_GROUP_SIZE;\n        drawnHeight = MAX_GROUP_SIZE;\n      }\n\n      var cacheId = \"groupAt\" + this.groupLevel;\n\n      if (group.smask) {\n        cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n      }\n\n      var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true);\n      var groupCtx = scratchCanvas.context;\n      groupCtx.scale(1 / scaleX, 1 / scaleY);\n      groupCtx.translate(-offsetX, -offsetY);\n      groupCtx.transform.apply(groupCtx, currentTransform);\n\n      if (group.smask) {\n        this.smaskStack.push({\n          canvas: scratchCanvas.canvas,\n          context: groupCtx,\n          offsetX: offsetX,\n          offsetY: offsetY,\n          scaleX: scaleX,\n          scaleY: scaleY,\n          subtype: group.smask.subtype,\n          backdrop: group.smask.backdrop,\n          transferMap: group.smask.transferMap || null,\n          startTransformInverse: null\n        });\n      } else {\n        currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n        currentCtx.translate(offsetX, offsetY);\n        currentCtx.scale(scaleX, scaleY);\n      }\n\n      copyCtxState(currentCtx, groupCtx);\n      this.ctx = groupCtx;\n      this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n      this.groupStack.push(currentCtx);\n      this.groupLevel++;\n      this.current.activeSMask = null;\n    },\n    endGroup: function CanvasGraphics_endGroup(group) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.groupLevel--;\n      var groupCtx = this.ctx;\n      this.ctx = this.groupStack.pop();\n\n      if (this.ctx.imageSmoothingEnabled !== undefined) {\n        this.ctx.imageSmoothingEnabled = false;\n      } else {\n        this.ctx.mozImageSmoothingEnabled = false;\n      }\n\n      if (group.smask) {\n        this.tempSMask = this.smaskStack.pop();\n      } else {\n        this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      }\n\n      this.restore();\n    },\n    beginAnnotations: function CanvasGraphics_beginAnnotations() {\n      this.save();\n\n      if (this.baseTransform) {\n        this.ctx.setTransform.apply(this.ctx, this.baseTransform);\n      }\n    },\n    endAnnotations: function CanvasGraphics_endAnnotations() {\n      this.restore();\n    },\n    beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) {\n      this.save();\n      resetCtxToDefault(this.ctx);\n      this.current = new CanvasExtraState();\n\n      if (Array.isArray(rect) && rect.length === 4) {\n        var width = rect[2] - rect[0];\n        var height = rect[3] - rect[1];\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.clip();\n        this.endPath();\n      }\n\n      this.transform.apply(this, transform);\n      this.transform.apply(this, matrix);\n    },\n    endAnnotation: function CanvasGraphics_endAnnotation() {\n      this.restore();\n    },\n    paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var width = img.width,\n          height = img.height;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var glyph = this.processingType3;\n\n      if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) {\n        if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) {\n          glyph.compiled = compileType3Glyph({\n            data: img.data,\n            width: width,\n            height: height\n          });\n        } else {\n          glyph.compiled = null;\n        }\n      }\n\n      if (glyph && glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n\n      var maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      var maskCtx = maskCanvas.context;\n      maskCtx.save();\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      this.paintInlineImageXObject(maskCanvas.canvas);\n    },\n    paintImageMaskXObjectRepeat: function paintImageMaskXObjectRepeat(imgData, scaleX) {\n      var skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var scaleY = arguments.length > 4 ? arguments[4] : undefined;\n      var positions = arguments.length > 5 ? arguments[5] : undefined;\n\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n      var maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      var maskCtx = maskCanvas.context;\n      maskCtx.save();\n      putBinaryImageMask(maskCtx, imgData);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      var ctx = this.ctx;\n\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\n        ctx.save();\n        ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]);\n        ctx.scale(1, -1);\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n        ctx.restore();\n      }\n    },\n    paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var fillColor = this.current.fillColor;\n      var isPatternFill = this.current.patternFill;\n\n      for (var i = 0, ii = images.length; i < ii; i++) {\n        var image = images[i];\n        var width = image.width,\n            height = image.height;\n        var maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n        var maskCtx = maskCanvas.context;\n        maskCtx.save();\n        putBinaryImageMask(maskCtx, image);\n        maskCtx.globalCompositeOperation = \"source-in\";\n        maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor;\n        maskCtx.fillRect(0, 0, width, height);\n        maskCtx.restore();\n        ctx.save();\n        ctx.transform.apply(ctx, image.transform);\n        ctx.scale(1, -1);\n        ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n        ctx.restore();\n      }\n    },\n    paintImageXObject: function CanvasGraphics_paintImageXObject(objId) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(\"Dependent image isn't ready yet\");\n        return;\n      }\n\n      this.paintInlineImageXObject(imgData);\n    },\n    paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n      if (!imgData) {\n        (0, _util.warn)(\"Dependent image isn't ready yet\");\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var map = [];\n\n      for (var i = 0, ii = positions.length; i < ii; i += 2) {\n        map.push({\n          transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n          x: 0,\n          y: 0,\n          w: width,\n          h: height\n        });\n      }\n\n      this.paintInlineImageXObjectGroup(imgData, map);\n    },\n    paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var width = imgData.width;\n      var height = imgData.height;\n      var ctx = this.ctx;\n      this.save();\n      ctx.scale(1 / width, -1 / height);\n      var currentTransform = ctx.mozCurrentTransformInverse;\n      var a = currentTransform[0],\n          b = currentTransform[1];\n      var widthScale = Math.max(Math.sqrt(a * a + b * b), 1);\n      var c = currentTransform[2],\n          d = currentTransform[3];\n      var heightScale = Math.max(Math.sqrt(c * c + d * d), 1);\n      var imgToPaint, tmpCanvas;\n\n      if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n        imgToPaint = imgData;\n      } else {\n        tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n        var tmpCtx = tmpCanvas.context;\n        putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n        imgToPaint = tmpCanvas.canvas;\n      }\n\n      var paintWidth = width,\n          paintHeight = height;\n      var tmpCanvasId = \"prescale1\";\n\n      while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n        var newWidth = paintWidth,\n            newHeight = paintHeight;\n\n        if (widthScale > 2 && paintWidth > 1) {\n          newWidth = Math.ceil(paintWidth / 2);\n          widthScale /= paintWidth / newWidth;\n        }\n\n        if (heightScale > 2 && paintHeight > 1) {\n          newHeight = Math.ceil(paintHeight / 2);\n          heightScale /= paintHeight / newHeight;\n        }\n\n        tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n        tmpCtx = tmpCanvas.context;\n        tmpCtx.clearRect(0, 0, newWidth, newHeight);\n        tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n        imgToPaint = tmpCanvas.canvas;\n        paintWidth = newWidth;\n        paintHeight = newHeight;\n        tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n      }\n\n      ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height);\n\n      if (this.imageLayer) {\n        var position = this.getCanvasPosition(0, -height);\n        this.imageLayer.appendImage({\n          imgData: imgData,\n          left: position[0],\n          top: position[1],\n          width: width / currentTransform[0],\n          height: height / currentTransform[3]\n        });\n      }\n\n      this.restore();\n    },\n    paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      var ctx = this.ctx;\n      var w = imgData.width;\n      var h = imgData.height;\n      var tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n      var tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData, this.current.transferMaps);\n\n      for (var i = 0, ii = map.length; i < ii; i++) {\n        var entry = map[i];\n        ctx.save();\n        ctx.transform.apply(ctx, entry.transform);\n        ctx.scale(1, -1);\n        ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n\n        if (this.imageLayer) {\n          var position = this.getCanvasPosition(entry.x, entry.y);\n          this.imageLayer.appendImage({\n            imgData: imgData,\n            left: position[0],\n            top: position[1],\n            width: w,\n            height: h\n          });\n        }\n\n        ctx.restore();\n      }\n    },\n    paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() {\n      if (!this.contentVisible) {\n        return;\n      }\n\n      this.ctx.fillRect(0, 0, 1, 1);\n    },\n    markPoint: function CanvasGraphics_markPoint(tag) {},\n    markPointProps: function CanvasGraphics_markPointProps(tag, properties) {},\n    beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {\n      this.markedContentStack.push({\n        visible: true\n      });\n    },\n    beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {\n      if (tag === \"OC\") {\n        this.markedContentStack.push({\n          visible: this.optionalContentConfig.isVisible(properties)\n        });\n      } else {\n        this.markedContentStack.push({\n          visible: true\n        });\n      }\n\n      this.contentVisible = this.isContentVisible();\n    },\n    endMarkedContent: function CanvasGraphics_endMarkedContent() {\n      this.markedContentStack.pop();\n      this.contentVisible = this.isContentVisible();\n    },\n    beginCompat: function CanvasGraphics_beginCompat() {},\n    endCompat: function CanvasGraphics_endCompat() {},\n    consumePath: function CanvasGraphics_consumePath() {\n      var ctx = this.ctx;\n\n      if (this.pendingClip) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(\"evenodd\");\n        } else {\n          ctx.clip();\n        }\n\n        this.pendingClip = null;\n      }\n\n      ctx.beginPath();\n    },\n    getSinglePixelWidth: function getSinglePixelWidth(scale) {\n      if (this._cachedGetSinglePixelWidth === null) {\n        var inverse = this.ctx.mozCurrentTransformInverse;\n        this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3]));\n      }\n\n      return this._cachedGetSinglePixelWidth;\n    },\n    getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) {\n      var transform = this.ctx.mozCurrentTransform;\n      return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]];\n    },\n    isContentVisible: function CanvasGraphics_isContentVisible() {\n      for (var i = this.markedContentStack.length - 1; i >= 0; i--) {\n        if (!this.markedContentStack[i].visible) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  };\n\n  for (var op in _util.OPS) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n\n  return CanvasGraphics;\n}();\n\nexports.CanvasGraphics = CanvasGraphics;\n\n/***/ }),\n/* 208 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getShadingPatternFromIR = getShadingPatternFromIR;\nexports.TilingPattern = void 0;\n\nvar _util = __w_pdfjs_require__(5);\n\nvar ShadingIRs = {};\n\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox || typeof Path2D === \"undefined\") {\n    return;\n  }\n\n  var width = bbox[2] - bbox[0];\n  var height = bbox[3] - bbox[1];\n  var region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\n\nShadingIRs.RadialAxial = {\n  fromIR: function RadialAxial_fromIR(raw) {\n    var type = raw[1];\n    var bbox = raw[2];\n    var colorStops = raw[3];\n    var p0 = raw[4];\n    var p1 = raw[5];\n    var r0 = raw[6];\n    var r1 = raw[7];\n    return {\n      type: \"Pattern\",\n      getPattern: function RadialAxial_getPattern(ctx) {\n        applyBoundingBox(ctx, bbox);\n        var grad;\n\n        if (type === \"axial\") {\n          grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]);\n        } else if (type === \"radial\") {\n          grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1);\n        }\n\n        for (var i = 0, ii = colorStops.length; i < ii; ++i) {\n          var c = colorStops[i];\n          grad.addColorStop(c[0], c[1]);\n        }\n\n        return grad;\n      }\n    };\n  }\n};\n\nvar createMeshCanvas = function createMeshCanvasClosure() {\n  function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n    var coords = context.coords,\n        colors = context.colors;\n    var bytes = data.data,\n        rowSize = data.width * 4;\n    var tmp;\n\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n      tmp = p1;\n      p1 = p2;\n      p2 = tmp;\n      tmp = c1;\n      c1 = c2;\n      c2 = tmp;\n    }\n\n    if (coords[p2 + 1] > coords[p3 + 1]) {\n      tmp = p2;\n      p2 = p3;\n      p3 = tmp;\n      tmp = c2;\n      c2 = c3;\n      c3 = tmp;\n    }\n\n    if (coords[p1 + 1] > coords[p2 + 1]) {\n      tmp = p1;\n      p1 = p2;\n      p2 = tmp;\n      tmp = c1;\n      c1 = c2;\n      c2 = tmp;\n    }\n\n    var x1 = (coords[p1] + context.offsetX) * context.scaleX;\n    var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n    var x2 = (coords[p2] + context.offsetX) * context.scaleX;\n    var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n    var x3 = (coords[p3] + context.offsetX) * context.scaleX;\n    var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n\n    if (y1 >= y3) {\n      return;\n    }\n\n    var c1r = colors[c1],\n        c1g = colors[c1 + 1],\n        c1b = colors[c1 + 2];\n    var c2r = colors[c2],\n        c2g = colors[c2 + 1],\n        c2b = colors[c2 + 2];\n    var c3r = colors[c3],\n        c3g = colors[c3 + 1],\n        c3b = colors[c3 + 2];\n    var minY = Math.round(y1),\n        maxY = Math.round(y3);\n    var xa, car, cag, cab;\n    var xb, cbr, cbg, cbb;\n\n    for (var y = minY; y <= maxY; y++) {\n      if (y < y2) {\n        var _k = void 0;\n\n        if (y < y1) {\n          _k = 0;\n        } else if (y1 === y2) {\n          _k = 1;\n        } else {\n          _k = (y1 - y) / (y1 - y2);\n        }\n\n        xa = x1 - (x1 - x2) * _k;\n        car = c1r - (c1r - c2r) * _k;\n        cag = c1g - (c1g - c2g) * _k;\n        cab = c1b - (c1b - c2b) * _k;\n      } else {\n        var _k2 = void 0;\n\n        if (y > y3) {\n          _k2 = 1;\n        } else if (y2 === y3) {\n          _k2 = 0;\n        } else {\n          _k2 = (y2 - y) / (y2 - y3);\n        }\n\n        xa = x2 - (x2 - x3) * _k2;\n        car = c2r - (c2r - c3r) * _k2;\n        cag = c2g - (c2g - c3g) * _k2;\n        cab = c2b - (c2b - c3b) * _k2;\n      }\n\n      var k = void 0;\n\n      if (y < y1) {\n        k = 0;\n      } else if (y > y3) {\n        k = 1;\n      } else {\n        k = (y1 - y) / (y1 - y3);\n      }\n\n      xb = x1 - (x1 - x3) * k;\n      cbr = c1r - (c1r - c3r) * k;\n      cbg = c1g - (c1g - c3g) * k;\n      cbb = c1b - (c1b - c3b) * k;\n      var x1_ = Math.round(Math.min(xa, xb));\n      var x2_ = Math.round(Math.max(xa, xb));\n      var j = rowSize * y + x1_ * 4;\n\n      for (var x = x1_; x <= x2_; x++) {\n        k = (xa - x) / (xa - xb);\n\n        if (k < 0) {\n          k = 0;\n        } else if (k > 1) {\n          k = 1;\n        }\n\n        bytes[j++] = car - (car - cbr) * k | 0;\n        bytes[j++] = cag - (cag - cbg) * k | 0;\n        bytes[j++] = cab - (cab - cbb) * k | 0;\n        bytes[j++] = 255;\n      }\n    }\n  }\n\n  function drawFigure(data, figure, context) {\n    var ps = figure.coords;\n    var cs = figure.colors;\n    var i, ii;\n\n    switch (figure.type) {\n      case \"lattice\":\n        var verticesPerRow = figure.verticesPerRow;\n        var rows = Math.floor(ps.length / verticesPerRow) - 1;\n        var cols = verticesPerRow - 1;\n\n        for (i = 0; i < rows; i++) {\n          var q = i * verticesPerRow;\n\n          for (var j = 0; j < cols; j++, q++) {\n            drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n            drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n          }\n        }\n\n        break;\n\n      case \"triangles\":\n        for (i = 0, ii = ps.length; i < ii; i += 3) {\n          drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n        }\n\n        break;\n\n      default:\n        throw new Error(\"illegal figure\");\n    }\n  }\n\n  function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) {\n    var EXPECTED_SCALE = 1.1;\n    var MAX_PATTERN_SIZE = 3000;\n    var BORDER_SIZE = 2;\n    var offsetX = Math.floor(bounds[0]);\n    var offsetY = Math.floor(bounds[1]);\n    var boundsWidth = Math.ceil(bounds[2]) - offsetX;\n    var boundsHeight = Math.ceil(bounds[3]) - offsetY;\n    var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    var scaleX = boundsWidth / width;\n    var scaleY = boundsHeight / height;\n    var context = {\n      coords: coords,\n      colors: colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    var paddedWidth = width + BORDER_SIZE * 2;\n    var paddedHeight = height + BORDER_SIZE * 2;\n    var canvas, tmpCanvas, i, ii;\n\n    if (webGLContext.isEnabled) {\n      canvas = webGLContext.drawFigures({\n        width: width,\n        height: height,\n        backgroundColor: backgroundColor,\n        figures: figures,\n        context: context\n      });\n      tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n      tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE);\n      canvas = tmpCanvas.canvas;\n    } else {\n      tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n      var tmpCtx = tmpCanvas.context;\n      var data = tmpCtx.createImageData(width, height);\n\n      if (backgroundColor) {\n        var bytes = data.data;\n\n        for (i = 0, ii = bytes.length; i < ii; i += 4) {\n          bytes[i] = backgroundColor[0];\n          bytes[i + 1] = backgroundColor[1];\n          bytes[i + 2] = backgroundColor[2];\n          bytes[i + 3] = 255;\n        }\n      }\n\n      for (i = 0; i < figures.length; i++) {\n        drawFigure(data, figures[i], context);\n      }\n\n      tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n      canvas = tmpCanvas.canvas;\n    }\n\n    return {\n      canvas: canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX: scaleX,\n      scaleY: scaleY\n    };\n  }\n\n  return createMeshCanvas;\n}();\n\nShadingIRs.Mesh = {\n  fromIR: function Mesh_fromIR(raw) {\n    var coords = raw[2];\n    var colors = raw[3];\n    var figures = raw[4];\n    var bounds = raw[5];\n    var matrix = raw[6];\n    var bbox = raw[7];\n    var background = raw[8];\n    return {\n      type: \"Pattern\",\n      getPattern: function Mesh_getPattern(ctx, owner, shadingFill) {\n        applyBoundingBox(ctx, bbox);\n        var scale;\n\n        if (shadingFill) {\n          scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform);\n        } else {\n          scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n\n          if (matrix) {\n            var matrixScale = _util.Util.singularValueDecompose2dScale(matrix);\n\n            scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n          }\n        }\n\n        var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext);\n\n        if (!shadingFill) {\n          ctx.setTransform.apply(ctx, owner.baseTransform);\n\n          if (matrix) {\n            ctx.transform.apply(ctx, matrix);\n          }\n        }\n\n        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n        return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n      }\n    };\n  }\n};\nShadingIRs.Dummy = {\n  fromIR: function Dummy_fromIR() {\n    return {\n      type: \"Pattern\",\n      getPattern: function Dummy_fromIR_getPattern() {\n        return \"hotpink\";\n      }\n    };\n  }\n};\n\nfunction getShadingPatternFromIR(raw) {\n  var shadingIR = ShadingIRs[raw[0]];\n\n  if (!shadingIR) {\n    throw new Error(\"Unknown IR type: \".concat(raw[0]));\n  }\n\n  return shadingIR.fromIR(raw);\n}\n\nvar TilingPattern = function TilingPatternClosure() {\n  var PaintType = {\n    COLORED: 1,\n    UNCOLORED: 2\n  };\n  var MAX_PATTERN_SIZE = 3000;\n\n  function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n    this.type = \"Pattern\";\n    this.ctx = ctx;\n  }\n\n  TilingPattern.prototype = {\n    createPatternCanvas: function TilinPattern_createPatternCanvas(owner) {\n      var operatorList = this.operatorList;\n      var bbox = this.bbox;\n      var xstep = this.xstep;\n      var ystep = this.ystep;\n      var paintType = this.paintType;\n      var tilingType = this.tilingType;\n      var color = this.color;\n      var canvasGraphicsFactory = this.canvasGraphicsFactory;\n      (0, _util.info)(\"TilingType: \" + tilingType);\n      var x0 = bbox[0],\n          y0 = bbox[1],\n          x1 = bbox[2],\n          y1 = bbox[3];\n\n      var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n\n      var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n\n      var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n      var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n      var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n      var tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n      var tmpCtx = tmpCanvas.context;\n      var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n      graphics.groupLevel = owner.groupLevel;\n      this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n      graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n      graphics.transform(1, 0, 0, 1, -x0, -y0);\n      this.clipBbox(graphics, bbox, x0, y0, x1, y1);\n      graphics.executeOperatorList(operatorList);\n      this.ctx.transform(1, 0, 0, 1, x0, y0);\n      this.ctx.scale(1 / dimx.scale, 1 / dimy.scale);\n      return tmpCanvas.canvas;\n    },\n    getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) {\n      step = Math.abs(step);\n      var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize);\n      var size = Math.ceil(step * scale);\n\n      if (size >= maxSize) {\n        size = maxSize;\n      } else {\n        scale = size / step;\n      }\n\n      return {\n        scale: scale,\n        size: size\n      };\n    },\n    clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) {\n      if (Array.isArray(bbox) && bbox.length === 4) {\n        var bboxWidth = x1 - x0;\n        var bboxHeight = y1 - y0;\n        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n        graphics.clip();\n        graphics.endPath();\n      }\n    },\n    setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) {\n      var context = graphics.ctx,\n          current = graphics.current;\n\n      switch (paintType) {\n        case PaintType.COLORED:\n          var ctx = this.ctx;\n          context.fillStyle = ctx.fillStyle;\n          context.strokeStyle = ctx.strokeStyle;\n          current.fillColor = ctx.fillStyle;\n          current.strokeColor = ctx.strokeStyle;\n          break;\n\n        case PaintType.UNCOLORED:\n          var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]);\n\n          context.fillStyle = cssColor;\n          context.strokeStyle = cssColor;\n          current.fillColor = cssColor;\n          current.strokeColor = cssColor;\n          break;\n\n        default:\n          throw new _util.FormatError(\"Unsupported paint type: \".concat(paintType));\n      }\n    },\n    getPattern: function TilingPattern_getPattern(ctx, owner) {\n      ctx = this.ctx;\n      ctx.setTransform.apply(ctx, this.baseTransform);\n      ctx.transform.apply(ctx, this.matrix);\n      var temporaryPatternCanvas = this.createPatternCanvas(owner);\n      return ctx.createPattern(temporaryPatternCanvas, \"repeat\");\n    }\n  };\n  return TilingPattern;\n}();\n\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 209 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GlobalWorkerOptions = void 0;\nvar GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort;\nGlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? \"\" : GlobalWorkerOptions.workerSrc;\n\n/***/ }),\n/* 210 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MessageHandler = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(5);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nvar StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\n\nfunction wrapReason(reason) {\n  if (_typeof(reason) !== \"object\" || reason === null) {\n    return reason;\n  }\n\n  switch (reason.name) {\n    case \"AbortException\":\n      return new _util.AbortException(reason.message);\n\n    case \"MissingPDFException\":\n      return new _util.MissingPDFException(reason.message);\n\n    case \"UnexpectedResponseException\":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n\n    case \"UnknownErrorException\":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\n\nvar MessageHandler = /*#__PURE__*/function () {\n  function MessageHandler(sourceName, targetName, comObj) {\n    var _this = this;\n\n    _classCallCheck(this, MessageHandler);\n\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.postMessageTransfers = true;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n\n    this._onComObjOnMessage = function (event) {\n      var data = event.data;\n\n      if (data.targetName !== _this.sourceName) {\n        return;\n      }\n\n      if (data.stream) {\n        _this._processStreamMessage(data);\n\n        return;\n      }\n\n      if (data.callback) {\n        var callbackId = data.callbackId;\n        var capability = _this.callbackCapabilities[callbackId];\n\n        if (!capability) {\n          throw new Error(\"Cannot resolve callback \".concat(callbackId));\n        }\n\n        delete _this.callbackCapabilities[callbackId];\n\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n\n        return;\n      }\n\n      var action = _this.actionHandler[data.action];\n\n      if (!action) {\n        throw new Error(\"Unknown action from worker: \".concat(data.action));\n      }\n\n      if (data.callbackId) {\n        var cbSourceName = _this.sourceName;\n        var cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n\n      if (data.streamId) {\n        _this._createStreamSink(data);\n\n        return;\n      }\n\n      action(data.data);\n    };\n\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n\n  _createClass(MessageHandler, [{\n    key: \"on\",\n    value: function on(actionName, handler) {\n      var ah = this.actionHandler;\n\n      if (ah[actionName]) {\n        throw new Error(\"There is already an actionName called \\\"\".concat(actionName, \"\\\"\"));\n      }\n\n      ah[actionName] = handler;\n    }\n  }, {\n    key: \"send\",\n    value: function send(actionName, data, transfers) {\n      this._postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        data: data\n      }, transfers);\n    }\n  }, {\n    key: \"sendWithPromise\",\n    value: function sendWithPromise(actionName, data, transfers) {\n      var callbackId = this.callbackId++;\n      var capability = (0, _util.createPromiseCapability)();\n      this.callbackCapabilities[callbackId] = capability;\n\n      try {\n        this._postMessage({\n          sourceName: this.sourceName,\n          targetName: this.targetName,\n          action: actionName,\n          callbackId: callbackId,\n          data: data\n        }, transfers);\n      } catch (ex) {\n        capability.reject(ex);\n      }\n\n      return capability.promise;\n    }\n  }, {\n    key: \"sendWithStream\",\n    value: function sendWithStream(actionName, data, queueingStrategy, transfers) {\n      var _this2 = this;\n\n      var streamId = this.streamId++;\n      var sourceName = this.sourceName;\n      var targetName = this.targetName;\n      var comObj = this.comObj;\n      return new ReadableStream({\n        start: function start(controller) {\n          var startCapability = (0, _util.createPromiseCapability)();\n          _this2.streamControllers[streamId] = {\n            controller: controller,\n            startCall: startCapability,\n            pullCall: null,\n            cancelCall: null,\n            isClosed: false\n          };\n\n          _this2._postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            action: actionName,\n            streamId: streamId,\n            data: data,\n            desiredSize: controller.desiredSize\n          }, transfers);\n\n          return startCapability.promise;\n        },\n        pull: function pull(controller) {\n          var pullCapability = (0, _util.createPromiseCapability)();\n          _this2.streamControllers[streamId].pullCall = pullCapability;\n          comObj.postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.PULL,\n            streamId: streamId,\n            desiredSize: controller.desiredSize\n          });\n          return pullCapability.promise;\n        },\n        cancel: function cancel(reason) {\n          (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n          var cancelCapability = (0, _util.createPromiseCapability)();\n          _this2.streamControllers[streamId].cancelCall = cancelCapability;\n          _this2.streamControllers[streamId].isClosed = true;\n          comObj.postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.CANCEL,\n            streamId: streamId,\n            reason: wrapReason(reason)\n          });\n          return cancelCapability.promise;\n        }\n      }, queueingStrategy);\n    }\n  }, {\n    key: \"_createStreamSink\",\n    value: function _createStreamSink(data) {\n      var self = this;\n      var action = this.actionHandler[data.action];\n      var streamId = data.streamId;\n      var sourceName = this.sourceName;\n      var targetName = data.sourceName;\n      var comObj = this.comObj;\n      var streamSink = {\n        enqueue: function enqueue(chunk) {\n          var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n          var transfers = arguments.length > 2 ? arguments[2] : undefined;\n\n          if (this.isCancelled) {\n            return;\n          }\n\n          var lastDesiredSize = this.desiredSize;\n          this.desiredSize -= size;\n\n          if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n            this.sinkCapability = (0, _util.createPromiseCapability)();\n            this.ready = this.sinkCapability.promise;\n          }\n\n          self._postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.ENQUEUE,\n            streamId: streamId,\n            chunk: chunk\n          }, transfers);\n        },\n        close: function close() {\n          if (this.isCancelled) {\n            return;\n          }\n\n          this.isCancelled = true;\n          comObj.postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.CLOSE,\n            streamId: streamId\n          });\n          delete self.streamSinks[streamId];\n        },\n        error: function error(reason) {\n          (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n\n          if (this.isCancelled) {\n            return;\n          }\n\n          this.isCancelled = true;\n          comObj.postMessage({\n            sourceName: sourceName,\n            targetName: targetName,\n            stream: StreamKind.ERROR,\n            streamId: streamId,\n            reason: wrapReason(reason)\n          });\n        },\n        sinkCapability: (0, _util.createPromiseCapability)(),\n        onPull: null,\n        onCancel: null,\n        isCancelled: false,\n        desiredSize: data.desiredSize,\n        ready: null\n      };\n      streamSink.sinkCapability.resolve();\n      streamSink.ready = streamSink.sinkCapability.promise;\n      this.streamSinks[streamId] = streamSink;\n      new Promise(function (resolve) {\n        resolve(action(data.data, streamSink));\n      }).then(function () {\n        comObj.postMessage({\n          sourceName: sourceName,\n          targetName: targetName,\n          stream: StreamKind.START_COMPLETE,\n          streamId: streamId,\n          success: true\n        });\n      }, function (reason) {\n        comObj.postMessage({\n          sourceName: sourceName,\n          targetName: targetName,\n          stream: StreamKind.START_COMPLETE,\n          streamId: streamId,\n          reason: wrapReason(reason)\n        });\n      });\n    }\n  }, {\n    key: \"_processStreamMessage\",\n    value: function _processStreamMessage(data) {\n      var streamId = data.streamId;\n      var sourceName = this.sourceName;\n      var targetName = data.sourceName;\n      var comObj = this.comObj;\n\n      switch (data.stream) {\n        case StreamKind.START_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].startCall.resolve();\n          } else {\n            this.streamControllers[streamId].startCall.reject(wrapReason(data.reason));\n          }\n\n          break;\n\n        case StreamKind.PULL_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].pullCall.resolve();\n          } else {\n            this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason));\n          }\n\n          break;\n\n        case StreamKind.PULL:\n          if (!this.streamSinks[streamId]) {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId: streamId,\n              success: true\n            });\n            break;\n          }\n\n          if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) {\n            this.streamSinks[streamId].sinkCapability.resolve();\n          }\n\n          this.streamSinks[streamId].desiredSize = data.desiredSize;\n          var onPull = this.streamSinks[data.streamId].onPull;\n          new Promise(function (resolve) {\n            resolve(onPull && onPull());\n          }).then(function () {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId: streamId,\n              success: true\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.PULL_COMPLETE,\n              streamId: streamId,\n              reason: wrapReason(reason)\n            });\n          });\n          break;\n\n        case StreamKind.ENQUEUE:\n          (0, _util.assert)(this.streamControllers[streamId], \"enqueue should have stream controller\");\n\n          if (this.streamControllers[streamId].isClosed) {\n            break;\n          }\n\n          this.streamControllers[streamId].controller.enqueue(data.chunk);\n          break;\n\n        case StreamKind.CLOSE:\n          (0, _util.assert)(this.streamControllers[streamId], \"close should have stream controller\");\n\n          if (this.streamControllers[streamId].isClosed) {\n            break;\n          }\n\n          this.streamControllers[streamId].isClosed = true;\n          this.streamControllers[streamId].controller.close();\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.ERROR:\n          (0, _util.assert)(this.streamControllers[streamId], \"error should have stream controller\");\n          this.streamControllers[streamId].controller.error(wrapReason(data.reason));\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.CANCEL_COMPLETE:\n          if (data.success) {\n            this.streamControllers[streamId].cancelCall.resolve();\n          } else {\n            this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason));\n          }\n\n          this._deleteStreamController(streamId);\n\n          break;\n\n        case StreamKind.CANCEL:\n          if (!this.streamSinks[streamId]) {\n            break;\n          }\n\n          var onCancel = this.streamSinks[data.streamId].onCancel;\n          new Promise(function (resolve) {\n            resolve(onCancel && onCancel(wrapReason(data.reason)));\n          }).then(function () {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.CANCEL_COMPLETE,\n              streamId: streamId,\n              success: true\n            });\n          }, function (reason) {\n            comObj.postMessage({\n              sourceName: sourceName,\n              targetName: targetName,\n              stream: StreamKind.CANCEL_COMPLETE,\n              streamId: streamId,\n              reason: wrapReason(reason)\n            });\n          });\n          this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason));\n          this.streamSinks[streamId].isCancelled = true;\n          delete this.streamSinks[streamId];\n          break;\n\n        default:\n          throw new Error(\"Unexpected stream case\");\n      }\n    }\n  }, {\n    key: \"_deleteStreamController\",\n    value: function () {\n      var _deleteStreamController2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(streamId) {\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) {\n                  return capability && capability.promise;\n                }));\n\n              case 2:\n                delete this.streamControllers[streamId];\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _deleteStreamController(_x) {\n        return _deleteStreamController2.apply(this, arguments);\n      }\n\n      return _deleteStreamController;\n    }()\n  }, {\n    key: \"_postMessage\",\n    value: function _postMessage(message, transfers) {\n      if (transfers && this.postMessageTransfers) {\n        this.comObj.postMessage(message, transfers);\n      } else {\n        this.comObj.postMessage(message);\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n    }\n  }]);\n\n  return MessageHandler;\n}();\n\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 211 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Metadata = void 0;\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _xml_parser = __w_pdfjs_require__(212);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar Metadata = /*#__PURE__*/function () {\n  function Metadata(data) {\n    _classCallCheck(this, Metadata);\n\n    (0, _util.assert)(typeof data === \"string\", \"Metadata: input is not a string\");\n    data = this._repair(data);\n    var parser = new _xml_parser.SimpleXMLParser();\n    var xmlDocument = parser.parseFromString(data);\n    this._metadataMap = new Map();\n\n    if (xmlDocument) {\n      this._parse(xmlDocument);\n    }\n  }\n\n  _createClass(Metadata, [{\n    key: \"_repair\",\n    value: function _repair(data) {\n      return data.replace(/^[^<]+/, \"\").replace(/>\\\\376\\\\377([^<]+)/g, function (all, codes) {\n        var bytes = codes.replace(/\\\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) {\n          return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1);\n        }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) {\n          switch (name) {\n            case \"amp\":\n              return \"&\";\n\n            case \"apos\":\n              return \"'\";\n\n            case \"gt\":\n              return \">\";\n\n            case \"lt\":\n              return \"<\";\n\n            case \"quot\":\n              return '\"';\n          }\n\n          throw new Error(\"_repair: \".concat(name, \" isn't defined.\"));\n        });\n        var chars = \"\";\n\n        for (var i = 0, ii = bytes.length; i < ii; i += 2) {\n          var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1);\n\n          if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) {\n            chars += String.fromCharCode(code);\n          } else {\n            chars += \"&#x\" + (0x10000 + code).toString(16).substring(1) + \";\";\n          }\n        }\n\n        return \">\" + chars;\n      });\n    }\n  }, {\n    key: \"_parse\",\n    value: function _parse(xmlDocument) {\n      var rdf = xmlDocument.documentElement;\n\n      if (rdf.nodeName.toLowerCase() !== \"rdf:rdf\") {\n        rdf = rdf.firstChild;\n\n        while (rdf && rdf.nodeName.toLowerCase() !== \"rdf:rdf\") {\n          rdf = rdf.nextSibling;\n        }\n      }\n\n      var nodeName = rdf ? rdf.nodeName.toLowerCase() : null;\n\n      if (!rdf || nodeName !== \"rdf:rdf\" || !rdf.hasChildNodes()) {\n        return;\n      }\n\n      var children = rdf.childNodes;\n\n      for (var i = 0, ii = children.length; i < ii; i++) {\n        var desc = children[i];\n\n        if (desc.nodeName.toLowerCase() !== \"rdf:description\") {\n          continue;\n        }\n\n        for (var j = 0, jj = desc.childNodes.length; j < jj; j++) {\n          if (desc.childNodes[j].nodeName.toLowerCase() !== \"#text\") {\n            var entry = desc.childNodes[j];\n            var name = entry.nodeName.toLowerCase();\n\n            this._metadataMap.set(name, entry.textContent.trim());\n          }\n        }\n      }\n    }\n  }, {\n    key: \"get\",\n    value: function get(name) {\n      return this._metadataMap.has(name) ? this._metadataMap.get(name) : null;\n    }\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      return Object.fromEntries(this._metadataMap);\n    }\n  }, {\n    key: \"has\",\n    value: function has(name) {\n      return this._metadataMap.has(name);\n    }\n  }]);\n\n  return Metadata;\n}();\n\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 212 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleXMLParser = void 0;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar XMLParserErrorCode = {\n  NoError: 0,\n  EndOfDocument: -1,\n  UnterminatedCdat: -2,\n  UnterminatedXmlDeclaration: -3,\n  UnterminatedDoctypeDeclaration: -4,\n  UnterminatedComment: -5,\n  MalformedElement: -6,\n  OutOfMemory: -7,\n  UnterminatedAttributeValue: -8,\n  UnterminatedElement: -9,\n  ElementNeverBegun: -10\n};\n\nfunction isWhitespace(s, index) {\n  var ch = s[index];\n  return ch === \" \" || ch === \"\\n\" || ch === \"\\r\" || ch === \"\\t\";\n}\n\nfunction isWhitespaceString(s) {\n  for (var i = 0, ii = s.length; i < ii; i++) {\n    if (!isWhitespace(s, i)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar XMLParserBase = /*#__PURE__*/function () {\n  function XMLParserBase() {\n    _classCallCheck(this, XMLParserBase);\n  }\n\n  _createClass(XMLParserBase, [{\n    key: \"_resolveEntities\",\n    value: function _resolveEntities(s) {\n      var _this = this;\n\n      return s.replace(/&([^;]+);/g, function (all, entity) {\n        if (entity.substring(0, 2) === \"#x\") {\n          return String.fromCharCode(parseInt(entity.substring(2), 16));\n        } else if (entity.substring(0, 1) === \"#\") {\n          return String.fromCharCode(parseInt(entity.substring(1), 10));\n        }\n\n        switch (entity) {\n          case \"lt\":\n            return \"<\";\n\n          case \"gt\":\n            return \">\";\n\n          case \"amp\":\n            return \"&\";\n\n          case \"quot\":\n            return '\"';\n        }\n\n        return _this.onResolveEntity(entity);\n      });\n    }\n  }, {\n    key: \"_parseContent\",\n    value: function _parseContent(s, start) {\n      var attributes = [];\n      var pos = start;\n\n      function skipWs() {\n        while (pos < s.length && isWhitespace(s, pos)) {\n          ++pos;\n        }\n      }\n\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\n        ++pos;\n      }\n\n      var name = s.substring(start, pos);\n      skipWs();\n\n      while (pos < s.length && s[pos] !== \">\" && s[pos] !== \"/\" && s[pos] !== \"?\") {\n        skipWs();\n        var attrName = \"\",\n            attrValue = \"\";\n\n        while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \"=\") {\n          attrName += s[pos];\n          ++pos;\n        }\n\n        skipWs();\n\n        if (s[pos] !== \"=\") {\n          return null;\n        }\n\n        ++pos;\n        skipWs();\n        var attrEndChar = s[pos];\n\n        if (attrEndChar !== '\"' && attrEndChar !== \"'\") {\n          return null;\n        }\n\n        var attrEndIndex = s.indexOf(attrEndChar, ++pos);\n\n        if (attrEndIndex < 0) {\n          return null;\n        }\n\n        attrValue = s.substring(pos, attrEndIndex);\n        attributes.push({\n          name: attrName,\n          value: this._resolveEntities(attrValue)\n        });\n        pos = attrEndIndex + 1;\n        skipWs();\n      }\n\n      return {\n        name: name,\n        attributes: attributes,\n        parsed: pos - start\n      };\n    }\n  }, {\n    key: \"_parseProcessingInstruction\",\n    value: function _parseProcessingInstruction(s, start) {\n      var pos = start;\n\n      function skipWs() {\n        while (pos < s.length && isWhitespace(s, pos)) {\n          ++pos;\n        }\n      }\n\n      while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== \">\" && s[pos] !== \"/\") {\n        ++pos;\n      }\n\n      var name = s.substring(start, pos);\n      skipWs();\n      var attrStart = pos;\n\n      while (pos < s.length && (s[pos] !== \"?\" || s[pos + 1] !== \">\")) {\n        ++pos;\n      }\n\n      var value = s.substring(attrStart, pos);\n      return {\n        name: name,\n        value: value,\n        parsed: pos - start\n      };\n    }\n  }, {\n    key: \"parseXml\",\n    value: function parseXml(s) {\n      var i = 0;\n\n      while (i < s.length) {\n        var ch = s[i];\n        var j = i;\n\n        if (ch === \"<\") {\n          ++j;\n          var ch2 = s[j];\n          var q = void 0;\n\n          switch (ch2) {\n            case \"/\":\n              ++j;\n              q = s.indexOf(\">\", j);\n\n              if (q < 0) {\n                this.onError(XMLParserErrorCode.UnterminatedElement);\n                return;\n              }\n\n              this.onEndElement(s.substring(j, q));\n              j = q + 1;\n              break;\n\n            case \"?\":\n              ++j;\n\n              var pi = this._parseProcessingInstruction(s, j);\n\n              if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== \"?>\") {\n                this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration);\n                return;\n              }\n\n              this.onPi(pi.name, pi.value);\n              j += pi.parsed + 2;\n              break;\n\n            case \"!\":\n              if (s.substring(j + 1, j + 3) === \"--\") {\n                q = s.indexOf(\"-->\", j + 3);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedComment);\n                  return;\n                }\n\n                this.onComment(s.substring(j + 3, q));\n                j = q + 3;\n              } else if (s.substring(j + 1, j + 8) === \"[CDATA[\") {\n                q = s.indexOf(\"]]>\", j + 8);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedCdat);\n                  return;\n                }\n\n                this.onCdata(s.substring(j + 8, q));\n                j = q + 3;\n              } else if (s.substring(j + 1, j + 8) === \"DOCTYPE\") {\n                var q2 = s.indexOf(\"[\", j + 8);\n                var complexDoctype = false;\n                q = s.indexOf(\">\", j + 8);\n\n                if (q < 0) {\n                  this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                  return;\n                }\n\n                if (q2 > 0 && q > q2) {\n                  q = s.indexOf(\"]>\", j + 8);\n\n                  if (q < 0) {\n                    this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration);\n                    return;\n                  }\n\n                  complexDoctype = true;\n                }\n\n                var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0));\n                this.onDoctype(doctypeContent);\n                j = q + (complexDoctype ? 2 : 1);\n              } else {\n                this.onError(XMLParserErrorCode.MalformedElement);\n                return;\n              }\n\n              break;\n\n            default:\n              var content = this._parseContent(s, j);\n\n              if (content === null) {\n                this.onError(XMLParserErrorCode.MalformedElement);\n                return;\n              }\n\n              var isClosed = false;\n\n              if (s.substring(j + content.parsed, j + content.parsed + 2) === \"/>\") {\n                isClosed = true;\n              } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== \">\") {\n                this.onError(XMLParserErrorCode.UnterminatedElement);\n                return;\n              }\n\n              this.onBeginElement(content.name, content.attributes, isClosed);\n              j += content.parsed + (isClosed ? 2 : 1);\n              break;\n          }\n        } else {\n          while (j < s.length && s[j] !== \"<\") {\n            j++;\n          }\n\n          var text = s.substring(i, j);\n          this.onText(this._resolveEntities(text));\n        }\n\n        i = j;\n      }\n    }\n  }, {\n    key: \"onResolveEntity\",\n    value: function onResolveEntity(name) {\n      return \"&\".concat(name, \";\");\n    }\n  }, {\n    key: \"onPi\",\n    value: function onPi(name, value) {}\n  }, {\n    key: \"onComment\",\n    value: function onComment(text) {}\n  }, {\n    key: \"onCdata\",\n    value: function onCdata(text) {}\n  }, {\n    key: \"onDoctype\",\n    value: function onDoctype(doctypeContent) {}\n  }, {\n    key: \"onText\",\n    value: function onText(text) {}\n  }, {\n    key: \"onBeginElement\",\n    value: function onBeginElement(name, attributes, isEmpty) {}\n  }, {\n    key: \"onEndElement\",\n    value: function onEndElement(name) {}\n  }, {\n    key: \"onError\",\n    value: function onError(code) {}\n  }]);\n\n  return XMLParserBase;\n}();\n\nvar SimpleDOMNode = /*#__PURE__*/function () {\n  function SimpleDOMNode(nodeName, nodeValue) {\n    _classCallCheck(this, SimpleDOMNode);\n\n    this.nodeName = nodeName;\n    this.nodeValue = nodeValue;\n    Object.defineProperty(this, \"parentNode\", {\n      value: null,\n      writable: true\n    });\n  }\n\n  _createClass(SimpleDOMNode, [{\n    key: \"hasChildNodes\",\n    value: function hasChildNodes() {\n      return this.childNodes && this.childNodes.length > 0;\n    }\n  }, {\n    key: \"firstChild\",\n    get: function get() {\n      return this.childNodes && this.childNodes[0];\n    }\n  }, {\n    key: \"nextSibling\",\n    get: function get() {\n      var childNodes = this.parentNode.childNodes;\n\n      if (!childNodes) {\n        return undefined;\n      }\n\n      var index = childNodes.indexOf(this);\n\n      if (index === -1) {\n        return undefined;\n      }\n\n      return childNodes[index + 1];\n    }\n  }, {\n    key: \"textContent\",\n    get: function get() {\n      if (!this.childNodes) {\n        return this.nodeValue || \"\";\n      }\n\n      return this.childNodes.map(function (child) {\n        return child.textContent;\n      }).join(\"\");\n    }\n  }]);\n\n  return SimpleDOMNode;\n}();\n\nvar SimpleXMLParser = /*#__PURE__*/function (_XMLParserBase) {\n  _inherits(SimpleXMLParser, _XMLParserBase);\n\n  var _super = _createSuper(SimpleXMLParser);\n\n  function SimpleXMLParser() {\n    var _this2;\n\n    _classCallCheck(this, SimpleXMLParser);\n\n    _this2 = _super.call(this);\n    _this2._currentFragment = null;\n    _this2._stack = null;\n    _this2._errorCode = XMLParserErrorCode.NoError;\n    return _this2;\n  }\n\n  _createClass(SimpleXMLParser, [{\n    key: \"parseFromString\",\n    value: function parseFromString(data) {\n      this._currentFragment = [];\n      this._stack = [];\n      this._errorCode = XMLParserErrorCode.NoError;\n      this.parseXml(data);\n\n      if (this._errorCode !== XMLParserErrorCode.NoError) {\n        return undefined;\n      }\n\n      var _this$_currentFragmen = _slicedToArray(this._currentFragment, 1),\n          documentElement = _this$_currentFragmen[0];\n\n      if (!documentElement) {\n        return undefined;\n      }\n\n      return {\n        documentElement: documentElement\n      };\n    }\n  }, {\n    key: \"onResolveEntity\",\n    value: function onResolveEntity(name) {\n      switch (name) {\n        case \"apos\":\n          return \"'\";\n      }\n\n      return _get(_getPrototypeOf(SimpleXMLParser.prototype), \"onResolveEntity\", this).call(this, name);\n    }\n  }, {\n    key: \"onText\",\n    value: function onText(text) {\n      if (isWhitespaceString(text)) {\n        return;\n      }\n\n      var node = new SimpleDOMNode(\"#text\", text);\n\n      this._currentFragment.push(node);\n    }\n  }, {\n    key: \"onCdata\",\n    value: function onCdata(text) {\n      var node = new SimpleDOMNode(\"#text\", text);\n\n      this._currentFragment.push(node);\n    }\n  }, {\n    key: \"onBeginElement\",\n    value: function onBeginElement(name, attributes, isEmpty) {\n      var node = new SimpleDOMNode(name);\n      node.childNodes = [];\n\n      this._currentFragment.push(node);\n\n      if (isEmpty) {\n        return;\n      }\n\n      this._stack.push(this._currentFragment);\n\n      this._currentFragment = node.childNodes;\n    }\n  }, {\n    key: \"onEndElement\",\n    value: function onEndElement(name) {\n      this._currentFragment = this._stack.pop() || [];\n      var lastElement = this._currentFragment[this._currentFragment.length - 1];\n\n      if (!lastElement) {\n        return;\n      }\n\n      for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) {\n        lastElement.childNodes[i].parentNode = lastElement;\n      }\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(code) {\n      this._errorCode = code;\n    }\n  }]);\n\n  return SimpleXMLParser;\n}(XMLParserBase);\n\nexports.SimpleXMLParser = SimpleXMLParser;\n\n/***/ }),\n/* 213 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OptionalContentConfig = void 0;\n\nvar _util = __w_pdfjs_require__(5);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar OptionalContentGroup = function OptionalContentGroup(name, intent) {\n  _classCallCheck(this, OptionalContentGroup);\n\n  this.visible = true;\n  this.name = name;\n  this.intent = intent;\n};\n\nvar OptionalContentConfig = /*#__PURE__*/function () {\n  function OptionalContentConfig(data) {\n    _classCallCheck(this, OptionalContentConfig);\n\n    this.name = null;\n    this.creator = null;\n    this._order = null;\n    this._groups = new Map();\n\n    if (data === null) {\n      return;\n    }\n\n    this.name = data.name;\n    this.creator = data.creator;\n    this._order = data.order;\n\n    var _iterator = _createForOfIteratorHelper(data.groups),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _group = _step.value;\n\n        this._groups.set(_group.id, new OptionalContentGroup(_group.name, _group.intent));\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    if (data.baseState === \"OFF\") {\n      var _iterator2 = _createForOfIteratorHelper(this._groups),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var group = _step2.value;\n          group.visible = false;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n\n    var _iterator3 = _createForOfIteratorHelper(data.on),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var on = _step3.value;\n        this._groups.get(on).visible = true;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    var _iterator4 = _createForOfIteratorHelper(data.off),\n        _step4;\n\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var off = _step4.value;\n        this._groups.get(off).visible = false;\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  _createClass(OptionalContentConfig, [{\n    key: \"isVisible\",\n    value: function isVisible(group) {\n      if (group.type === \"OCG\") {\n        if (!this._groups.has(group.id)) {\n          (0, _util.warn)(\"Optional content group not found: \".concat(group.id));\n          return true;\n        }\n\n        return this._groups.get(group.id).visible;\n      } else if (group.type === \"OCMD\") {\n        if (group.expression) {\n          (0, _util.warn)(\"Visibility expression not supported yet.\");\n        }\n\n        if (!group.policy || group.policy === \"AnyOn\") {\n          var _iterator5 = _createForOfIteratorHelper(group.ids),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var id = _step5.value;\n\n              if (!this._groups.has(id)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(id));\n                return true;\n              }\n\n              if (this._groups.get(id).visible) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          return false;\n        } else if (group.policy === \"AllOn\") {\n          var _iterator6 = _createForOfIteratorHelper(group.ids),\n              _step6;\n\n          try {\n            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n              var _id = _step6.value;\n\n              if (!this._groups.has(_id)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(_id));\n                return true;\n              }\n\n              if (!this._groups.get(_id).visible) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _iterator6.e(err);\n          } finally {\n            _iterator6.f();\n          }\n\n          return true;\n        } else if (group.policy === \"AnyOff\") {\n          var _iterator7 = _createForOfIteratorHelper(group.ids),\n              _step7;\n\n          try {\n            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n              var _id2 = _step7.value;\n\n              if (!this._groups.has(_id2)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(_id2));\n                return true;\n              }\n\n              if (!this._groups.get(_id2).visible) {\n                return true;\n              }\n            }\n          } catch (err) {\n            _iterator7.e(err);\n          } finally {\n            _iterator7.f();\n          }\n\n          return false;\n        } else if (group.policy === \"AllOff\") {\n          var _iterator8 = _createForOfIteratorHelper(group.ids),\n              _step8;\n\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var _id3 = _step8.value;\n\n              if (!this._groups.has(_id3)) {\n                (0, _util.warn)(\"Optional content group not found: \".concat(_id3));\n                return true;\n              }\n\n              if (this._groups.get(_id3).visible) {\n                return false;\n              }\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n\n          return true;\n        }\n\n        (0, _util.warn)(\"Unknown optional content policy \".concat(group.policy, \".\"));\n        return true;\n      }\n\n      (0, _util.warn)(\"Unknown group type \".concat(group.type, \".\"));\n      return true;\n    }\n  }, {\n    key: \"setVisibility\",\n    value: function setVisibility(id) {\n      var visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      if (!this._groups.has(id)) {\n        (0, _util.warn)(\"Optional content group not found: \".concat(id));\n        return;\n      }\n\n      this._groups.get(id).visible = !!visible;\n    }\n  }, {\n    key: \"getOrder\",\n    value: function getOrder() {\n      if (!this._groups.size) {\n        return null;\n      }\n\n      if (this._order) {\n        return this._order.slice();\n      }\n\n      return Array.from(this._groups.keys());\n    }\n  }, {\n    key: \"getGroups\",\n    value: function getGroups() {\n      if (!this._groups.size) {\n        return null;\n      }\n\n      return Object.fromEntries(this._groups);\n    }\n  }, {\n    key: \"getGroup\",\n    value: function getGroup(id) {\n      return this._groups.get(id) || null;\n    }\n  }]);\n\n  return OptionalContentConfig;\n}();\n\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 214 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFDataTransportStream = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(5);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar PDFDataTransportStream = /*#__PURE__*/function () {\n  function PDFDataTransportStream(params, pdfDataRangeTransport) {\n    var _this = this;\n\n    _classCallCheck(this, PDFDataTransportStream);\n\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    this._queuedChunks = [];\n    this._progressiveDone = params.progressiveDone || false;\n    var initialData = params.initialData;\n\n    if (initialData && initialData.length > 0) {\n      var buffer = new Uint8Array(initialData).buffer;\n\n      this._queuedChunks.push(buffer);\n    }\n\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !params.disableStream;\n    this._isRangeSupported = !params.disableRange;\n    this._contentLength = params.length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n\n    this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) {\n      _this._onReceiveData({\n        begin: begin,\n        chunk: chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressListener(function (loaded, total) {\n      _this._onProgress({\n        loaded: loaded,\n        total: total\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) {\n      _this._onReceiveData({\n        chunk: chunk\n      });\n    });\n\n    this._pdfDataRangeTransport.addProgressiveDoneListener(function () {\n      _this._onProgressiveDone();\n    });\n\n    this._pdfDataRangeTransport.transportReady();\n  }\n\n  _createClass(PDFDataTransportStream, [{\n    key: \"_onReceiveData\",\n    value: function _onReceiveData(args) {\n      var buffer = new Uint8Array(args.chunk).buffer;\n\n      if (args.begin === undefined) {\n        if (this._fullRequestReader) {\n          this._fullRequestReader._enqueue(buffer);\n        } else {\n          this._queuedChunks.push(buffer);\n        }\n      } else {\n        var found = this._rangeReaders.some(function (rangeReader) {\n          if (rangeReader._begin !== args.begin) {\n            return false;\n          }\n\n          rangeReader._enqueue(buffer);\n\n          return true;\n        });\n\n        (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n      }\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(evt) {\n      if (evt.total === undefined) {\n        var firstReader = this._rangeReaders[0];\n\n        if (firstReader && firstReader.onProgress) {\n          firstReader.onProgress({\n            loaded: evt.loaded\n          });\n        }\n      } else {\n        var fullReader = this._fullRequestReader;\n\n        if (fullReader && fullReader.onProgress) {\n          fullReader.onProgress({\n            loaded: evt.loaded,\n            total: evt.total\n          });\n        }\n      }\n    }\n  }, {\n    key: \"_onProgressiveDone\",\n    value: function _onProgressiveDone() {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.progressiveDone();\n      }\n\n      this._progressiveDone = true;\n    }\n  }, {\n    key: \"_removeRangeReader\",\n    value: function _removeRangeReader(reader) {\n      var i = this._rangeReaders.indexOf(reader);\n\n      if (i >= 0) {\n        this._rangeReaders.splice(i, 1);\n      }\n    }\n  }, {\n    key: \"getFullReader\",\n    value: function getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n      var queuedChunks = this._queuedChunks;\n      this._queuedChunks = null;\n      return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone);\n    }\n  }, {\n    key: \"getRangeReader\",\n    value: function getRangeReader(begin, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      var reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n\n      this._pdfDataRangeTransport.requestDataRange(begin, end);\n\n      this._rangeReaders.push(reader);\n\n      return reader;\n    }\n  }, {\n    key: \"cancelAllRequests\",\n    value: function cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      var readers = this._rangeReaders.slice(0);\n\n      readers.forEach(function (rangeReader) {\n        rangeReader.cancel(reason);\n      });\n\n      this._pdfDataRangeTransport.abort();\n    }\n  }, {\n    key: \"_progressiveDataLength\",\n    get: function get() {\n      return this._fullRequestReader ? this._fullRequestReader._loaded : 0;\n    }\n  }]);\n\n  return PDFDataTransportStream;\n}();\n\nexports.PDFDataTransportStream = PDFDataTransportStream;\n\nvar PDFDataTransportStreamReader = /*#__PURE__*/function () {\n  function PDFDataTransportStreamReader(stream, queuedChunks) {\n    var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, PDFDataTransportStreamReader);\n\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n\n    var _iterator = _createForOfIteratorHelper(this._queuedChunks),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var chunk = _step.value;\n        this._loaded += chunk.byteLength;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n\n  _createClass(PDFDataTransportStreamReader, [{\n    key: \"_enqueue\",\n    value: function _enqueue(chunk) {\n      if (this._done) {\n        return;\n      }\n\n      if (this._requests.length > 0) {\n        var requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: chunk,\n          done: false\n        });\n      } else {\n        this._queuedChunks.push(chunk);\n      }\n\n      this._loaded += chunk.byteLength;\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var chunk, requestCapability;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(this._queuedChunks.length > 0)) {\n                  _context.next = 3;\n                  break;\n                }\n\n                chunk = this._queuedChunks.shift();\n                return _context.abrupt(\"return\", {\n                  value: chunk,\n                  done: false\n                });\n\n              case 3:\n                if (!this._done) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 5:\n                requestCapability = (0, _util.createPromiseCapability)();\n\n                this._requests.push(requestCapability);\n\n                return _context.abrupt(\"return\", requestCapability.promise);\n\n              case 8:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read() {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n    }\n  }, {\n    key: \"progressiveDone\",\n    value: function progressiveDone() {\n      if (this._done) {\n        return;\n      }\n\n      this._done = true;\n    }\n  }, {\n    key: \"headersReady\",\n    get: function get() {\n      return this._headersReady;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._filename;\n    }\n  }, {\n    key: \"isRangeSupported\",\n    get: function get() {\n      return this._stream._isRangeSupported;\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._stream._isStreamingSupported;\n    }\n  }, {\n    key: \"contentLength\",\n    get: function get() {\n      return this._stream._contentLength;\n    }\n  }]);\n\n  return PDFDataTransportStreamReader;\n}();\n\nvar PDFDataTransportStreamRangeReader = /*#__PURE__*/function () {\n  function PDFDataTransportStreamRangeReader(stream, begin, end) {\n    _classCallCheck(this, PDFDataTransportStreamRangeReader);\n\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n\n  _createClass(PDFDataTransportStreamRangeReader, [{\n    key: \"_enqueue\",\n    value: function _enqueue(chunk) {\n      if (this._done) {\n        return;\n      }\n\n      if (this._requests.length === 0) {\n        this._queuedChunk = chunk;\n      } else {\n        var requestsCapability = this._requests.shift();\n\n        requestsCapability.resolve({\n          value: chunk,\n          done: false\n        });\n\n        this._requests.forEach(function (requestCapability) {\n          requestCapability.resolve({\n            value: undefined,\n            done: true\n          });\n        });\n\n        this._requests = [];\n      }\n\n      this._done = true;\n\n      this._stream._removeRangeReader(this);\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var chunk, requestCapability;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!this._queuedChunk) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                chunk = this._queuedChunk;\n                this._queuedChunk = null;\n                return _context2.abrupt(\"return\", {\n                  value: chunk,\n                  done: false\n                });\n\n              case 4:\n                if (!this._done) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 6:\n                requestCapability = (0, _util.createPromiseCapability)();\n\n                this._requests.push(requestCapability);\n\n                return _context2.abrupt(\"return\", requestCapability.promise);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read() {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      this._stream._removeRangeReader(this);\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return PDFDataTransportStreamRangeReader;\n}();\n\n/***/ }),\n/* 215 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebGLContext = void 0;\n\nvar _util = __w_pdfjs_require__(5);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar WebGLContext = /*#__PURE__*/function () {\n  function WebGLContext(_ref) {\n    var _ref$enable = _ref.enable,\n        enable = _ref$enable === void 0 ? false : _ref$enable;\n\n    _classCallCheck(this, WebGLContext);\n\n    this._enabled = enable === true;\n  }\n\n  _createClass(WebGLContext, [{\n    key: \"composeSMask\",\n    value: function composeSMask(_ref2) {\n      var layer = _ref2.layer,\n          mask = _ref2.mask,\n          properties = _ref2.properties;\n      return WebGLUtils.composeSMask(layer, mask, properties);\n    }\n  }, {\n    key: \"drawFigures\",\n    value: function drawFigures(_ref3) {\n      var width = _ref3.width,\n          height = _ref3.height,\n          backgroundColor = _ref3.backgroundColor,\n          figures = _ref3.figures,\n          context = _ref3.context;\n      return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context);\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      WebGLUtils.cleanup();\n    }\n  }, {\n    key: \"isEnabled\",\n    get: function get() {\n      var enabled = this._enabled;\n\n      if (enabled) {\n        enabled = WebGLUtils.tryInitGL();\n      }\n\n      return (0, _util.shadow)(this, \"isEnabled\", enabled);\n    }\n  }]);\n\n  return WebGLContext;\n}();\n\nexports.WebGLContext = WebGLContext;\n\nvar WebGLUtils = function WebGLUtilsClosure() {\n  function loadShader(gl, code, shaderType) {\n    var shader = gl.createShader(shaderType);\n    gl.shaderSource(shader, code);\n    gl.compileShader(shader);\n    var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n    if (!compiled) {\n      var errorMsg = gl.getShaderInfoLog(shader);\n      throw new Error(\"Error during shader compilation: \" + errorMsg);\n    }\n\n    return shader;\n  }\n\n  function createVertexShader(gl, code) {\n    return loadShader(gl, code, gl.VERTEX_SHADER);\n  }\n\n  function createFragmentShader(gl, code) {\n    return loadShader(gl, code, gl.FRAGMENT_SHADER);\n  }\n\n  function createProgram(gl, shaders) {\n    var program = gl.createProgram();\n\n    for (var i = 0, ii = shaders.length; i < ii; ++i) {\n      gl.attachShader(program, shaders[i]);\n    }\n\n    gl.linkProgram(program);\n    var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n\n    if (!linked) {\n      var errorMsg = gl.getProgramInfoLog(program);\n      throw new Error(\"Error during program linking: \" + errorMsg);\n    }\n\n    return program;\n  }\n\n  function createTexture(gl, image, textureId) {\n    gl.activeTexture(textureId);\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n    return texture;\n  }\n\n  var currentGL, currentCanvas;\n\n  function generateGL() {\n    if (currentGL) {\n      return;\n    }\n\n    currentCanvas = document.createElement(\"canvas\");\n    currentGL = currentCanvas.getContext(\"webgl\", {\n      premultipliedalpha: false\n    });\n  }\n\n  var smaskVertexShaderCode = \"\\\n  attribute vec2 a_position;                                    \\\n  attribute vec2 a_texCoord;                                    \\\n                                                                \\\n  uniform vec2 u_resolution;                                    \\\n                                                                \\\n  varying vec2 v_texCoord;                                      \\\n                                                                \\\n  void main() {                                                 \\\n    vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0;   \\\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                \\\n    v_texCoord = a_texCoord;                                    \\\n  }                                                             \";\n  var smaskFragmentShaderCode = \"\\\n  precision mediump float;                                      \\\n                                                                \\\n  uniform vec4 u_backdrop;                                      \\\n  uniform int u_subtype;                                        \\\n  uniform sampler2D u_image;                                    \\\n  uniform sampler2D u_mask;                                     \\\n                                                                \\\n  varying vec2 v_texCoord;                                      \\\n                                                                \\\n  void main() {                                                 \\\n    vec4 imageColor = texture2D(u_image, v_texCoord);           \\\n    vec4 maskColor = texture2D(u_mask, v_texCoord);             \\\n    if (u_backdrop.a > 0.0) {                                   \\\n      maskColor.rgb = maskColor.rgb * maskColor.a +             \\\n                      u_backdrop.rgb * (1.0 - maskColor.a);     \\\n    }                                                           \\\n    float lum;                                                  \\\n    if (u_subtype == 0) {                                       \\\n      lum = maskColor.a;                                        \\\n    } else {                                                    \\\n      lum = maskColor.r * 0.3 + maskColor.g * 0.59 +            \\\n            maskColor.b * 0.11;                                 \\\n    }                                                           \\\n    imageColor.a *= lum;                                        \\\n    imageColor.rgb *= imageColor.a;                             \\\n    gl_FragColor = imageColor;                                  \\\n  }                                                             \";\n  var smaskCache = null;\n\n  function initSmaskGL() {\n    var canvas, gl;\n    generateGL();\n    canvas = currentCanvas;\n    currentCanvas = null;\n    gl = currentGL;\n    currentGL = null;\n    var vertexShader = createVertexShader(gl, smaskVertexShaderCode);\n    var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode);\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\n    gl.useProgram(program);\n    var cache = {};\n    cache.gl = gl;\n    cache.canvas = canvas;\n    cache.resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n    cache.positionLocation = gl.getAttribLocation(program, \"a_position\");\n    cache.backdropLocation = gl.getUniformLocation(program, \"u_backdrop\");\n    cache.subtypeLocation = gl.getUniformLocation(program, \"u_subtype\");\n    var texCoordLocation = gl.getAttribLocation(program, \"a_texCoord\");\n    var texLayerLocation = gl.getUniformLocation(program, \"u_image\");\n    var texMaskLocation = gl.getUniformLocation(program, \"u_mask\");\n    var texCoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(texCoordLocation);\n    gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.uniform1i(texLayerLocation, 0);\n    gl.uniform1i(texMaskLocation, 1);\n    smaskCache = cache;\n  }\n\n  function composeSMask(layer, mask, properties) {\n    var width = layer.width,\n        height = layer.height;\n\n    if (!smaskCache) {\n      initSmaskGL();\n    }\n\n    var cache = smaskCache,\n        canvas = cache.canvas,\n        gl = cache.gl;\n    canvas.width = width;\n    canvas.height = height;\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.uniform2f(cache.resolutionLocation, width, height);\n\n    if (properties.backdrop) {\n      gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1);\n    } else {\n      gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0);\n    }\n\n    gl.uniform1i(cache.subtypeLocation, properties.subtype === \"Luminosity\" ? 1 : 0);\n    var texture = createTexture(gl, layer, gl.TEXTURE0);\n    var maskTexture = createTexture(gl, mask, gl.TEXTURE1);\n    var buffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.positionLocation);\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    gl.clearColor(0, 0, 0, 0);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    gl.flush();\n    gl.deleteTexture(texture);\n    gl.deleteTexture(maskTexture);\n    gl.deleteBuffer(buffer);\n    return canvas;\n  }\n\n  var figuresVertexShaderCode = \"\\\n  attribute vec2 a_position;                                    \\\n  attribute vec3 a_color;                                       \\\n                                                                \\\n  uniform vec2 u_resolution;                                    \\\n  uniform vec2 u_scale;                                         \\\n  uniform vec2 u_offset;                                        \\\n                                                                \\\n  varying vec4 v_color;                                         \\\n                                                                \\\n  void main() {                                                 \\\n    vec2 position = (a_position + u_offset) * u_scale;          \\\n    vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0;     \\\n    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);          \\\n                                                                \\\n    v_color = vec4(a_color / 255.0, 1.0);                       \\\n  }                                                             \";\n  var figuresFragmentShaderCode = \"\\\n  precision mediump float;                                      \\\n                                                                \\\n  varying vec4 v_color;                                         \\\n                                                                \\\n  void main() {                                                 \\\n    gl_FragColor = v_color;                                     \\\n  }                                                             \";\n  var figuresCache = null;\n\n  function initFiguresGL() {\n    var canvas, gl;\n    generateGL();\n    canvas = currentCanvas;\n    currentCanvas = null;\n    gl = currentGL;\n    currentGL = null;\n    var vertexShader = createVertexShader(gl, figuresVertexShaderCode);\n    var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode);\n    var program = createProgram(gl, [vertexShader, fragmentShader]);\n    gl.useProgram(program);\n    var cache = {};\n    cache.gl = gl;\n    cache.canvas = canvas;\n    cache.resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n    cache.scaleLocation = gl.getUniformLocation(program, \"u_scale\");\n    cache.offsetLocation = gl.getUniformLocation(program, \"u_offset\");\n    cache.positionLocation = gl.getAttribLocation(program, \"a_position\");\n    cache.colorLocation = gl.getAttribLocation(program, \"a_color\");\n    figuresCache = cache;\n  }\n\n  function drawFigures(width, height, backgroundColor, figures, context) {\n    if (!figuresCache) {\n      initFiguresGL();\n    }\n\n    var cache = figuresCache,\n        canvas = cache.canvas,\n        gl = cache.gl;\n    canvas.width = width;\n    canvas.height = height;\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.uniform2f(cache.resolutionLocation, width, height);\n    var count = 0;\n    var i, ii, rows;\n\n    for (i = 0, ii = figures.length; i < ii; i++) {\n      switch (figures[i].type) {\n        case \"lattice\":\n          rows = figures[i].coords.length / figures[i].verticesPerRow | 0;\n          count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6;\n          break;\n\n        case \"triangles\":\n          count += figures[i].coords.length;\n          break;\n      }\n    }\n\n    var coords = new Float32Array(count * 2);\n    var colors = new Uint8Array(count * 3);\n    var coordsMap = context.coords,\n        colorsMap = context.colors;\n    var pIndex = 0,\n        cIndex = 0;\n\n    for (i = 0, ii = figures.length; i < ii; i++) {\n      var figure = figures[i],\n          ps = figure.coords,\n          cs = figure.colors;\n\n      switch (figure.type) {\n        case \"lattice\":\n          var cols = figure.verticesPerRow;\n          rows = ps.length / cols | 0;\n\n          for (var row = 1; row < rows; row++) {\n            var offset = row * cols + 1;\n\n            for (var col = 1; col < cols; col++, offset++) {\n              coords[pIndex] = coordsMap[ps[offset - cols - 1]];\n              coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1];\n              coords[pIndex + 2] = coordsMap[ps[offset - cols]];\n              coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1];\n              coords[pIndex + 4] = coordsMap[ps[offset - 1]];\n              coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1];\n              colors[cIndex] = colorsMap[cs[offset - cols - 1]];\n              colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1];\n              colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2];\n              colors[cIndex + 3] = colorsMap[cs[offset - cols]];\n              colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1];\n              colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2];\n              colors[cIndex + 6] = colorsMap[cs[offset - 1]];\n              colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1];\n              colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2];\n              coords[pIndex + 6] = coords[pIndex + 2];\n              coords[pIndex + 7] = coords[pIndex + 3];\n              coords[pIndex + 8] = coords[pIndex + 4];\n              coords[pIndex + 9] = coords[pIndex + 5];\n              coords[pIndex + 10] = coordsMap[ps[offset]];\n              coords[pIndex + 11] = coordsMap[ps[offset] + 1];\n              colors[cIndex + 9] = colors[cIndex + 3];\n              colors[cIndex + 10] = colors[cIndex + 4];\n              colors[cIndex + 11] = colors[cIndex + 5];\n              colors[cIndex + 12] = colors[cIndex + 6];\n              colors[cIndex + 13] = colors[cIndex + 7];\n              colors[cIndex + 14] = colors[cIndex + 8];\n              colors[cIndex + 15] = colorsMap[cs[offset]];\n              colors[cIndex + 16] = colorsMap[cs[offset] + 1];\n              colors[cIndex + 17] = colorsMap[cs[offset] + 2];\n              pIndex += 12;\n              cIndex += 18;\n            }\n          }\n\n          break;\n\n        case \"triangles\":\n          for (var j = 0, jj = ps.length; j < jj; j++) {\n            coords[pIndex] = coordsMap[ps[j]];\n            coords[pIndex + 1] = coordsMap[ps[j] + 1];\n            colors[cIndex] = colorsMap[cs[j]];\n            colors[cIndex + 1] = colorsMap[cs[j] + 1];\n            colors[cIndex + 2] = colorsMap[cs[j] + 2];\n            pIndex += 2;\n            cIndex += 3;\n          }\n\n          break;\n      }\n    }\n\n    if (backgroundColor) {\n      gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0);\n    } else {\n      gl.clearColor(0, 0, 0, 0);\n    }\n\n    gl.clear(gl.COLOR_BUFFER_BIT);\n    var coordsBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.positionLocation);\n    gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0);\n    var colorsBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n    gl.enableVertexAttribArray(cache.colorLocation);\n    gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0);\n    gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY);\n    gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY);\n    gl.drawArrays(gl.TRIANGLES, 0, count);\n    gl.flush();\n    gl.deleteBuffer(coordsBuffer);\n    gl.deleteBuffer(colorsBuffer);\n    return canvas;\n  }\n\n  return {\n    tryInitGL: function tryInitGL() {\n      try {\n        generateGL();\n        return !!currentGL;\n      } catch (ex) {}\n\n      return false;\n    },\n    composeSMask: composeSMask,\n    drawFigures: drawFigures,\n    cleanup: function cleanup() {\n      if (smaskCache && smaskCache.canvas) {\n        smaskCache.canvas.width = 0;\n        smaskCache.canvas.height = 0;\n      }\n\n      if (figuresCache && figuresCache.canvas) {\n        figuresCache.canvas.width = 0;\n        figuresCache.canvas.height = 0;\n      }\n\n      smaskCache = null;\n      figuresCache = null;\n    }\n  };\n}();\n\n/***/ }),\n/* 216 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AnnotationLayer = void 0;\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _annotation_storage = __w_pdfjs_require__(205);\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AnnotationElementFactory = /*#__PURE__*/function () {\n  function AnnotationElementFactory() {\n    _classCallCheck(this, AnnotationElementFactory);\n  }\n\n  _createClass(AnnotationElementFactory, null, [{\n    key: \"create\",\n    value: function create(parameters) {\n      var subtype = parameters.data.annotationType;\n\n      switch (subtype) {\n        case _util.AnnotationType.LINK:\n          return new LinkAnnotationElement(parameters);\n\n        case _util.AnnotationType.TEXT:\n          return new TextAnnotationElement(parameters);\n\n        case _util.AnnotationType.WIDGET:\n          var fieldType = parameters.data.fieldType;\n\n          switch (fieldType) {\n            case \"Tx\":\n              return new TextWidgetAnnotationElement(parameters);\n\n            case \"Btn\":\n              if (parameters.data.radioButton) {\n                return new RadioButtonWidgetAnnotationElement(parameters);\n              } else if (parameters.data.checkBox) {\n                return new CheckboxWidgetAnnotationElement(parameters);\n              }\n\n              return new PushButtonWidgetAnnotationElement(parameters);\n\n            case \"Ch\":\n              return new ChoiceWidgetAnnotationElement(parameters);\n          }\n\n          return new WidgetAnnotationElement(parameters);\n\n        case _util.AnnotationType.POPUP:\n          return new PopupAnnotationElement(parameters);\n\n        case _util.AnnotationType.FREETEXT:\n          return new FreeTextAnnotationElement(parameters);\n\n        case _util.AnnotationType.LINE:\n          return new LineAnnotationElement(parameters);\n\n        case _util.AnnotationType.SQUARE:\n          return new SquareAnnotationElement(parameters);\n\n        case _util.AnnotationType.CIRCLE:\n          return new CircleAnnotationElement(parameters);\n\n        case _util.AnnotationType.POLYLINE:\n          return new PolylineAnnotationElement(parameters);\n\n        case _util.AnnotationType.CARET:\n          return new CaretAnnotationElement(parameters);\n\n        case _util.AnnotationType.INK:\n          return new InkAnnotationElement(parameters);\n\n        case _util.AnnotationType.POLYGON:\n          return new PolygonAnnotationElement(parameters);\n\n        case _util.AnnotationType.HIGHLIGHT:\n          return new HighlightAnnotationElement(parameters);\n\n        case _util.AnnotationType.UNDERLINE:\n          return new UnderlineAnnotationElement(parameters);\n\n        case _util.AnnotationType.SQUIGGLY:\n          return new SquigglyAnnotationElement(parameters);\n\n        case _util.AnnotationType.STRIKEOUT:\n          return new StrikeOutAnnotationElement(parameters);\n\n        case _util.AnnotationType.STAMP:\n          return new StampAnnotationElement(parameters);\n\n        case _util.AnnotationType.FILEATTACHMENT:\n          return new FileAttachmentAnnotationElement(parameters);\n\n        default:\n          return new AnnotationElement(parameters);\n      }\n    }\n  }]);\n\n  return AnnotationElementFactory;\n}();\n\nvar AnnotationElement = /*#__PURE__*/function () {\n  function AnnotationElement(parameters) {\n    var isRenderable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var ignoreBorder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    _classCallCheck(this, AnnotationElement);\n\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.page = parameters.page;\n    this.viewport = parameters.viewport;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderInteractiveForms = parameters.renderInteractiveForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n  }\n\n  _createClass(AnnotationElement, [{\n    key: \"_createContainer\",\n    value: function _createContainer() {\n      var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var data = this.data,\n          page = this.page,\n          viewport = this.viewport;\n      var container = document.createElement(\"section\");\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      container.setAttribute(\"data-annotation-id\", data.id);\n\n      var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n\n      container.style.transform = \"matrix(\".concat(viewport.transform.join(\",\"), \")\");\n      container.style.transformOrigin = \"-\".concat(rect[0], \"px -\").concat(rect[1], \"px\");\n\n      if (!ignoreBorder && data.borderStyle.width > 0) {\n        container.style.borderWidth = \"\".concat(data.borderStyle.width, \"px\");\n\n        if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) {\n          width = width - 2 * data.borderStyle.width;\n          height = height - 2 * data.borderStyle.width;\n        }\n\n        var horizontalRadius = data.borderStyle.horizontalCornerRadius;\n        var verticalRadius = data.borderStyle.verticalCornerRadius;\n\n        if (horizontalRadius > 0 || verticalRadius > 0) {\n          var radius = \"\".concat(horizontalRadius, \"px / \").concat(verticalRadius, \"px\");\n          container.style.borderRadius = radius;\n        }\n\n        switch (data.borderStyle.style) {\n          case _util.AnnotationBorderStyleType.SOLID:\n            container.style.borderStyle = \"solid\";\n            break;\n\n          case _util.AnnotationBorderStyleType.DASHED:\n            container.style.borderStyle = \"dashed\";\n            break;\n\n          case _util.AnnotationBorderStyleType.BEVELED:\n            (0, _util.warn)(\"Unimplemented border style: beveled\");\n            break;\n\n          case _util.AnnotationBorderStyleType.INSET:\n            (0, _util.warn)(\"Unimplemented border style: inset\");\n            break;\n\n          case _util.AnnotationBorderStyleType.UNDERLINE:\n            container.style.borderBottomStyle = \"solid\";\n            break;\n\n          default:\n            break;\n        }\n\n        if (data.color) {\n          container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0);\n        } else {\n          container.style.borderWidth = 0;\n        }\n      }\n\n      container.style.left = \"\".concat(rect[0], \"px\");\n      container.style.top = \"\".concat(rect[1], \"px\");\n      container.style.width = \"\".concat(width, \"px\");\n      container.style.height = \"\".concat(height, \"px\");\n      return container;\n    }\n  }, {\n    key: \"_createPopup\",\n    value: function _createPopup(container, trigger, data) {\n      if (!trigger) {\n        trigger = document.createElement(\"div\");\n        trigger.style.height = container.style.height;\n        trigger.style.width = container.style.width;\n        container.appendChild(trigger);\n      }\n\n      var popupElement = new PopupElement({\n        container: container,\n        trigger: trigger,\n        color: data.color,\n        title: data.title,\n        modificationDate: data.modificationDate,\n        contents: data.contents,\n        hideWrapper: true\n      });\n      var popup = popupElement.render();\n      popup.style.left = container.style.width;\n      container.appendChild(popup);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n    }\n  }]);\n\n  return AnnotationElement;\n}();\n\nvar LinkAnnotationElement = /*#__PURE__*/function (_AnnotationElement) {\n  _inherits(LinkAnnotationElement, _AnnotationElement);\n\n  var _super = _createSuper(LinkAnnotationElement);\n\n  function LinkAnnotationElement(parameters) {\n    _classCallCheck(this, LinkAnnotationElement);\n\n    var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action);\n    return _super.call(this, parameters, isRenderable);\n  }\n\n  _createClass(LinkAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"linkAnnotation\";\n      var data = this.data,\n          linkService = this.linkService;\n      var link = document.createElement(\"a\");\n\n      if (data.url) {\n        (0, _display_utils.addLinkAttributes)(link, {\n          url: data.url,\n          target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget,\n          rel: linkService.externalLinkRel,\n          enabled: linkService.externalLinkEnabled\n        });\n      } else if (data.action) {\n        this._bindNamedAction(link, data.action);\n      } else {\n        this._bindLink(link, data.dest);\n      }\n\n      this.container.appendChild(link);\n      return this.container;\n    }\n  }, {\n    key: \"_bindLink\",\n    value: function _bindLink(link, destination) {\n      var _this = this;\n\n      link.href = this.linkService.getDestinationHash(destination);\n\n      link.onclick = function () {\n        if (destination) {\n          _this.linkService.navigateTo(destination);\n        }\n\n        return false;\n      };\n\n      if (destination) {\n        link.className = \"internalLink\";\n      }\n    }\n  }, {\n    key: \"_bindNamedAction\",\n    value: function _bindNamedAction(link, action) {\n      var _this2 = this;\n\n      link.href = this.linkService.getAnchorUrl(\"\");\n\n      link.onclick = function () {\n        _this2.linkService.executeNamedAction(action);\n\n        return false;\n      };\n\n      link.className = \"internalLink\";\n    }\n  }]);\n\n  return LinkAnnotationElement;\n}(AnnotationElement);\n\nvar TextAnnotationElement = /*#__PURE__*/function (_AnnotationElement2) {\n  _inherits(TextAnnotationElement, _AnnotationElement2);\n\n  var _super2 = _createSuper(TextAnnotationElement);\n\n  function TextAnnotationElement(parameters) {\n    _classCallCheck(this, TextAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super2.call(this, parameters, isRenderable);\n  }\n\n  _createClass(TextAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"textAnnotation\";\n      var image = document.createElement(\"img\");\n      image.style.height = this.container.style.height;\n      image.style.width = this.container.style.width;\n      image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n      image.alt = \"[{{type}} Annotation]\";\n      image.dataset.l10nId = \"text_annotation_type\";\n      image.dataset.l10nArgs = JSON.stringify({\n        type: this.data.name\n      });\n\n      if (!this.data.hasPopup) {\n        this._createPopup(this.container, image, this.data);\n      }\n\n      this.container.appendChild(image);\n      return this.container;\n    }\n  }]);\n\n  return TextAnnotationElement;\n}(AnnotationElement);\n\nvar WidgetAnnotationElement = /*#__PURE__*/function (_AnnotationElement3) {\n  _inherits(WidgetAnnotationElement, _AnnotationElement3);\n\n  var _super3 = _createSuper(WidgetAnnotationElement);\n\n  function WidgetAnnotationElement() {\n    _classCallCheck(this, WidgetAnnotationElement);\n\n    return _super3.apply(this, arguments);\n  }\n\n  _createClass(WidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      return this.container;\n    }\n  }]);\n\n  return WidgetAnnotationElement;\n}(AnnotationElement);\n\nvar TextWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem) {\n  _inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem);\n\n  var _super4 = _createSuper(TextWidgetAnnotationElement);\n\n  function TextWidgetAnnotationElement(parameters) {\n    _classCallCheck(this, TextWidgetAnnotationElement);\n\n    var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    return _super4.call(this, parameters, isRenderable);\n  }\n\n  _createClass(TextWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n      var storage = this.annotationStorage;\n      var id = this.data.id;\n      this.container.className = \"textWidgetAnnotation\";\n      var element = null;\n\n      if (this.renderInteractiveForms) {\n        var textContent = storage.getOrCreateValue(id, this.data.fieldValue);\n\n        if (this.data.multiLine) {\n          element = document.createElement(\"textarea\");\n          element.textContent = textContent;\n        } else {\n          element = document.createElement(\"input\");\n          element.type = \"text\";\n          element.setAttribute(\"value\", textContent);\n        }\n\n        element.addEventListener(\"input\", function (event) {\n          storage.setValue(id, event.target.value);\n        });\n        element.disabled = this.data.readOnly;\n        element.name = this.data.fieldName;\n\n        if (this.data.maxLen !== null) {\n          element.maxLength = this.data.maxLen;\n        }\n\n        if (this.data.comb) {\n          var fieldWidth = this.data.rect[2] - this.data.rect[0];\n          var combWidth = fieldWidth / this.data.maxLen;\n          element.classList.add(\"comb\");\n          element.style.letterSpacing = \"calc(\".concat(combWidth, \"px - 1ch)\");\n        }\n      } else {\n        element = document.createElement(\"div\");\n        element.textContent = this.data.fieldValue;\n        element.style.verticalAlign = \"middle\";\n        element.style.display = \"table-cell\";\n        var font = null;\n\n        if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) {\n          font = this.page.commonObjs.get(this.data.fontRefName);\n        }\n\n        this._setTextStyle(element, font);\n      }\n\n      if (this.data.textAlignment !== null) {\n        element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n      }\n\n      this.container.appendChild(element);\n      return this.container;\n    }\n  }, {\n    key: \"_setTextStyle\",\n    value: function _setTextStyle(element, font) {\n      var style = element.style;\n      style.fontSize = \"\".concat(this.data.fontSize, \"px\");\n      style.direction = this.data.fontDirection < 0 ? \"rtl\" : \"ltr\";\n\n      if (!font) {\n        return;\n      }\n\n      var bold = \"normal\";\n\n      if (font.black) {\n        bold = \"900\";\n      } else if (font.bold) {\n        bold = \"bold\";\n      }\n\n      style.fontWeight = bold;\n      style.fontStyle = font.italic ? \"italic\" : \"normal\";\n      var fontFamily = font.loadedName ? \"\\\"\".concat(font.loadedName, \"\\\", \") : \"\";\n      var fallbackName = font.fallbackName || \"Helvetica, sans-serif\";\n      style.fontFamily = fontFamily + fallbackName;\n    }\n  }]);\n\n  return TextWidgetAnnotationElement;\n}(WidgetAnnotationElement);\n\nvar CheckboxWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem2) {\n  _inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2);\n\n  var _super5 = _createSuper(CheckboxWidgetAnnotationElement);\n\n  function CheckboxWidgetAnnotationElement(parameters) {\n    _classCallCheck(this, CheckboxWidgetAnnotationElement);\n\n    return _super5.call(this, parameters, parameters.renderInteractiveForms);\n  }\n\n  _createClass(CheckboxWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var storage = this.annotationStorage;\n      var data = this.data;\n      var id = data.id;\n      var value = storage.getOrCreateValue(id, data.fieldValue && data.fieldValue !== \"Off\");\n      this.container.className = \"buttonWidgetAnnotation checkBox\";\n      var element = document.createElement(\"input\");\n      element.disabled = data.readOnly;\n      element.type = \"checkbox\";\n      element.name = this.data.fieldName;\n\n      if (value) {\n        element.setAttribute(\"checked\", true);\n      }\n\n      element.addEventListener(\"change\", function (event) {\n        storage.setValue(id, event.target.checked);\n      });\n      this.container.appendChild(element);\n      return this.container;\n    }\n  }]);\n\n  return CheckboxWidgetAnnotationElement;\n}(WidgetAnnotationElement);\n\nvar RadioButtonWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem3) {\n  _inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3);\n\n  var _super6 = _createSuper(RadioButtonWidgetAnnotationElement);\n\n  function RadioButtonWidgetAnnotationElement(parameters) {\n    _classCallCheck(this, RadioButtonWidgetAnnotationElement);\n\n    return _super6.call(this, parameters, parameters.renderInteractiveForms);\n  }\n\n  _createClass(RadioButtonWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"buttonWidgetAnnotation radioButton\";\n      var storage = this.annotationStorage;\n      var data = this.data;\n      var id = data.id;\n      var value = storage.getOrCreateValue(id, data.fieldValue === data.buttonValue);\n      var element = document.createElement(\"input\");\n      element.disabled = data.readOnly;\n      element.type = \"radio\";\n      element.name = data.fieldName;\n\n      if (value) {\n        element.setAttribute(\"checked\", true);\n      }\n\n      element.addEventListener(\"change\", function (event) {\n        var name = event.target.name;\n\n        var _iterator = _createForOfIteratorHelper(document.getElementsByName(name)),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var radio = _step.value;\n\n            if (radio !== event.target) {\n              storage.setValue(radio.parentNode.getAttribute(\"data-annotation-id\"), false);\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        storage.setValue(id, event.target.checked);\n      });\n      this.container.appendChild(element);\n      return this.container;\n    }\n  }]);\n\n  return RadioButtonWidgetAnnotationElement;\n}(WidgetAnnotationElement);\n\nvar PushButtonWidgetAnnotationElement = /*#__PURE__*/function (_LinkAnnotationElemen) {\n  _inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen);\n\n  var _super7 = _createSuper(PushButtonWidgetAnnotationElement);\n\n  function PushButtonWidgetAnnotationElement() {\n    _classCallCheck(this, PushButtonWidgetAnnotationElement);\n\n    return _super7.apply(this, arguments);\n  }\n\n  _createClass(PushButtonWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), \"render\", this).call(this);\n\n      container.className = \"buttonWidgetAnnotation pushButton\";\n      return container;\n    }\n  }]);\n\n  return PushButtonWidgetAnnotationElement;\n}(LinkAnnotationElement);\n\nvar ChoiceWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem4) {\n  _inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4);\n\n  var _super8 = _createSuper(ChoiceWidgetAnnotationElement);\n\n  function ChoiceWidgetAnnotationElement(parameters) {\n    _classCallCheck(this, ChoiceWidgetAnnotationElement);\n\n    return _super8.call(this, parameters, parameters.renderInteractiveForms);\n  }\n\n  _createClass(ChoiceWidgetAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"choiceWidgetAnnotation\";\n      var storage = this.annotationStorage;\n      var id = this.data.id;\n      storage.getOrCreateValue(id, this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null);\n      var selectElement = document.createElement(\"select\");\n      selectElement.disabled = this.data.readOnly;\n      selectElement.name = this.data.fieldName;\n\n      if (!this.data.combo) {\n        selectElement.size = this.data.options.length;\n\n        if (this.data.multiSelect) {\n          selectElement.multiple = true;\n        }\n      }\n\n      var _iterator2 = _createForOfIteratorHelper(this.data.options),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var option = _step2.value;\n          var optionElement = document.createElement(\"option\");\n          optionElement.textContent = option.displayValue;\n          optionElement.value = option.exportValue;\n\n          if (this.data.fieldValue.includes(option.exportValue)) {\n            optionElement.setAttribute(\"selected\", true);\n          }\n\n          selectElement.appendChild(optionElement);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      selectElement.addEventListener(\"input\", function (event) {\n        var options = event.target.options;\n        var value = options[options.selectedIndex].value;\n        storage.setValue(id, value);\n      });\n      this.container.appendChild(selectElement);\n      return this.container;\n    }\n  }]);\n\n  return ChoiceWidgetAnnotationElement;\n}(WidgetAnnotationElement);\n\nvar PopupAnnotationElement = /*#__PURE__*/function (_AnnotationElement4) {\n  _inherits(PopupAnnotationElement, _AnnotationElement4);\n\n  var _super9 = _createSuper(PopupAnnotationElement);\n\n  function PopupAnnotationElement(parameters) {\n    _classCallCheck(this, PopupAnnotationElement);\n\n    var isRenderable = !!(parameters.data.title || parameters.data.contents);\n    return _super9.call(this, parameters, isRenderable);\n  }\n\n  _createClass(PopupAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      var IGNORE_TYPES = [\"Line\", \"Square\", \"Circle\", \"PolyLine\", \"Polygon\", \"Ink\"];\n      this.container.className = \"popupAnnotation\";\n\n      if (IGNORE_TYPES.includes(this.data.parentType)) {\n        return this.container;\n      }\n\n      var selector = \"[data-annotation-id=\\\"\".concat(this.data.parentId, \"\\\"]\");\n      var parentElement = this.layer.querySelector(selector);\n\n      if (!parentElement) {\n        return this.container;\n      }\n\n      var popup = new PopupElement({\n        container: this.container,\n        trigger: parentElement,\n        color: this.data.color,\n        title: this.data.title,\n        modificationDate: this.data.modificationDate,\n        contents: this.data.contents\n      });\n      var parentLeft = parseFloat(parentElement.style.left);\n      var parentWidth = parseFloat(parentElement.style.width);\n      this.container.style.transformOrigin = \"-\".concat(parentLeft + parentWidth, \"px -\").concat(parentElement.style.top);\n      this.container.style.left = \"\".concat(parentLeft + parentWidth, \"px\");\n      this.container.appendChild(popup.render());\n      return this.container;\n    }\n  }]);\n\n  return PopupAnnotationElement;\n}(AnnotationElement);\n\nvar PopupElement = /*#__PURE__*/function () {\n  function PopupElement(parameters) {\n    _classCallCheck(this, PopupElement);\n\n    this.container = parameters.container;\n    this.trigger = parameters.trigger;\n    this.color = parameters.color;\n    this.title = parameters.title;\n    this.modificationDate = parameters.modificationDate;\n    this.contents = parameters.contents;\n    this.hideWrapper = parameters.hideWrapper || false;\n    this.pinned = false;\n  }\n\n  _createClass(PopupElement, [{\n    key: \"render\",\n    value: function render() {\n      var BACKGROUND_ENLIGHT = 0.7;\n      var wrapper = document.createElement(\"div\");\n      wrapper.className = \"popupWrapper\";\n      this.hideElement = this.hideWrapper ? wrapper : this.container;\n      this.hideElement.setAttribute(\"hidden\", true);\n      var popup = document.createElement(\"div\");\n      popup.className = \"popup\";\n      var color = this.color;\n\n      if (color) {\n        var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0];\n        var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1];\n        var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2];\n        popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0);\n      }\n\n      var title = document.createElement(\"h1\");\n      title.textContent = this.title;\n      popup.appendChild(title);\n\n      var dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate);\n\n      if (dateObject) {\n        var modificationDate = document.createElement(\"span\");\n        modificationDate.textContent = \"{{date}}, {{time}}\";\n        modificationDate.dataset.l10nId = \"annotation_date_string\";\n        modificationDate.dataset.l10nArgs = JSON.stringify({\n          date: dateObject.toLocaleDateString(),\n          time: dateObject.toLocaleTimeString()\n        });\n        popup.appendChild(modificationDate);\n      }\n\n      var contents = this._formatContents(this.contents);\n\n      popup.appendChild(contents);\n      this.trigger.addEventListener(\"click\", this._toggle.bind(this));\n      this.trigger.addEventListener(\"mouseover\", this._show.bind(this, false));\n      this.trigger.addEventListener(\"mouseout\", this._hide.bind(this, false));\n      popup.addEventListener(\"click\", this._hide.bind(this, true));\n      wrapper.appendChild(popup);\n      return wrapper;\n    }\n  }, {\n    key: \"_formatContents\",\n    value: function _formatContents(contents) {\n      var p = document.createElement(\"p\");\n      var lines = contents.split(/(?:\\r\\n?|\\n)/);\n\n      for (var i = 0, ii = lines.length; i < ii; ++i) {\n        var line = lines[i];\n        p.appendChild(document.createTextNode(line));\n\n        if (i < ii - 1) {\n          p.appendChild(document.createElement(\"br\"));\n        }\n      }\n\n      return p;\n    }\n  }, {\n    key: \"_toggle\",\n    value: function _toggle() {\n      if (this.pinned) {\n        this._hide(true);\n      } else {\n        this._show(true);\n      }\n    }\n  }, {\n    key: \"_show\",\n    value: function _show() {\n      var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (pin) {\n        this.pinned = true;\n      }\n\n      if (this.hideElement.hasAttribute(\"hidden\")) {\n        this.hideElement.removeAttribute(\"hidden\");\n        this.container.style.zIndex += 1;\n      }\n    }\n  }, {\n    key: \"_hide\",\n    value: function _hide() {\n      var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n\n      if (unpin) {\n        this.pinned = false;\n      }\n\n      if (!this.hideElement.hasAttribute(\"hidden\") && !this.pinned) {\n        this.hideElement.setAttribute(\"hidden\", true);\n        this.container.style.zIndex -= 1;\n      }\n    }\n  }]);\n\n  return PopupElement;\n}();\n\nvar FreeTextAnnotationElement = /*#__PURE__*/function (_AnnotationElement5) {\n  _inherits(FreeTextAnnotationElement, _AnnotationElement5);\n\n  var _super10 = _createSuper(FreeTextAnnotationElement);\n\n  function FreeTextAnnotationElement(parameters) {\n    _classCallCheck(this, FreeTextAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super10.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(FreeTextAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"freeTextAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(this.container, null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return FreeTextAnnotationElement;\n}(AnnotationElement);\n\nvar LineAnnotationElement = /*#__PURE__*/function (_AnnotationElement6) {\n  _inherits(LineAnnotationElement, _AnnotationElement6);\n\n  var _super11 = _createSuper(LineAnnotationElement);\n\n  function LineAnnotationElement(parameters) {\n    _classCallCheck(this, LineAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super11.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(LineAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"lineAnnotation\";\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n      var line = this.svgFactory.createElement(\"svg:line\");\n      line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n      line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n      line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n      line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n      line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      line.setAttribute(\"stroke\", \"transparent\");\n      svg.appendChild(line);\n      this.container.append(svg);\n\n      this._createPopup(this.container, line, data);\n\n      return this.container;\n    }\n  }]);\n\n  return LineAnnotationElement;\n}(AnnotationElement);\n\nvar SquareAnnotationElement = /*#__PURE__*/function (_AnnotationElement7) {\n  _inherits(SquareAnnotationElement, _AnnotationElement7);\n\n  var _super12 = _createSuper(SquareAnnotationElement);\n\n  function SquareAnnotationElement(parameters) {\n    _classCallCheck(this, SquareAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super12.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(SquareAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"squareAnnotation\";\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n      var borderWidth = data.borderStyle.width;\n      var square = this.svgFactory.createElement(\"svg:rect\");\n      square.setAttribute(\"x\", borderWidth / 2);\n      square.setAttribute(\"y\", borderWidth / 2);\n      square.setAttribute(\"width\", width - borderWidth);\n      square.setAttribute(\"height\", height - borderWidth);\n      square.setAttribute(\"stroke-width\", borderWidth || 1);\n      square.setAttribute(\"stroke\", \"transparent\");\n      square.setAttribute(\"fill\", \"none\");\n      svg.appendChild(square);\n      this.container.append(svg);\n\n      this._createPopup(this.container, square, data);\n\n      return this.container;\n    }\n  }]);\n\n  return SquareAnnotationElement;\n}(AnnotationElement);\n\nvar CircleAnnotationElement = /*#__PURE__*/function (_AnnotationElement8) {\n  _inherits(CircleAnnotationElement, _AnnotationElement8);\n\n  var _super13 = _createSuper(CircleAnnotationElement);\n\n  function CircleAnnotationElement(parameters) {\n    _classCallCheck(this, CircleAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super13.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(CircleAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"circleAnnotation\";\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n      var borderWidth = data.borderStyle.width;\n      var circle = this.svgFactory.createElement(\"svg:ellipse\");\n      circle.setAttribute(\"cx\", width / 2);\n      circle.setAttribute(\"cy\", height / 2);\n      circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n      circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n      circle.setAttribute(\"stroke-width\", borderWidth || 1);\n      circle.setAttribute(\"stroke\", \"transparent\");\n      circle.setAttribute(\"fill\", \"none\");\n      svg.appendChild(circle);\n      this.container.append(svg);\n\n      this._createPopup(this.container, circle, data);\n\n      return this.container;\n    }\n  }]);\n\n  return CircleAnnotationElement;\n}(AnnotationElement);\n\nvar PolylineAnnotationElement = /*#__PURE__*/function (_AnnotationElement9) {\n  _inherits(PolylineAnnotationElement, _AnnotationElement9);\n\n  var _super14 = _createSuper(PolylineAnnotationElement);\n\n  function PolylineAnnotationElement(parameters) {\n    var _this3;\n\n    _classCallCheck(this, PolylineAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    _this3 = _super14.call(this, parameters, isRenderable, true);\n    _this3.containerClassName = \"polylineAnnotation\";\n    _this3.svgElementName = \"svg:polyline\";\n    return _this3;\n  }\n\n  _createClass(PolylineAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = this.containerClassName;\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n      var points = [];\n\n      var _iterator3 = _createForOfIteratorHelper(data.vertices),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var coordinate = _step3.value;\n          var x = coordinate.x - data.rect[0];\n          var y = data.rect[3] - coordinate.y;\n          points.push(x + \",\" + y);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      points = points.join(\" \");\n      var polyline = this.svgFactory.createElement(this.svgElementName);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"none\");\n      svg.appendChild(polyline);\n      this.container.append(svg);\n\n      this._createPopup(this.container, polyline, data);\n\n      return this.container;\n    }\n  }]);\n\n  return PolylineAnnotationElement;\n}(AnnotationElement);\n\nvar PolygonAnnotationElement = /*#__PURE__*/function (_PolylineAnnotationEl) {\n  _inherits(PolygonAnnotationElement, _PolylineAnnotationEl);\n\n  var _super15 = _createSuper(PolygonAnnotationElement);\n\n  function PolygonAnnotationElement(parameters) {\n    var _this4;\n\n    _classCallCheck(this, PolygonAnnotationElement);\n\n    _this4 = _super15.call(this, parameters);\n    _this4.containerClassName = \"polygonAnnotation\";\n    _this4.svgElementName = \"svg:polygon\";\n    return _this4;\n  }\n\n  return PolygonAnnotationElement;\n}(PolylineAnnotationElement);\n\nvar CaretAnnotationElement = /*#__PURE__*/function (_AnnotationElement10) {\n  _inherits(CaretAnnotationElement, _AnnotationElement10);\n\n  var _super16 = _createSuper(CaretAnnotationElement);\n\n  function CaretAnnotationElement(parameters) {\n    _classCallCheck(this, CaretAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super16.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(CaretAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"caretAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(this.container, null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return CaretAnnotationElement;\n}(AnnotationElement);\n\nvar InkAnnotationElement = /*#__PURE__*/function (_AnnotationElement11) {\n  _inherits(InkAnnotationElement, _AnnotationElement11);\n\n  var _super17 = _createSuper(InkAnnotationElement);\n\n  function InkAnnotationElement(parameters) {\n    var _this5;\n\n    _classCallCheck(this, InkAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    _this5 = _super17.call(this, parameters, isRenderable, true);\n    _this5.containerClassName = \"inkAnnotation\";\n    _this5.svgElementName = \"svg:polyline\";\n    return _this5;\n  }\n\n  _createClass(InkAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = this.containerClassName;\n      var data = this.data;\n      var width = data.rect[2] - data.rect[0];\n      var height = data.rect[3] - data.rect[1];\n      var svg = this.svgFactory.create(width, height);\n\n      var _iterator4 = _createForOfIteratorHelper(data.inkLists),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var inkList = _step4.value;\n          var points = [];\n\n          var _iterator5 = _createForOfIteratorHelper(inkList),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var coordinate = _step5.value;\n              var x = coordinate.x - data.rect[0];\n              var y = data.rect[3] - coordinate.y;\n              points.push(\"\".concat(x, \",\").concat(y));\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n\n          points = points.join(\" \");\n          var polyline = this.svgFactory.createElement(this.svgElementName);\n          polyline.setAttribute(\"points\", points);\n          polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n          polyline.setAttribute(\"stroke\", \"transparent\");\n          polyline.setAttribute(\"fill\", \"none\");\n\n          this._createPopup(this.container, polyline, data);\n\n          svg.appendChild(polyline);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n\n      this.container.append(svg);\n      return this.container;\n    }\n  }]);\n\n  return InkAnnotationElement;\n}(AnnotationElement);\n\nvar HighlightAnnotationElement = /*#__PURE__*/function (_AnnotationElement12) {\n  _inherits(HighlightAnnotationElement, _AnnotationElement12);\n\n  var _super18 = _createSuper(HighlightAnnotationElement);\n\n  function HighlightAnnotationElement(parameters) {\n    _classCallCheck(this, HighlightAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super18.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(HighlightAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"highlightAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(this.container, null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return HighlightAnnotationElement;\n}(AnnotationElement);\n\nvar UnderlineAnnotationElement = /*#__PURE__*/function (_AnnotationElement13) {\n  _inherits(UnderlineAnnotationElement, _AnnotationElement13);\n\n  var _super19 = _createSuper(UnderlineAnnotationElement);\n\n  function UnderlineAnnotationElement(parameters) {\n    _classCallCheck(this, UnderlineAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super19.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(UnderlineAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"underlineAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(this.container, null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return UnderlineAnnotationElement;\n}(AnnotationElement);\n\nvar SquigglyAnnotationElement = /*#__PURE__*/function (_AnnotationElement14) {\n  _inherits(SquigglyAnnotationElement, _AnnotationElement14);\n\n  var _super20 = _createSuper(SquigglyAnnotationElement);\n\n  function SquigglyAnnotationElement(parameters) {\n    _classCallCheck(this, SquigglyAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super20.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(SquigglyAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"squigglyAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(this.container, null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return SquigglyAnnotationElement;\n}(AnnotationElement);\n\nvar StrikeOutAnnotationElement = /*#__PURE__*/function (_AnnotationElement15) {\n  _inherits(StrikeOutAnnotationElement, _AnnotationElement15);\n\n  var _super21 = _createSuper(StrikeOutAnnotationElement);\n\n  function StrikeOutAnnotationElement(parameters) {\n    _classCallCheck(this, StrikeOutAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super21.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(StrikeOutAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"strikeoutAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(this.container, null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return StrikeOutAnnotationElement;\n}(AnnotationElement);\n\nvar StampAnnotationElement = /*#__PURE__*/function (_AnnotationElement16) {\n  _inherits(StampAnnotationElement, _AnnotationElement16);\n\n  var _super22 = _createSuper(StampAnnotationElement);\n\n  function StampAnnotationElement(parameters) {\n    _classCallCheck(this, StampAnnotationElement);\n\n    var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents);\n    return _super22.call(this, parameters, isRenderable, true);\n  }\n\n  _createClass(StampAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"stampAnnotation\";\n\n      if (!this.data.hasPopup) {\n        this._createPopup(this.container, null, this.data);\n      }\n\n      return this.container;\n    }\n  }]);\n\n  return StampAnnotationElement;\n}(AnnotationElement);\n\nvar FileAttachmentAnnotationElement = /*#__PURE__*/function (_AnnotationElement17) {\n  _inherits(FileAttachmentAnnotationElement, _AnnotationElement17);\n\n  var _super23 = _createSuper(FileAttachmentAnnotationElement);\n\n  function FileAttachmentAnnotationElement(parameters) {\n    var _this6;\n\n    _classCallCheck(this, FileAttachmentAnnotationElement);\n\n    _this6 = _super23.call(this, parameters, true);\n    var _this6$data$file = _this6.data.file,\n        filename = _this6$data$file.filename,\n        content = _this6$data$file.content;\n    _this6.filename = (0, _display_utils.getFilenameFromUrl)(filename);\n    _this6.content = content;\n\n    if (_this6.linkService.eventBus) {\n      _this6.linkService.eventBus.dispatch(\"fileattachmentannotation\", {\n        source: _assertThisInitialized(_this6),\n        id: (0, _util.stringToPDFString)(filename),\n        filename: filename,\n        content: content\n      });\n    }\n\n    return _this6;\n  }\n\n  _createClass(FileAttachmentAnnotationElement, [{\n    key: \"render\",\n    value: function render() {\n      this.container.className = \"fileAttachmentAnnotation\";\n      var trigger = document.createElement(\"div\");\n      trigger.style.height = this.container.style.height;\n      trigger.style.width = this.container.style.width;\n      trigger.addEventListener(\"dblclick\", this._download.bind(this));\n\n      if (!this.data.hasPopup && (this.data.title || this.data.contents)) {\n        this._createPopup(this.container, trigger, this.data);\n      }\n\n      this.container.appendChild(trigger);\n      return this.container;\n    }\n  }, {\n    key: \"_download\",\n    value: function _download() {\n      if (!this.downloadManager) {\n        (0, _util.warn)(\"Download cannot be started due to unavailable download manager\");\n        return;\n      }\n\n      this.downloadManager.downloadData(this.content, this.filename, \"\");\n    }\n  }]);\n\n  return FileAttachmentAnnotationElement;\n}(AnnotationElement);\n\nvar AnnotationLayer = /*#__PURE__*/function () {\n  function AnnotationLayer() {\n    _classCallCheck(this, AnnotationLayer);\n  }\n\n  _createClass(AnnotationLayer, null, [{\n    key: \"render\",\n    value: function render(parameters) {\n      var sortedAnnotations = [],\n          popupAnnotations = [];\n\n      var _iterator6 = _createForOfIteratorHelper(parameters.annotations),\n          _step6;\n\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var _data = _step6.value;\n\n          if (!_data) {\n            continue;\n          }\n\n          if (_data.annotationType === _util.AnnotationType.POPUP) {\n            popupAnnotations.push(_data);\n            continue;\n          }\n\n          sortedAnnotations.push(_data);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n\n      if (popupAnnotations.length) {\n        sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations);\n      }\n\n      for (var _i = 0, _sortedAnnotations = sortedAnnotations; _i < _sortedAnnotations.length; _i++) {\n        var data = _sortedAnnotations[_i];\n        var element = AnnotationElementFactory.create({\n          data: data,\n          layer: parameters.div,\n          page: parameters.page,\n          viewport: parameters.viewport,\n          linkService: parameters.linkService,\n          downloadManager: parameters.downloadManager,\n          imageResourcesPath: parameters.imageResourcesPath || \"\",\n          renderInteractiveForms: typeof parameters.renderInteractiveForms === \"boolean\" ? parameters.renderInteractiveForms : true,\n          svgFactory: new _display_utils.DOMSVGFactory(),\n          annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage()\n        });\n\n        if (element.isRenderable) {\n          parameters.div.appendChild(element.render());\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(parameters) {\n      var _iterator7 = _createForOfIteratorHelper(parameters.annotations),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var data = _step7.value;\n          var element = parameters.div.querySelector(\"[data-annotation-id=\\\"\".concat(data.id, \"\\\"]\"));\n\n          if (element) {\n            element.style.transform = \"matrix(\".concat(parameters.viewport.transform.join(\",\"), \")\");\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      parameters.div.removeAttribute(\"hidden\");\n    }\n  }]);\n\n  return AnnotationLayer;\n}();\n\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 217 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderTextLayer = void 0;\n\nvar _util = __w_pdfjs_require__(5);\n\nvar renderTextLayer = function renderTextLayerClosure() {\n  var MAX_TEXT_DIVS_TO_RENDER = 100000;\n  var NonWhitespaceRegexp = /\\S/;\n\n  function isAllWhitespace(str) {\n    return !NonWhitespaceRegexp.test(str);\n  }\n\n  function appendText(task, geom, styles) {\n    var textDiv = document.createElement(\"span\");\n    var textDivProperties = {\n      angle: 0,\n      canvasWidth: 0,\n      isWhitespace: false,\n      originalTransform: null,\n      paddingBottom: 0,\n      paddingLeft: 0,\n      paddingRight: 0,\n      paddingTop: 0,\n      scale: 1\n    };\n\n    task._textDivs.push(textDiv);\n\n    if (isAllWhitespace(geom.str)) {\n      textDivProperties.isWhitespace = true;\n\n      task._textDivProperties.set(textDiv, textDivProperties);\n\n      return;\n    }\n\n    var tx = _util.Util.transform(task._viewport.transform, geom.transform);\n\n    var angle = Math.atan2(tx[1], tx[0]);\n    var style = styles[geom.fontName];\n\n    if (style.vertical) {\n      angle += Math.PI / 2;\n    }\n\n    var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]);\n    var fontAscent = fontHeight;\n\n    if (style.ascent) {\n      fontAscent = style.ascent * fontAscent;\n    } else if (style.descent) {\n      fontAscent = (1 + style.descent) * fontAscent;\n    }\n\n    var left, top;\n\n    if (angle === 0) {\n      left = tx[4];\n      top = tx[5] - fontAscent;\n    } else {\n      left = tx[4] + fontAscent * Math.sin(angle);\n      top = tx[5] - fontAscent * Math.cos(angle);\n    }\n\n    textDiv.style.left = \"\".concat(left, \"px\");\n    textDiv.style.top = \"\".concat(top, \"px\");\n    textDiv.style.fontSize = \"\".concat(fontHeight, \"px\");\n    textDiv.style.fontFamily = style.fontFamily;\n    textDiv.textContent = geom.str;\n\n    if (task._fontInspectorEnabled) {\n      textDiv.dataset.fontName = geom.fontName;\n    }\n\n    if (angle !== 0) {\n      textDivProperties.angle = angle * (180 / Math.PI);\n    }\n\n    var shouldScaleText = false;\n\n    if (geom.str.length > 1) {\n      shouldScaleText = true;\n    } else if (geom.transform[0] !== geom.transform[3]) {\n      var absScaleX = Math.abs(geom.transform[0]),\n          absScaleY = Math.abs(geom.transform[3]);\n\n      if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n        shouldScaleText = true;\n      }\n    }\n\n    if (shouldScaleText) {\n      if (style.vertical) {\n        textDivProperties.canvasWidth = geom.height * task._viewport.scale;\n      } else {\n        textDivProperties.canvasWidth = geom.width * task._viewport.scale;\n      }\n    }\n\n    task._textDivProperties.set(textDiv, textDivProperties);\n\n    if (task._textContentStream) {\n      task._layoutText(textDiv);\n    }\n\n    if (task._enhanceTextSelection) {\n      var angleCos = 1,\n          angleSin = 0;\n\n      if (angle !== 0) {\n        angleCos = Math.cos(angle);\n        angleSin = Math.sin(angle);\n      }\n\n      var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale;\n      var divHeight = fontHeight;\n      var m, b;\n\n      if (angle !== 0) {\n        m = [angleCos, angleSin, -angleSin, angleCos, left, top];\n        b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m);\n      } else {\n        b = [left, top, left + divWidth, top + divHeight];\n      }\n\n      task._bounds.push({\n        left: b[0],\n        top: b[1],\n        right: b[2],\n        bottom: b[3],\n        div: textDiv,\n        size: [divWidth, divHeight],\n        m: m\n      });\n    }\n  }\n\n  function render(task) {\n    if (task._canceled) {\n      return;\n    }\n\n    var textDivs = task._textDivs;\n    var capability = task._capability;\n    var textDivsLength = textDivs.length;\n\n    if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n      task._renderingDone = true;\n      capability.resolve();\n      return;\n    }\n\n    if (!task._textContentStream) {\n      for (var i = 0; i < textDivsLength; i++) {\n        task._layoutText(textDivs[i]);\n      }\n    }\n\n    task._renderingDone = true;\n    capability.resolve();\n  }\n\n  function findPositiveMin(ts, offset, count) {\n    var result = 0;\n\n    for (var i = 0; i < count; i++) {\n      var t = ts[offset++];\n\n      if (t > 0) {\n        result = result ? Math.min(t, result) : t;\n      }\n    }\n\n    return result;\n  }\n\n  function expand(task) {\n    var bounds = task._bounds;\n    var viewport = task._viewport;\n    var expanded = expandBounds(viewport.width, viewport.height, bounds);\n\n    for (var i = 0; i < expanded.length; i++) {\n      var div = bounds[i].div;\n\n      var divProperties = task._textDivProperties.get(div);\n\n      if (divProperties.angle === 0) {\n        divProperties.paddingLeft = bounds[i].left - expanded[i].left;\n        divProperties.paddingTop = bounds[i].top - expanded[i].top;\n        divProperties.paddingRight = expanded[i].right - bounds[i].right;\n        divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom;\n\n        task._textDivProperties.set(div, divProperties);\n\n        continue;\n      }\n\n      var e = expanded[i],\n          b = bounds[i];\n      var m = b.m,\n          c = m[0],\n          s = m[1];\n      var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size];\n      var ts = new Float64Array(64);\n      points.forEach(function (p, j) {\n        var t = _util.Util.applyTransform(p, m);\n\n        ts[j + 0] = c && (e.left - t[0]) / c;\n        ts[j + 4] = s && (e.top - t[1]) / s;\n        ts[j + 8] = c && (e.right - t[0]) / c;\n        ts[j + 12] = s && (e.bottom - t[1]) / s;\n        ts[j + 16] = s && (e.left - t[0]) / -s;\n        ts[j + 20] = c && (e.top - t[1]) / c;\n        ts[j + 24] = s && (e.right - t[0]) / -s;\n        ts[j + 28] = c && (e.bottom - t[1]) / c;\n        ts[j + 32] = c && (e.left - t[0]) / -c;\n        ts[j + 36] = s && (e.top - t[1]) / -s;\n        ts[j + 40] = c && (e.right - t[0]) / -c;\n        ts[j + 44] = s && (e.bottom - t[1]) / -s;\n        ts[j + 48] = s && (e.left - t[0]) / s;\n        ts[j + 52] = c && (e.top - t[1]) / -c;\n        ts[j + 56] = s && (e.right - t[0]) / s;\n        ts[j + 60] = c && (e.bottom - t[1]) / -c;\n      });\n      var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s));\n      divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale;\n      divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale;\n      divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale;\n      divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale;\n\n      task._textDivProperties.set(div, divProperties);\n    }\n  }\n\n  function expandBounds(width, height, boxes) {\n    var bounds = boxes.map(function (box, i) {\n      return {\n        x1: box.left,\n        y1: box.top,\n        x2: box.right,\n        y2: box.bottom,\n        index: i,\n        x1New: undefined,\n        x2New: undefined\n      };\n    });\n    expandBoundsLTR(width, bounds);\n    var expanded = new Array(boxes.length);\n    bounds.forEach(function (b) {\n      var i = b.index;\n      expanded[i] = {\n        left: b.x1New,\n        top: 0,\n        right: b.x2New,\n        bottom: 0\n      };\n    });\n    boxes.map(function (box, i) {\n      var e = expanded[i],\n          b = bounds[i];\n      b.x1 = box.top;\n      b.y1 = width - e.right;\n      b.x2 = box.bottom;\n      b.y2 = width - e.left;\n      b.index = i;\n      b.x1New = undefined;\n      b.x2New = undefined;\n    });\n    expandBoundsLTR(height, bounds);\n    bounds.forEach(function (b) {\n      var i = b.index;\n      expanded[i].top = b.x1New;\n      expanded[i].bottom = b.x2New;\n    });\n    return expanded;\n  }\n\n  function expandBoundsLTR(width, bounds) {\n    bounds.sort(function (a, b) {\n      return a.x1 - b.x1 || a.index - b.index;\n    });\n    var fakeBoundary = {\n      x1: -Infinity,\n      y1: -Infinity,\n      x2: 0,\n      y2: Infinity,\n      index: -1,\n      x1New: 0,\n      x2New: 0\n    };\n    var horizon = [{\n      start: -Infinity,\n      end: Infinity,\n      boundary: fakeBoundary\n    }];\n    bounds.forEach(function (boundary) {\n      var i = 0;\n\n      while (i < horizon.length && horizon[i].end <= boundary.y1) {\n        i++;\n      }\n\n      var j = horizon.length - 1;\n\n      while (j >= 0 && horizon[j].start >= boundary.y2) {\n        j--;\n      }\n\n      var horizonPart, affectedBoundary;\n      var q,\n          k,\n          maxXNew = -Infinity;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n        var xNew;\n\n        if (affectedBoundary.x2 > boundary.x1) {\n          xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1;\n        } else if (affectedBoundary.x2New === undefined) {\n          xNew = (affectedBoundary.x2 + boundary.x1) / 2;\n        } else {\n          xNew = affectedBoundary.x2New;\n        }\n\n        if (xNew > maxXNew) {\n          maxXNew = xNew;\n        }\n      }\n\n      boundary.x1New = maxXNew;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n\n        if (affectedBoundary.x2New === undefined) {\n          if (affectedBoundary.x2 > boundary.x1) {\n            if (affectedBoundary.index > boundary.index) {\n              affectedBoundary.x2New = affectedBoundary.x2;\n            }\n          } else {\n            affectedBoundary.x2New = maxXNew;\n          }\n        } else if (affectedBoundary.x2New > maxXNew) {\n          affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2);\n        }\n      }\n\n      var changedHorizon = [],\n          lastBoundary = null;\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n        var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary;\n\n        if (lastBoundary === useBoundary) {\n          changedHorizon[changedHorizon.length - 1].end = horizonPart.end;\n        } else {\n          changedHorizon.push({\n            start: horizonPart.start,\n            end: horizonPart.end,\n            boundary: useBoundary\n          });\n          lastBoundary = useBoundary;\n        }\n      }\n\n      if (horizon[i].start < boundary.y1) {\n        changedHorizon[0].start = boundary.y1;\n        changedHorizon.unshift({\n          start: horizon[i].start,\n          end: boundary.y1,\n          boundary: horizon[i].boundary\n        });\n      }\n\n      if (boundary.y2 < horizon[j].end) {\n        changedHorizon[changedHorizon.length - 1].end = boundary.y2;\n        changedHorizon.push({\n          start: boundary.y2,\n          end: horizon[j].end,\n          boundary: horizon[j].boundary\n        });\n      }\n\n      for (q = i; q <= j; q++) {\n        horizonPart = horizon[q];\n        affectedBoundary = horizonPart.boundary;\n\n        if (affectedBoundary.x2New !== undefined) {\n          continue;\n        }\n\n        var used = false;\n\n        for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) {\n          used = horizon[k].boundary === affectedBoundary;\n        }\n\n        for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) {\n          used = horizon[k].boundary === affectedBoundary;\n        }\n\n        for (k = 0; !used && k < changedHorizon.length; k++) {\n          used = changedHorizon[k].boundary === affectedBoundary;\n        }\n\n        if (!used) {\n          affectedBoundary.x2New = maxXNew;\n        }\n      }\n\n      Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon));\n    });\n    horizon.forEach(function (horizonPart) {\n      var affectedBoundary = horizonPart.boundary;\n\n      if (affectedBoundary.x2New === undefined) {\n        affectedBoundary.x2New = Math.max(width, affectedBoundary.x2);\n      }\n    });\n  }\n\n  function TextLayerRenderTask(_ref) {\n    var _this = this;\n\n    var textContent = _ref.textContent,\n        textContentStream = _ref.textContentStream,\n        container = _ref.container,\n        viewport = _ref.viewport,\n        textDivs = _ref.textDivs,\n        textContentItemsStr = _ref.textContentItemsStr,\n        enhanceTextSelection = _ref.enhanceTextSelection;\n    this._textContent = textContent;\n    this._textContentStream = textContentStream;\n    this._container = container;\n    this._document = container.ownerDocument;\n    this._viewport = viewport;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._enhanceTextSelection = !!enhanceTextSelection;\n    this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled);\n    this._reader = null;\n    this._layoutTextLastFontSize = null;\n    this._layoutTextLastFontFamily = null;\n    this._layoutTextCtx = null;\n    this._textDivProperties = new WeakMap();\n    this._renderingDone = false;\n    this._canceled = false;\n    this._capability = (0, _util.createPromiseCapability)();\n    this._renderTimer = null;\n    this._bounds = [];\n\n    this._capability.promise[\"finally\"](function () {\n      if (_this._layoutTextCtx) {\n        _this._layoutTextCtx.canvas.width = 0;\n        _this._layoutTextCtx.canvas.height = 0;\n        _this._layoutTextCtx = null;\n      }\n    })[\"catch\"](function () {});\n  }\n\n  TextLayerRenderTask.prototype = {\n    get promise() {\n      return this._capability.promise;\n    },\n\n    cancel: function TextLayer_cancel() {\n      this._canceled = true;\n\n      if (this._reader) {\n        this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\"));\n\n        this._reader = null;\n      }\n\n      if (this._renderTimer !== null) {\n        clearTimeout(this._renderTimer);\n        this._renderTimer = null;\n      }\n\n      this._capability.reject(new Error(\"TextLayer task cancelled.\"));\n    },\n    _processItems: function _processItems(items, styleCache) {\n      for (var i = 0, len = items.length; i < len; i++) {\n        this._textContentItemsStr.push(items[i].str);\n\n        appendText(this, items[i], styleCache);\n      }\n    },\n    _layoutText: function _layoutText(textDiv) {\n      var textDivProperties = this._textDivProperties.get(textDiv);\n\n      if (textDivProperties.isWhitespace) {\n        return;\n      }\n\n      var transform = \"\";\n\n      if (textDivProperties.canvasWidth !== 0) {\n        var _textDiv$style = textDiv.style,\n            fontSize = _textDiv$style.fontSize,\n            fontFamily = _textDiv$style.fontFamily;\n\n        if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) {\n          this._layoutTextCtx.font = \"\".concat(fontSize, \" \").concat(fontFamily);\n          this._layoutTextLastFontSize = fontSize;\n          this._layoutTextLastFontFamily = fontFamily;\n        }\n\n        var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent),\n            width = _this$_layoutTextCtx$.width;\n\n        if (width > 0) {\n          textDivProperties.scale = textDivProperties.canvasWidth / width;\n          transform = \"scaleX(\".concat(textDivProperties.scale, \")\");\n        }\n      }\n\n      if (textDivProperties.angle !== 0) {\n        transform = \"rotate(\".concat(textDivProperties.angle, \"deg) \").concat(transform);\n      }\n\n      if (transform.length > 0) {\n        if (this._enhanceTextSelection) {\n          textDivProperties.originalTransform = transform;\n        }\n\n        textDiv.style.transform = transform;\n      }\n\n      this._textDivProperties.set(textDiv, textDivProperties);\n\n      this._container.appendChild(textDiv);\n    },\n    _render: function TextLayer_render(timeout) {\n      var _this2 = this;\n\n      var capability = (0, _util.createPromiseCapability)();\n      var styleCache = Object.create(null);\n\n      var canvas = this._document.createElement(\"canvas\");\n\n      canvas.mozOpaque = true;\n      this._layoutTextCtx = canvas.getContext(\"2d\", {\n        alpha: false\n      });\n\n      if (this._textContent) {\n        var textItems = this._textContent.items;\n        var textStyles = this._textContent.styles;\n\n        this._processItems(textItems, textStyles);\n\n        capability.resolve();\n      } else if (this._textContentStream) {\n        var pump = function pump() {\n          _this2._reader.read().then(function (_ref2) {\n            var value = _ref2.value,\n                done = _ref2.done;\n\n            if (done) {\n              capability.resolve();\n              return;\n            }\n\n            Object.assign(styleCache, value.styles);\n\n            _this2._processItems(value.items, styleCache);\n\n            pump();\n          }, capability.reject);\n        };\n\n        this._reader = this._textContentStream.getReader();\n        pump();\n      } else {\n        throw new Error('Neither \"textContent\" nor \"textContentStream\"' + \" parameters specified.\");\n      }\n\n      capability.promise.then(function () {\n        styleCache = null;\n\n        if (!timeout) {\n          render(_this2);\n        } else {\n          _this2._renderTimer = setTimeout(function () {\n            render(_this2);\n            _this2._renderTimer = null;\n          }, timeout);\n        }\n      }, this._capability.reject);\n    },\n    expandTextDivs: function TextLayer_expandTextDivs(expandDivs) {\n      if (!this._enhanceTextSelection || !this._renderingDone) {\n        return;\n      }\n\n      if (this._bounds !== null) {\n        expand(this);\n        this._bounds = null;\n      }\n\n      var transformBuf = [],\n          paddingBuf = [];\n\n      for (var i = 0, ii = this._textDivs.length; i < ii; i++) {\n        var div = this._textDivs[i];\n\n        var divProps = this._textDivProperties.get(div);\n\n        if (divProps.isWhitespace) {\n          continue;\n        }\n\n        if (expandDivs) {\n          transformBuf.length = 0;\n          paddingBuf.length = 0;\n\n          if (divProps.originalTransform) {\n            transformBuf.push(divProps.originalTransform);\n          }\n\n          if (divProps.paddingTop > 0) {\n            paddingBuf.push(\"\".concat(divProps.paddingTop, \"px\"));\n            transformBuf.push(\"translateY(\".concat(-divProps.paddingTop, \"px)\"));\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingRight > 0) {\n            paddingBuf.push(\"\".concat(divProps.paddingRight / divProps.scale, \"px\"));\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingBottom > 0) {\n            paddingBuf.push(\"\".concat(divProps.paddingBottom, \"px\"));\n          } else {\n            paddingBuf.push(0);\n          }\n\n          if (divProps.paddingLeft > 0) {\n            paddingBuf.push(\"\".concat(divProps.paddingLeft / divProps.scale, \"px\"));\n            transformBuf.push(\"translateX(\".concat(-divProps.paddingLeft / divProps.scale, \"px)\"));\n          } else {\n            paddingBuf.push(0);\n          }\n\n          div.style.padding = paddingBuf.join(\" \");\n\n          if (transformBuf.length) {\n            div.style.transform = transformBuf.join(\" \");\n          }\n        } else {\n          div.style.padding = null;\n          div.style.transform = divProps.originalTransform;\n        }\n      }\n    }\n  };\n\n  function renderTextLayer(renderParameters) {\n    var task = new TextLayerRenderTask({\n      textContent: renderParameters.textContent,\n      textContentStream: renderParameters.textContentStream,\n      container: renderParameters.container,\n      viewport: renderParameters.viewport,\n      textDivs: renderParameters.textDivs,\n      textContentItemsStr: renderParameters.textContentItemsStr,\n      enhanceTextSelection: renderParameters.enhanceTextSelection\n    });\n\n    task._render(renderParameters.timeout);\n\n    return task;\n  }\n\n  return renderTextLayer;\n}();\n\nexports.renderTextLayer = renderTextLayer;\n\n/***/ }),\n/* 218 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SVGGraphics = void 0;\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _display_utils = __w_pdfjs_require__(1);\n\nvar _is_node = __w_pdfjs_require__(7);\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar SVGGraphics = function SVGGraphics() {\n  throw new Error(\"Not implemented: SVGGraphics\");\n};\n\nexports.SVGGraphics = SVGGraphics;\n{\n  var opListToTree = function opListToTree(opList) {\n    var opTree = [];\n    var tmp = [];\n\n    var _iterator = _createForOfIteratorHelper(opList),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var opListElement = _step.value;\n\n        if (opListElement.fn === \"save\") {\n          opTree.push({\n            fnId: 92,\n            fn: \"group\",\n            items: []\n          });\n          tmp.push(opTree);\n          opTree = opTree[opTree.length - 1].items;\n          continue;\n        }\n\n        if (opListElement.fn === \"restore\") {\n          opTree = tmp.pop();\n        } else {\n          opTree.push(opListElement);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return opTree;\n  };\n\n  var pf = function pf(value) {\n    if (Number.isInteger(value)) {\n      return value.toString();\n    }\n\n    var s = value.toFixed(10);\n    var i = s.length - 1;\n\n    if (s[i] !== \"0\") {\n      return s;\n    }\n\n    do {\n      i--;\n    } while (s[i] === \"0\");\n\n    return s.substring(0, s[i] === \".\" ? i : i + 1);\n  };\n\n  var pm = function pm(m) {\n    if (m[4] === 0 && m[5] === 0) {\n      if (m[1] === 0 && m[2] === 0) {\n        if (m[0] === 1 && m[3] === 1) {\n          return \"\";\n        }\n\n        return \"scale(\".concat(pf(m[0]), \" \").concat(pf(m[3]), \")\");\n      }\n\n      if (m[0] === m[3] && m[1] === -m[2]) {\n        var a = Math.acos(m[0]) * 180 / Math.PI;\n        return \"rotate(\".concat(pf(a), \")\");\n      }\n    } else {\n      if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n        return \"translate(\".concat(pf(m[4]), \" \").concat(pf(m[5]), \")\");\n      }\n    }\n\n    return \"matrix(\".concat(pf(m[0]), \" \").concat(pf(m[1]), \" \").concat(pf(m[2]), \" \").concat(pf(m[3]), \" \").concat(pf(m[4]), \" \") + \"\".concat(pf(m[5]), \")\");\n  };\n\n  var SVG_DEFAULTS = {\n    fontStyle: \"normal\",\n    fontWeight: \"normal\",\n    fillColor: \"#000000\"\n  };\n  var XML_NS = \"http://www.w3.org/XML/1998/namespace\";\n  var XLINK_NS = \"http://www.w3.org/1999/xlink\";\n  var LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\n  var LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\n\n  var convertImgDataToPng = function () {\n    var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n    var CHUNK_WRAPPER_SIZE = 12;\n    var crcTable = new Int32Array(256);\n\n    for (var i = 0; i < 256; i++) {\n      var c = i;\n\n      for (var h = 0; h < 8; h++) {\n        if (c & 1) {\n          c = 0xedb88320 ^ c >> 1 & 0x7fffffff;\n        } else {\n          c = c >> 1 & 0x7fffffff;\n        }\n      }\n\n      crcTable[i] = c;\n    }\n\n    function crc32(data, start, end) {\n      var crc = -1;\n\n      for (var _i = start; _i < end; _i++) {\n        var a = (crc ^ data[_i]) & 0xff;\n        var b = crcTable[a];\n        crc = crc >>> 8 ^ b;\n      }\n\n      return crc ^ -1;\n    }\n\n    function writePngChunk(type, body, data, offset) {\n      var p = offset;\n      var len = body.length;\n      data[p] = len >> 24 & 0xff;\n      data[p + 1] = len >> 16 & 0xff;\n      data[p + 2] = len >> 8 & 0xff;\n      data[p + 3] = len & 0xff;\n      p += 4;\n      data[p] = type.charCodeAt(0) & 0xff;\n      data[p + 1] = type.charCodeAt(1) & 0xff;\n      data[p + 2] = type.charCodeAt(2) & 0xff;\n      data[p + 3] = type.charCodeAt(3) & 0xff;\n      p += 4;\n      data.set(body, p);\n      p += body.length;\n      var crc = crc32(data, offset + 4, p);\n      data[p] = crc >> 24 & 0xff;\n      data[p + 1] = crc >> 16 & 0xff;\n      data[p + 2] = crc >> 8 & 0xff;\n      data[p + 3] = crc & 0xff;\n    }\n\n    function adler32(data, start, end) {\n      var a = 1;\n      var b = 0;\n\n      for (var _i2 = start; _i2 < end; ++_i2) {\n        a = (a + (data[_i2] & 0xff)) % 65521;\n        b = (b + a) % 65521;\n      }\n\n      return b << 16 | a;\n    }\n\n    function deflateSync(literals) {\n      if (!_is_node.isNodeJS) {\n        return deflateSyncUncompressed(literals);\n      }\n\n      try {\n        var input;\n\n        if (parseInt(process.versions.node) >= 8) {\n          input = literals;\n        } else {\n          input = Buffer.from(literals);\n        }\n\n        var output = __webpack_require__(/*! zlib */ \"?3098\").deflateSync(input, {\n          level: 9\n        });\n\n        return output instanceof Uint8Array ? output : new Uint8Array(output);\n      } catch (e) {\n        (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n      }\n\n      return deflateSyncUncompressed(literals);\n    }\n\n    function deflateSyncUncompressed(literals) {\n      var len = literals.length;\n      var maxBlockLength = 0xffff;\n      var deflateBlocks = Math.ceil(len / maxBlockLength);\n      var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n      var pi = 0;\n      idat[pi++] = 0x78;\n      idat[pi++] = 0x9c;\n      var pos = 0;\n\n      while (len > maxBlockLength) {\n        idat[pi++] = 0x00;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0xff;\n        idat[pi++] = 0x00;\n        idat[pi++] = 0x00;\n        idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n        pi += maxBlockLength;\n        pos += maxBlockLength;\n        len -= maxBlockLength;\n      }\n\n      idat[pi++] = 0x01;\n      idat[pi++] = len & 0xff;\n      idat[pi++] = len >> 8 & 0xff;\n      idat[pi++] = ~len & 0xffff & 0xff;\n      idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n      idat.set(literals.subarray(pos), pi);\n      pi += literals.length - pos;\n      var adler = adler32(literals, 0, literals.length);\n      idat[pi++] = adler >> 24 & 0xff;\n      idat[pi++] = adler >> 16 & 0xff;\n      idat[pi++] = adler >> 8 & 0xff;\n      idat[pi++] = adler & 0xff;\n      return idat;\n    }\n\n    function encode(imgData, kind, forceDataSchema, isMask) {\n      var width = imgData.width;\n      var height = imgData.height;\n      var bitDepth, colorType, lineSize;\n      var bytes = imgData.data;\n\n      switch (kind) {\n        case _util.ImageKind.GRAYSCALE_1BPP:\n          colorType = 0;\n          bitDepth = 1;\n          lineSize = width + 7 >> 3;\n          break;\n\n        case _util.ImageKind.RGB_24BPP:\n          colorType = 2;\n          bitDepth = 8;\n          lineSize = width * 3;\n          break;\n\n        case _util.ImageKind.RGBA_32BPP:\n          colorType = 6;\n          bitDepth = 8;\n          lineSize = width * 4;\n          break;\n\n        default:\n          throw new Error(\"invalid format\");\n      }\n\n      var literals = new Uint8Array((1 + lineSize) * height);\n      var offsetLiterals = 0,\n          offsetBytes = 0;\n\n      for (var y = 0; y < height; ++y) {\n        literals[offsetLiterals++] = 0;\n        literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n        offsetBytes += lineSize;\n        offsetLiterals += lineSize;\n      }\n\n      if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n        offsetLiterals = 0;\n\n        for (var _y = 0; _y < height; _y++) {\n          offsetLiterals++;\n\n          for (var _i3 = 0; _i3 < lineSize; _i3++) {\n            literals[offsetLiterals++] ^= 0xff;\n          }\n        }\n      }\n\n      var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n      var idat = deflateSync(literals);\n      var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n      var data = new Uint8Array(pngLength);\n      var offset = 0;\n      data.set(PNG_HEADER, offset);\n      offset += PNG_HEADER.length;\n      writePngChunk(\"IHDR\", ihdr, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n      writePngChunk(\"IDATA\", idat, data, offset);\n      offset += CHUNK_WRAPPER_SIZE + idat.length;\n      writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n      return (0, _util.createObjectURL)(data, \"image/png\", forceDataSchema);\n    }\n\n    return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n      var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n      return encode(imgData, kind, forceDataSchema, isMask);\n    };\n  }();\n\n  var SVGExtraState = /*#__PURE__*/function () {\n    function SVGExtraState() {\n      _classCallCheck(this, SVGExtraState);\n\n      this.fontSizeScale = 1;\n      this.fontWeight = SVG_DEFAULTS.fontWeight;\n      this.fontSize = 0;\n      this.textMatrix = _util.IDENTITY_MATRIX;\n      this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n      this.leading = 0;\n      this.textRenderingMode = _util.TextRenderingMode.FILL;\n      this.textMatrixScale = 1;\n      this.x = 0;\n      this.y = 0;\n      this.lineX = 0;\n      this.lineY = 0;\n      this.charSpacing = 0;\n      this.wordSpacing = 0;\n      this.textHScale = 1;\n      this.textRise = 0;\n      this.fillColor = SVG_DEFAULTS.fillColor;\n      this.strokeColor = \"#000000\";\n      this.fillAlpha = 1;\n      this.strokeAlpha = 1;\n      this.lineWidth = 1;\n      this.lineJoin = \"\";\n      this.lineCap = \"\";\n      this.miterLimit = 0;\n      this.dashArray = [];\n      this.dashPhase = 0;\n      this.dependencies = [];\n      this.activeClipUrl = null;\n      this.clipGroup = null;\n      this.maskId = \"\";\n    }\n\n    _createClass(SVGExtraState, [{\n      key: \"clone\",\n      value: function clone() {\n        return Object.create(this);\n      }\n    }, {\n      key: \"setCurrentPoint\",\n      value: function setCurrentPoint(x, y) {\n        this.x = x;\n        this.y = y;\n      }\n    }]);\n\n    return SVGExtraState;\n  }();\n\n  var clipCount = 0;\n  var maskCount = 0;\n  var shadingCount = 0;\n\n  exports.SVGGraphics = SVGGraphics = /*#__PURE__*/function () {\n    function SVGGraphics(commonObjs, objs) {\n      var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      _classCallCheck(this, SVGGraphics);\n\n      this.svgFactory = new _display_utils.DOMSVGFactory();\n      this.current = new SVGExtraState();\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.transformStack = [];\n      this.extraStack = [];\n      this.commonObjs = commonObjs;\n      this.objs = objs;\n      this.pendingClip = null;\n      this.pendingEOFill = false;\n      this.embedFonts = false;\n      this.embeddedFonts = Object.create(null);\n      this.cssStyle = null;\n      this.forceDataSchema = !!forceDataSchema;\n      this._operatorIdMapping = [];\n\n      for (var op in _util.OPS) {\n        this._operatorIdMapping[_util.OPS[op]] = op;\n      }\n    }\n\n    _createClass(SVGGraphics, [{\n      key: \"save\",\n      value: function save() {\n        this.transformStack.push(this.transformMatrix);\n        var old = this.current;\n        this.extraStack.push(old);\n        this.current = old.clone();\n      }\n    }, {\n      key: \"restore\",\n      value: function restore() {\n        this.transformMatrix = this.transformStack.pop();\n        this.current = this.extraStack.pop();\n        this.pendingClip = null;\n        this.tgrp = null;\n      }\n    }, {\n      key: \"group\",\n      value: function group(items) {\n        this.save();\n        this.executeOpTree(items);\n        this.restore();\n      }\n    }, {\n      key: \"loadDependencies\",\n      value: function loadDependencies(operatorList) {\n        var _this = this;\n\n        var fnArray = operatorList.fnArray;\n        var argsArray = operatorList.argsArray;\n\n        for (var i = 0, ii = fnArray.length; i < ii; i++) {\n          if (fnArray[i] !== _util.OPS.dependency) {\n            continue;\n          }\n\n          var _iterator2 = _createForOfIteratorHelper(argsArray[i]),\n              _step2;\n\n          try {\n            var _loop = function _loop() {\n              var obj = _step2.value;\n              var objsPool = obj.startsWith(\"g_\") ? _this.commonObjs : _this.objs;\n              var promise = new Promise(function (resolve) {\n                objsPool.get(obj, resolve);\n              });\n\n              _this.current.dependencies.push(promise);\n            };\n\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              _loop();\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n\n        return Promise.all(this.current.dependencies);\n      }\n    }, {\n      key: \"transform\",\n      value: function transform(a, b, c, d, e, f) {\n        var transformMatrix = [a, b, c, d, e, f];\n        this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n        this.tgrp = null;\n      }\n    }, {\n      key: \"getSVG\",\n      value: function getSVG(operatorList, viewport) {\n        var _this2 = this;\n\n        this.viewport = viewport;\n\n        var svgElement = this._initialize(viewport);\n\n        return this.loadDependencies(operatorList).then(function () {\n          _this2.transformMatrix = _util.IDENTITY_MATRIX;\n\n          _this2.executeOpTree(_this2.convertOpList(operatorList));\n\n          return svgElement;\n        });\n      }\n    }, {\n      key: \"convertOpList\",\n      value: function convertOpList(operatorList) {\n        var operatorIdMapping = this._operatorIdMapping;\n        var argsArray = operatorList.argsArray;\n        var fnArray = operatorList.fnArray;\n        var opList = [];\n\n        for (var i = 0, ii = fnArray.length; i < ii; i++) {\n          var fnId = fnArray[i];\n          opList.push({\n            fnId: fnId,\n            fn: operatorIdMapping[fnId],\n            args: argsArray[i]\n          });\n        }\n\n        return opListToTree(opList);\n      }\n    }, {\n      key: \"executeOpTree\",\n      value: function executeOpTree(opTree) {\n        var _iterator3 = _createForOfIteratorHelper(opTree),\n            _step3;\n\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var opTreeElement = _step3.value;\n            var fn = opTreeElement.fn;\n            var fnId = opTreeElement.fnId;\n            var args = opTreeElement.args;\n\n            switch (fnId | 0) {\n              case _util.OPS.beginText:\n                this.beginText();\n                break;\n\n              case _util.OPS.dependency:\n                break;\n\n              case _util.OPS.setLeading:\n                this.setLeading(args);\n                break;\n\n              case _util.OPS.setLeadingMoveText:\n                this.setLeadingMoveText(args[0], args[1]);\n                break;\n\n              case _util.OPS.setFont:\n                this.setFont(args);\n                break;\n\n              case _util.OPS.showText:\n                this.showText(args[0]);\n                break;\n\n              case _util.OPS.showSpacedText:\n                this.showText(args[0]);\n                break;\n\n              case _util.OPS.endText:\n                this.endText();\n                break;\n\n              case _util.OPS.moveText:\n                this.moveText(args[0], args[1]);\n                break;\n\n              case _util.OPS.setCharSpacing:\n                this.setCharSpacing(args[0]);\n                break;\n\n              case _util.OPS.setWordSpacing:\n                this.setWordSpacing(args[0]);\n                break;\n\n              case _util.OPS.setHScale:\n                this.setHScale(args[0]);\n                break;\n\n              case _util.OPS.setTextMatrix:\n                this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n                break;\n\n              case _util.OPS.setTextRise:\n                this.setTextRise(args[0]);\n                break;\n\n              case _util.OPS.setTextRenderingMode:\n                this.setTextRenderingMode(args[0]);\n                break;\n\n              case _util.OPS.setLineWidth:\n                this.setLineWidth(args[0]);\n                break;\n\n              case _util.OPS.setLineJoin:\n                this.setLineJoin(args[0]);\n                break;\n\n              case _util.OPS.setLineCap:\n                this.setLineCap(args[0]);\n                break;\n\n              case _util.OPS.setMiterLimit:\n                this.setMiterLimit(args[0]);\n                break;\n\n              case _util.OPS.setFillRGBColor:\n                this.setFillRGBColor(args[0], args[1], args[2]);\n                break;\n\n              case _util.OPS.setStrokeRGBColor:\n                this.setStrokeRGBColor(args[0], args[1], args[2]);\n                break;\n\n              case _util.OPS.setStrokeColorN:\n                this.setStrokeColorN(args);\n                break;\n\n              case _util.OPS.setFillColorN:\n                this.setFillColorN(args);\n                break;\n\n              case _util.OPS.shadingFill:\n                this.shadingFill(args[0]);\n                break;\n\n              case _util.OPS.setDash:\n                this.setDash(args[0], args[1]);\n                break;\n\n              case _util.OPS.setRenderingIntent:\n                this.setRenderingIntent(args[0]);\n                break;\n\n              case _util.OPS.setFlatness:\n                this.setFlatness(args[0]);\n                break;\n\n              case _util.OPS.setGState:\n                this.setGState(args[0]);\n                break;\n\n              case _util.OPS.fill:\n                this.fill();\n                break;\n\n              case _util.OPS.eoFill:\n                this.eoFill();\n                break;\n\n              case _util.OPS.stroke:\n                this.stroke();\n                break;\n\n              case _util.OPS.fillStroke:\n                this.fillStroke();\n                break;\n\n              case _util.OPS.eoFillStroke:\n                this.eoFillStroke();\n                break;\n\n              case _util.OPS.clip:\n                this.clip(\"nonzero\");\n                break;\n\n              case _util.OPS.eoClip:\n                this.clip(\"evenodd\");\n                break;\n\n              case _util.OPS.paintSolidColorImageMask:\n                this.paintSolidColorImageMask();\n                break;\n\n              case _util.OPS.paintImageXObject:\n                this.paintImageXObject(args[0]);\n                break;\n\n              case _util.OPS.paintInlineImageXObject:\n                this.paintInlineImageXObject(args[0]);\n                break;\n\n              case _util.OPS.paintImageMaskXObject:\n                this.paintImageMaskXObject(args[0]);\n                break;\n\n              case _util.OPS.paintFormXObjectBegin:\n                this.paintFormXObjectBegin(args[0], args[1]);\n                break;\n\n              case _util.OPS.paintFormXObjectEnd:\n                this.paintFormXObjectEnd();\n                break;\n\n              case _util.OPS.closePath:\n                this.closePath();\n                break;\n\n              case _util.OPS.closeStroke:\n                this.closeStroke();\n                break;\n\n              case _util.OPS.closeFillStroke:\n                this.closeFillStroke();\n                break;\n\n              case _util.OPS.closeEOFillStroke:\n                this.closeEOFillStroke();\n                break;\n\n              case _util.OPS.nextLine:\n                this.nextLine();\n                break;\n\n              case _util.OPS.transform:\n                this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n                break;\n\n              case _util.OPS.constructPath:\n                this.constructPath(args[0], args[1]);\n                break;\n\n              case _util.OPS.endPath:\n                this.endPath();\n                break;\n\n              case 92:\n                this.group(opTreeElement.items);\n                break;\n\n              default:\n                (0, _util.warn)(\"Unimplemented operator \".concat(fn));\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }, {\n      key: \"setWordSpacing\",\n      value: function setWordSpacing(wordSpacing) {\n        this.current.wordSpacing = wordSpacing;\n      }\n    }, {\n      key: \"setCharSpacing\",\n      value: function setCharSpacing(charSpacing) {\n        this.current.charSpacing = charSpacing;\n      }\n    }, {\n      key: \"nextLine\",\n      value: function nextLine() {\n        this.moveText(0, this.current.leading);\n      }\n    }, {\n      key: \"setTextMatrix\",\n      value: function setTextMatrix(a, b, c, d, e, f) {\n        var current = this.current;\n        current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n        current.textMatrixScale = Math.sqrt(a * a + b * b);\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n        current.xcoords = [];\n        current.ycoords = [];\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n        current.txtElement.appendChild(current.tspan);\n      }\n    }, {\n      key: \"beginText\",\n      value: function beginText() {\n        var current = this.current;\n        current.x = current.lineX = 0;\n        current.y = current.lineY = 0;\n        current.textMatrix = _util.IDENTITY_MATRIX;\n        current.lineMatrix = _util.IDENTITY_MATRIX;\n        current.textMatrixScale = 1;\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.txtElement = this.svgFactory.createElement(\"svg:text\");\n        current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n        current.xcoords = [];\n        current.ycoords = [];\n      }\n    }, {\n      key: \"moveText\",\n      value: function moveText(x, y) {\n        var current = this.current;\n        current.x = current.lineX += x;\n        current.y = current.lineY += y;\n        current.xcoords = [];\n        current.ycoords = [];\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n      }\n    }, {\n      key: \"showText\",\n      value: function showText(glyphs) {\n        var current = this.current;\n        var font = current.font;\n        var fontSize = current.fontSize;\n\n        if (fontSize === 0) {\n          return;\n        }\n\n        var fontSizeScale = current.fontSizeScale;\n        var charSpacing = current.charSpacing;\n        var wordSpacing = current.wordSpacing;\n        var fontDirection = current.fontDirection;\n        var textHScale = current.textHScale * fontDirection;\n        var vertical = font.vertical;\n        var spacingDir = vertical ? 1 : -1;\n        var defaultVMetrics = font.defaultVMetrics;\n        var widthAdvanceScale = fontSize * current.fontMatrix[0];\n        var x = 0;\n\n        var _iterator4 = _createForOfIteratorHelper(glyphs),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var glyph = _step4.value;\n\n            if (glyph === null) {\n              x += fontDirection * wordSpacing;\n              continue;\n            } else if ((0, _util.isNum)(glyph)) {\n              x += spacingDir * glyph * fontSize / 1000;\n              continue;\n            }\n\n            var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n            var character = glyph.fontChar;\n            var scaledX = void 0,\n                scaledY = void 0;\n            var width = glyph.width;\n\n            if (vertical) {\n              var vx = void 0;\n              var vmetric = glyph.vmetric || defaultVMetrics;\n              vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n              vx = -vx * widthAdvanceScale;\n              var vy = vmetric[2] * widthAdvanceScale;\n              width = vmetric ? -vmetric[0] : width;\n              scaledX = vx / fontSizeScale;\n              scaledY = (x + vy) / fontSizeScale;\n            } else {\n              scaledX = x / fontSizeScale;\n              scaledY = 0;\n            }\n\n            if (glyph.isInFont || font.missingFile) {\n              current.xcoords.push(current.x + scaledX);\n\n              if (vertical) {\n                current.ycoords.push(-current.y + scaledY);\n              }\n\n              current.tspan.textContent += character;\n            } else {}\n\n            var charWidth = void 0;\n\n            if (vertical) {\n              charWidth = width * widthAdvanceScale - spacing * fontDirection;\n            } else {\n              charWidth = width * widthAdvanceScale + spacing * fontDirection;\n            }\n\n            x += charWidth;\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n\n        current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n\n        if (vertical) {\n          current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n        } else {\n          current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        }\n\n        if (vertical) {\n          current.y -= x;\n        } else {\n          current.x += x * textHScale;\n        }\n\n        current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n        current.tspan.setAttributeNS(null, \"font-size\", \"\".concat(pf(current.fontSize), \"px\"));\n\n        if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n          current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n        }\n\n        if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n          current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n        }\n\n        var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n\n        if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n            current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n          }\n\n          if (current.fillAlpha < 1) {\n            current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n          }\n        } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n          current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n        } else {\n          current.tspan.setAttributeNS(null, \"fill\", \"none\");\n        }\n\n        if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n          var lineWidthScale = 1 / (current.textMatrixScale || 1);\n\n          this._setStrokeAttributes(current.tspan, lineWidthScale);\n        }\n\n        var textMatrix = current.textMatrix;\n\n        if (current.textRise !== 0) {\n          textMatrix = textMatrix.slice();\n          textMatrix[5] += current.textRise;\n        }\n\n        current.txtElement.setAttributeNS(null, \"transform\", \"\".concat(pm(textMatrix), \" scale(\").concat(pf(textHScale), \", -1)\"));\n        current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n        current.txtElement.appendChild(current.tspan);\n        current.txtgrp.appendChild(current.txtElement);\n\n        this._ensureTransformGroup().appendChild(current.txtElement);\n      }\n    }, {\n      key: \"setLeadingMoveText\",\n      value: function setLeadingMoveText(x, y) {\n        this.setLeading(-y);\n        this.moveText(x, y);\n      }\n    }, {\n      key: \"addFontStyle\",\n      value: function addFontStyle(fontObj) {\n        if (!fontObj.data) {\n          throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n        }\n\n        if (!this.cssStyle) {\n          this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n          this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n          this.defs.appendChild(this.cssStyle);\n        }\n\n        var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n        this.cssStyle.textContent += \"@font-face { font-family: \\\"\".concat(fontObj.loadedName, \"\\\";\") + \" src: url(\".concat(url, \"); }\\n\");\n      }\n    }, {\n      key: \"setFont\",\n      value: function setFont(details) {\n        var current = this.current;\n        var fontObj = this.commonObjs.get(details[0]);\n        var size = details[1];\n        current.font = fontObj;\n\n        if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n          this.addFontStyle(fontObj);\n          this.embeddedFonts[fontObj.loadedName] = fontObj;\n        }\n\n        current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX;\n        var bold = \"normal\";\n\n        if (fontObj.black) {\n          bold = \"900\";\n        } else if (fontObj.bold) {\n          bold = \"bold\";\n        }\n\n        var italic = fontObj.italic ? \"italic\" : \"normal\";\n\n        if (size < 0) {\n          size = -size;\n          current.fontDirection = -1;\n        } else {\n          current.fontDirection = 1;\n        }\n\n        current.fontSize = size;\n        current.fontFamily = fontObj.loadedName;\n        current.fontWeight = bold;\n        current.fontStyle = italic;\n        current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n        current.xcoords = [];\n        current.ycoords = [];\n      }\n    }, {\n      key: \"endText\",\n      value: function endText() {\n        var current = this.current;\n\n        if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) {\n          current.element = current.txtElement;\n          this.clip(\"nonzero\");\n          this.endPath();\n        }\n      }\n    }, {\n      key: \"setLineWidth\",\n      value: function setLineWidth(width) {\n        if (width > 0) {\n          this.current.lineWidth = width;\n        }\n      }\n    }, {\n      key: \"setLineCap\",\n      value: function setLineCap(style) {\n        this.current.lineCap = LINE_CAP_STYLES[style];\n      }\n    }, {\n      key: \"setLineJoin\",\n      value: function setLineJoin(style) {\n        this.current.lineJoin = LINE_JOIN_STYLES[style];\n      }\n    }, {\n      key: \"setMiterLimit\",\n      value: function setMiterLimit(limit) {\n        this.current.miterLimit = limit;\n      }\n    }, {\n      key: \"setStrokeAlpha\",\n      value: function setStrokeAlpha(strokeAlpha) {\n        this.current.strokeAlpha = strokeAlpha;\n      }\n    }, {\n      key: \"setStrokeRGBColor\",\n      value: function setStrokeRGBColor(r, g, b) {\n        this.current.strokeColor = _util.Util.makeCssRgb(r, g, b);\n      }\n    }, {\n      key: \"setFillAlpha\",\n      value: function setFillAlpha(fillAlpha) {\n        this.current.fillAlpha = fillAlpha;\n      }\n    }, {\n      key: \"setFillRGBColor\",\n      value: function setFillRGBColor(r, g, b) {\n        this.current.fillColor = _util.Util.makeCssRgb(r, g, b);\n        this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n        this.current.xcoords = [];\n        this.current.ycoords = [];\n      }\n    }, {\n      key: \"setStrokeColorN\",\n      value: function setStrokeColorN(args) {\n        this.current.strokeColor = this._makeColorN_Pattern(args);\n      }\n    }, {\n      key: \"setFillColorN\",\n      value: function setFillColorN(args) {\n        this.current.fillColor = this._makeColorN_Pattern(args);\n      }\n    }, {\n      key: \"shadingFill\",\n      value: function shadingFill(args) {\n        var width = this.viewport.width;\n        var height = this.viewport.height;\n\n        var inv = _util.Util.inverseTransform(this.transformMatrix);\n\n        var bl = _util.Util.applyTransform([0, 0], inv);\n\n        var br = _util.Util.applyTransform([0, height], inv);\n\n        var ul = _util.Util.applyTransform([width, 0], inv);\n\n        var ur = _util.Util.applyTransform([width, height], inv);\n\n        var x0 = Math.min(bl[0], br[0], ul[0], ur[0]);\n        var y0 = Math.min(bl[1], br[1], ul[1], ur[1]);\n        var x1 = Math.max(bl[0], br[0], ul[0], ur[0]);\n        var y1 = Math.max(bl[1], br[1], ul[1], ur[1]);\n        var rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", x0);\n        rect.setAttributeNS(null, \"y\", y0);\n        rect.setAttributeNS(null, \"width\", x1 - x0);\n        rect.setAttributeNS(null, \"height\", y1 - y0);\n        rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n\n        if (this.current.fillAlpha < 1) {\n          rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n        }\n\n        this._ensureTransformGroup().appendChild(rect);\n      }\n    }, {\n      key: \"_makeColorN_Pattern\",\n      value: function _makeColorN_Pattern(args) {\n        if (args[0] === \"TilingPattern\") {\n          return this._makeTilingPattern(args);\n        }\n\n        return this._makeShadingPattern(args);\n      }\n    }, {\n      key: \"_makeTilingPattern\",\n      value: function _makeTilingPattern(args) {\n        var color = args[1];\n        var operatorList = args[2];\n        var matrix = args[3] || _util.IDENTITY_MATRIX;\n\n        var _args$ = _slicedToArray(args[4], 4),\n            x0 = _args$[0],\n            y0 = _args$[1],\n            x1 = _args$[2],\n            y1 = _args$[3];\n\n        var xstep = args[5];\n        var ystep = args[6];\n        var paintType = args[7];\n        var tilingId = \"shading\".concat(shadingCount++);\n\n        var _Util$applyTransform = _util.Util.applyTransform([x0, y0], matrix),\n            _Util$applyTransform2 = _slicedToArray(_Util$applyTransform, 2),\n            tx0 = _Util$applyTransform2[0],\n            ty0 = _Util$applyTransform2[1];\n\n        var _Util$applyTransform3 = _util.Util.applyTransform([x1, y1], matrix),\n            _Util$applyTransform4 = _slicedToArray(_Util$applyTransform3, 2),\n            tx1 = _Util$applyTransform4[0],\n            ty1 = _Util$applyTransform4[1];\n\n        var _Util$singularValueDe = _util.Util.singularValueDecompose2dScale(matrix),\n            _Util$singularValueDe2 = _slicedToArray(_Util$singularValueDe, 2),\n            xscale = _Util$singularValueDe2[0],\n            yscale = _Util$singularValueDe2[1];\n\n        var txstep = xstep * xscale;\n        var tystep = ystep * yscale;\n        var tiling = this.svgFactory.createElement(\"svg:pattern\");\n        tiling.setAttributeNS(null, \"id\", tilingId);\n        tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n        tiling.setAttributeNS(null, \"width\", txstep);\n        tiling.setAttributeNS(null, \"height\", tystep);\n        tiling.setAttributeNS(null, \"x\", \"\".concat(tx0));\n        tiling.setAttributeNS(null, \"y\", \"\".concat(ty0));\n        var svg = this.svg;\n        var transformMatrix = this.transformMatrix;\n        var fillColor = this.current.fillColor;\n        var strokeColor = this.current.strokeColor;\n        var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n        this.svg = bbox;\n        this.transformMatrix = matrix;\n\n        if (paintType === 2) {\n          var cssColor = _util.Util.makeCssRgb.apply(_util.Util, _toConsumableArray(color));\n\n          this.current.fillColor = cssColor;\n          this.current.strokeColor = cssColor;\n        }\n\n        this.executeOpTree(this.convertOpList(operatorList));\n        this.svg = svg;\n        this.transformMatrix = transformMatrix;\n        this.current.fillColor = fillColor;\n        this.current.strokeColor = strokeColor;\n        tiling.appendChild(bbox.childNodes[0]);\n        this.defs.appendChild(tiling);\n        return \"url(#\".concat(tilingId, \")\");\n      }\n    }, {\n      key: \"_makeShadingPattern\",\n      value: function _makeShadingPattern(args) {\n        switch (args[0]) {\n          case \"RadialAxial\":\n            var shadingId = \"shading\".concat(shadingCount++);\n            var colorStops = args[3];\n            var gradient;\n\n            switch (args[1]) {\n              case \"axial\":\n                var point0 = args[4];\n                var point1 = args[5];\n                gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n                gradient.setAttributeNS(null, \"id\", shadingId);\n                gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                gradient.setAttributeNS(null, \"x1\", point0[0]);\n                gradient.setAttributeNS(null, \"y1\", point0[1]);\n                gradient.setAttributeNS(null, \"x2\", point1[0]);\n                gradient.setAttributeNS(null, \"y2\", point1[1]);\n                break;\n\n              case \"radial\":\n                var focalPoint = args[4];\n                var circlePoint = args[5];\n                var focalRadius = args[6];\n                var circleRadius = args[7];\n                gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n                gradient.setAttributeNS(null, \"id\", shadingId);\n                gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n                gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n                gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n                gradient.setAttributeNS(null, \"r\", circleRadius);\n                gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n                gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n                gradient.setAttributeNS(null, \"fr\", focalRadius);\n                break;\n\n              default:\n                throw new Error(\"Unknown RadialAxial type: \".concat(args[1]));\n            }\n\n            var _iterator5 = _createForOfIteratorHelper(colorStops),\n                _step5;\n\n            try {\n              for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n                var colorStop = _step5.value;\n                var stop = this.svgFactory.createElement(\"svg:stop\");\n                stop.setAttributeNS(null, \"offset\", colorStop[0]);\n                stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n                gradient.appendChild(stop);\n              }\n            } catch (err) {\n              _iterator5.e(err);\n            } finally {\n              _iterator5.f();\n            }\n\n            this.defs.appendChild(gradient);\n            return \"url(#\".concat(shadingId, \")\");\n\n          case \"Mesh\":\n            (0, _util.warn)(\"Unimplemented pattern Mesh\");\n            return null;\n\n          case \"Dummy\":\n            return \"hotpink\";\n\n          default:\n            throw new Error(\"Unknown IR type: \".concat(args[0]));\n        }\n      }\n    }, {\n      key: \"setDash\",\n      value: function setDash(dashArray, dashPhase) {\n        this.current.dashArray = dashArray;\n        this.current.dashPhase = dashPhase;\n      }\n    }, {\n      key: \"constructPath\",\n      value: function constructPath(ops, args) {\n        var current = this.current;\n        var x = current.x,\n            y = current.y;\n        var d = [];\n        var j = 0;\n\n        var _iterator6 = _createForOfIteratorHelper(ops),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var op = _step6.value;\n\n            switch (op | 0) {\n              case _util.OPS.rectangle:\n                x = args[j++];\n                y = args[j++];\n                var width = args[j++];\n                var height = args[j++];\n                var xw = x + width;\n                var yh = y + height;\n                d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n                break;\n\n              case _util.OPS.moveTo:\n                x = args[j++];\n                y = args[j++];\n                d.push(\"M\", pf(x), pf(y));\n                break;\n\n              case _util.OPS.lineTo:\n                x = args[j++];\n                y = args[j++];\n                d.push(\"L\", pf(x), pf(y));\n                break;\n\n              case _util.OPS.curveTo:\n                x = args[j + 4];\n                y = args[j + 5];\n                d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n                j += 6;\n                break;\n\n              case _util.OPS.curveTo2:\n                d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n                x = args[j + 2];\n                y = args[j + 3];\n                j += 4;\n                break;\n\n              case _util.OPS.curveTo3:\n                x = args[j + 2];\n                y = args[j + 3];\n                d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n                j += 4;\n                break;\n\n              case _util.OPS.closePath:\n                d.push(\"Z\");\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        d = d.join(\" \");\n\n        if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n          d = current.path.getAttributeNS(null, \"d\") + d;\n        } else {\n          current.path = this.svgFactory.createElement(\"svg:path\");\n\n          this._ensureTransformGroup().appendChild(current.path);\n        }\n\n        current.path.setAttributeNS(null, \"d\", d);\n        current.path.setAttributeNS(null, \"fill\", \"none\");\n        current.element = current.path;\n        current.setCurrentPoint(x, y);\n      }\n    }, {\n      key: \"endPath\",\n      value: function endPath() {\n        var current = this.current;\n        current.path = null;\n\n        if (!this.pendingClip) {\n          return;\n        }\n\n        if (!current.element) {\n          this.pendingClip = null;\n          return;\n        }\n\n        var clipId = \"clippath\".concat(clipCount++);\n        var clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n        clipPath.setAttributeNS(null, \"id\", clipId);\n        clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n        var clipElement = current.element.cloneNode(true);\n\n        if (this.pendingClip === \"evenodd\") {\n          clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n        } else {\n          clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n        }\n\n        this.pendingClip = null;\n        clipPath.appendChild(clipElement);\n        this.defs.appendChild(clipPath);\n\n        if (current.activeClipUrl) {\n          current.clipGroup = null;\n          this.extraStack.forEach(function (prev) {\n            prev.clipGroup = null;\n          });\n          clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n        }\n\n        current.activeClipUrl = \"url(#\".concat(clipId, \")\");\n        this.tgrp = null;\n      }\n    }, {\n      key: \"clip\",\n      value: function clip(type) {\n        this.pendingClip = type;\n      }\n    }, {\n      key: \"closePath\",\n      value: function closePath() {\n        var current = this.current;\n\n        if (current.path) {\n          var d = \"\".concat(current.path.getAttributeNS(null, \"d\"), \"Z\");\n          current.path.setAttributeNS(null, \"d\", d);\n        }\n      }\n    }, {\n      key: \"setLeading\",\n      value: function setLeading(leading) {\n        this.current.leading = -leading;\n      }\n    }, {\n      key: \"setTextRise\",\n      value: function setTextRise(textRise) {\n        this.current.textRise = textRise;\n      }\n    }, {\n      key: \"setTextRenderingMode\",\n      value: function setTextRenderingMode(textRenderingMode) {\n        this.current.textRenderingMode = textRenderingMode;\n      }\n    }, {\n      key: \"setHScale\",\n      value: function setHScale(scale) {\n        this.current.textHScale = scale / 100;\n      }\n    }, {\n      key: \"setRenderingIntent\",\n      value: function setRenderingIntent(intent) {}\n    }, {\n      key: \"setFlatness\",\n      value: function setFlatness(flatness) {}\n    }, {\n      key: \"setGState\",\n      value: function setGState(states) {\n        var _iterator7 = _createForOfIteratorHelper(states),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var _step7$value = _slicedToArray(_step7.value, 2),\n                key = _step7$value[0],\n                value = _step7$value[1];\n\n            switch (key) {\n              case \"LW\":\n                this.setLineWidth(value);\n                break;\n\n              case \"LC\":\n                this.setLineCap(value);\n                break;\n\n              case \"LJ\":\n                this.setLineJoin(value);\n                break;\n\n              case \"ML\":\n                this.setMiterLimit(value);\n                break;\n\n              case \"D\":\n                this.setDash(value[0], value[1]);\n                break;\n\n              case \"RI\":\n                this.setRenderingIntent(value);\n                break;\n\n              case \"FL\":\n                this.setFlatness(value);\n                break;\n\n              case \"Font\":\n                this.setFont(value);\n                break;\n\n              case \"CA\":\n                this.setStrokeAlpha(value);\n                break;\n\n              case \"ca\":\n                this.setFillAlpha(value);\n                break;\n\n              default:\n                (0, _util.warn)(\"Unimplemented graphic state operator \".concat(key));\n                break;\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n      }\n    }, {\n      key: \"fill\",\n      value: function fill() {\n        var current = this.current;\n\n        if (current.element) {\n          current.element.setAttributeNS(null, \"fill\", current.fillColor);\n          current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n          this.endPath();\n        }\n      }\n    }, {\n      key: \"stroke\",\n      value: function stroke() {\n        var current = this.current;\n\n        if (current.element) {\n          this._setStrokeAttributes(current.element);\n\n          current.element.setAttributeNS(null, \"fill\", \"none\");\n          this.endPath();\n        }\n      }\n    }, {\n      key: \"_setStrokeAttributes\",\n      value: function _setStrokeAttributes(element) {\n        var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        var current = this.current;\n        var dashArray = current.dashArray;\n\n        if (lineWidthScale !== 1 && dashArray.length > 0) {\n          dashArray = dashArray.map(function (value) {\n            return lineWidthScale * value;\n          });\n        }\n\n        element.setAttributeNS(null, \"stroke\", current.strokeColor);\n        element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n        element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n        element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n        element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n        element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n        element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n        element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n      }\n    }, {\n      key: \"eoFill\",\n      value: function eoFill() {\n        if (this.current.element) {\n          this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n        }\n\n        this.fill();\n      }\n    }, {\n      key: \"fillStroke\",\n      value: function fillStroke() {\n        this.stroke();\n        this.fill();\n      }\n    }, {\n      key: \"eoFillStroke\",\n      value: function eoFillStroke() {\n        if (this.current.element) {\n          this.current.element.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n        }\n\n        this.fillStroke();\n      }\n    }, {\n      key: \"closeStroke\",\n      value: function closeStroke() {\n        this.closePath();\n        this.stroke();\n      }\n    }, {\n      key: \"closeFillStroke\",\n      value: function closeFillStroke() {\n        this.closePath();\n        this.fillStroke();\n      }\n    }, {\n      key: \"closeEOFillStroke\",\n      value: function closeEOFillStroke() {\n        this.closePath();\n        this.eoFillStroke();\n      }\n    }, {\n      key: \"paintSolidColorImageMask\",\n      value: function paintSolidColorImageMask() {\n        var rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", \"0\");\n        rect.setAttributeNS(null, \"y\", \"0\");\n        rect.setAttributeNS(null, \"width\", \"1px\");\n        rect.setAttributeNS(null, \"height\", \"1px\");\n        rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n\n        this._ensureTransformGroup().appendChild(rect);\n      }\n    }, {\n      key: \"paintImageXObject\",\n      value: function paintImageXObject(objId) {\n        var imgData = objId.startsWith(\"g_\") ? this.commonObjs.get(objId) : this.objs.get(objId);\n\n        if (!imgData) {\n          (0, _util.warn)(\"Dependent image with object ID \".concat(objId, \" is not ready yet\"));\n          return;\n        }\n\n        this.paintInlineImageXObject(imgData);\n      }\n    }, {\n      key: \"paintInlineImageXObject\",\n      value: function paintInlineImageXObject(imgData, mask) {\n        var width = imgData.width;\n        var height = imgData.height;\n        var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n        var cliprect = this.svgFactory.createElement(\"svg:rect\");\n        cliprect.setAttributeNS(null, \"x\", \"0\");\n        cliprect.setAttributeNS(null, \"y\", \"0\");\n        cliprect.setAttributeNS(null, \"width\", pf(width));\n        cliprect.setAttributeNS(null, \"height\", pf(height));\n        this.current.element = cliprect;\n        this.clip(\"nonzero\");\n        var imgEl = this.svgFactory.createElement(\"svg:image\");\n        imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n        imgEl.setAttributeNS(null, \"x\", \"0\");\n        imgEl.setAttributeNS(null, \"y\", pf(-height));\n        imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n        imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n        imgEl.setAttributeNS(null, \"transform\", \"scale(\".concat(pf(1 / width), \" \").concat(pf(-1 / height), \")\"));\n\n        if (mask) {\n          mask.appendChild(imgEl);\n        } else {\n          this._ensureTransformGroup().appendChild(imgEl);\n        }\n      }\n    }, {\n      key: \"paintImageMaskXObject\",\n      value: function paintImageMaskXObject(imgData) {\n        var current = this.current;\n        var width = imgData.width;\n        var height = imgData.height;\n        var fillColor = current.fillColor;\n        current.maskId = \"mask\".concat(maskCount++);\n        var mask = this.svgFactory.createElement(\"svg:mask\");\n        mask.setAttributeNS(null, \"id\", current.maskId);\n        var rect = this.svgFactory.createElement(\"svg:rect\");\n        rect.setAttributeNS(null, \"x\", \"0\");\n        rect.setAttributeNS(null, \"y\", \"0\");\n        rect.setAttributeNS(null, \"width\", pf(width));\n        rect.setAttributeNS(null, \"height\", pf(height));\n        rect.setAttributeNS(null, \"fill\", fillColor);\n        rect.setAttributeNS(null, \"mask\", \"url(#\".concat(current.maskId, \")\"));\n        this.defs.appendChild(mask);\n\n        this._ensureTransformGroup().appendChild(rect);\n\n        this.paintInlineImageXObject(imgData, mask);\n      }\n    }, {\n      key: \"paintFormXObjectBegin\",\n      value: function paintFormXObjectBegin(matrix, bbox) {\n        if (Array.isArray(matrix) && matrix.length === 6) {\n          this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        }\n\n        if (bbox) {\n          var width = bbox[2] - bbox[0];\n          var height = bbox[3] - bbox[1];\n          var cliprect = this.svgFactory.createElement(\"svg:rect\");\n          cliprect.setAttributeNS(null, \"x\", bbox[0]);\n          cliprect.setAttributeNS(null, \"y\", bbox[1]);\n          cliprect.setAttributeNS(null, \"width\", pf(width));\n          cliprect.setAttributeNS(null, \"height\", pf(height));\n          this.current.element = cliprect;\n          this.clip(\"nonzero\");\n          this.endPath();\n        }\n      }\n    }, {\n      key: \"paintFormXObjectEnd\",\n      value: function paintFormXObjectEnd() {}\n    }, {\n      key: \"_initialize\",\n      value: function _initialize(viewport) {\n        var svg = this.svgFactory.create(viewport.width, viewport.height);\n        var definitions = this.svgFactory.createElement(\"svg:defs\");\n        svg.appendChild(definitions);\n        this.defs = definitions;\n        var rootGroup = this.svgFactory.createElement(\"svg:g\");\n        rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n        svg.appendChild(rootGroup);\n        this.svg = rootGroup;\n        return svg;\n      }\n    }, {\n      key: \"_ensureClipGroup\",\n      value: function _ensureClipGroup() {\n        if (!this.current.clipGroup) {\n          var clipGroup = this.svgFactory.createElement(\"svg:g\");\n          clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n          this.svg.appendChild(clipGroup);\n          this.current.clipGroup = clipGroup;\n        }\n\n        return this.current.clipGroup;\n      }\n    }, {\n      key: \"_ensureTransformGroup\",\n      value: function _ensureTransformGroup() {\n        if (!this.tgrp) {\n          this.tgrp = this.svgFactory.createElement(\"svg:g\");\n          this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n\n          if (this.current.activeClipUrl) {\n            this._ensureClipGroup().appendChild(this.tgrp);\n          } else {\n            this.svg.appendChild(this.tgrp);\n          }\n        }\n\n        return this.tgrp;\n      }\n    }]);\n\n    return SVGGraphics;\n  }();\n}\n\n/***/ }),\n/* 219 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFNodeStream = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _network_utils = __w_pdfjs_require__(220);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n;\n\nvar fs = __webpack_require__(/*! fs */ \"?e97d\");\n\nvar http = __webpack_require__(/*! http */ \"?4b1a\");\n\nvar https = __webpack_require__(/*! https */ \"?8c50\");\n\nvar url = __webpack_require__(/*! url */ \"?a9a4\");\n\nvar fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\n\nfunction parseUrl(sourceUrl) {\n  var parsedUrl = url.parse(sourceUrl);\n\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(\"file:///\".concat(sourceUrl));\n  }\n\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n\n  return parsedUrl;\n}\n\nvar PDFNodeStream = /*#__PURE__*/function () {\n  function PDFNodeStream(source) {\n    _classCallCheck(this, PDFNodeStream);\n\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _createClass(PDFNodeStream, [{\n    key: \"getFullReader\",\n    value: function getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n      this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n      return this._fullRequestReader;\n    }\n  }, {\n    key: \"getRangeReader\",\n    value: function getRangeReader(start, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n\n      this._rangeRequestReaders.push(rangeReader);\n\n      return rangeReader;\n    }\n  }, {\n    key: \"cancelAllRequests\",\n    value: function cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      var readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n  }, {\n    key: \"_progressiveDataLength\",\n    get: function get() {\n      return this._fullRequestReader ? this._fullRequestReader._loaded : 0;\n    }\n  }]);\n\n  return PDFNodeStream;\n}();\n\nexports.PDFNodeStream = PDFNodeStream;\n\nvar BaseFullReader = /*#__PURE__*/function () {\n  function BaseFullReader(stream) {\n    _classCallCheck(this, BaseFullReader);\n\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    var source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._headersCapability = (0, _util.createPromiseCapability)();\n  }\n\n  _createClass(BaseFullReader, [{\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var chunk, buffer;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._readCapability.promise;\n\n              case 2:\n                if (!this._done) {\n                  _context.next = 4;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 4:\n                if (!this._storedError) {\n                  _context.next = 6;\n                  break;\n                }\n\n                throw this._storedError;\n\n              case 6:\n                chunk = this._readableStream.read();\n\n                if (!(chunk === null)) {\n                  _context.next = 10;\n                  break;\n                }\n\n                this._readCapability = (0, _util.createPromiseCapability)();\n                return _context.abrupt(\"return\", this.read());\n\n              case 10:\n                this._loaded += chunk.length;\n\n                if (this.onProgress) {\n                  this.onProgress({\n                    loaded: this._loaded,\n                    total: this._contentLength\n                  });\n                }\n\n                buffer = new Uint8Array(chunk).buffer;\n                return _context.abrupt(\"return\", {\n                  value: buffer,\n                  done: false\n                });\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read() {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      if (!this._readableStream) {\n        this._error(reason);\n\n        return;\n      }\n\n      this._readableStream.destroy(reason);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(reason) {\n      this._storedError = reason;\n\n      this._readCapability.resolve();\n    }\n  }, {\n    key: \"_setReadableStream\",\n    value: function _setReadableStream(readableStream) {\n      var _this = this;\n\n      this._readableStream = readableStream;\n      readableStream.on(\"readable\", function () {\n        _this._readCapability.resolve();\n      });\n      readableStream.on(\"end\", function () {\n        readableStream.destroy();\n        _this._done = true;\n\n        _this._readCapability.resolve();\n      });\n      readableStream.on(\"error\", function (reason) {\n        _this._error(reason);\n      });\n\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this._error(new _util.AbortException(\"streaming is disabled\"));\n      }\n\n      if (this._storedError) {\n        this._readableStream.destroy(this._storedError);\n      }\n    }\n  }, {\n    key: \"headersReady\",\n    get: function get() {\n      return this._headersCapability.promise;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._filename;\n    }\n  }, {\n    key: \"contentLength\",\n    get: function get() {\n      return this._contentLength;\n    }\n  }, {\n    key: \"isRangeSupported\",\n    get: function get() {\n      return this._isRangeSupported;\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }]);\n\n  return BaseFullReader;\n}();\n\nvar BaseRangeReader = /*#__PURE__*/function () {\n  function BaseRangeReader(stream) {\n    _classCallCheck(this, BaseRangeReader);\n\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    var source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n\n  _createClass(BaseRangeReader, [{\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var chunk, buffer;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._readCapability.promise;\n\n              case 2:\n                if (!this._done) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 4:\n                if (!this._storedError) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                throw this._storedError;\n\n              case 6:\n                chunk = this._readableStream.read();\n\n                if (!(chunk === null)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                this._readCapability = (0, _util.createPromiseCapability)();\n                return _context2.abrupt(\"return\", this.read());\n\n              case 10:\n                this._loaded += chunk.length;\n\n                if (this.onProgress) {\n                  this.onProgress({\n                    loaded: this._loaded\n                  });\n                }\n\n                buffer = new Uint8Array(chunk).buffer;\n                return _context2.abrupt(\"return\", {\n                  value: buffer,\n                  done: false\n                });\n\n              case 14:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read() {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      if (!this._readableStream) {\n        this._error(reason);\n\n        return;\n      }\n\n      this._readableStream.destroy(reason);\n    }\n  }, {\n    key: \"_error\",\n    value: function _error(reason) {\n      this._storedError = reason;\n\n      this._readCapability.resolve();\n    }\n  }, {\n    key: \"_setReadableStream\",\n    value: function _setReadableStream(readableStream) {\n      var _this2 = this;\n\n      this._readableStream = readableStream;\n      readableStream.on(\"readable\", function () {\n        _this2._readCapability.resolve();\n      });\n      readableStream.on(\"end\", function () {\n        readableStream.destroy();\n        _this2._done = true;\n\n        _this2._readCapability.resolve();\n      });\n      readableStream.on(\"error\", function (reason) {\n        _this2._error(reason);\n      });\n\n      if (this._storedError) {\n        this._readableStream.destroy(this._storedError);\n      }\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }]);\n\n  return BaseRangeReader;\n}();\n\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers: headers\n  };\n}\n\nvar PDFNodeStreamFullReader = /*#__PURE__*/function (_BaseFullReader) {\n  _inherits(PDFNodeStreamFullReader, _BaseFullReader);\n\n  var _super = _createSuper(PDFNodeStreamFullReader);\n\n  function PDFNodeStreamFullReader(stream) {\n    var _this3;\n\n    _classCallCheck(this, PDFNodeStreamFullReader);\n\n    _this3 = _super.call(this, stream);\n\n    var handleResponse = function handleResponse(response) {\n      if (response.statusCode === 404) {\n        var error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(_this3._url, \"\\\".\"));\n        _this3._storedError = error;\n\n        _this3._headersCapability.reject(error);\n\n        return;\n      }\n\n      _this3._headersCapability.resolve();\n\n      _this3._setReadableStream(response);\n\n      var getResponseHeader = function getResponseHeader(name) {\n        return _this3._readableStream.headers[name.toLowerCase()];\n      };\n\n      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader: getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: _this3._rangeChunkSize,\n        disableRange: _this3._disableRange\n      }),\n          allowRangeRequests = _validateRangeRequest.allowRangeRequests,\n          suggestedLength = _validateRangeRequest.suggestedLength;\n\n      _this3._isRangeSupported = allowRangeRequests;\n      _this3._contentLength = suggestedLength || _this3._contentLength;\n      _this3._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n\n    _this3._request = null;\n\n    if (_this3._url.protocol === \"http:\") {\n      _this3._request = http.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);\n    } else {\n      _this3._request = https.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse);\n    }\n\n    _this3._request.on(\"error\", function (reason) {\n      _this3._storedError = reason;\n\n      _this3._headersCapability.reject(reason);\n    });\n\n    _this3._request.end();\n\n    return _this3;\n  }\n\n  return PDFNodeStreamFullReader;\n}(BaseFullReader);\n\nvar PDFNodeStreamRangeReader = /*#__PURE__*/function (_BaseRangeReader) {\n  _inherits(PDFNodeStreamRangeReader, _BaseRangeReader);\n\n  var _super2 = _createSuper(PDFNodeStreamRangeReader);\n\n  function PDFNodeStreamRangeReader(stream, start, end) {\n    var _this4;\n\n    _classCallCheck(this, PDFNodeStreamRangeReader);\n\n    _this4 = _super2.call(this, stream);\n    _this4._httpHeaders = {};\n\n    for (var property in stream.httpHeaders) {\n      var value = stream.httpHeaders[property];\n\n      if (typeof value === \"undefined\") {\n        continue;\n      }\n\n      _this4._httpHeaders[property] = value;\n    }\n\n    _this4._httpHeaders.Range = \"bytes=\".concat(start, \"-\").concat(end - 1);\n\n    var handleResponse = function handleResponse(response) {\n      if (response.statusCode === 404) {\n        var error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(_this4._url, \"\\\".\"));\n        _this4._storedError = error;\n        return;\n      }\n\n      _this4._setReadableStream(response);\n    };\n\n    _this4._request = null;\n\n    if (_this4._url.protocol === \"http:\") {\n      _this4._request = http.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);\n    } else {\n      _this4._request = https.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse);\n    }\n\n    _this4._request.on(\"error\", function (reason) {\n      _this4._storedError = reason;\n    });\n\n    _this4._request.end();\n\n    return _this4;\n  }\n\n  return PDFNodeStreamRangeReader;\n}(BaseRangeReader);\n\nvar PDFNodeStreamFsFullReader = /*#__PURE__*/function (_BaseFullReader2) {\n  _inherits(PDFNodeStreamFsFullReader, _BaseFullReader2);\n\n  var _super3 = _createSuper(PDFNodeStreamFsFullReader);\n\n  function PDFNodeStreamFsFullReader(stream) {\n    var _this5;\n\n    _classCallCheck(this, PDFNodeStreamFsFullReader);\n\n    _this5 = _super3.call(this, stream);\n    var path = decodeURIComponent(_this5._url.path);\n\n    if (fileUriRegex.test(_this5._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    fs.lstat(path, function (error, stat) {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new _util.MissingPDFException(\"Missing PDF \\\"\".concat(path, \"\\\".\"));\n        }\n\n        _this5._storedError = error;\n\n        _this5._headersCapability.reject(error);\n\n        return;\n      }\n\n      _this5._contentLength = stat.size;\n\n      _this5._setReadableStream(fs.createReadStream(path));\n\n      _this5._headersCapability.resolve();\n    });\n    return _this5;\n  }\n\n  return PDFNodeStreamFsFullReader;\n}(BaseFullReader);\n\nvar PDFNodeStreamFsRangeReader = /*#__PURE__*/function (_BaseRangeReader2) {\n  _inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2);\n\n  var _super4 = _createSuper(PDFNodeStreamFsRangeReader);\n\n  function PDFNodeStreamFsRangeReader(stream, start, end) {\n    var _this6;\n\n    _classCallCheck(this, PDFNodeStreamFsRangeReader);\n\n    _this6 = _super4.call(this, stream);\n    var path = decodeURIComponent(_this6._url.path);\n\n    if (fileUriRegex.test(_this6._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n\n    _this6._setReadableStream(fs.createReadStream(path, {\n      start: start,\n      end: end - 1\n    }));\n\n    return _this6;\n  }\n\n  return PDFNodeStreamFsRangeReader;\n}(BaseRangeReader);\n\n/***/ }),\n/* 220 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _content_disposition = __w_pdfjs_require__(221);\n\nfunction validateRangeRequestCapabilities(_ref) {\n  var getResponseHeader = _ref.getResponseHeader,\n      isHttp = _ref.isHttp,\n      rangeChunkSize = _ref.rangeChunkSize,\n      disableRange = _ref.disableRange;\n  (0, _util.assert)(rangeChunkSize > 0, \"Range chunk size must be larger than zero\");\n  var returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  var length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n\n  returnValues.suggestedLength = length;\n\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n\n  var contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\n\nfunction extractFilenameFromHeader(getResponseHeader) {\n  var contentDisposition = getResponseHeader(\"Content-Disposition\");\n\n  if (contentDisposition) {\n    var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch (ex) {}\n    }\n\n    if (/\\.pdf$/i.test(filename)) {\n      return filename;\n    }\n  }\n\n  return null;\n}\n\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n\n  return new _util.UnexpectedResponseException(\"Unexpected server response (\" + status + ') while retrieving PDF \"' + url + '\".', status);\n}\n\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 221 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  var needsEncodingFixup = true;\n  var tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n    var filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n\n  tmp = rfc2231getparam(contentDisposition);\n\n  if (tmp) {\n    var _filename = rfc2047decode(tmp);\n\n    return fixupEncoding(_filename);\n  }\n\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n\n  if (tmp) {\n    tmp = tmp[1];\n\n    var _filename2 = rfc2616unquote(tmp);\n\n    _filename2 = rfc2047decode(_filename2);\n    return fixupEncoding(_filename2);\n  }\n\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n\n      try {\n        var decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        var bytes = Array.from(value, function (ch) {\n          return ch.charCodeAt(0) & 0xff;\n        });\n        value = decoder.decode(new Uint8Array(bytes));\n        needsEncodingFixup = false;\n      } catch (e) {\n        if (/^utf-?8$/i.test(encoding)) {\n          try {\n            value = decodeURIComponent(escape(value));\n            needsEncodingFixup = false;\n          } catch (err) {}\n        }\n      }\n    }\n\n    return value;\n  }\n\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n\n    return value;\n  }\n\n  function rfc2231getparam(contentDispositionStr) {\n    var matches = [];\n    var match;\n    var iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      var _match = match,\n          _match2 = _slicedToArray(_match, 4),\n          n = _match2[1],\n          quot = _match2[2],\n          part = _match2[3];\n\n      n = parseInt(n, 10);\n\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n\n        continue;\n      }\n\n      matches[n] = [quot, part];\n    }\n\n    var parts = [];\n\n    for (var _n2 = 0; _n2 < matches.length; ++_n2) {\n      if (!(_n2 in matches)) {\n        break;\n      }\n\n      var _matches$_n = _slicedToArray(matches[_n2], 2),\n          _quot = _matches$_n[0],\n          _part = _matches$_n[1];\n\n      _part = rfc2616unquote(_part);\n\n      if (_quot) {\n        _part = unescape(_part);\n\n        if (_n2 === 0) {\n          _part = rfc5987decode(_part);\n        }\n      }\n\n      parts.push(_part);\n    }\n\n    return parts.join(\"\");\n  }\n\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      var parts = value.slice(1).split('\\\\\"');\n\n      for (var i = 0; i < parts.length; ++i) {\n        var quotindex = parts[i].indexOf('\"');\n\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n\n        parts[i] = parts[i].replace(/\\\\(.)/g, \"$1\");\n      }\n\n      value = parts.join('\"');\n    }\n\n    return value;\n  }\n\n  function rfc5987decode(extvalue) {\n    var encodingend = extvalue.indexOf(\"'\");\n\n    if (encodingend === -1) {\n      return extvalue;\n    }\n\n    var encoding = extvalue.slice(0, encodingend);\n    var langvalue = extvalue.slice(encodingend + 1);\n    var value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n\n    return value.replace(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replace(/_/g, \" \");\n        text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n\n      try {\n        text = atob(text);\n      } catch (e) {}\n\n      return textdecode(charset, text);\n    });\n  }\n\n  return \"\";\n}\n\n/***/ }),\n/* 222 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFNetworkStream = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _network_utils = __w_pdfjs_require__(220);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n;\nvar OK_RESPONSE = 200;\nvar PARTIAL_CONTENT_RESPONSE = 206;\n\nfunction getArrayBuffer(xhr) {\n  var data = xhr.response;\n\n  if (typeof data !== \"string\") {\n    return data;\n  }\n\n  var array = (0, _util.stringToBytes)(data);\n  return array.buffer;\n}\n\nvar NetworkManager = /*#__PURE__*/function () {\n  function NetworkManager(url, args) {\n    _classCallCheck(this, NetworkManager);\n\n    this.url = url;\n    args = args || {};\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || {};\n    this.withCredentials = args.withCredentials || false;\n\n    this.getXhr = args.getXhr || function NetworkManager_getXhr() {\n      return new XMLHttpRequest();\n    };\n\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n\n  _createClass(NetworkManager, [{\n    key: \"requestRange\",\n    value: function requestRange(begin, end, listeners) {\n      var args = {\n        begin: begin,\n        end: end\n      };\n\n      for (var prop in listeners) {\n        args[prop] = listeners[prop];\n      }\n\n      return this.request(args);\n    }\n  }, {\n    key: \"requestFull\",\n    value: function requestFull(listeners) {\n      return this.request(listeners);\n    }\n  }, {\n    key: \"request\",\n    value: function request(args) {\n      var xhr = this.getXhr();\n      var xhrId = this.currXhrId++;\n      var pendingRequest = this.pendingRequests[xhrId] = {\n        xhr: xhr\n      };\n      xhr.open(\"GET\", this.url);\n      xhr.withCredentials = this.withCredentials;\n\n      for (var property in this.httpHeaders) {\n        var value = this.httpHeaders[property];\n\n        if (typeof value === \"undefined\") {\n          continue;\n        }\n\n        xhr.setRequestHeader(property, value);\n      }\n\n      if (this.isHttp && \"begin\" in args && \"end\" in args) {\n        xhr.setRequestHeader(\"Range\", \"bytes=\".concat(args.begin, \"-\").concat(args.end - 1));\n        pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n      } else {\n        pendingRequest.expectedStatus = OK_RESPONSE;\n      }\n\n      xhr.responseType = \"arraybuffer\";\n\n      if (args.onError) {\n        xhr.onerror = function (evt) {\n          args.onError(xhr.status);\n        };\n      }\n\n      xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n      xhr.onprogress = this.onProgress.bind(this, xhrId);\n      pendingRequest.onHeadersReceived = args.onHeadersReceived;\n      pendingRequest.onDone = args.onDone;\n      pendingRequest.onError = args.onError;\n      pendingRequest.onProgress = args.onProgress;\n      xhr.send(null);\n      return xhrId;\n    }\n  }, {\n    key: \"onProgress\",\n    value: function onProgress(xhrId, evt) {\n      var pendingRequest = this.pendingRequests[xhrId];\n\n      if (!pendingRequest) {\n        return;\n      }\n\n      if (pendingRequest.onProgress) {\n        pendingRequest.onProgress(evt);\n      }\n    }\n  }, {\n    key: \"onStateChange\",\n    value: function onStateChange(xhrId, evt) {\n      var pendingRequest = this.pendingRequests[xhrId];\n\n      if (!pendingRequest) {\n        return;\n      }\n\n      var xhr = pendingRequest.xhr;\n\n      if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n        pendingRequest.onHeadersReceived();\n        delete pendingRequest.onHeadersReceived;\n      }\n\n      if (xhr.readyState !== 4) {\n        return;\n      }\n\n      if (!(xhrId in this.pendingRequests)) {\n        return;\n      }\n\n      delete this.pendingRequests[xhrId];\n\n      if (xhr.status === 0 && this.isHttp) {\n        if (pendingRequest.onError) {\n          pendingRequest.onError(xhr.status);\n        }\n\n        return;\n      }\n\n      var xhrStatus = xhr.status || OK_RESPONSE;\n      var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n\n      if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n        if (pendingRequest.onError) {\n          pendingRequest.onError(xhr.status);\n        }\n\n        return;\n      }\n\n      var chunk = getArrayBuffer(xhr);\n\n      if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n        var rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n        var matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n        pendingRequest.onDone({\n          begin: parseInt(matches[1], 10),\n          chunk: chunk\n        });\n      } else if (chunk) {\n        pendingRequest.onDone({\n          begin: 0,\n          chunk: chunk\n        });\n      } else if (pendingRequest.onError) {\n        pendingRequest.onError(xhr.status);\n      }\n    }\n  }, {\n    key: \"getRequestXhr\",\n    value: function getRequestXhr(xhrId) {\n      return this.pendingRequests[xhrId].xhr;\n    }\n  }, {\n    key: \"isPendingRequest\",\n    value: function isPendingRequest(xhrId) {\n      return xhrId in this.pendingRequests;\n    }\n  }, {\n    key: \"abortRequest\",\n    value: function abortRequest(xhrId) {\n      var xhr = this.pendingRequests[xhrId].xhr;\n      delete this.pendingRequests[xhrId];\n      xhr.abort();\n    }\n  }]);\n\n  return NetworkManager;\n}();\n\nvar PDFNetworkStream = /*#__PURE__*/function () {\n  function PDFNetworkStream(source) {\n    _classCallCheck(this, PDFNetworkStream);\n\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _createClass(PDFNetworkStream, [{\n    key: \"_onRangeRequestReaderClosed\",\n    value: function _onRangeRequestReaderClosed(reader) {\n      var i = this._rangeRequestReaders.indexOf(reader);\n\n      if (i >= 0) {\n        this._rangeRequestReaders.splice(i, 1);\n      }\n    }\n  }, {\n    key: \"getFullReader\",\n    value: function getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n      this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n      return this._fullRequestReader;\n    }\n  }, {\n    key: \"getRangeReader\",\n    value: function getRangeReader(begin, end) {\n      var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n      reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n\n      this._rangeRequestReaders.push(reader);\n\n      return reader;\n    }\n  }, {\n    key: \"cancelAllRequests\",\n    value: function cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      var readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n  }]);\n\n  return PDFNetworkStream;\n}();\n\nexports.PDFNetworkStream = PDFNetworkStream;\n\nvar PDFNetworkStreamFullRequestReader = /*#__PURE__*/function () {\n  function PDFNetworkStreamFullRequestReader(manager, source) {\n    _classCallCheck(this, PDFNetworkStreamFullRequestReader);\n\n    this._manager = manager;\n    var args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n\n  _createClass(PDFNetworkStreamFullRequestReader, [{\n    key: \"_onHeadersReceived\",\n    value: function _onHeadersReceived() {\n      var fullRequestXhrId = this._fullRequestId;\n\n      var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n\n      var getResponseHeader = function getResponseHeader(name) {\n        return fullRequestXhr.getResponseHeader(name);\n      };\n\n      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader: getResponseHeader,\n        isHttp: this._manager.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      }),\n          allowRangeRequests = _validateRangeRequest.allowRangeRequests,\n          suggestedLength = _validateRangeRequest.suggestedLength;\n\n      if (allowRangeRequests) {\n        this._isRangeSupported = true;\n      }\n\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (this._isRangeSupported) {\n        this._manager.abortRequest(fullRequestXhrId);\n      }\n\n      this._headersReceivedCapability.resolve();\n    }\n  }, {\n    key: \"_onDone\",\n    value: function _onDone(args) {\n      if (args) {\n        if (this._requests.length > 0) {\n          var requestCapability = this._requests.shift();\n\n          requestCapability.resolve({\n            value: args.chunk,\n            done: false\n          });\n        } else {\n          this._cachedChunks.push(args.chunk);\n        }\n      }\n\n      this._done = true;\n\n      if (this._cachedChunks.length > 0) {\n        return;\n      }\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n    }\n  }, {\n    key: \"_onError\",\n    value: function _onError(status) {\n      var url = this._url;\n      var exception = (0, _network_utils.createResponseStatusError)(status, url);\n      this._storedError = exception;\n\n      this._headersReceivedCapability.reject(exception);\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.reject(exception);\n      });\n\n      this._requests = [];\n      this._cachedChunks = [];\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(data) {\n      if (this.onProgress) {\n        this.onProgress({\n          loaded: data.loaded,\n          total: data.lengthComputable ? data.total : this._contentLength\n        });\n      }\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var chunk, requestCapability;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!this._storedError) {\n                  _context.next = 2;\n                  break;\n                }\n\n                throw this._storedError;\n\n              case 2:\n                if (!(this._cachedChunks.length > 0)) {\n                  _context.next = 5;\n                  break;\n                }\n\n                chunk = this._cachedChunks.shift();\n                return _context.abrupt(\"return\", {\n                  value: chunk,\n                  done: false\n                });\n\n              case 5:\n                if (!this._done) {\n                  _context.next = 7;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 7:\n                requestCapability = (0, _util.createPromiseCapability)();\n\n                this._requests.push(requestCapability);\n\n                return _context.abrupt(\"return\", requestCapability.promise);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read() {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this._done = true;\n\n      this._headersReceivedCapability.reject(reason);\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      if (this._manager.isPendingRequest(this._fullRequestId)) {\n        this._manager.abortRequest(this._fullRequestId);\n      }\n\n      this._fullRequestReader = null;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._filename;\n    }\n  }, {\n    key: \"isRangeSupported\",\n    get: function get() {\n      return this._isRangeSupported;\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }, {\n    key: \"contentLength\",\n    get: function get() {\n      return this._contentLength;\n    }\n  }, {\n    key: \"headersReady\",\n    get: function get() {\n      return this._headersReceivedCapability.promise;\n    }\n  }]);\n\n  return PDFNetworkStreamFullRequestReader;\n}();\n\nvar PDFNetworkStreamRangeRequestReader = /*#__PURE__*/function () {\n  function PDFNetworkStreamRangeRequestReader(manager, begin, end) {\n    _classCallCheck(this, PDFNetworkStreamRangeRequestReader);\n\n    this._manager = manager;\n    var args = {\n      onDone: this._onDone.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n\n  _createClass(PDFNetworkStreamRangeRequestReader, [{\n    key: \"_close\",\n    value: function _close() {\n      if (this.onClosed) {\n        this.onClosed(this);\n      }\n    }\n  }, {\n    key: \"_onDone\",\n    value: function _onDone(data) {\n      var chunk = data.chunk;\n\n      if (this._requests.length > 0) {\n        var requestCapability = this._requests.shift();\n\n        requestCapability.resolve({\n          value: chunk,\n          done: false\n        });\n      } else {\n        this._queuedChunk = chunk;\n      }\n\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      this._close();\n    }\n  }, {\n    key: \"_onProgress\",\n    value: function _onProgress(evt) {\n      if (!this.isStreamingSupported && this.onProgress) {\n        this.onProgress({\n          loaded: evt.loaded\n        });\n      }\n    }\n  }, {\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var chunk, requestCapability;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(this._queuedChunk !== null)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                chunk = this._queuedChunk;\n                this._queuedChunk = null;\n                return _context2.abrupt(\"return\", {\n                  value: chunk,\n                  done: false\n                });\n\n              case 4:\n                if (!this._done) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: undefined,\n                  done: true\n                });\n\n              case 6:\n                requestCapability = (0, _util.createPromiseCapability)();\n\n                this._requests.push(requestCapability);\n\n                return _context2.abrupt(\"return\", requestCapability.promise);\n\n              case 9:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read() {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      this._done = true;\n\n      this._requests.forEach(function (requestCapability) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      });\n\n      this._requests = [];\n\n      if (this._manager.isPendingRequest(this._requestId)) {\n        this._manager.abortRequest(this._requestId);\n      }\n\n      this._close();\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return false;\n    }\n  }]);\n\n  return PDFNetworkStreamRangeRequestReader;\n}();\n\n/***/ }),\n/* 223 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFFetchStream = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(2));\n\nvar _util = __w_pdfjs_require__(5);\n\nvar _network_utils = __w_pdfjs_require__(220);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n;\n\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers: headers,\n    signal: abortController && abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\n\nfunction createHeaders(httpHeaders) {\n  var headers = new Headers();\n\n  for (var property in httpHeaders) {\n    var value = httpHeaders[property];\n\n    if (typeof value === \"undefined\") {\n      continue;\n    }\n\n    headers.append(property, value);\n  }\n\n  return headers;\n}\n\nvar PDFFetchStream = /*#__PURE__*/function () {\n  function PDFFetchStream(source) {\n    _classCallCheck(this, PDFFetchStream);\n\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n\n  _createClass(PDFFetchStream, [{\n    key: \"getFullReader\",\n    value: function getFullReader() {\n      (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n      this._fullRequestReader = new PDFFetchStreamReader(this);\n      return this._fullRequestReader;\n    }\n  }, {\n    key: \"getRangeReader\",\n    value: function getRangeReader(begin, end) {\n      if (end <= this._progressiveDataLength) {\n        return null;\n      }\n\n      var reader = new PDFFetchStreamRangeReader(this, begin, end);\n\n      this._rangeRequestReaders.push(reader);\n\n      return reader;\n    }\n  }, {\n    key: \"cancelAllRequests\",\n    value: function cancelAllRequests(reason) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader.cancel(reason);\n      }\n\n      var readers = this._rangeRequestReaders.slice(0);\n\n      readers.forEach(function (reader) {\n        reader.cancel(reason);\n      });\n    }\n  }, {\n    key: \"_progressiveDataLength\",\n    get: function get() {\n      return this._fullRequestReader ? this._fullRequestReader._loaded : 0;\n    }\n  }]);\n\n  return PDFFetchStream;\n}();\n\nexports.PDFFetchStream = PDFFetchStream;\n\nvar PDFFetchStreamReader = /*#__PURE__*/function () {\n  function PDFFetchStreamReader(stream) {\n    var _this = this;\n\n    _classCallCheck(this, PDFFetchStreamReader);\n\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    var source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = (0, _util.createPromiseCapability)();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    var url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      _this._reader = response.body.getReader();\n\n      _this._headersCapability.resolve();\n\n      var getResponseHeader = function getResponseHeader(name) {\n        return response.headers.get(name);\n      };\n\n      var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader: getResponseHeader,\n        isHttp: _this._stream.isHttp,\n        rangeChunkSize: _this._rangeChunkSize,\n        disableRange: _this._disableRange\n      }),\n          allowRangeRequests = _validateRangeRequest.allowRangeRequests,\n          suggestedLength = _validateRangeRequest.suggestedLength;\n\n      _this._isRangeSupported = allowRangeRequests;\n      _this._contentLength = suggestedLength || _this._contentLength;\n      _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n\n      if (!_this._isStreamingSupported && _this._isRangeSupported) {\n        _this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n      }\n    })[\"catch\"](this._headersCapability.reject);\n    this.onProgress = null;\n  }\n\n  _createClass(PDFFetchStreamReader, [{\n    key: \"read\",\n    value: function () {\n      var _read = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var _yield$this$_reader$r, value, done, buffer;\n\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._headersCapability.promise;\n\n              case 2:\n                _context.next = 4;\n                return this._reader.read();\n\n              case 4:\n                _yield$this$_reader$r = _context.sent;\n                value = _yield$this$_reader$r.value;\n                done = _yield$this$_reader$r.done;\n\n                if (!done) {\n                  _context.next = 9;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", {\n                  value: value,\n                  done: done\n                });\n\n              case 9:\n                this._loaded += value.byteLength;\n\n                if (this.onProgress) {\n                  this.onProgress({\n                    loaded: this._loaded,\n                    total: this._contentLength\n                  });\n                }\n\n                buffer = new Uint8Array(value).buffer;\n                return _context.abrupt(\"return\", {\n                  value: buffer,\n                  done: false\n                });\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function read() {\n        return _read.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      if (this._reader) {\n        this._reader.cancel(reason);\n      }\n\n      if (this._abortController) {\n        this._abortController.abort();\n      }\n    }\n  }, {\n    key: \"headersReady\",\n    get: function get() {\n      return this._headersCapability.promise;\n    }\n  }, {\n    key: \"filename\",\n    get: function get() {\n      return this._filename;\n    }\n  }, {\n    key: \"contentLength\",\n    get: function get() {\n      return this._contentLength;\n    }\n  }, {\n    key: \"isRangeSupported\",\n    get: function get() {\n      return this._isRangeSupported;\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }]);\n\n  return PDFFetchStreamReader;\n}();\n\nvar PDFFetchStreamRangeReader = /*#__PURE__*/function () {\n  function PDFFetchStreamRangeReader(stream, begin, end) {\n    var _this2 = this;\n\n    _classCallCheck(this, PDFFetchStreamRangeReader);\n\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    var source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = (0, _util.createPromiseCapability)();\n    this._isStreamingSupported = !source.disableStream;\n\n    if (typeof AbortController !== \"undefined\") {\n      this._abortController = new AbortController();\n    }\n\n    this._headers = createHeaders(this._stream.httpHeaders);\n\n    this._headers.append(\"Range\", \"bytes=\".concat(begin, \"-\").concat(end - 1));\n\n    var url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n\n      _this2._readCapability.resolve();\n\n      _this2._reader = response.body.getReader();\n    })[\"catch\"](function (reason) {\n      if (reason && reason.name === \"AbortError\") {\n        return;\n      }\n\n      throw reason;\n    });\n    this.onProgress = null;\n  }\n\n  _createClass(PDFFetchStreamRangeReader, [{\n    key: \"read\",\n    value: function () {\n      var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var _yield$this$_reader$r2, value, done, buffer;\n\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._readCapability.promise;\n\n              case 2:\n                _context2.next = 4;\n                return this._reader.read();\n\n              case 4:\n                _yield$this$_reader$r2 = _context2.sent;\n                value = _yield$this$_reader$r2.value;\n                done = _yield$this$_reader$r2.done;\n\n                if (!done) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\", {\n                  value: value,\n                  done: done\n                });\n\n              case 9:\n                this._loaded += value.byteLength;\n\n                if (this.onProgress) {\n                  this.onProgress({\n                    loaded: this._loaded\n                  });\n                }\n\n                buffer = new Uint8Array(value).buffer;\n                return _context2.abrupt(\"return\", {\n                  value: buffer,\n                  done: false\n                });\n\n              case 13:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function read() {\n        return _read2.apply(this, arguments);\n      }\n\n      return read;\n    }()\n  }, {\n    key: \"cancel\",\n    value: function cancel(reason) {\n      if (this._reader) {\n        this._reader.cancel(reason);\n      }\n\n      if (this._abortController) {\n        this._abortController.abort();\n      }\n    }\n  }, {\n    key: \"isStreamingSupported\",\n    get: function get() {\n      return this._isStreamingSupported;\n    }\n  }]);\n\n  return PDFFetchStreamRangeReader;\n}();\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=pdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC1zaWcvZXM1L2J1aWxkL3BkZi5qcz9kZDcxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLcUQ7QUFDM0QsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRix3REFBd0QsUUFBUSxtRUFBbUUsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHFCQUFxQixVQUFVLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQiwyQkFBMkIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLCtEQUErRCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVuK0IsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckwsNEVBQTRFLE1BQU0sMEJBQTBCLHdCQUF3QixFQUFFLGdCQUFnQixlQUFlLFFBQVEsRUFBRSxpQkFBaUIsZ0JBQWdCLEVBQUUsT0FBTyw0Q0FBNEMsRUFBRTs7QUFFdlEsZ0NBQWdDLHFCQUFxQixtQ0FBbUMsZ0RBQWdELGdDQUFnQyx3QkFBd0Isd0VBQXdFLEVBQUUsdUJBQXVCLHVFQUF1RSxFQUFFLGtCQUFrQixFQUFFLEVBQUUsR0FBRzs7QUFFblksdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxxRkFBcUY7QUFDckY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLCtCQUErQjtBQUMxRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0RBQXNELEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSwyQkFBMkIsRUFBRSxtQkFBbUIsRUFBRTtBQUMvSzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw4Q0FBOEMsUUFBUTtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyxNQUFLLEdBQUcsQ0FBUyxzREFBc0Q7O0FBRTNFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDRCQUE0Qjs7QUFFNUIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4sdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixhQUFhO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQSxHQUFHO0FBQ0gscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBLEdBQUc7QUFDSCxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBLCtDQUErQzs7QUFFL0MscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSx1QkFBdUIsMkJBQTJCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFeFg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE1BQU07QUFDbkI7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxhQUFhO0FBQ3hGO0FBQ0E7O0FBRUEsd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhFQUE4RSxlQUFlO0FBQzdGO0FBQ0E7O0FBRUEsMENBQTBDLHVCQUF1QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSx1QkFBdUIsMkJBQTJCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFeFgsdUJBQXVCLE9BQU8seUNBQXlDLE9BQU8sbUJBQW1CLE9BQU8saUNBQWlDLE9BQU8sa0JBQWtCLE9BQU8sc0JBQXNCLE9BQU8sU0FBUyxPQUFPO0FBQ3ROOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUcsZUFBZSxHQUFHLHFCQUFxQjs7QUFFMUMsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixpREFBaUQ7QUFDakQsRUFBRTtBQUNGLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0S0FBNEsscUJBQU0sZ0JBQWdCLHFCQUFNOztBQUV4TSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxtQ0FBbUM7QUFDbkM7QUFDQSxnRkFBZ0YsT0FBTztBQUN2RjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsZ0JBQWdCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQ0FBMEM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsYUFBYTs7QUFFakIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLG9DQUFvQztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsaUJBQWlCOztBQUVyQixPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPLGdDQUFnQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxJQUFJLE9BQU87QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLHVCQUF1QiwrQ0FBK0M7QUFDdEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxnQkFBZ0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLHVCQUF1Qjs7QUFFM0IsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxlQUFlO0FBQ2xFOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFDRDtBQUNBO0FBQ0EsRUFBRTtBQUNGLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsMkJBQTJCLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUcsR0FBRyxlQUFlO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyw4QkFBOEI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsNkNBQTZDLHNCQUFzQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixFQUFFO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxQkFBcUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxXQUFXO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSCxDQUFDO0FBQ0Qsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBLENBQUMsR0FBRyxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsc0JBQXNCOztBQUUxQixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLG1DQUFtQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLG1CQUFtQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLEVBQUUsRUFBRSxjQUFjO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsd0JBQXdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBLHlCQUF5QiwyQkFBMkI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLG1CQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsR0FBRyw4Q0FBOEM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0EsRUFBRSxLQUFJLHNCQUFzQixDQUFTO0FBQ3JDLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLEdBQUc7QUFDSCwrRUFBK0Usb0JBQW9CO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usb0JBQW9CO0FBQzFGLHdFQUF3RSxvQkFBb0I7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdCQUFnQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsWUFBWTtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSxFQUFFO0FBQ0YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0RBQWdELGlEQUFpRDtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSw2RUFBNkUsZUFBZTtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxHQUFHLGtCQUFrQjtBQUN0QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxZQUFZLFFBQVEsc0NBQXNDO0FBQ25ILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsZ0NBQWdDLDhDQUE4QztBQUM5RTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFLEdBQUcsd0JBQXdCO0FBQzdCOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxPQUFPO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Riw0RUFBNEUsTUFBTSwwQkFBMEIsd0JBQXdCLEVBQUUsZ0JBQWdCLGVBQWUsUUFBUSxFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSxPQUFPLDRDQUE0QyxFQUFFOztBQUV2USxnQ0FBZ0MscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3Qix3RUFBd0UsRUFBRSx1QkFBdUIsdUVBQXVFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxHQUFHOztBQUVuWSxrQ0FBa0MscUhBQXFIOztBQUV2SiwrQkFBK0IsNkpBQTZKOztBQUU1TCxpQ0FBaUMsK0ZBQStGOztBQUVoSSxrQ0FBa0MsdURBQXVEOztBQUV6Rix3REFBd0QsUUFBUSxtRUFBbUUsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHNCQUFzQixXQUFXLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQiwyQkFBMkIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLCtEQUErRCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVyK0IsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4saUNBQWlDLDJIQUEySDs7QUFFNUosNkJBQTZCLGtLQUFrSzs7QUFFL0wsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckwsd0NBQXdDLGdGQUFnRixlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsbUNBQW1DLEVBQUUsRUFBRSxjQUFjLFdBQVcsVUFBVSxFQUFFLFVBQVUsTUFBTSxpREFBaUQsRUFBRSxVQUFVLGtCQUFrQixFQUFFLEVBQUUsYUFBYTs7QUFFdmUsK0JBQStCLG9DQUFvQzs7QUFFbkUsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkIsK0JBQStCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixpQ0FBaUM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx3RkFBd0Y7QUFDeEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdGQUF3RjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEIsaUNBQWlDO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0Esb0RBQW9ELFFBQVE7QUFDNUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLHVCQUF1QixzQ0FBc0M7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJCQUEyQixvQ0FBb0M7QUFDL0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkIsVUFBYztBQUN6QztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDJDQUEyQyxVQUFjO0FBQ3pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdURBQXVEOztBQUV2RDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7O0FBRWI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0QsUUFBUTtBQUM5RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSw0RUFBNEUsTUFBTSwwQkFBMEIsd0JBQXdCLEVBQUUsZ0JBQWdCLGVBQWUsUUFBUSxFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSxPQUFPLDRDQUE0QyxFQUFFOztBQUV2USxnQ0FBZ0MscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3Qix3RUFBd0UsRUFBRSx1QkFBdUIsdUVBQXVFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxHQUFHOztBQUVuWSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLCtCQUErQjtBQUN6RSxnQ0FBZ0MsMkNBQTJDLHFCQUFxQjtBQUNoRztBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0NBQXNDLFFBQVE7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNFQUFzRTs7QUFFdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxnQ0FBZ0M7QUFDcEYsOEJBQThCLDRDQUE0QyxxQkFBcUI7O0FBRS9GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBTyxDQUFDLHFCQUFROztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLGlCQUFJOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUEsd0RBQXdELFFBQVEsbUVBQW1FLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUyw4QkFBOEIsRUFBRSxxQkFBcUIsVUFBVSxFQUFFLFNBQVMsRUFBRSw4SkFBOEosRUFBRSxrREFBa0QsU0FBUyxrQkFBa0IsMkJBQTJCLEVBQUUsbUJBQW1CLHNCQUFzQiw4QkFBOEIsYUFBYSxFQUFFLHNCQUFzQixlQUFlLFdBQVcsRUFBRSxtQkFBbUIsTUFBTSwrREFBK0QsRUFBRSxVQUFVLHVCQUF1QixFQUFFLEVBQUUsR0FBRzs7QUFFbitCLGlEQUFpRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNELGtIQUFrSDs7QUFFOVosc0NBQXNDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLGtCQUFrQixFQUFFLGFBQWE7O0FBRXJMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGFBQWEsWUFBWTtBQUN6QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGVBQWUsV0FBVztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxXQUFXO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSxzQkFBc0I7QUFDbkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTs7QUFFQSxtQkFBbUIscUJBQXFCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsdUJBQXVCO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixpQkFBaUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0NBQWtDLEtBQUs7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUEscUJBQXFCLHFCQUFxQjtBQUMxQzs7QUFFQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDJDQUEyQyxRQUFRO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsbUJBQW1CLFlBQVk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0IsK0JBQStCO0FBQzlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOERBQThEO0FBQzlELGtEQUFrRDtBQUNsRDtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsa0JBQWtCO0FBQ25DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsUUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCx3REFBd0Q7QUFDeEQsOEVBQThFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlEQUF5RDtBQUN6RCxxREFBcUQ7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esc0RBQXNELFFBQVE7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsV0FBVztBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLFVBQVU7QUFDakM7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLFVBQVU7QUFDN0I7O0FBRUEseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtQ0FBbUMsUUFBUTtBQUMzQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRiw0RUFBNEUsTUFBTSwwQkFBMEIsd0JBQXdCLEVBQUUsZ0JBQWdCLGVBQWUsUUFBUSxFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSxPQUFPLDRDQUE0QyxFQUFFOztBQUV2USxnQ0FBZ0MscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3Qix3RUFBd0UsRUFBRSx1QkFBdUIsdUVBQXVFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxHQUFHOztBQUVuWSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTix1QkFBdUIsMkJBQTJCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFeFg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7O0FBRVg7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0NBQWtDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsMENBQTBDLFFBQVE7QUFDbEQ7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWCw0RUFBNEU7QUFDNUU7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsMkNBQTJDLFFBQVE7QUFDbkQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCxRQUFRO0FBQzVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLGlDQUFpQywySEFBMkg7O0FBRTVKLDZCQUE2QixrS0FBa0s7O0FBRS9MLGlEQUFpRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNELGtIQUFrSDs7QUFFOVosc0NBQXNDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLGtCQUFrQixFQUFFLGFBQWE7O0FBRXJMLHdDQUF3QyxnRkFBZ0YsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLG1DQUFtQyxFQUFFLEVBQUUsY0FBYyxXQUFXLFVBQVUsRUFBRSxVQUFVLE1BQU0saURBQWlELEVBQUUsVUFBVSxrQkFBa0IsRUFBRSxFQUFFLGFBQWE7O0FBRXZlLCtCQUErQixvQ0FBb0M7O0FBRW5FLDJDQUEyQyxxREFBcUQsb0JBQW9CLEVBQUUsT0FBTyxtREFBbUQsNkNBQTZDLG1CQUFtQiw0REFBNEQsZ0JBQWdCLGdDQUFnQyxFQUFFLG1CQUFtQixHQUFHLEVBQUUsbURBQW1EOztBQUV6YSwyQ0FBMkMsa0VBQWtFLGtDQUFrQyw0QkFBNEIsRUFBRSxlQUFlOztBQUU1TCwwQ0FBMEMsK0RBQStELDJFQUEyRSxFQUFFLHlFQUF5RSxlQUFlLHNEQUFzRCxFQUFFLEVBQUUsdURBQXVEOztBQUUvWCxnQ0FBZ0MsNEVBQTRFLGlCQUFpQixVQUFVLEdBQUcsOEJBQThCOztBQUV4SyxnQ0FBZ0MsNkRBQTZELHlDQUF5Qyw4Q0FBOEMsaUNBQWlDLG1EQUFtRCx5REFBeUQsRUFBRSxPQUFPLHVDQUF1QyxFQUFFLGlEQUFpRCxHQUFHOztBQUV2YSxpREFBaUQsMEVBQTBFLGFBQWEsRUFBRSxxQ0FBcUM7O0FBRS9LLHVDQUF1Qyx1QkFBdUIsdUZBQXVGLEVBQUUsYUFBYTs7QUFFcEssc0NBQXNDLHdFQUF3RSwwQ0FBMEMsOENBQThDLE1BQU0sd0VBQXdFLEdBQUcsYUFBYSxFQUFFLFlBQVksY0FBYyxFQUFFOztBQUVsVSw2QkFBNkIsZ0dBQWdHLGdEQUFnRCxHQUFHLDJCQUEyQjs7QUFFM00saURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixJQUFJO0FBQ2pDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQSx3REFBd0QsUUFBUSxtRUFBbUUsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHFCQUFxQixVQUFVLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQiwyQkFBMkIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLCtEQUErRCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVuK0IsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckwsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4saURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdko7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLCtCQUErQjtBQUN4RDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsaUNBQWlDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsaUNBQWlDO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxpQ0FBaUM7QUFDakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRiw0RUFBNEUsTUFBTSwwQkFBMEIsd0JBQXdCLEVBQUUsZ0JBQWdCLGVBQWUsUUFBUSxFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSxPQUFPLDRDQUE0QyxFQUFFOztBQUV2USxnQ0FBZ0MscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3Qix3RUFBd0UsRUFBRSx1QkFBdUIsdUVBQXVFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxHQUFHOztBQUVuWSx3REFBd0QsUUFBUSxtRUFBbUUsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHFCQUFxQixVQUFVLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQiwyQkFBMkIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLCtEQUErRCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVuK0IsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckwsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx5QkFBeUIsK0JBQStCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxlQUFlO0FBQ2YsNkRBQTZEO0FBQzdELHNEQUFzRDtBQUN0RDtBQUNBLDRCQUE0QjtBQUM1QixHQUFHO0FBQ0g7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0I7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxlQUFlO0FBQ2YscURBQXFEO0FBQ3JELG1EQUFtRDtBQUNuRCw2QkFBNkI7QUFDN0I7QUFDQSwyREFBMkQ7QUFDM0QsS0FBSztBQUNMLGNBQWM7QUFDZCx5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLEtBQUssT0FBTztBQUNaO0FBQ0EsK0JBQStCO0FBQy9CLEtBQUs7QUFDTCx3QkFBd0I7QUFDeEIsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCLHlCQUF5QjtBQUN6QjtBQUNBLDRCQUE0QjtBQUM1Qix1QkFBdUI7QUFDdkIsd0JBQXdCO0FBQ3hCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0EsZUFBZTtBQUNmLHNEQUFzRDtBQUN0RCwyREFBMkQ7QUFDM0Qsc0RBQXNEO0FBQ3REO0FBQ0EseUNBQXlDO0FBQ3pDLEdBQUc7QUFDSDtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLGVBQWU7QUFDZiwyQkFBMkI7QUFDM0IsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0MsUUFBUTtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCLFlBQVk7QUFDdkM7O0FBRUEsNkJBQTZCLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLDJDQUEyQyxxREFBcUQsb0JBQW9CLEVBQUUsT0FBTyxtREFBbUQsNkNBQTZDLG1CQUFtQiw0REFBNEQsZ0JBQWdCLGdDQUFnQyxFQUFFLG1CQUFtQixHQUFHLEVBQUUsbURBQW1EOztBQUV6YSwyQ0FBMkMsa0VBQWtFLGtDQUFrQyw0QkFBNEIsRUFBRSxlQUFlOztBQUU1TCx3REFBd0QsUUFBUSxtRUFBbUUsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHFCQUFxQixVQUFVLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQiwyQkFBMkIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLCtEQUErRCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVuK0IsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckwsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixNQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDLE1BQU0sSUFBSSxNQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLGlDQUFpQztBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsZ0NBQWdDO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QixpQ0FBaUM7QUFDN0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxtQkFBbUIsV0FBVztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUEsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsdUJBQXVCLDREQUE0RDtBQUNuRjtBQUNBOztBQUVBLHVCQUF1QixzRUFBc0U7QUFDN0Y7QUFDQTs7QUFFQSxtQkFBbUIsb0NBQW9DO0FBQ3ZEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUsseUJBQXlCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpREFBaUQsUUFBUTtBQUN6RDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxrQ0FBa0MscUhBQXFIOztBQUV2SiwrQkFBK0IsNkpBQTZKOztBQUU1TCxpQ0FBaUMsK0ZBQStGOztBQUVoSSxrQ0FBa0MsdURBQXVEOztBQUV6RixpQ0FBaUMsMkhBQTJIOztBQUU1Siw2QkFBNkIsa0tBQWtLOztBQUUvTCx3Q0FBd0MsZ0ZBQWdGLGVBQWUsZUFBZSxnQkFBZ0Isb0JBQW9CLE1BQU0sMENBQTBDLCtCQUErQixhQUFhLHFCQUFxQixtQ0FBbUMsRUFBRSxFQUFFLGNBQWMsV0FBVyxVQUFVLEVBQUUsVUFBVSxNQUFNLGlEQUFpRCxFQUFFLFVBQVUsa0JBQWtCLEVBQUUsRUFBRSxhQUFhOztBQUV2ZSwrQkFBK0Isb0NBQW9DOztBQUVuRSx3REFBd0QsUUFBUSxtRUFBbUUsd0hBQXdILGdCQUFnQixXQUFXLHlCQUF5QixTQUFTLHdCQUF3Qiw0QkFBNEIsY0FBYyxTQUFTLDhCQUE4QixFQUFFLHNCQUFzQixXQUFXLEVBQUUsU0FBUyxFQUFFLDhKQUE4SixFQUFFLGtEQUFrRCxTQUFTLGtCQUFrQiwyQkFBMkIsRUFBRSxtQkFBbUIsc0JBQXNCLDhCQUE4QixhQUFhLEVBQUUsc0JBQXNCLGVBQWUsV0FBVyxFQUFFLG1CQUFtQixNQUFNLCtEQUErRCxFQUFFLFVBQVUsdUJBQXVCLEVBQUUsRUFBRSxHQUFHOztBQUVyK0IsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckwsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QiwrQkFBK0I7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1Qjs7QUFFQSxxQkFBcUIsT0FBTztBQUM1QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixXQUFXO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEscUJBQXFCLE9BQU87QUFDNUI7QUFDQSxTQUFTO0FBQ1Qsa0JBQWtCLE1BQU07QUFDeEI7O0FBRUEscUJBQXFCLG9EQUEyQjtBQUNoRDtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3QixhQUFhO0FBQ3JDOztBQUVBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlOztBQUVmO0FBQ0E7O0FBRUEsZ0NBQWdDLGlDQUFpQztBQUNqRTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsaUNBQWlDO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTs7QUFFYjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0RBQWtELGlEQUFpRCxpQ0FBaUMsRUFBRTtBQUN0STtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsaUNBQWlDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGlDQUFpQztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGlDQUFpQztBQUMvRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7QUFDSDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLDBDQUEwQywrREFBK0QsMkVBQTJFLEVBQUUseUVBQXlFLGVBQWUsc0RBQXNELEVBQUUsRUFBRSx1REFBdUQ7O0FBRS9YLGdDQUFnQyw0RUFBNEUsaUJBQWlCLFVBQVUsR0FBRyw4QkFBOEI7O0FBRXhLLGdDQUFnQyw2REFBNkQseUNBQXlDLDhDQUE4QyxpQ0FBaUMsbURBQW1ELHlEQUF5RCxFQUFFLE9BQU8sdUNBQXVDLEVBQUUsaURBQWlELEdBQUc7O0FBRXZhLGlEQUFpRCwwRUFBMEUsYUFBYSxFQUFFLHFDQUFxQzs7QUFFL0ssdUNBQXVDLHVCQUF1Qix1RkFBdUYsRUFBRSxhQUFhOztBQUVwSyxzQ0FBc0Msd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSx3RUFBd0UsR0FBRyxhQUFhLEVBQUUsWUFBWSxjQUFjLEVBQUU7O0FBRWxVLDZCQUE2QixnR0FBZ0csZ0RBQWdELEdBQUcsMkJBQTJCOztBQUUzTSw0RUFBNEUsTUFBTSwwQkFBMEIsd0JBQXdCLEVBQUUsZ0JBQWdCLGVBQWUsUUFBUSxFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSxPQUFPLDRDQUE0QyxFQUFFOztBQUV2USxnQ0FBZ0MscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3Qix3RUFBd0UsRUFBRSx1QkFBdUIsdUVBQXVFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxHQUFHOztBQUVuWSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjs7QUFFQSxTQUFTLG1CQUFPLENBQUMsaUJBQUk7O0FBRXJCLFdBQVcsbUJBQU8sQ0FBQyxtQkFBTTs7QUFFekIsWUFBWSxtQkFBTyxDQUFDLG9CQUFPOztBQUUzQixVQUFVLG1CQUFPLENBQUMsa0JBQUs7O0FBRXZCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBLGlDQUFpQywySEFBMkg7O0FBRTVKLDZCQUE2QixrS0FBa0s7O0FBRS9MLGlEQUFpRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNELGtIQUFrSDs7QUFFOVosc0NBQXNDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLGtCQUFrQixFQUFFLGFBQWE7O0FBRXJMLHdDQUF3QyxnRkFBZ0YsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLG1DQUFtQyxFQUFFLEVBQUUsY0FBYyxXQUFXLFVBQVUsRUFBRSxVQUFVLE1BQU0saURBQWlELEVBQUUsVUFBVSxrQkFBa0IsRUFBRSxFQUFFLGFBQWE7O0FBRXZlLCtCQUErQixvQ0FBb0M7O0FBRW5FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixxREFBcUQsT0FBTztBQUN6Rjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxxQkFBcUIsc0JBQXNCO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixrQkFBa0I7QUFDdkM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsRUFBRTtBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxnQkFBZ0I7O0FBRTdGLDRFQUE0RSxNQUFNLDBCQUEwQix3QkFBd0IsRUFBRSxnQkFBZ0IsZUFBZSxRQUFRLEVBQUUsaUJBQWlCLGdCQUFnQixFQUFFLE9BQU8sNENBQTRDLEVBQUU7O0FBRXZRLGdDQUFnQyxxQkFBcUIsbUNBQW1DLGdEQUFnRCxnQ0FBZ0Msd0JBQXdCLHdFQUF3RSxFQUFFLHVCQUF1Qix1RUFBdUUsRUFBRSxrQkFBa0IsRUFBRSxFQUFFLEdBQUc7O0FBRW5ZLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsZ0JBQWdCOztBQUU3Riw0RUFBNEUsTUFBTSwwQkFBMEIsd0JBQXdCLEVBQUUsZ0JBQWdCLGVBQWUsUUFBUSxFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSxPQUFPLDRDQUE0QyxFQUFFOztBQUV2USxnQ0FBZ0MscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3Qix3RUFBd0UsRUFBRSx1QkFBdUIsdUVBQXVFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxHQUFHOztBQUVuWSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxDQUFDO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC1zaWcvZXM1L2J1aWxkL3BkZi5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY3N0YXJ0IFRoZSBmb2xsb3dpbmcgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhc2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKlxuICogQ29weXJpZ2h0IDIwMjAgTW96aWxsYSBGb3VuZGF0aW9uXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBsaWNlbmQgVGhlIGFib3ZlIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YXNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICovXG5cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwicGRmanMtZGlzdC9idWlsZC9wZGZcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0gPSByb290LnBkZmpzTGliID0gZmFjdG9yeSgpO1xufSkodGhpcywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dfcGRmanNfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dfcGRmanNfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dfcGRmanNfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193X3BkZmpzX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd19wZGZqc19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dfcGRmanNfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dfcGRmanNfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dfcGRmanNfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dfcGRmanNfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dfcGRmanNfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193X3BkZmpzX3JlcXVpcmVfXyhfX3dfcGRmanNfcmVxdWlyZV9fLnMgPSAwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImFkZExpbmtBdHRyaWJ1dGVzXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmFkZExpbmtBdHRyaWJ1dGVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldEZpbGVuYW1lRnJvbVVybFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5nZXRGaWxlbmFtZUZyb21Vcmw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTGlua1RhcmdldFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5MaW5rVGFyZ2V0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRTY3JpcHRcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMubG9hZFNjcmlwdDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZEYXRlU3RyaW5nXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlBERkRhdGVTdHJpbmc7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJidWlsZFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpLmJ1aWxkO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERvY3VtZW50XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcGkuZ2V0RG9jdW1lbnQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTG9vcGJhY2tQb3J0XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hcGkuTG9vcGJhY2tQb3J0O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBERkRhdGFSYW5nZVRyYW5zcG9ydFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpLlBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZXb3JrZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX2FwaS5QREZXb3JrZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpLnZlcnNpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQ01hcENvbXByZXNzaW9uVHlwZVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZU9iamVjdFVSTFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5jcmVhdGVPYmplY3RVUkw7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHlcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiY3JlYXRlVmFsaWRBYnNvbHV0ZVVybFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5jcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkludmFsaWRQREZFeGNlcHRpb25cIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3V0aWwuSW52YWxpZFBERkV4Y2VwdGlvbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiT1BTXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91dGlsLk9QUztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQYXNzd29yZFJlc3BvbnNlc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5QYXNzd29yZFJlc3BvbnNlcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtaXNzaW9uRmxhZ1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5QZXJtaXNzaW9uRmxhZztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJyZW1vdmVOdWxsQ2hhcmFjdGVyc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5yZW1vdmVOdWxsQ2hhcmFjdGVycztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzaGFkb3dcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3V0aWwuc2hhZG93O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVU5TVVBQT1JURURfRkVBVFVSRVNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3V0aWwuVU5TVVBQT1JURURfRkVBVFVSRVM7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRpbFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdXRpbC5VdGlsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlZlcmJvc2l0eUxldmVsXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91dGlsLlZlcmJvc2l0eUxldmVsO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25MYXllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYW5ub3RhdGlvbl9sYXllci5Bbm5vdGF0aW9uTGF5ZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYXBpQ29tcGF0aWJpbGl0eVBhcmFtc1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYXBpX2NvbXBhdGliaWxpdHkuYXBpQ29tcGF0aWJpbGl0eVBhcmFtcztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHbG9iYWxXb3JrZXJPcHRpb25zXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbmRlclRleHRMYXllclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGV4dF9sYXllci5yZW5kZXJUZXh0TGF5ZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU1ZHR3JhcGhpY3NcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3N2Zy5TVkdHcmFwaGljcztcbiAgfVxufSk7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfYXBpID0gX193X3BkZmpzX3JlcXVpcmVfXygyMDIpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxNik7XG5cbnZhciBfYXBpX2NvbXBhdGliaWxpdHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwNik7XG5cbnZhciBfd29ya2VyX29wdGlvbnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwOSk7XG5cbnZhciBfdGV4dF9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjE3KTtcblxudmFyIF9zdmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxOCk7XG5cbnZhciBwZGZqc1ZlcnNpb24gPSAnMi42LjM0Nyc7XG52YXIgcGRmanNCdWlsZCA9ICczYmU5YzY1Zic7XG57XG4gIHZhciBfcmVxdWlyZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNyksXG4gICAgICBpc05vZGVKUyA9IF9yZXF1aXJlLmlzTm9kZUpTO1xuXG4gIGlmIChpc05vZGVKUykge1xuICAgIHZhciBQREZOb2RlU3RyZWFtID0gX193X3BkZmpzX3JlcXVpcmVfXygyMTkpLlBERk5vZGVTdHJlYW07XG5cbiAgICAoMCwgX2FwaS5zZXRQREZOZXR3b3JrU3RyZWFtRmFjdG9yeSkoZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgcmV0dXJuIG5ldyBQREZOb2RlU3RyZWFtKHBhcmFtcyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFBERk5ldHdvcmtTdHJlYW0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyMikuUERGTmV0d29ya1N0cmVhbTtcblxuICAgIHZhciBQREZGZXRjaFN0cmVhbTtcblxuICAgIGlmICgoMCwgX2Rpc3BsYXlfdXRpbHMuaXNGZXRjaFN1cHBvcnRlZCkoKSkge1xuICAgICAgUERGRmV0Y2hTdHJlYW0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyMykuUERGRmV0Y2hTdHJlYW07XG4gICAgfVxuXG4gICAgKDAsIF9hcGkuc2V0UERGTmV0d29ya1N0cmVhbUZhY3RvcnkpKGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgIGlmIChQREZGZXRjaFN0cmVhbSAmJiAoMCwgX2Rpc3BsYXlfdXRpbHMuaXNWYWxpZEZldGNoVXJsKShwYXJhbXMudXJsKSkge1xuICAgICAgICByZXR1cm4gbmV3IFBERkZldGNoU3RyZWFtKHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUERGTmV0d29ya1N0cmVhbShwYXJhbXMpO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hZGRMaW5rQXR0cmlidXRlcyA9IGFkZExpbmtBdHRyaWJ1dGVzO1xuZXhwb3J0cy5nZXRGaWxlbmFtZUZyb21VcmwgPSBnZXRGaWxlbmFtZUZyb21Vcmw7XG5leHBvcnRzLmlzRmV0Y2hTdXBwb3J0ZWQgPSBpc0ZldGNoU3VwcG9ydGVkO1xuZXhwb3J0cy5pc1ZhbGlkRmV0Y2hVcmwgPSBpc1ZhbGlkRmV0Y2hVcmw7XG5leHBvcnRzLmxvYWRTY3JpcHQgPSBsb2FkU2NyaXB0O1xuZXhwb3J0cy5kZXByZWNhdGVkID0gZGVwcmVjYXRlZDtcbmV4cG9ydHMuUERGRGF0ZVN0cmluZyA9IGV4cG9ydHMuU3RhdFRpbWVyID0gZXhwb3J0cy5ET01TVkdGYWN0b3J5ID0gZXhwb3J0cy5ET01DTWFwUmVhZGVyRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUNNYXBSZWFkZXJGYWN0b3J5ID0gZXhwb3J0cy5ET01DYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5CYXNlQ2FudmFzRmFjdG9yeSA9IGV4cG9ydHMuREVGQVVMVF9MSU5LX1JFTCA9IGV4cG9ydHMuTGlua1RhcmdldCA9IGV4cG9ydHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gZXhwb3J0cy5QYWdlVmlld3BvcnQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd19wZGZqc19yZXF1aXJlX18oMikpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgREVGQVVMVF9MSU5LX1JFTCA9IFwibm9vcGVuZXIgbm9yZWZlcnJlciBub2ZvbGxvd1wiO1xuZXhwb3J0cy5ERUZBVUxUX0xJTktfUkVMID0gREVGQVVMVF9MSU5LX1JFTDtcbnZhciBTVkdfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5cbnZhciBCYXNlQ2FudmFzRmFjdG9yeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VDYW52YXNGYWN0b3J5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlQ2FudmFzRmFjdG9yeSk7XG5cbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNhbnZhc0ZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlQ2FudmFzRmFjdG9yeS5cIik7XG4gICAgfVxuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VDYW52YXNGYWN0b3J5LCBbe1xuICAgIGtleTogXCJjcmVhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYGNyZWF0ZWAgY2FsbGVkLlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoY2FudmFzQW5kQ29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICAgIH1cblxuICAgICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICAgIGlmICghY2FudmFzQW5kQ29udGV4dC5jYW52YXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgICB9XG5cbiAgICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLndpZHRoID0gMDtcbiAgICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcyA9IG51bGw7XG4gICAgICBjYW52YXNBbmRDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlQ2FudmFzRmFjdG9yeTtcbn0oKTtcblxuZXhwb3J0cy5CYXNlQ2FudmFzRmFjdG9yeSA9IEJhc2VDYW52YXNGYWN0b3J5O1xuXG52YXIgRE9NQ2FudmFzRmFjdG9yeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDYW52YXNGYWN0b3J5KSB7XG4gIF9pbmhlcml0cyhET01DYW52YXNGYWN0b3J5LCBfQmFzZUNhbnZhc0ZhY3RvcnkpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoRE9NQ2FudmFzRmFjdG9yeSk7XG5cbiAgZnVuY3Rpb24gRE9NQ2FudmFzRmFjdG9yeSgpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgIF9yZWYkb3duZXJEb2N1bWVudCA9IF9yZWYub3duZXJEb2N1bWVudCxcbiAgICAgICAgb3duZXJEb2N1bWVudCA9IF9yZWYkb3duZXJEb2N1bWVudCA9PT0gdm9pZCAwID8gZ2xvYmFsVGhpcy5kb2N1bWVudCA6IF9yZWYkb3duZXJEb2N1bWVudDtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBET01DYW52YXNGYWN0b3J5KTtcblxuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcyk7XG4gICAgX3RoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRE9NQ2FudmFzRmFjdG9yeSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblxuICAgICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERPTUNhbnZhc0ZhY3Rvcnk7XG59KEJhc2VDYW52YXNGYWN0b3J5KTtcblxuZXhwb3J0cy5ET01DYW52YXNGYWN0b3J5ID0gRE9NQ2FudmFzRmFjdG9yeTtcblxudmFyIEJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJhc2VDTWFwUmVhZGVyRmFjdG9yeShfcmVmMikge1xuICAgIHZhciBfcmVmMiRiYXNlVXJsID0gX3JlZjIuYmFzZVVybCxcbiAgICAgICAgYmFzZVVybCA9IF9yZWYyJGJhc2VVcmwgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmMiRiYXNlVXJsLFxuICAgICAgICBfcmVmMiRpc0NvbXByZXNzZWQgPSBfcmVmMi5pc0NvbXByZXNzZWQsXG4gICAgICAgIGlzQ29tcHJlc3NlZCA9IF9yZWYyJGlzQ29tcHJlc3NlZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMiRpc0NvbXByZXNzZWQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUNNYXBSZWFkZXJGYWN0b3J5KTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlQ01hcFJlYWRlckZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlQ01hcFJlYWRlckZhY3RvcnkuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgdGhpcy5pc0NvbXByZXNzZWQgPSBpc0NvbXByZXNzZWQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZUNNYXBSZWFkZXJGYWN0b3J5LCBbe1xuICAgIGtleTogXCJmZXRjaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2ZldGNoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShfcmVmMykge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB2YXIgbmFtZSwgdXJsLCBjb21wcmVzc2lvblR5cGU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgbmFtZSA9IF9yZWYzLm5hbWU7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5iYXNlVXJsKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIENNYXAgXCJiYXNlVXJsXCIgcGFyYW1ldGVyIG11c3QgYmUgc3BlY2lmaWVkLCBlbnN1cmUgdGhhdCAnICsgJ3RoZSBcImNNYXBVcmxcIiBhbmQgXCJjTWFwUGFja2VkXCIgQVBJIHBhcmFtZXRlcnMgYXJlIHByb3ZpZGVkLicpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB1cmwgPSB0aGlzLmJhc2VVcmwgKyBuYW1lICsgKHRoaXMuaXNDb21wcmVzc2VkID8gXCIuYmNtYXBcIiA6IFwiXCIpO1xuICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uVHlwZSA9IHRoaXMuaXNDb21wcmVzc2VkID8gX3V0aWwuQ01hcENvbXByZXNzaW9uVHlwZS5CSU5BUlkgOiBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlLk5PTkU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGxvYWQgXCIuY29uY2F0KF90aGlzMi5pc0NvbXByZXNzZWQgPyBcImJpbmFyeSBcIiA6IFwiXCIsIFwiQ01hcCBhdDogXCIpLmNvbmNhdCh1cmwpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBmZXRjaChfeCkge1xuICAgICAgICByZXR1cm4gX2ZldGNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmZXRjaDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfZmV0Y2hEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9mZXRjaERhdGFgIGNhbGxlZC5cIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VDTWFwUmVhZGVyRmFjdG9yeTtcbn0oKTtcblxuZXhwb3J0cy5CYXNlQ01hcFJlYWRlckZhY3RvcnkgPSBCYXNlQ01hcFJlYWRlckZhY3Rvcnk7XG5cbnZhciBET01DTWFwUmVhZGVyRmFjdG9yeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDTWFwUmVhZGVyRmFjdG9yKSB7XG4gIF9pbmhlcml0cyhET01DTWFwUmVhZGVyRmFjdG9yeSwgX0Jhc2VDTWFwUmVhZGVyRmFjdG9yKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihET01DTWFwUmVhZGVyRmFjdG9yeSk7XG5cbiAgZnVuY3Rpb24gRE9NQ01hcFJlYWRlckZhY3RvcnkoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERPTUNNYXBSZWFkZXJGYWN0b3J5KTtcblxuICAgIHJldHVybiBfc3VwZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRE9NQ01hcFJlYWRlckZhY3RvcnksIFt7XG4gICAga2V5OiBcIl9mZXRjaERhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICAgIGlmIChpc0ZldGNoU3VwcG9ydGVkKCkgJiYgaXNWYWxpZEZldGNoVXJsKHVybCwgZG9jdW1lbnQuYmFzZVVSSSkpIHtcbiAgICAgICAgcmV0dXJuIGZldGNoKHVybCkudGhlbiggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgX3JlZjQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMihyZXNwb25zZSkge1xuICAgICAgICAgICAgdmFyIGNNYXBEYXRhO1xuICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzMy5pc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLnQwID0gVWludDhBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDEgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgY01hcERhdGEgPSBuZXcgX2NvbnRleHQyLnQwKF9jb250ZXh0Mi50MSk7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDIgPSBfdXRpbC5zdHJpbmdUb0J5dGVzO1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIudDMgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgY01hcERhdGEgPSAoMCwgX2NvbnRleHQyLnQyKShfY29udGV4dDIudDMpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgY01hcERhdGE6IGNNYXBEYXRhLFxuICAgICAgICAgICAgICAgICAgICAgIGNvbXByZXNzaW9uVHlwZTogY29tcHJlc3Npb25UeXBlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94Mikge1xuICAgICAgICAgICAgcmV0dXJuIF9yZWY0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKF90aGlzMy5pc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IFwiYXJyYXlidWZmZXJcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IFhNTEh0dHBSZXF1ZXN0LkRPTkUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIGNNYXBEYXRhO1xuXG4gICAgICAgICAgICBpZiAoX3RoaXMzLmlzQ29tcHJlc3NlZCAmJiByZXF1ZXN0LnJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgIGNNYXBEYXRhID0gbmV3IFVpbnQ4QXJyYXkocmVxdWVzdC5yZXNwb25zZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFfdGhpczMuaXNDb21wcmVzc2VkICYmIHJlcXVlc3QucmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICAgIGNNYXBEYXRhID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNNYXBEYXRhKSB7XG4gICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgIGNNYXBEYXRhOiBjTWFwRGF0YSxcbiAgICAgICAgICAgICAgICBjb21wcmVzc2lvblR5cGU6IGNvbXByZXNzaW9uVHlwZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IocmVxdWVzdC5zdGF0dXNUZXh0KSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIERPTUNNYXBSZWFkZXJGYWN0b3J5O1xufShCYXNlQ01hcFJlYWRlckZhY3RvcnkpO1xuXG5leHBvcnRzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ID0gRE9NQ01hcFJlYWRlckZhY3Rvcnk7XG5cbnZhciBET01TVkdGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRE9NU1ZHRmFjdG9yeSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRE9NU1ZHRmFjdG9yeSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRE9NU1ZHRmFjdG9yeSwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh3aWR0aCA+IDAgJiYgaGVpZ2h0ID4gMCwgXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgICAgdmFyIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwic3ZnOnN2Z1wiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoICsgXCJweFwiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0ICsgXCJweFwiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwibm9uZVwiKTtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIFwiMCAwIFwiICsgd2lkdGggKyBcIiBcIiArIGhlaWdodCk7XG4gICAgICByZXR1cm4gc3ZnO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVFbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSkge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIsIFwiSW52YWxpZCBTVkcgZWxlbWVudCB0eXBlXCIpO1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIHR5cGUpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBET01TVkdGYWN0b3J5O1xufSgpO1xuXG5leHBvcnRzLkRPTVNWR0ZhY3RvcnkgPSBET01TVkdGYWN0b3J5O1xuXG52YXIgUGFnZVZpZXdwb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGFnZVZpZXdwb3J0KF9yZWY1KSB7XG4gICAgdmFyIHZpZXdCb3ggPSBfcmVmNS52aWV3Qm94LFxuICAgICAgICBzY2FsZSA9IF9yZWY1LnNjYWxlLFxuICAgICAgICByb3RhdGlvbiA9IF9yZWY1LnJvdGF0aW9uLFxuICAgICAgICBfcmVmNSRvZmZzZXRYID0gX3JlZjUub2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WCA9IF9yZWY1JG9mZnNldFggPT09IHZvaWQgMCA/IDAgOiBfcmVmNSRvZmZzZXRYLFxuICAgICAgICBfcmVmNSRvZmZzZXRZID0gX3JlZjUub2Zmc2V0WSxcbiAgICAgICAgb2Zmc2V0WSA9IF9yZWY1JG9mZnNldFkgPT09IHZvaWQgMCA/IDAgOiBfcmVmNSRvZmZzZXRZLFxuICAgICAgICBfcmVmNSRkb250RmxpcCA9IF9yZWY1LmRvbnRGbGlwLFxuICAgICAgICBkb250RmxpcCA9IF9yZWY1JGRvbnRGbGlwID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY1JGRvbnRGbGlwO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBhZ2VWaWV3cG9ydCk7XG5cbiAgICB0aGlzLnZpZXdCb3ggPSB2aWV3Qm94O1xuICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICB0aGlzLnJvdGF0aW9uID0gcm90YXRpb247XG4gICAgdGhpcy5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICB0aGlzLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgIHZhciBjZW50ZXJYID0gKHZpZXdCb3hbMl0gKyB2aWV3Qm94WzBdKSAvIDI7XG4gICAgdmFyIGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICB2YXIgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiA9IHJvdGF0aW9uICUgMzYwO1xuICAgIHJvdGF0aW9uID0gcm90YXRpb24gPCAwID8gcm90YXRpb24gKyAzNjAgOiByb3RhdGlvbjtcblxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByb3RhdGVBID0gLTE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDkwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IDE7XG4gICAgICAgIHJvdGF0ZUMgPSAxO1xuICAgICAgICByb3RhdGVEID0gMDtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IC0xO1xuICAgICAgICByb3RhdGVDID0gLTE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAwOlxuICAgICAgICByb3RhdGVBID0gMTtcbiAgICAgICAgcm90YXRlQiA9IDA7XG4gICAgICAgIHJvdGF0ZUMgPSAwO1xuICAgICAgICByb3RhdGVEID0gLTE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWdlVmlld3BvcnQ6IEludmFsaWQgcm90YXRpb24sIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA5MCBkZWdyZWVzLlwiKTtcbiAgICB9XG5cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQztcbiAgICAgIHJvdGF0ZUQgPSAtcm90YXRlRDtcbiAgICB9XG5cbiAgICB2YXIgb2Zmc2V0Q2FudmFzWCwgb2Zmc2V0Q2FudmFzWTtcbiAgICB2YXIgd2lkdGgsIGhlaWdodDtcblxuICAgIGlmIChyb3RhdGVBID09PSAwKSB7XG4gICAgICBvZmZzZXRDYW52YXNYID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRYO1xuICAgICAgb2Zmc2V0Q2FudmFzWSA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WTtcbiAgICAgIHdpZHRoID0gTWF0aC5hYnModmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSBNYXRoLmFicyh2aWV3Qm94WzJdIC0gdmlld0JveFswXSkgKiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2Zmc2V0Q2FudmFzWCA9IE1hdGguYWJzKGNlbnRlclggLSB2aWV3Qm94WzBdKSAqIHNjYWxlICsgb2Zmc2V0WDtcbiAgICAgIG9mZnNldENhbnZhc1kgPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFk7XG4gICAgICB3aWR0aCA9IE1hdGguYWJzKHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdKSAqIHNjYWxlO1xuICAgICAgaGVpZ2h0ID0gTWF0aC5hYnModmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuXG4gICAgdGhpcy50cmFuc2Zvcm0gPSBbcm90YXRlQSAqIHNjYWxlLCByb3RhdGVCICogc2NhbGUsIHJvdGF0ZUMgKiBzY2FsZSwgcm90YXRlRCAqIHNjYWxlLCBvZmZzZXRDYW52YXNYIC0gcm90YXRlQSAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUMgKiBzY2FsZSAqIGNlbnRlclksIG9mZnNldENhbnZhc1kgLSByb3RhdGVCICogc2NhbGUgKiBjZW50ZXJYIC0gcm90YXRlRCAqIHNjYWxlICogY2VudGVyWV07XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhZ2VWaWV3cG9ydCwgW3tcbiAgICBrZXk6IFwiY2xvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvbmUoKSB7XG4gICAgICB2YXIgX3JlZjYgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWY2JHNjYWxlID0gX3JlZjYuc2NhbGUsXG4gICAgICAgICAgc2NhbGUgPSBfcmVmNiRzY2FsZSA9PT0gdm9pZCAwID8gdGhpcy5zY2FsZSA6IF9yZWY2JHNjYWxlLFxuICAgICAgICAgIF9yZWY2JHJvdGF0aW9uID0gX3JlZjYucm90YXRpb24sXG4gICAgICAgICAgcm90YXRpb24gPSBfcmVmNiRyb3RhdGlvbiA9PT0gdm9pZCAwID8gdGhpcy5yb3RhdGlvbiA6IF9yZWY2JHJvdGF0aW9uLFxuICAgICAgICAgIF9yZWY2JG9mZnNldFggPSBfcmVmNi5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFggPSBfcmVmNiRvZmZzZXRYID09PSB2b2lkIDAgPyB0aGlzLm9mZnNldFggOiBfcmVmNiRvZmZzZXRYLFxuICAgICAgICAgIF9yZWY2JG9mZnNldFkgPSBfcmVmNi5vZmZzZXRZLFxuICAgICAgICAgIG9mZnNldFkgPSBfcmVmNiRvZmZzZXRZID09PSB2b2lkIDAgPyB0aGlzLm9mZnNldFkgOiBfcmVmNiRvZmZzZXRZLFxuICAgICAgICAgIF9yZWY2JGRvbnRGbGlwID0gX3JlZjYuZG9udEZsaXAsXG4gICAgICAgICAgZG9udEZsaXAgPSBfcmVmNiRkb250RmxpcCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNiRkb250RmxpcDtcblxuICAgICAgcmV0dXJuIG5ldyBQYWdlVmlld3BvcnQoe1xuICAgICAgICB2aWV3Qm94OiB0aGlzLnZpZXdCb3guc2xpY2UoKSxcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICAgIGRvbnRGbGlwOiBkb250RmxpcFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnZlcnRUb1ZpZXdwb3J0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydFRvVmlld3BvcnRQb2ludCh4LCB5KSB7XG4gICAgICByZXR1cm4gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydFRvVmlld3BvcnRSZWN0YW5nbGUocmVjdCkge1xuICAgICAgdmFyIHRvcExlZnQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzBdLCByZWN0WzFdXSwgdGhpcy50cmFuc2Zvcm0pO1xuXG4gICAgICB2YXIgYm90dG9tUmlnaHQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzNdXSwgdGhpcy50cmFuc2Zvcm0pO1xuXG4gICAgICByZXR1cm4gW3RvcExlZnRbMF0sIHRvcExlZnRbMV0sIGJvdHRvbVJpZ2h0WzBdLCBib3R0b21SaWdodFsxXV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnZlcnRUb1BkZlBvaW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnZlcnRUb1BkZlBvaW50KHgsIHkpIHtcbiAgICAgIHJldHVybiBfdXRpbC5VdGlsLmFwcGx5SW52ZXJzZVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUGFnZVZpZXdwb3J0O1xufSgpO1xuXG5leHBvcnRzLlBhZ2VWaWV3cG9ydCA9IFBhZ2VWaWV3cG9ydDtcblxudmFyIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VFeGNlcHRpb24pIHtcbiAgX2luaGVyaXRzKFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb24pO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbik7XG5cbiAgZnVuY3Rpb24gUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKG1zZywgdHlwZSkge1xuICAgIHZhciBfdGhpczQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKTtcblxuICAgIF90aGlzNCA9IF9zdXBlcjMuY2FsbCh0aGlzLCBtc2cpO1xuICAgIF90aGlzNC50eXBlID0gdHlwZTtcbiAgICByZXR1cm4gX3RoaXM0O1xuICB9XG5cbiAgcmV0dXJuIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbjtcbn0oX3V0aWwuQmFzZUV4Y2VwdGlvbik7XG5cbmV4cG9ydHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uO1xudmFyIExpbmtUYXJnZXQgPSB7XG4gIE5PTkU6IDAsXG4gIFNFTEY6IDEsXG4gIEJMQU5LOiAyLFxuICBQQVJFTlQ6IDMsXG4gIFRPUDogNFxufTtcbmV4cG9ydHMuTGlua1RhcmdldCA9IExpbmtUYXJnZXQ7XG5cbmZ1bmN0aW9uIGFkZExpbmtBdHRyaWJ1dGVzKGxpbmspIHtcbiAgdmFyIF9yZWY3ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIHVybCA9IF9yZWY3LnVybCxcbiAgICAgIHRhcmdldCA9IF9yZWY3LnRhcmdldCxcbiAgICAgIHJlbCA9IF9yZWY3LnJlbCxcbiAgICAgIF9yZWY3JGVuYWJsZWQgPSBfcmVmNy5lbmFibGVkLFxuICAgICAgZW5hYmxlZCA9IF9yZWY3JGVuYWJsZWQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmNyRlbmFibGVkO1xuXG4gICgwLCBfdXRpbC5hc3NlcnQpKHVybCAmJiB0eXBlb2YgdXJsID09PSBcInN0cmluZ1wiLCAnYWRkTGlua0F0dHJpYnV0ZXM6IEEgdmFsaWQgXCJ1cmxcIiBwYXJhbWV0ZXIgbXVzdCBwcm92aWRlZC4nKTtcbiAgdmFyIHVybE51bGxSZW1vdmVkID0gKDAsIF91dGlsLnJlbW92ZU51bGxDaGFyYWN0ZXJzKSh1cmwpO1xuXG4gIGlmIChlbmFibGVkKSB7XG4gICAgbGluay5ocmVmID0gbGluay50aXRsZSA9IHVybE51bGxSZW1vdmVkO1xuICB9IGVsc2Uge1xuICAgIGxpbmsuaHJlZiA9IFwiXCI7XG4gICAgbGluay50aXRsZSA9IFwiRGlzYWJsZWQ6IFwiLmNvbmNhdCh1cmxOdWxsUmVtb3ZlZCk7XG5cbiAgICBsaW5rLm9uY2xpY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB0YXJnZXRTdHIgPSBcIlwiO1xuXG4gIHN3aXRjaCAodGFyZ2V0KSB7XG4gICAgY2FzZSBMaW5rVGFyZ2V0Lk5PTkU6XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTGlua1RhcmdldC5TRUxGOlxuICAgICAgdGFyZ2V0U3RyID0gXCJfc2VsZlwiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExpbmtUYXJnZXQuQkxBTks6XG4gICAgICB0YXJnZXRTdHIgPSBcIl9ibGFua1wiO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExpbmtUYXJnZXQuUEFSRU5UOlxuICAgICAgdGFyZ2V0U3RyID0gXCJfcGFyZW50XCI7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgTGlua1RhcmdldC5UT1A6XG4gICAgICB0YXJnZXRTdHIgPSBcIl90b3BcIjtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgbGluay50YXJnZXQgPSB0YXJnZXRTdHI7XG4gIGxpbmsucmVsID0gdHlwZW9mIHJlbCA9PT0gXCJzdHJpbmdcIiA/IHJlbCA6IERFRkFVTFRfTElOS19SRUw7XG59XG5cbmZ1bmN0aW9uIGdldEZpbGVuYW1lRnJvbVVybCh1cmwpIHtcbiAgdmFyIGFuY2hvciA9IHVybC5pbmRleE9mKFwiI1wiKTtcbiAgdmFyIHF1ZXJ5ID0gdXJsLmluZGV4T2YoXCI/XCIpO1xuICB2YXIgZW5kID0gTWF0aC5taW4oYW5jaG9yID4gMCA/IGFuY2hvciA6IHVybC5sZW5ndGgsIHF1ZXJ5ID4gMCA/IHF1ZXJ5IDogdXJsLmxlbmd0aCk7XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKHVybC5sYXN0SW5kZXhPZihcIi9cIiwgZW5kKSArIDEsIGVuZCk7XG59XG5cbnZhciBTdGF0VGltZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdGF0VGltZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YXRUaW1lcik7XG5cbiAgICB0aGlzLnN0YXJ0ZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMudGltZXMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTdGF0VGltZXIsIFt7XG4gICAga2V5OiBcInRpbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGltZShuYW1lKSB7XG4gICAgICBpZiAobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVGltZXIgaXMgYWxyZWFkeSBydW5uaW5nIGZvciBcIi5jb25jYXQobmFtZSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnN0YXJ0ZWRbbmFtZV0gPSBEYXRlLm5vdygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0aW1lRW5kXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRpbWVFbmQobmFtZSkge1xuICAgICAgaWYgKCEobmFtZSBpbiB0aGlzLnN0YXJ0ZWQpKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIlRpbWVyIGhhcyBub3QgYmVlbiBzdGFydGVkIGZvciBcIi5jb25jYXQobmFtZSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBzdGFydDogdGhpcy5zdGFydGVkW25hbWVdLFxuICAgICAgICBlbmQ6IERhdGUubm93KClcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHRoaXMuc3RhcnRlZFtuYW1lXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidG9TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgICB2YXIgb3V0QnVmID0gW107XG4gICAgICB2YXIgbG9uZ2VzdCA9IDA7XG5cbiAgICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLnRpbWVzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgdGltZSA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBuYW1lID0gdGltZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gbG9uZ2VzdCkge1xuICAgICAgICAgICAgbG9uZ2VzdCA9IG5hbWUubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMudGltZXMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3RpbWUgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gX3RpbWUuZW5kIC0gX3RpbWUuc3RhcnQ7XG4gICAgICAgICAgb3V0QnVmLnB1c2goXCJcIi5jb25jYXQoX3RpbWUubmFtZS5wYWRFbmQobG9uZ2VzdCksIFwiIFwiKS5jb25jYXQoZHVyYXRpb24sIFwibXNcXG5cIikpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG91dEJ1Zi5qb2luKFwiXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdGF0VGltZXI7XG59KCk7XG5cbmV4cG9ydHMuU3RhdFRpbWVyID0gU3RhdFRpbWVyO1xuXG5mdW5jdGlvbiBpc0ZldGNoU3VwcG9ydGVkKCkge1xuICByZXR1cm4gdHlwZW9mIGZldGNoICE9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBSZXNwb25zZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcImJvZHlcIiBpbiBSZXNwb25zZS5wcm90b3R5cGUgJiYgdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSBcInVuZGVmaW5lZFwiO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRmV0Y2hVcmwodXJsLCBiYXNlVXJsKSB7XG4gIHRyeSB7XG4gICAgdmFyIF9yZWY4ID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKSxcbiAgICAgICAgcHJvdG9jb2wgPSBfcmVmOC5wcm90b2NvbDtcblxuICAgIHJldHVybiBwcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICB9IGNhdGNoIChleCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsb2FkU2NyaXB0KHNyYykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgc2NyaXB0Lm9ubG9hZCA9IHJlc29sdmU7XG5cbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJDYW5ub3QgbG9hZCBzY3JpcHQgYXQ6IFwiLmNvbmNhdChzY3JpcHQuc3JjKSkpO1xuICAgIH07XG5cbiAgICAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cblxudmFyIHBkZkRhdGVTdHJpbmdSZWdleDtcblxudmFyIFBERkRhdGVTdHJpbmcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZEYXRlU3RyaW5nKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZEYXRlU3RyaW5nKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZEYXRlU3RyaW5nLCBudWxsLCBbe1xuICAgIGtleTogXCJ0b0RhdGVPYmplY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9EYXRlT2JqZWN0KGlucHV0KSB7XG4gICAgICBpZiAoIWlucHV0IHx8ICEoMCwgX3V0aWwuaXNTdHJpbmcpKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwZGZEYXRlU3RyaW5nUmVnZXgpIHtcbiAgICAgICAgcGRmRGF0ZVN0cmluZ1JlZ2V4ID0gbmV3IFJlZ0V4cChcIl5EOlwiICsgXCIoXFxcXGR7NH0pXCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihcXFxcZHsyfSk/XCIgKyBcIihbWnwrfC1dKT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiJz9cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXRjaGVzID0gcGRmRGF0ZVN0cmluZ1JlZ2V4LmV4ZWMoaW5wdXQpO1xuXG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQobWF0Y2hlc1sxXSwgMTApO1xuICAgICAgdmFyIG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgICAgbW9udGggPSBtb250aCA+PSAxICYmIG1vbnRoIDw9IDEyID8gbW9udGggLSAxIDogMDtcbiAgICAgIHZhciBkYXkgPSBwYXJzZUludChtYXRjaGVzWzNdLCAxMCk7XG4gICAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgICAgdmFyIGhvdXIgPSBwYXJzZUludChtYXRjaGVzWzRdLCAxMCk7XG4gICAgICBob3VyID0gaG91ciA+PSAwICYmIGhvdXIgPD0gMjMgPyBob3VyIDogMDtcbiAgICAgIHZhciBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgICBtaW51dGUgPSBtaW51dGUgPj0gMCAmJiBtaW51dGUgPD0gNTkgPyBtaW51dGUgOiAwO1xuICAgICAgdmFyIHNlY29uZCA9IHBhcnNlSW50KG1hdGNoZXNbNl0sIDEwKTtcbiAgICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgICB2YXIgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICAgIHZhciBvZmZzZXRIb3VyID0gcGFyc2VJbnQobWF0Y2hlc1s4XSwgMTApO1xuICAgICAgb2Zmc2V0SG91ciA9IG9mZnNldEhvdXIgPj0gMCAmJiBvZmZzZXRIb3VyIDw9IDIzID8gb2Zmc2V0SG91ciA6IDA7XG4gICAgICB2YXIgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgICBvZmZzZXRNaW51dGUgPSBvZmZzZXRNaW51dGUgPj0gMCAmJiBvZmZzZXRNaW51dGUgPD0gNTkgPyBvZmZzZXRNaW51dGUgOiAwO1xuXG4gICAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgICBob3VyICs9IG9mZnNldEhvdXI7XG4gICAgICAgIG1pbnV0ZSArPSBvZmZzZXRNaW51dGU7XG4gICAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgICAgaG91ciAtPSBvZmZzZXRIb3VyO1xuICAgICAgICBtaW51dGUgLT0gb2Zmc2V0TWludXRlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeWVhciwgbW9udGgsIGRheSwgaG91ciwgbWludXRlLCBzZWNvbmQpKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGRGF0ZVN0cmluZztcbn0oKTtcblxuZXhwb3J0cy5QREZEYXRlU3RyaW5nID0gUERGRGF0ZVN0cmluZztcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKG1vZHVsZSkge1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBydW50aW1lID0gZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkO1xuICB2YXIgJFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiA/IFN5bWJvbCA6IHt9O1xuICB2YXIgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiO1xuICB2YXIgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiO1xuICB2YXIgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiO1xuXG4gIGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBvYmpba2V5XTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuICAgIGdlbmVyYXRvci5faW52b2tlID0gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG5cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcblxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKVxuICAgICAgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwidGhyb3dcIixcbiAgICAgICAgYXJnOiBlcnJcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkU3RhcnQgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkID0gXCJzdXNwZW5kZWRZaWVsZFwiO1xuICB2YXIgR2VuU3RhdGVFeGVjdXRpbmcgPSBcImV4ZWN1dGluZ1wiO1xuICB2YXIgR2VuU3RhdGVDb21wbGV0ZWQgPSBcImNvbXBsZXRlZFwiO1xuICB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9O1xuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG5cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcblxuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG5cbiAgaWYgKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR3AuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgPSBHZW5lcmF0b3JGdW5jdGlvbjtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpO1xuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IHR5cGVvZiBnZW5GdW4gPT09IFwiZnVuY3Rpb25cIiAmJiBnZW5GdW4uY29uc3RydWN0b3I7XG4gICAgcmV0dXJuIGN0b3IgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgOiBmYWxzZTtcbiAgfTtcblxuICBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG5cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB7XG4gICAgICBfX2F3YWl0OiBhcmdcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgcmVqZWN0KHJlY29yZC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmc7XG4gICAgICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblxuICAgICAgICBpZiAodmFsdWUgJiYgX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuXG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRvbmVSZXN1bHQoKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5tZXRob2QgPSBtZXRob2Q7XG4gICAgICBjb250ZXh0LmFyZyA9IGFyZztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTtcblxuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gR2VuU3RhdGVDb21wbGV0ZWQ7XG4gICAgICAgICAgICB0aHJvdyBjb250ZXh0LmFyZztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTtcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcblxuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IEdlblN0YXRlQ29tcGxldGVkIDogR2VuU3RhdGVTdXNwZW5kZWRZaWVsZDtcblxuICAgICAgICAgIGlmIChyZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcblxuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGlmIChkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSkge1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpO1xuICAgICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG5cbiAgICBpZiAoaW5mby5kb25lKSB7XG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcbiAgICAgIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2M7XG5cbiAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCAhPT0gXCJyZXR1cm5cIikge1xuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICBHcFtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7XG4gICAgICB0cnlMb2M6IGxvY3NbMF1cbiAgICB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgIH1dO1xuICAgIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKTtcbiAgICB0aGlzLnJlc2V0KHRydWUpO1xuICB9XG5cbiAgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICB9XG5cbiAgICBrZXlzLnJldmVyc2UoKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcblxuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG5cbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsXG4gICAgICAgICAgICBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgIH07XG4gIH1cblxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgZG9uZTogdHJ1ZVxuICAgIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpO1xuXG4gICAgICBpZiAoIXNraXBUZW1wUmVzZXQpIHtcbiAgICAgICAgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSB7XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcblxuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcblxuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gISFjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkgJiYgKHR5cGUgPT09IFwiYnJlYWtcIiB8fCB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYykge1xuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJicmVha1wiIHx8IHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuICAgIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9XG4gIH07XG4gIHJldHVybiBleHBvcnRzO1xufSgoIGZhbHNlID8gdW5kZWZpbmVkIDogX3R5cGVvZihtb2R1bGUpKSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge30pO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dfcGRmanNfcmVxdWlyZV9fKDQpKG1vZHVsZSkpKVxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobW9kdWxlKSB7XG4gIGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuICAgIG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICAgIG1vZHVsZS5wYXRocyA9IFtdO1xuICAgIGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUubDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIG1vZHVsZS5pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuICB9XG5cbiAgcmV0dXJuIG1vZHVsZTtcbn07XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5hcnJheUJ5dGVMZW5ndGggPSBhcnJheUJ5dGVMZW5ndGg7XG5leHBvcnRzLmFycmF5c1RvQnl0ZXMgPSBhcnJheXNUb0J5dGVzO1xuZXhwb3J0cy5hc3NlcnQgPSBhc3NlcnQ7XG5leHBvcnRzLmJ5dGVzVG9TdHJpbmcgPSBieXRlc1RvU3RyaW5nO1xuZXhwb3J0cy5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSA9IGNyZWF0ZVByb21pc2VDYXBhYmlsaXR5O1xuZXhwb3J0cy5lc2NhcGVTdHJpbmcgPSBlc2NhcGVTdHJpbmc7XG5leHBvcnRzLmdldE1vZGlmaWNhdGlvbkRhdGUgPSBnZXRNb2RpZmljYXRpb25EYXRlO1xuZXhwb3J0cy5nZXRWZXJib3NpdHlMZXZlbCA9IGdldFZlcmJvc2l0eUxldmVsO1xuZXhwb3J0cy5pbmZvID0gaW5mbztcbmV4cG9ydHMuaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG5leHBvcnRzLmlzQXJyYXlFcXVhbCA9IGlzQXJyYXlFcXVhbDtcbmV4cG9ydHMuaXNCb29sID0gaXNCb29sO1xuZXhwb3J0cy5pc051bSA9IGlzTnVtO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc1NhbWVPcmlnaW4gPSBpc1NhbWVPcmlnaW47XG5leHBvcnRzLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwgPSBjcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuZXhwb3J0cy5yZW1vdmVOdWxsQ2hhcmFjdGVycyA9IHJlbW92ZU51bGxDaGFyYWN0ZXJzO1xuZXhwb3J0cy5zZXRWZXJib3NpdHlMZXZlbCA9IHNldFZlcmJvc2l0eUxldmVsO1xuZXhwb3J0cy5zaGFkb3cgPSBzaGFkb3c7XG5leHBvcnRzLnN0cmluZzMyID0gc3RyaW5nMzI7XG5leHBvcnRzLnN0cmluZ1RvQnl0ZXMgPSBzdHJpbmdUb0J5dGVzO1xuZXhwb3J0cy5zdHJpbmdUb1BERlN0cmluZyA9IHN0cmluZ1RvUERGU3RyaW5nO1xuZXhwb3J0cy5zdHJpbmdUb1VURjhTdHJpbmcgPSBzdHJpbmdUb1VURjhTdHJpbmc7XG5leHBvcnRzLnV0ZjhTdHJpbmdUb1N0cmluZyA9IHV0ZjhTdHJpbmdUb1N0cmluZztcbmV4cG9ydHMud2FybiA9IHdhcm47XG5leHBvcnRzLnVucmVhY2hhYmxlID0gdW5yZWFjaGFibGU7XG5leHBvcnRzLklzRXZhbFN1cHBvcnRlZENhY2hlZCA9IGV4cG9ydHMuSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSBleHBvcnRzLmNyZWF0ZU9iamVjdFVSTCA9IGV4cG9ydHMuRm9ybWF0RXJyb3IgPSBleHBvcnRzLlV0aWwgPSBleHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IGV4cG9ydHMuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gZXhwb3J0cy5UZXh0UmVuZGVyaW5nTW9kZSA9IGV4cG9ydHMuU3RyZWFtVHlwZSA9IGV4cG9ydHMuUGVybWlzc2lvbkZsYWcgPSBleHBvcnRzLlBhc3N3b3JkUmVzcG9uc2VzID0gZXhwb3J0cy5QYXNzd29yZEV4Y2VwdGlvbiA9IGV4cG9ydHMuTWlzc2luZ1BERkV4Y2VwdGlvbiA9IGV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IGV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSBleHBvcnRzLkNNYXBDb21wcmVzc2lvblR5cGUgPSBleHBvcnRzLkltYWdlS2luZCA9IGV4cG9ydHMuRm9udFR5cGUgPSBleHBvcnRzLkFubm90YXRpb25UeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uU3RhdGVNb2RlbFR5cGUgPSBleHBvcnRzLkFubm90YXRpb25SZXZpZXdTdGF0ZSA9IGV4cG9ydHMuQW5ub3RhdGlvblJlcGx5VHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbk1hcmtlZFN0YXRlID0gZXhwb3J0cy5Bbm5vdGF0aW9uRmxhZyA9IGV4cG9ydHMuQW5ub3RhdGlvbkZpZWxkRmxhZyA9IGV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IGV4cG9ydHMuVU5TVVBQT1JURURfRkVBVFVSRVMgPSBleHBvcnRzLlZlcmJvc2l0eUxldmVsID0gZXhwb3J0cy5PUFMgPSBleHBvcnRzLklERU5USVRZX01BVFJJWCA9IGV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkJhc2VFeGNlcHRpb24gPSB2b2lkIDA7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oNik7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxudmFyIElERU5USVRZX01BVFJJWCA9IFsxLCAwLCAwLCAxLCAwLCAwXTtcbmV4cG9ydHMuSURFTlRJVFlfTUFUUklYID0gSURFTlRJVFlfTUFUUklYO1xudmFyIEZPTlRfSURFTlRJVFlfTUFUUklYID0gWzAuMDAxLCAwLCAwLCAwLjAwMSwgMCwgMF07XG5leHBvcnRzLkZPTlRfSURFTlRJVFlfTUFUUklYID0gRk9OVF9JREVOVElUWV9NQVRSSVg7XG52YXIgUGVybWlzc2lvbkZsYWcgPSB7XG4gIFBSSU5UOiAweDA0LFxuICBNT0RJRllfQ09OVEVOVFM6IDB4MDgsXG4gIENPUFk6IDB4MTAsXG4gIE1PRElGWV9BTk5PVEFUSU9OUzogMHgyMCxcbiAgRklMTF9JTlRFUkFDVElWRV9GT1JNUzogMHgxMDAsXG4gIENPUFlfRk9SX0FDQ0VTU0lCSUxJVFk6IDB4MjAwLFxuICBBU1NFTUJMRTogMHg0MDAsXG4gIFBSSU5UX0hJR0hfUVVBTElUWTogMHg4MDBcbn07XG5leHBvcnRzLlBlcm1pc3Npb25GbGFnID0gUGVybWlzc2lvbkZsYWc7XG52YXIgVGV4dFJlbmRlcmluZ01vZGUgPSB7XG4gIEZJTEw6IDAsXG4gIFNUUk9LRTogMSxcbiAgRklMTF9TVFJPS0U6IDIsXG4gIElOVklTSUJMRTogMyxcbiAgRklMTF9BRERfVE9fUEFUSDogNCxcbiAgU1RST0tFX0FERF9UT19QQVRIOiA1LFxuICBGSUxMX1NUUk9LRV9BRERfVE9fUEFUSDogNixcbiAgQUREX1RPX1BBVEg6IDcsXG4gIEZJTExfU1RST0tFX01BU0s6IDMsXG4gIEFERF9UT19QQVRIX0ZMQUc6IDRcbn07XG5leHBvcnRzLlRleHRSZW5kZXJpbmdNb2RlID0gVGV4dFJlbmRlcmluZ01vZGU7XG52YXIgSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuZXhwb3J0cy5JbWFnZUtpbmQgPSBJbWFnZUtpbmQ7XG52YXIgQW5ub3RhdGlvblR5cGUgPSB7XG4gIFRFWFQ6IDEsXG4gIExJTks6IDIsXG4gIEZSRUVURVhUOiAzLFxuICBMSU5FOiA0LFxuICBTUVVBUkU6IDUsXG4gIENJUkNMRTogNixcbiAgUE9MWUdPTjogNyxcbiAgUE9MWUxJTkU6IDgsXG4gIEhJR0hMSUdIVDogOSxcbiAgVU5ERVJMSU5FOiAxMCxcbiAgU1FVSUdHTFk6IDExLFxuICBTVFJJS0VPVVQ6IDEyLFxuICBTVEFNUDogMTMsXG4gIENBUkVUOiAxNCxcbiAgSU5LOiAxNSxcbiAgUE9QVVA6IDE2LFxuICBGSUxFQVRUQUNITUVOVDogMTcsXG4gIFNPVU5EOiAxOCxcbiAgTU9WSUU6IDE5LFxuICBXSURHRVQ6IDIwLFxuICBTQ1JFRU46IDIxLFxuICBQUklOVEVSTUFSSzogMjIsXG4gIFRSQVBORVQ6IDIzLFxuICBXQVRFUk1BUks6IDI0LFxuICBUSFJFRUQ6IDI1LFxuICBSRURBQ1Q6IDI2XG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uVHlwZSA9IEFubm90YXRpb25UeXBlO1xudmFyIEFubm90YXRpb25TdGF0ZU1vZGVsVHlwZSA9IHtcbiAgTUFSS0VEOiBcIk1hcmtlZFwiLFxuICBSRVZJRVc6IFwiUmV2aWV3XCJcbn07XG5leHBvcnRzLkFubm90YXRpb25TdGF0ZU1vZGVsVHlwZSA9IEFubm90YXRpb25TdGF0ZU1vZGVsVHlwZTtcbnZhciBBbm5vdGF0aW9uTWFya2VkU3RhdGUgPSB7XG4gIE1BUktFRDogXCJNYXJrZWRcIixcbiAgVU5NQVJLRUQ6IFwiVW5tYXJrZWRcIlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbk1hcmtlZFN0YXRlID0gQW5ub3RhdGlvbk1hcmtlZFN0YXRlO1xudmFyIEFubm90YXRpb25SZXZpZXdTdGF0ZSA9IHtcbiAgQUNDRVBURUQ6IFwiQWNjZXB0ZWRcIixcbiAgUkVKRUNURUQ6IFwiUmVqZWN0ZWRcIixcbiAgQ0FOQ0VMTEVEOiBcIkNhbmNlbGxlZFwiLFxuICBDT01QTEVURUQ6IFwiQ29tcGxldGVkXCIsXG4gIE5PTkU6IFwiTm9uZVwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uUmV2aWV3U3RhdGUgPSBBbm5vdGF0aW9uUmV2aWV3U3RhdGU7XG52YXIgQW5ub3RhdGlvblJlcGx5VHlwZSA9IHtcbiAgR1JPVVA6IFwiR3JvdXBcIixcbiAgUkVQTFk6IFwiUlwiXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uUmVwbHlUeXBlID0gQW5ub3RhdGlvblJlcGx5VHlwZTtcbnZhciBBbm5vdGF0aW9uRmxhZyA9IHtcbiAgSU5WSVNJQkxFOiAweDAxLFxuICBISURERU46IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBOT1pPT006IDB4MDgsXG4gIE5PUk9UQVRFOiAweDEwLFxuICBOT1ZJRVc6IDB4MjAsXG4gIFJFQURPTkxZOiAweDQwLFxuICBMT0NLRUQ6IDB4ODAsXG4gIFRPR0dMRU5PVklFVzogMHgxMDAsXG4gIExPQ0tFRENPTlRFTlRTOiAweDIwMFxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkZsYWcgPSBBbm5vdGF0aW9uRmxhZztcbnZhciBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5leHBvcnRzLkFubm90YXRpb25GaWVsZEZsYWcgPSBBbm5vdGF0aW9uRmllbGRGbGFnO1xudmFyIEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSB7XG4gIFNPTElEOiAxLFxuICBEQVNIRUQ6IDIsXG4gIEJFVkVMRUQ6IDMsXG4gIElOU0VUOiA0LFxuICBVTkRFUkxJTkU6IDVcbn07XG5leHBvcnRzLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUgPSBBbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlO1xudmFyIFN0cmVhbVR5cGUgPSB7XG4gIFVOS05PV046IFwiVU5LTk9XTlwiLFxuICBGTEFURTogXCJGTEFURVwiLFxuICBMWlc6IFwiTFpXXCIsXG4gIERDVDogXCJEQ1RcIixcbiAgSlBYOiBcIkpQWFwiLFxuICBKQklHOiBcIkpCSUdcIixcbiAgQTg1OiBcIkE4NVwiLFxuICBBSFg6IFwiQUhYXCIsXG4gIENDRjogXCJDQ0ZcIixcbiAgUkxYOiBcIlJMWFwiXG59O1xuZXhwb3J0cy5TdHJlYW1UeXBlID0gU3RyZWFtVHlwZTtcbnZhciBGb250VHlwZSA9IHtcbiAgVU5LTk9XTjogXCJVTktOT1dOXCIsXG4gIFRZUEUxOiBcIlRZUEUxXCIsXG4gIFRZUEUxQzogXCJUWVBFMUNcIixcbiAgQ0lERk9OVFRZUEUwOiBcIkNJREZPTlRUWVBFMFwiLFxuICBDSURGT05UVFlQRTBDOiBcIkNJREZPTlRUWVBFMENcIixcbiAgVFJVRVRZUEU6IFwiVFJVRVRZUEVcIixcbiAgQ0lERk9OVFRZUEUyOiBcIkNJREZPTlRUWVBFMlwiLFxuICBUWVBFMzogXCJUWVBFM1wiLFxuICBPUEVOVFlQRTogXCJPUEVOVFlQRVwiLFxuICBUWVBFMDogXCJUWVBFMFwiLFxuICBNTVRZUEUxOiBcIk1NVFlQRTFcIlxufTtcbmV4cG9ydHMuRm9udFR5cGUgPSBGb250VHlwZTtcbnZhciBWZXJib3NpdHlMZXZlbCA9IHtcbiAgRVJST1JTOiAwLFxuICBXQVJOSU5HUzogMSxcbiAgSU5GT1M6IDVcbn07XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gVmVyYm9zaXR5TGV2ZWw7XG52YXIgQ01hcENvbXByZXNzaW9uVHlwZSA9IHtcbiAgTk9ORTogMCxcbiAgQklOQVJZOiAxLFxuICBTVFJFQU06IDJcbn07XG5leHBvcnRzLkNNYXBDb21wcmVzc2lvblR5cGUgPSBDTWFwQ29tcHJlc3Npb25UeXBlO1xudmFyIE9QUyA9IHtcbiAgZGVwZW5kZW5jeTogMSxcbiAgc2V0TGluZVdpZHRoOiAyLFxuICBzZXRMaW5lQ2FwOiAzLFxuICBzZXRMaW5lSm9pbjogNCxcbiAgc2V0TWl0ZXJMaW1pdDogNSxcbiAgc2V0RGFzaDogNixcbiAgc2V0UmVuZGVyaW5nSW50ZW50OiA3LFxuICBzZXRGbGF0bmVzczogOCxcbiAgc2V0R1N0YXRlOiA5LFxuICBzYXZlOiAxMCxcbiAgcmVzdG9yZTogMTEsXG4gIHRyYW5zZm9ybTogMTIsXG4gIG1vdmVUbzogMTMsXG4gIGxpbmVUbzogMTQsXG4gIGN1cnZlVG86IDE1LFxuICBjdXJ2ZVRvMjogMTYsXG4gIGN1cnZlVG8zOiAxNyxcbiAgY2xvc2VQYXRoOiAxOCxcbiAgcmVjdGFuZ2xlOiAxOSxcbiAgc3Ryb2tlOiAyMCxcbiAgY2xvc2VTdHJva2U6IDIxLFxuICBmaWxsOiAyMixcbiAgZW9GaWxsOiAyMyxcbiAgZmlsbFN0cm9rZTogMjQsXG4gIGVvRmlsbFN0cm9rZTogMjUsXG4gIGNsb3NlRmlsbFN0cm9rZTogMjYsXG4gIGNsb3NlRU9GaWxsU3Ryb2tlOiAyNyxcbiAgZW5kUGF0aDogMjgsXG4gIGNsaXA6IDI5LFxuICBlb0NsaXA6IDMwLFxuICBiZWdpblRleHQ6IDMxLFxuICBlbmRUZXh0OiAzMixcbiAgc2V0Q2hhclNwYWNpbmc6IDMzLFxuICBzZXRXb3JkU3BhY2luZzogMzQsXG4gIHNldEhTY2FsZTogMzUsXG4gIHNldExlYWRpbmc6IDM2LFxuICBzZXRGb250OiAzNyxcbiAgc2V0VGV4dFJlbmRlcmluZ01vZGU6IDM4LFxuICBzZXRUZXh0UmlzZTogMzksXG4gIG1vdmVUZXh0OiA0MCxcbiAgc2V0TGVhZGluZ01vdmVUZXh0OiA0MSxcbiAgc2V0VGV4dE1hdHJpeDogNDIsXG4gIG5leHRMaW5lOiA0MyxcbiAgc2hvd1RleHQ6IDQ0LFxuICBzaG93U3BhY2VkVGV4dDogNDUsXG4gIG5leHRMaW5lU2hvd1RleHQ6IDQ2LFxuICBuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDogNDcsXG4gIHNldENoYXJXaWR0aDogNDgsXG4gIHNldENoYXJXaWR0aEFuZEJvdW5kczogNDksXG4gIHNldFN0cm9rZUNvbG9yU3BhY2U6IDUwLFxuICBzZXRGaWxsQ29sb3JTcGFjZTogNTEsXG4gIHNldFN0cm9rZUNvbG9yOiA1MixcbiAgc2V0U3Ryb2tlQ29sb3JOOiA1MyxcbiAgc2V0RmlsbENvbG9yOiA1NCxcbiAgc2V0RmlsbENvbG9yTjogNTUsXG4gIHNldFN0cm9rZUdyYXk6IDU2LFxuICBzZXRGaWxsR3JheTogNTcsXG4gIHNldFN0cm9rZVJHQkNvbG9yOiA1OCxcbiAgc2V0RmlsbFJHQkNvbG9yOiA1OSxcbiAgc2V0U3Ryb2tlQ01ZS0NvbG9yOiA2MCxcbiAgc2V0RmlsbENNWUtDb2xvcjogNjEsXG4gIHNoYWRpbmdGaWxsOiA2MixcbiAgYmVnaW5JbmxpbmVJbWFnZTogNjMsXG4gIGJlZ2luSW1hZ2VEYXRhOiA2NCxcbiAgZW5kSW5saW5lSW1hZ2U6IDY1LFxuICBwYWludFhPYmplY3Q6IDY2LFxuICBtYXJrUG9pbnQ6IDY3LFxuICBtYXJrUG9pbnRQcm9wczogNjgsXG4gIGJlZ2luTWFya2VkQ29udGVudDogNjksXG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiA3MCxcbiAgZW5kTWFya2VkQ29udGVudDogNzEsXG4gIGJlZ2luQ29tcGF0OiA3MixcbiAgZW5kQ29tcGF0OiA3MyxcbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luOiA3NCxcbiAgcGFpbnRGb3JtWE9iamVjdEVuZDogNzUsXG4gIGJlZ2luR3JvdXA6IDc2LFxuICBlbmRHcm91cDogNzcsXG4gIGJlZ2luQW5ub3RhdGlvbnM6IDc4LFxuICBlbmRBbm5vdGF0aW9uczogNzksXG4gIGJlZ2luQW5ub3RhdGlvbjogODAsXG4gIGVuZEFubm90YXRpb246IDgxLFxuICBwYWludEpwZWdYT2JqZWN0OiA4MixcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiA4MyxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IDg0LFxuICBwYWludEltYWdlWE9iamVjdDogODUsXG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0OiA4NixcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3RHcm91cDogODcsXG4gIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiA4OCxcbiAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiA4OSxcbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOiA5MCxcbiAgY29uc3RydWN0UGF0aDogOTFcbn07XG5leHBvcnRzLk9QUyA9IE9QUztcbnZhciBVTlNVUFBPUlRFRF9GRUFUVVJFUyA9IHtcbiAgdW5rbm93bjogXCJ1bmtub3duXCIsXG4gIGZvcm1zOiBcImZvcm1zXCIsXG4gIGphdmFTY3JpcHQ6IFwiamF2YVNjcmlwdFwiLFxuICBzbWFzazogXCJzbWFza1wiLFxuICBzaGFkaW5nUGF0dGVybjogXCJzaGFkaW5nUGF0dGVyblwiLFxuICBmb250OiBcImZvbnRcIixcbiAgZXJyb3JUaWxpbmdQYXR0ZXJuOiBcImVycm9yVGlsaW5nUGF0dGVyblwiLFxuICBlcnJvckV4dEdTdGF0ZTogXCJlcnJvckV4dEdTdGF0ZVwiLFxuICBlcnJvclhPYmplY3Q6IFwiZXJyb3JYT2JqZWN0XCIsXG4gIGVycm9yRm9udExvYWRUeXBlMzogXCJlcnJvckZvbnRMb2FkVHlwZTNcIixcbiAgZXJyb3JGb250U3RhdGU6IFwiZXJyb3JGb250U3RhdGVcIixcbiAgZXJyb3JGb250TWlzc2luZzogXCJlcnJvckZvbnRNaXNzaW5nXCIsXG4gIGVycm9yRm9udFRyYW5zbGF0ZTogXCJlcnJvckZvbnRUcmFuc2xhdGVcIixcbiAgZXJyb3JDb2xvclNwYWNlOiBcImVycm9yQ29sb3JTcGFjZVwiLFxuICBlcnJvck9wZXJhdG9yTGlzdDogXCJlcnJvck9wZXJhdG9yTGlzdFwiLFxuICBlcnJvckZvbnRUb1VuaWNvZGU6IFwiZXJyb3JGb250VG9Vbmljb2RlXCIsXG4gIGVycm9yRm9udExvYWROYXRpdmU6IFwiZXJyb3JGb250TG9hZE5hdGl2ZVwiLFxuICBlcnJvckZvbnRHZXRQYXRoOiBcImVycm9yRm9udEdldFBhdGhcIixcbiAgZXJyb3JNYXJrZWRDb250ZW50OiBcImVycm9yTWFya2VkQ29udGVudFwiXG59O1xuZXhwb3J0cy5VTlNVUFBPUlRFRF9GRUFUVVJFUyA9IFVOU1VQUE9SVEVEX0ZFQVRVUkVTO1xudmFyIFBhc3N3b3JkUmVzcG9uc2VzID0ge1xuICBORUVEX1BBU1NXT1JEOiAxLFxuICBJTkNPUlJFQ1RfUEFTU1dPUkQ6IDJcbn07XG5leHBvcnRzLlBhc3N3b3JkUmVzcG9uc2VzID0gUGFzc3dvcmRSZXNwb25zZXM7XG52YXIgdmVyYm9zaXR5ID0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1M7XG5cbmZ1bmN0aW9uIHNldFZlcmJvc2l0eUxldmVsKGxldmVsKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGxldmVsKSkge1xuICAgIHZlcmJvc2l0eSA9IGxldmVsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFZlcmJvc2l0eUxldmVsKCkge1xuICByZXR1cm4gdmVyYm9zaXR5O1xufVxuXG5mdW5jdGlvbiBpbmZvKG1zZykge1xuICBpZiAodmVyYm9zaXR5ID49IFZlcmJvc2l0eUxldmVsLklORk9TKSB7XG4gICAgY29uc29sZS5sb2coXCJJbmZvOiBcIi5jb25jYXQobXNnKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybihtc2cpIHtcbiAgaWYgKHZlcmJvc2l0eSA+PSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUykge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogXCIuY29uY2F0KG1zZykpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIG1zZykge1xuICBpZiAoIWNvbmQpIHtcbiAgICB1bnJlYWNoYWJsZShtc2cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZU9yaWdpbihiYXNlVXJsLCBvdGhlclVybCkge1xuICB2YXIgYmFzZTtcblxuICB0cnkge1xuICAgIGJhc2UgPSBuZXcgVVJMKGJhc2VVcmwpO1xuXG4gICAgaWYgKCFiYXNlLm9yaWdpbiB8fCBiYXNlLm9yaWdpbiA9PT0gXCJudWxsXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgb3RoZXIgPSBuZXcgVVJMKG90aGVyVXJsLCBiYXNlKTtcbiAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG59XG5cbmZ1bmN0aW9uIF9pc1ZhbGlkUHJvdG9jb2wodXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3dpdGNoICh1cmwucHJvdG9jb2wpIHtcbiAgICBjYXNlIFwiaHR0cDpcIjpcbiAgICBjYXNlIFwiaHR0cHM6XCI6XG4gICAgY2FzZSBcImZ0cDpcIjpcbiAgICBjYXNlIFwibWFpbHRvOlwiOlxuICAgIGNhc2UgXCJ0ZWw6XCI6XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwsIGJhc2VVcmwpIHtcbiAgaWYgKCF1cmwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmFyIGFic29sdXRlVXJsID0gYmFzZVVybCA/IG5ldyBVUkwodXJsLCBiYXNlVXJsKSA6IG5ldyBVUkwodXJsKTtcblxuICAgIGlmIChfaXNWYWxpZFByb3RvY29sKGFic29sdXRlVXJsKSkge1xuICAgICAgcmV0dXJuIGFic29sdXRlVXJsO1xuICAgIH1cbiAgfSBjYXRjaCAoZXgpIHt9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5cbnZhciBCYXNlRXhjZXB0aW9uID0gZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEJhc2VFeGNlcHRpb24obWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRXhjZXB0aW9uKSB7XG4gICAgICB1bnJlYWNoYWJsZShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VFeGNlcHRpb24uXCIpO1xuICAgIH1cblxuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuXG5leHBvcnRzLkJhc2VFeGNlcHRpb24gPSBCYXNlRXhjZXB0aW9uO1xuXG52YXIgUGFzc3dvcmRFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlRXhjZXB0aW9uKSB7XG4gIF9pbmhlcml0cyhQYXNzd29yZEV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb24pO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUGFzc3dvcmRFeGNlcHRpb24pO1xuXG4gIGZ1bmN0aW9uIFBhc3N3b3JkRXhjZXB0aW9uKG1zZywgY29kZSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXNzd29yZEV4Y2VwdGlvbik7XG5cbiAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1zZyk7XG4gICAgX3RoaXMuY29kZSA9IGNvZGU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIFBhc3N3b3JkRXhjZXB0aW9uO1xufShCYXNlRXhjZXB0aW9uKTtcblxuZXhwb3J0cy5QYXNzd29yZEV4Y2VwdGlvbiA9IFBhc3N3b3JkRXhjZXB0aW9uO1xuXG52YXIgVW5rbm93bkVycm9yRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjIpIHtcbiAgX2luaGVyaXRzKFVua25vd25FcnJvckV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb24yKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihVbmtub3duRXJyb3JFeGNlcHRpb24pO1xuXG4gIGZ1bmN0aW9uIFVua25vd25FcnJvckV4Y2VwdGlvbihtc2csIGRldGFpbHMpIHtcbiAgICB2YXIgX3RoaXMyO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFVua25vd25FcnJvckV4Y2VwdGlvbik7XG5cbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcywgbXNnKTtcbiAgICBfdGhpczIuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgcmV0dXJuIF90aGlzMjtcbiAgfVxuXG4gIHJldHVybiBVbmtub3duRXJyb3JFeGNlcHRpb247XG59KEJhc2VFeGNlcHRpb24pO1xuXG5leHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcblxudmFyIEludmFsaWRQREZFeGNlcHRpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlRXhjZXB0aW9uMykge1xuICBfaW5oZXJpdHMoSW52YWxpZFBERkV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb24zKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihJbnZhbGlkUERGRXhjZXB0aW9uKTtcblxuICBmdW5jdGlvbiBJbnZhbGlkUERGRXhjZXB0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnZhbGlkUERGRXhjZXB0aW9uKTtcblxuICAgIHJldHVybiBfc3VwZXIzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gSW52YWxpZFBERkV4Y2VwdGlvbjtcbn0oQmFzZUV4Y2VwdGlvbik7XG5cbmV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IEludmFsaWRQREZFeGNlcHRpb247XG5cbnZhciBNaXNzaW5nUERGRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjQpIHtcbiAgX2luaGVyaXRzKE1pc3NpbmdQREZFeGNlcHRpb24sIF9CYXNlRXhjZXB0aW9uNCk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoTWlzc2luZ1BERkV4Y2VwdGlvbik7XG5cbiAgZnVuY3Rpb24gTWlzc2luZ1BERkV4Y2VwdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWlzc2luZ1BERkV4Y2VwdGlvbik7XG5cbiAgICByZXR1cm4gX3N1cGVyNC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIE1pc3NpbmdQREZFeGNlcHRpb247XG59KEJhc2VFeGNlcHRpb24pO1xuXG5leHBvcnRzLk1pc3NpbmdQREZFeGNlcHRpb24gPSBNaXNzaW5nUERGRXhjZXB0aW9uO1xuXG52YXIgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjUpIHtcbiAgX2luaGVyaXRzKFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiwgX0Jhc2VFeGNlcHRpb241KTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24pO1xuXG4gIGZ1bmN0aW9uIFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbihtc2csIHN0YXR1cykge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKTtcblxuICAgIF90aGlzMyA9IF9zdXBlcjUuY2FsbCh0aGlzLCBtc2cpO1xuICAgIF90aGlzMy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIHJldHVybiBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG59KEJhc2VFeGNlcHRpb24pO1xuXG5leHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IFVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcblxudmFyIEZvcm1hdEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjYpIHtcbiAgX2luaGVyaXRzKEZvcm1hdEVycm9yLCBfQmFzZUV4Y2VwdGlvbjYpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKEZvcm1hdEVycm9yKTtcblxuICBmdW5jdGlvbiBGb3JtYXRFcnJvcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRm9ybWF0RXJyb3IpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBGb3JtYXRFcnJvcjtcbn0oQmFzZUV4Y2VwdGlvbik7XG5cbmV4cG9ydHMuRm9ybWF0RXJyb3IgPSBGb3JtYXRFcnJvcjtcblxudmFyIEFib3J0RXhjZXB0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUV4Y2VwdGlvbjcpIHtcbiAgX2luaGVyaXRzKEFib3J0RXhjZXB0aW9uLCBfQmFzZUV4Y2VwdGlvbjcpO1xuXG4gIHZhciBfc3VwZXI3ID0gX2NyZWF0ZVN1cGVyKEFib3J0RXhjZXB0aW9uKTtcblxuICBmdW5jdGlvbiBBYm9ydEV4Y2VwdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJvcnRFeGNlcHRpb24pO1xuXG4gICAgcmV0dXJuIF9zdXBlcjcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBBYm9ydEV4Y2VwdGlvbjtcbn0oQmFzZUV4Y2VwdGlvbik7XG5cbmV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSBBYm9ydEV4Y2VwdGlvbjtcbnZhciBOdWxsQ2hhcmFjdGVyc1JlZ0V4cCA9IC9cXHgwMC9nO1xuXG5mdW5jdGlvbiByZW1vdmVOdWxsQ2hhcmFjdGVycyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB3YXJuKFwiVGhlIGFyZ3VtZW50IGZvciByZW1vdmVOdWxsQ2hhcmFjdGVycyBtdXN0IGJlIGEgc3RyaW5nLlwiKTtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5yZXBsYWNlKE51bGxDaGFyYWN0ZXJzUmVnRXhwLCBcIlwiKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBhc3NlcnQoYnl0ZXMgIT09IG51bGwgJiYgX3R5cGVvZihieXRlcykgPT09IFwib2JqZWN0XCIgJiYgYnl0ZXMubGVuZ3RoICE9PSB1bmRlZmluZWQsIFwiSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZ1wiKTtcbiAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgdmFyIE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG5cbiAgaWYgKGxlbmd0aCA8IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJ5dGVzKTtcbiAgfVxuXG4gIHZhciBzdHJCdWYgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICB2YXIgY2h1bmtFbmQgPSBNYXRoLm1pbihpICsgTUFYX0FSR1VNRU5UX0NPVU5ULCBsZW5ndGgpO1xuICAgIHZhciBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cblxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIGFzc2VydCh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiLCBcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIHZhciBsZW5ndGggPSBzdHIubGVuZ3RoO1xuICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBieXRlc1tpXSA9IHN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZjtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZnVuY3Rpb24gYXJyYXlCeXRlTGVuZ3RoKGFycikge1xuICBpZiAoYXJyLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGFyci5sZW5ndGg7XG4gIH1cblxuICBhc3NlcnQoYXJyLmJ5dGVMZW5ndGggIT09IHVuZGVmaW5lZCwgXCJhcnJheUJ5dGVMZW5ndGggLSBpbnZhbGlkIGFyZ3VtZW50LlwiKTtcbiAgcmV0dXJuIGFyci5ieXRlTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBhcnJheXNUb0J5dGVzKGFycikge1xuICB2YXIgbGVuZ3RoID0gYXJyLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoID09PSAxICYmIGFyclswXSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICByZXR1cm4gYXJyWzBdO1xuICB9XG5cbiAgdmFyIHJlc3VsdExlbmd0aCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdExlbmd0aCArPSBhcnJheUJ5dGVMZW5ndGgoYXJyW2ldKTtcbiAgfVxuXG4gIHZhciBwb3MgPSAwO1xuICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlc3VsdExlbmd0aCk7XG5cbiAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGxlbmd0aDsgX2krKykge1xuICAgIHZhciBpdGVtID0gYXJyW19pXTtcblxuICAgIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGl0ZW0gPSBzdHJpbmdUb0J5dGVzKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbSA9IG5ldyBVaW50OEFycmF5KGl0ZW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpdGVtTGVuZ3RoID0gaXRlbS5ieXRlTGVuZ3RoO1xuICAgIGRhdGEuc2V0KGl0ZW0sIHBvcyk7XG4gICAgcG9zICs9IGl0ZW1MZW5ndGg7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgPj4gMjQgJiAweGZmLCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuXG5mdW5jdGlvbiBpc0xpdHRsZUVuZGlhbigpIHtcbiAgdmFyIGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSg0KTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIHZhciB2aWV3MzIgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyOC5idWZmZXIsIDAsIDEpO1xuICByZXR1cm4gdmlldzMyWzBdID09PSAxO1xufVxuXG52YXIgSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwidmFsdWVcIiwgaXNMaXR0bGVFbmRpYW4oKSk7XG4gIH1cblxufTtcbmV4cG9ydHMuSXNMaXR0bGVFbmRpYW5DYWNoZWQgPSBJc0xpdHRsZUVuZGlhbkNhY2hlZDtcblxuZnVuY3Rpb24gaXNFdmFsU3VwcG9ydGVkKCkge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbihcIlwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG52YXIgSXNFdmFsU3VwcG9ydGVkQ2FjaGVkID0ge1xuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInZhbHVlXCIsIGlzRXZhbFN1cHBvcnRlZCgpKTtcbiAgfVxuXG59O1xuZXhwb3J0cy5Jc0V2YWxTdXBwb3J0ZWRDYWNoZWQgPSBJc0V2YWxTdXBwb3J0ZWRDYWNoZWQ7XG52YXIgcmdiQnVmID0gW1wicmdiKFwiLCAwLCBcIixcIiwgMCwgXCIsXCIsIDAsIFwiKVwiXTtcblxudmFyIFV0aWwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBVdGlsKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBVdGlsKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhVdGlsLCBudWxsLCBbe1xuICAgIGtleTogXCJtYWtlQ3NzUmdiXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1ha2VDc3NSZ2IociwgZywgYikge1xuICAgICAgcmdiQnVmWzFdID0gcjtcbiAgICAgIHJnYkJ1ZlszXSA9IGc7XG4gICAgICByZ2JCdWZbNV0gPSBiO1xuICAgICAgcmV0dXJuIHJnYkJ1Zi5qb2luKFwiXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNmb3JtKG0xLCBtMikge1xuICAgICAgcmV0dXJuIFttMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXSwgbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV0sIG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdLCBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXSwgbTFbMF0gKiBtMls0XSArIG0xWzJdICogbTJbNV0gKyBtMVs0XSwgbTFbMV0gKiBtMls0XSArIG0xWzNdICogbTJbNV0gKyBtMVs1XV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5VHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5VHJhbnNmb3JtKHAsIG0pIHtcbiAgICAgIHZhciB4dCA9IHBbMF0gKiBtWzBdICsgcFsxXSAqIG1bMl0gKyBtWzRdO1xuICAgICAgdmFyIHl0ID0gcFswXSAqIG1bMV0gKyBwWzFdICogbVszXSArIG1bNV07XG4gICAgICByZXR1cm4gW3h0LCB5dF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFwcGx5SW52ZXJzZVRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUludmVyc2VUcmFuc2Zvcm0ocCwgbSkge1xuICAgICAgdmFyIGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgICAgdmFyIHh0ID0gKHBbMF0gKiBtWzNdIC0gcFsxXSAqIG1bMl0gKyBtWzJdICogbVs1XSAtIG1bNF0gKiBtWzNdKSAvIGQ7XG4gICAgICB2YXIgeXQgPSAoLXBbMF0gKiBtWzFdICsgcFsxXSAqIG1bMF0gKyBtWzRdICogbVsxXSAtIG1bNV0gKiBtWzBdKSAvIGQ7XG4gICAgICByZXR1cm4gW3h0LCB5dF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHIsIG0pIHtcbiAgICAgIHZhciBwMSA9IFV0aWwuYXBwbHlUcmFuc2Zvcm0ociwgbSk7XG4gICAgICB2YXIgcDIgPSBVdGlsLmFwcGx5VHJhbnNmb3JtKHIuc2xpY2UoMiwgNCksIG0pO1xuICAgICAgdmFyIHAzID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclswXSwgclszXV0sIG0pO1xuICAgICAgdmFyIHA0ID0gVXRpbC5hcHBseVRyYW5zZm9ybShbclsyXSwgclsxXV0sIG0pO1xuICAgICAgcmV0dXJuIFtNYXRoLm1pbihwMVswXSwgcDJbMF0sIHAzWzBdLCBwNFswXSksIE1hdGgubWluKHAxWzFdLCBwMlsxXSwgcDNbMV0sIHA0WzFdKSwgTWF0aC5tYXgocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1heChwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnZlcnNlVHJhbnNmb3JtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludmVyc2VUcmFuc2Zvcm0obSkge1xuICAgICAgdmFyIGQgPSBtWzBdICogbVszXSAtIG1bMV0gKiBtWzJdO1xuICAgICAgcmV0dXJuIFttWzNdIC8gZCwgLW1bMV0gLyBkLCAtbVsyXSAvIGQsIG1bMF0gLyBkLCAobVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkLCAobVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYXBwbHkzZFRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseTNkVHJhbnNmb3JtKG0sIHYpIHtcbiAgICAgIHJldHVybiBbbVswXSAqIHZbMF0gKyBtWzFdICogdlsxXSArIG1bMl0gKiB2WzJdLCBtWzNdICogdlswXSArIG1bNF0gKiB2WzFdICsgbVs1XSAqIHZbMl0sIG1bNl0gKiB2WzBdICsgbVs3XSAqIHZbMV0gKyBtWzhdICogdlsyXV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG0pIHtcbiAgICAgIHZhciB0cmFuc3Bvc2UgPSBbbVswXSwgbVsyXSwgbVsxXSwgbVszXV07XG4gICAgICB2YXIgYSA9IG1bMF0gKiB0cmFuc3Bvc2VbMF0gKyBtWzFdICogdHJhbnNwb3NlWzJdO1xuICAgICAgdmFyIGIgPSBtWzBdICogdHJhbnNwb3NlWzFdICsgbVsxXSAqIHRyYW5zcG9zZVszXTtcbiAgICAgIHZhciBjID0gbVsyXSAqIHRyYW5zcG9zZVswXSArIG1bM10gKiB0cmFuc3Bvc2VbMl07XG4gICAgICB2YXIgZCA9IG1bMl0gKiB0cmFuc3Bvc2VbMV0gKyBtWzNdICogdHJhbnNwb3NlWzNdO1xuICAgICAgdmFyIGZpcnN0ID0gKGEgKyBkKSAvIDI7XG4gICAgICB2YXIgc2Vjb25kID0gTWF0aC5zcXJ0KChhICsgZCkgKiAoYSArIGQpIC0gNCAqIChhICogZCAtIGMgKiBiKSkgLyAyO1xuICAgICAgdmFyIHN4ID0gZmlyc3QgKyBzZWNvbmQgfHwgMTtcbiAgICAgIHZhciBzeSA9IGZpcnN0IC0gc2Vjb25kIHx8IDE7XG4gICAgICByZXR1cm4gW01hdGguc3FydChzeCksIE1hdGguc3FydChzeSldO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3JtYWxpemVSZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vcm1hbGl6ZVJlY3QocmVjdCkge1xuICAgICAgdmFyIHIgPSByZWN0LnNsaWNlKDApO1xuXG4gICAgICBpZiAocmVjdFswXSA+IHJlY3RbMl0pIHtcbiAgICAgICAgclswXSA9IHJlY3RbMl07XG4gICAgICAgIHJbMl0gPSByZWN0WzBdO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjdFsxXSA+IHJlY3RbM10pIHtcbiAgICAgICAgclsxXSA9IHJlY3RbM107XG4gICAgICAgIHJbM10gPSByZWN0WzFdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW50ZXJzZWN0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGludGVyc2VjdChyZWN0MSwgcmVjdDIpIHtcbiAgICAgIGZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcmRlcmVkWCA9IFtyZWN0MVswXSwgcmVjdDFbMl0sIHJlY3QyWzBdLCByZWN0MlsyXV0uc29ydChjb21wYXJlKTtcbiAgICAgIHZhciBvcmRlcmVkWSA9IFtyZWN0MVsxXSwgcmVjdDFbM10sIHJlY3QyWzFdLCByZWN0MlszXV0uc29ydChjb21wYXJlKTtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIHJlY3QxID0gVXRpbC5ub3JtYWxpemVSZWN0KHJlY3QxKTtcbiAgICAgIHJlY3QyID0gVXRpbC5ub3JtYWxpemVSZWN0KHJlY3QyKTtcblxuICAgICAgaWYgKG9yZGVyZWRYWzBdID09PSByZWN0MVswXSAmJiBvcmRlcmVkWFsxXSA9PT0gcmVjdDJbMF0gfHwgb3JkZXJlZFhbMF0gPT09IHJlY3QyWzBdICYmIG9yZGVyZWRYWzFdID09PSByZWN0MVswXSkge1xuICAgICAgICByZXN1bHRbMF0gPSBvcmRlcmVkWFsxXTtcbiAgICAgICAgcmVzdWx0WzJdID0gb3JkZXJlZFhbMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKG9yZGVyZWRZWzBdID09PSByZWN0MVsxXSAmJiBvcmRlcmVkWVsxXSA9PT0gcmVjdDJbMV0gfHwgb3JkZXJlZFlbMF0gPT09IHJlY3QyWzFdICYmIG9yZGVyZWRZWzFdID09PSByZWN0MVsxXSkge1xuICAgICAgICByZXN1bHRbMV0gPSBvcmRlcmVkWVsxXTtcbiAgICAgICAgcmVzdWx0WzNdID0gb3JkZXJlZFlbMl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVXRpbDtcbn0oKTtcblxuZXhwb3J0cy5VdGlsID0gVXRpbDtcbnZhciBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDJEOCwgMHgyQzcsIDB4MkM2LCAweDJEOSwgMHgyREQsIDB4MkRCLCAweDJEQSwgMHgyREMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LCAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNBLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFFLCAweDIwMUMsIDB4MjAxRCwgMHgyMDE4LCAweDIwMTksIDB4MjAxQSwgMHgyMTIyLCAweEZCMDEsIDB4RkIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCwgMHgxNzgsIDB4MTdELCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN0UsIDAsIDB4MjBBQ107XG5cbmZ1bmN0aW9uIHN0cmluZ1RvUERGU3RyaW5nKHN0cikge1xuICB2YXIgbGVuZ3RoID0gc3RyLmxlbmd0aCxcbiAgICAgIHN0ckJ1ZiA9IFtdO1xuXG4gIGlmIChzdHJbMF0gPT09IFwiXFx4RkVcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkZcIikge1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoc3RyLmNoYXJDb2RlQXQoaSkgPDwgOCB8IHN0ci5jaGFyQ29kZUF0KGkgKyAxKSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdHJbMF0gPT09IFwiXFx4RkZcIiAmJiBzdHJbMV0gPT09IFwiXFx4RkVcIikge1xuICAgIGZvciAodmFyIF9pMiA9IDI7IF9pMiA8IGxlbmd0aDsgX2kyICs9IDIpIHtcbiAgICAgIHN0ckJ1Zi5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoc3RyLmNoYXJDb2RlQXQoX2kyICsgMSkgPDwgOCB8IHN0ci5jaGFyQ29kZUF0KF9pMikpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbGVuZ3RoOyArK19pMykge1xuICAgICAgdmFyIGNvZGUgPSBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZVtzdHIuY2hhckNvZGVBdChfaTMpXTtcbiAgICAgIHN0ckJ1Zi5wdXNoKGNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIDogc3RyLmNoYXJBdChfaTMpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyQnVmLmpvaW4oXCJcIik7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW1xcKFxcKVxcXFxdKS9nLCBcIlxcXFwkMVwiKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn1cblxuZnVuY3Rpb24gdXRmOFN0cmluZ1RvU3RyaW5nKHN0cikge1xuICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpO1xufVxuXG5mdW5jdGlvbiBpc0Jvb2wodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiO1xufVxuXG5mdW5jdGlvbiBpc051bSh2KSB7XG4gIHJldHVybiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIjtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodikge1xuICByZXR1cm4gX3R5cGVvZih2KSA9PT0gXCJvYmplY3RcIiAmJiB2ICE9PSBudWxsICYmIHYuYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5RXF1YWwoYXJyMSwgYXJyMikge1xuICBpZiAoYXJyMS5sZW5ndGggIT09IGFycjIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGFycjEuZXZlcnkoZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPT09IGFycjJbaW5kZXhdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TW9kaWZpY2F0aW9uRGF0ZSgpIHtcbiAgdmFyIGRhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG5ldyBEYXRlKERhdGUubm93KCkpO1xuICB2YXIgYnVmZmVyID0gW2RhdGUuZ2V0VVRDRnVsbFllYXIoKS50b1N0cmluZygpLCAoZGF0ZS5nZXRVVENNb250aCgpICsgMSkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIChkYXRlLmdldFVUQ0RhdGUoKSArIDEpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ0hvdXJzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDTWludXRlcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpLCBkYXRlLmdldFVUQ1NlY29uZHMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKV07XG4gIHJldHVybiBidWZmZXIuam9pbihcIlwiKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkoKSB7XG4gIHZhciBjYXBhYmlsaXR5ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGlzU2V0dGxlZCA9IGZhbHNlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2FwYWJpbGl0eSwgXCJzZXR0bGVkXCIsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBpc1NldHRsZWQ7XG4gICAgfVxuICB9KTtcbiAgY2FwYWJpbGl0eS5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGNhcGFiaWxpdHkucmVzb2x2ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpc1NldHRsZWQgPSB0cnVlO1xuICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICB9O1xuXG4gICAgY2FwYWJpbGl0eS5yZWplY3QgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBpc1NldHRsZWQgPSB0cnVlO1xuICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgfTtcbiAgfSk7XG4gIHJldHVybiBjYXBhYmlsaXR5O1xufVxuXG52YXIgY3JlYXRlT2JqZWN0VVJMID0gZnVuY3Rpb24gY3JlYXRlT2JqZWN0VVJMQ2xvc3VyZSgpIHtcbiAgdmFyIGRpZ2l0cyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdFVSTChkYXRhLCBjb250ZW50VHlwZSkge1xuICAgIHZhciBmb3JjZURhdGFTY2hlbWEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgaWYgKCFmb3JjZURhdGFTY2hlbWEgJiYgVVJMLmNyZWF0ZU9iamVjdFVSTCkge1xuICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbZGF0YV0sIHtcbiAgICAgICAgdHlwZTogY29udGVudFR5cGVcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlciA9IFwiZGF0YTpcIi5jb25jYXQoY29udGVudFR5cGUsIFwiO2Jhc2U2NCxcIik7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBkYXRhLmxlbmd0aDsgaSA8IGlpOyBpICs9IDMpIHtcbiAgICAgIHZhciBiMSA9IGRhdGFbaV0gJiAweGZmO1xuICAgICAgdmFyIGIyID0gZGF0YVtpICsgMV0gJiAweGZmO1xuICAgICAgdmFyIGIzID0gZGF0YVtpICsgMl0gJiAweGZmO1xuICAgICAgdmFyIGQxID0gYjEgPj4gMixcbiAgICAgICAgICBkMiA9IChiMSAmIDMpIDw8IDQgfCBiMiA+PiA0O1xuICAgICAgdmFyIGQzID0gaSArIDEgPCBpaSA/IChiMiAmIDB4ZikgPDwgMiB8IGIzID4+IDYgOiA2NDtcbiAgICAgIHZhciBkNCA9IGkgKyAyIDwgaWkgPyBiMyAmIDB4M2YgOiA2NDtcbiAgICAgIGJ1ZmZlciArPSBkaWdpdHNbZDFdICsgZGlnaXRzW2QyXSArIGRpZ2l0c1tkM10gKyBkaWdpdHNbZDRdO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG59KCk7XG5cbmV4cG9ydHMuY3JlYXRlT2JqZWN0VVJMID0gY3JlYXRlT2JqZWN0VVJMO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9pc19ub2RlID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5pZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwidW5kZWZpbmVkXCIgfHwgIWdsb2JhbFRoaXMuX3BkZmpzQ29tcGF0aWJpbGl0eUNoZWNrZWQpIHtcbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcInVuZGVmaW5lZFwiIHx8IGdsb2JhbFRoaXMuTWF0aCAhPT0gTWF0aCkge1xuICAgIGdsb2JhbFRoaXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuICB9XG5cbiAgZ2xvYmFsVGhpcy5fcGRmanNDb21wYXRpYmlsaXR5Q2hlY2tlZCA9IHRydWU7XG4gIHZhciBoYXNET00gPSAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKHdpbmRvdykpID09PSBcIm9iamVjdFwiICYmICh0eXBlb2YgZG9jdW1lbnQgPT09IFwidW5kZWZpbmVkXCIgPyBcInVuZGVmaW5lZFwiIDogX3R5cGVvZihkb2N1bWVudCkpID09PSBcIm9iamVjdFwiO1xuICB2YXIgdXNlckFnZW50ID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG4gIHZhciBpc0lFID0gL1RyaWRlbnQvLnRlc3QodXNlckFnZW50KTtcblxuICAoZnVuY3Rpb24gY2hlY2tOb2RlQnRvYSgpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5idG9hIHx8ICFfaXNfbm9kZS5pc05vZGVKUykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsb2JhbFRoaXMuYnRvYSA9IGZ1bmN0aW9uIChjaGFycykge1xuICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNoYXJzLCBcImJpbmFyeVwiKS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja05vZGVBdG9iKCkge1xuICAgIGlmIChnbG9iYWxUaGlzLmF0b2IgfHwgIV9pc19ub2RlLmlzTm9kZUpTKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5hdG9iID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oaW5wdXQsIFwiYmFzZTY0XCIpLnRvU3RyaW5nKFwiYmluYXJ5XCIpO1xuICAgIH07XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrQ2hpbGROb2RlUmVtb3ZlKCkge1xuICAgIGlmICghaGFzRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBFbGVtZW50LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAodGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja0RPTVRva2VuTGlzdEFkZFJlbW92ZSgpIHtcbiAgICBpZiAoIWhhc0RPTSB8fCBfaXNfbm9kZS5pc05vZGVKUykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5jbGFzc0xpc3QuYWRkKFwidGVzdE9uZVwiLCBcInRlc3RUd29cIik7XG5cbiAgICBpZiAoZGl2LmNsYXNzTGlzdC5jb250YWlucyhcInRlc3RPbmVcIikgPT09IHRydWUgJiYgZGl2LmNsYXNzTGlzdC5jb250YWlucyhcInRlc3RUd29cIikgPT09IHRydWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgT3JpZ2luYWxET01Ub2tlbkxpc3RBZGQgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLmFkZDtcbiAgICB2YXIgT3JpZ2luYWxET01Ub2tlbkxpc3RSZW1vdmUgPSBET01Ub2tlbkxpc3QucHJvdG90eXBlLnJlbW92ZTtcblxuICAgIERPTVRva2VuTGlzdC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHRva2VucyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgdG9rZW5zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF90b2tlbnMgPSB0b2tlbnM7IF9pIDwgX3Rva2Vucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gX3Rva2Vuc1tfaV07XG4gICAgICAgIE9yaWdpbmFsRE9NVG9rZW5MaXN0QWRkLmNhbGwodGhpcywgdG9rZW4pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgdG9rZW5zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIHRva2Vuc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwLCBfdG9rZW5zMiA9IHRva2VuczsgX2kyIDwgX3Rva2VuczIubGVuZ3RoOyBfaTIrKykge1xuICAgICAgICB2YXIgdG9rZW4gPSBfdG9rZW5zMltfaTJdO1xuICAgICAgICBPcmlnaW5hbERPTVRva2VuTGlzdFJlbW92ZS5jYWxsKHRoaXMsIHRva2VuKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja0RPTVRva2VuTGlzdFRvZ2dsZSgpIHtcbiAgICBpZiAoIWhhc0RPTSB8fCBfaXNfbm9kZS5pc05vZGVKUykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgaWYgKGRpdi5jbGFzc0xpc3QudG9nZ2xlKFwidGVzdFwiLCAwKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBET01Ub2tlbkxpc3QucHJvdG90eXBlLnRvZ2dsZSA9IGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgdmFyIGZvcmNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyAhIWFyZ3VtZW50c1sxXSA6ICF0aGlzLmNvbnRhaW5zKHRva2VuKTtcbiAgICAgIHJldHVybiB0aGlzW2ZvcmNlID8gXCJhZGRcIiA6IFwicmVtb3ZlXCJdKHRva2VuKSwgZm9yY2U7XG4gICAgfTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tXaW5kb3dIaXN0b3J5UHVzaFN0YXRlUmVwbGFjZVN0YXRlKCkge1xuICAgIGlmICghaGFzRE9NIHx8ICFpc0lFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIE9yaWdpbmFsUHVzaFN0YXRlID0gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlO1xuICAgIHZhciBPcmlnaW5hbFJlcGxhY2VTdGF0ZSA9IHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZTtcblxuICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgdGl0bGUsIHVybCkge1xuICAgICAgdmFyIGFyZ3MgPSB1cmwgPT09IHVuZGVmaW5lZCA/IFtzdGF0ZSwgdGl0bGVdIDogW3N0YXRlLCB0aXRsZSwgdXJsXTtcbiAgICAgIE9yaWdpbmFsUHVzaFN0YXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH07XG5cbiAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHRpdGxlLCB1cmwpIHtcbiAgICAgIHZhciBhcmdzID0gdXJsID09PSB1bmRlZmluZWQgPyBbc3RhdGUsIHRpdGxlXSA6IFtzdGF0ZSwgdGl0bGUsIHVybF07XG4gICAgICBPcmlnaW5hbFJlcGxhY2VTdGF0ZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1N0cmluZ1N0YXJ0c1dpdGgoKSB7XG4gICAgaWYgKFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIF9fd19wZGZqc19yZXF1aXJlX18oNTMpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1N0cmluZ0VuZHNXaXRoKCkge1xuICAgIGlmIChTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX193X3BkZmpzX3JlcXVpcmVfXyg2NCk7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrU3RyaW5nSW5jbHVkZXMoKSB7XG4gICAgaWYgKFN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfX3dfcGRmanNfcmVxdWlyZV9fKDY2KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tBcnJheUluY2x1ZGVzKCkge1xuICAgIGlmIChBcnJheS5wcm90b3R5cGUuaW5jbHVkZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfX3dfcGRmanNfcmVxdWlyZV9fKDY4KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tBcnJheUZyb20oKSB7XG4gICAgaWYgKEFycmF5LmZyb20pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfX3dfcGRmanNfcmVxdWlyZV9fKDc2KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tPYmplY3RBc3NpZ24oKSB7XG4gICAgaWYgKE9iamVjdC5hc3NpZ24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfX3dfcGRmanNfcmVxdWlyZV9fKDk4KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tPYmplY3RGcm9tRW50cmllcygpIHtcbiAgICBpZiAoT2JqZWN0LmZyb21FbnRyaWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX193X3BkZmpzX3JlcXVpcmVfXygxMDEpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja01hdGhMb2cyKCkge1xuICAgIGlmIChNYXRoLmxvZzIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBNYXRoLmxvZzIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrTnVtYmVySXNOYU4oKSB7XG4gICAgaWYgKE51bWJlci5pc05hTikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE51bWJlci5pc05hTiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTA3KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tOdW1iZXJJc0ludGVnZXIoKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBOdW1iZXIuaXNJbnRlZ2VyID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDkpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1R5cGVkQXJyYXlTbGljZSgpIHtcbiAgICBpZiAoVWludDhBcnJheS5wcm90b3R5cGUuc2xpY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfX3dfcGRmanNfcmVxdWlyZV9fKDExMik7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrUHJvbWlzZSgpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5Qcm9taXNlICYmIGdsb2JhbFRoaXMuUHJvbWlzZS5hbGxTZXR0bGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZ2xvYmFsVGhpcy5Qcm9taXNlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTcpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1VSTCgpIHtcbiAgICBnbG9iYWxUaGlzLlVSTCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTM4KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tSZWFkYWJsZVN0cmVhbSgpIHtcbiAgICB2YXIgaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHR5cGVvZiBSZWFkYWJsZVN0cmVhbSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlzUmVhZGFibGVTdHJlYW1TdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICBpZiAoaXNSZWFkYWJsZVN0cmVhbVN1cHBvcnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsb2JhbFRoaXMuUmVhZGFibGVTdHJlYW0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0NSkuUmVhZGFibGVTdHJlYW07XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrTWFwRW50cmllcygpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5NYXAgJiYgZ2xvYmFsVGhpcy5NYXAucHJvdG90eXBlLmVudHJpZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnbG9iYWxUaGlzLk1hcCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQ2KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tTZXRFbnRyaWVzKCkge1xuICAgIGlmIChnbG9iYWxUaGlzLlNldCAmJiBnbG9iYWxUaGlzLlNldC5wcm90b3R5cGUuZW50cmllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsb2JhbFRoaXMuU2V0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTMpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1dlYWtNYXAoKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuV2Vha01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdsb2JhbFRoaXMuV2Vha01hcCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU1KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tXZWFrU2V0KCkge1xuICAgIGlmIChnbG9iYWxUaGlzLldlYWtTZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnbG9iYWxUaGlzLldlYWtTZXQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2MSk7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrU3RyaW5nQ29kZVBvaW50QXQoKSB7XG4gICAgaWYgKFN0cmluZy5wcm90b3R5cGUuY29kZVBvaW50QXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfX3dfcGRmanNfcmVxdWlyZV9fKDE2Myk7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrU3RyaW5nRnJvbUNvZGVQb2ludCgpIHtcbiAgICBpZiAoU3RyaW5nLmZyb21Db2RlUG9pbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBTdHJpbmcuZnJvbUNvZGVQb2ludCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTY1KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tTeW1ib2woKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuU3ltYm9sKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX193X3BkZmpzX3JlcXVpcmVfXygxNjcpO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1N0cmluZ1BhZFN0YXJ0KCkge1xuICAgIGlmIChTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgX193X3BkZmpzX3JlcXVpcmVfXygxOTApO1xuICB9KSgpO1xuXG4gIChmdW5jdGlvbiBjaGVja1N0cmluZ1BhZEVuZCgpIHtcbiAgICBpZiAoU3RyaW5nLnByb3RvdHlwZS5wYWRFbmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBfX3dfcGRmanNfcmVxdWlyZV9fKDE5NSk7XG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uIGNoZWNrT2JqZWN0VmFsdWVzKCkge1xuICAgIGlmIChPYmplY3QudmFsdWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgT2JqZWN0LnZhbHVlcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTk3KTtcbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tPYmplY3RFbnRyaWVzKCkge1xuICAgIGlmIChPYmplY3QuZW50cmllcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIE9iamVjdC5lbnRyaWVzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMDApO1xuICB9KSgpO1xufVxuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuaXNOb2RlSlMgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxudmFyIGlzTm9kZUpTID0gKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YocHJvY2VzcykpID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgKyBcIlwiID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiAhcHJvY2Vzcy52ZXJzaW9ucy5udyAmJiAhKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gJiYgcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSAhPT0gXCJicm93c2VyXCIpO1xuZXhwb3J0cy5pc05vZGVKUyA9IGlzTm9kZUpTO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcbm1vZHVsZS5leHBvcnRzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xuJCh7IGdsb2JhbDogdHJ1ZSB9LCB7IGdsb2JhbFRoaXM6IGdsb2JhbCB9KTtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxMikuZjtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI2KTtcbnZhciByZWRlZmluZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjkpO1xudmFyIHNldEdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzApO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQwKTtcbnZhciBpc0ZvcmNlZCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gdmFyIFRBUkdFVCA9IG9wdGlvbnMudGFyZ2V0O1xuIHZhciBHTE9CQUwgPSBvcHRpb25zLmdsb2JhbDtcbiB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuIHZhciBGT1JDRUQsIHRhcmdldCwga2V5LCB0YXJnZXRQcm9wZXJ0eSwgc291cmNlUHJvcGVydHksIGRlc2NyaXB0b3I7XG4gaWYgKEdMT0JBTCkge1xuICB0YXJnZXQgPSBnbG9iYWw7XG4gfSBlbHNlIGlmIChTVEFUSUMpIHtcbiAgdGFyZ2V0ID0gZ2xvYmFsW1RBUkdFVF0gfHwgc2V0R2xvYmFsKFRBUkdFVCwge30pO1xuIH0gZWxzZSB7XG4gIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuIH1cbiBpZiAodGFyZ2V0KVxuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICBpZiAob3B0aW9ucy5ub1RhcmdldEdldCkge1xuICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgfSBlbHNlXG4gICAgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PT0gdHlwZW9mIHRhcmdldFByb3BlcnR5KVxuICAgICBjb250aW51ZTtcbiAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICB9XG4gICBpZiAob3B0aW9ucy5zaGFtIHx8IHRhcmdldFByb3BlcnR5ICYmIHRhcmdldFByb3BlcnR5LnNoYW0pIHtcbiAgICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoc291cmNlUHJvcGVydHksICdzaGFtJywgdHJ1ZSk7XG4gICB9XG4gICByZWRlZmluZSh0YXJnZXQsIGtleSwgc291cmNlUHJvcGVydHksIG9wdGlvbnMpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBjaGVjayA9IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiBpdCAmJiBpdC5NYXRoID09IE1hdGggJiYgaXQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fCBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHwgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHwgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2KTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3KTtcbnZhciB0b1ByaW1pdGl2ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIElFOF9ET01fREVGSU5FID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiBpZiAoSUU4X0RPTV9ERUZJTkUpXG4gIHRyeSB7XG4gICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICB9XG4gaWYgKGhhcyhPLCBQKSlcbiAgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZi5jYWxsKE8sIFApLCBPW1BdKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgMSwge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiA3O1xuICB9XG4gfSlbMV0gIT0gNztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiB0cnkge1xuICByZXR1cm4gISFleGVjKCk7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG4gfVxufTtcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBOQVNIT1JOX0JVRyA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiAhbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh7IDE6IDIgfSwgMSk7XG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiB2YXIgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0aGlzLCBWKTtcbiByZXR1cm4gISFkZXNjcmlwdG9yICYmIGRlc2NyaXB0b3IuZW51bWVyYWJsZTtcbn0gOiBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gcmV0dXJuIHtcbiAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgdmFsdWU6IHZhbHVlXG4gfTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4KTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiBJbmRleGVkT2JqZWN0KHJlcXVpcmVPYmplY3RDb2VyY2libGUoaXQpKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgY2xhc3NvZiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gIU9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIHRvU3RyaW5nLmNhbGwoaXQpLnNsaWNlKDgsIC0xKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiBpZiAoaXQgPT0gdW5kZWZpbmVkKVxuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiByZXR1cm4gaXQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5wdXQsIFBSRUZFUlJFRF9TVFJJTkcpIHtcbiBpZiAoIWlzT2JqZWN0KGlucHV0KSlcbiAgcmV0dXJuIGlucHV0O1xuIHZhciBmbiwgdmFsO1xuIGlmIChQUkVGRVJSRURfU1RSSU5HICYmIHR5cGVvZiAoZm4gPSBpbnB1dC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKVxuICByZXR1cm4gdmFsO1xuIGlmICh0eXBlb2YgKGZuID0gaW5wdXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKVxuICByZXR1cm4gdmFsO1xuIGlmICghUFJFRkVSUkVEX1NUUklORyAmJiB0eXBlb2YgKGZuID0gaW5wdXQudG9TdHJpbmcpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaW5wdXQpKSlcbiAgcmV0dXJuIHZhbDtcbiB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IHR5cGVvZiBpdCA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoaXQsIGtleSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgY3JlYXRlRWxlbWVudCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gNztcbiAgfVxuIH0pLmEgIT0gNztcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExKTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xudmFyIEVYSVNUUyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIEVYSVNUUyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxNik7XG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiByZXR1cm4gb2JqZWN0O1xufTtcblxuLyoqKi8gfSksXG4vKiAyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjQpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlRGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gYW5PYmplY3QoTyk7XG4gUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuIGlmIChJRThfRE9NX0RFRklORSlcbiAgdHJ5IHtcbiAgIHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgfVxuIGlmICgnZ2V0JyBpbiBBdHRyaWJ1dGVzIHx8ICdzZXQnIGluIEF0dHJpYnV0ZXMpXG4gIHRocm93IFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKVxuICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiByZXR1cm4gTztcbn07XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIGlmICghaXNPYmplY3QoaXQpKSB7XG4gIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gfVxuIHJldHVybiBpdDtcbn07XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIHNldEdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzApO1xudmFyIGluc3BlY3RTb3VyY2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMxKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMyk7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIFRFTVBMQVRFID0gU3RyaW5nKFN0cmluZykuc3BsaXQoJ1N0cmluZycpO1xuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiB2YXIgdW5zYWZlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy51bnNhZmUgOiBmYWxzZTtcbiB2YXIgc2ltcGxlID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5lbnVtZXJhYmxlIDogZmFsc2U7XG4gdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuIGlmICh0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJykge1xuICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJyAmJiAhaGFzKHZhbHVlLCAnbmFtZScpKVxuICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHZhbHVlLCAnbmFtZScsIGtleSk7XG4gIGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKS5zb3VyY2UgPSBURU1QTEFURS5qb2luKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycgPyBrZXkgOiAnJyk7XG4gfVxuIGlmIChPID09PSBnbG9iYWwpIHtcbiAgaWYgKHNpbXBsZSlcbiAgIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlXG4gICBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gIHJldHVybjtcbiB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgZGVsZXRlIE9ba2V5XTtcbiB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgc2ltcGxlID0gdHJ1ZTtcbiB9XG4gaWYgKHNpbXBsZSlcbiAgT1trZXldID0gdmFsdWU7XG4gZWxzZVxuICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoTywga2V5LCB2YWx1ZSk7XG59KShGdW5jdGlvbi5wcm90b3R5cGUsICd0b1N0cmluZycsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59KTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gdHJ5IHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbCwga2V5LCB2YWx1ZSk7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiB9XG4gcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqKi8gfSksXG4vKiAzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgc3RvcmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMyKTtcbnZhciBmdW5jdGlvblRvU3RyaW5nID0gRnVuY3Rpb24udG9TdHJpbmc7XG5pZiAodHlwZW9mIHN0b3JlLmluc3BlY3RTb3VyY2UgIT0gJ2Z1bmN0aW9uJykge1xuIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG4gfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gc3RvcmUuaW5zcGVjdFNvdXJjZTtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgc2V0R2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygzMCk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlO1xuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBOQVRJVkVfV0VBS19NQVAgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM0KTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExKTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpO1xudmFyIG9iamVjdEhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIHNoYXJlZEtleSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzUpO1xudmFyIGhpZGRlbktleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM5KTtcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICB2YXIgc3RhdGU7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG4gfTtcbn07XG5pZiAoTkFUSVZFX1dFQUtfTUFQKSB7XG4gdmFyIHN0b3JlID0gbmV3IFdlYWtNYXAoKTtcbiB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gdmFyIHdtaGFzID0gc3RvcmUuaGFzO1xuIHZhciB3bXNldCA9IHN0b3JlLnNldDtcbiBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gIHdtc2V0LmNhbGwoc3RvcmUsIGl0LCBtZXRhZGF0YSk7XG4gIHJldHVybiBtZXRhZGF0YTtcbiB9O1xuIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gd21nZXQuY2FsbChzdG9yZSwgaXQpIHx8IHt9O1xuIH07XG4gaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gfTtcbn0gZWxzZSB7XG4gdmFyIFNUQVRFID0gc2hhcmVkS2V5KCdzdGF0ZScpO1xuIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShpdCwgU1RBVEUsIG1ldGFkYXRhKTtcbiAgcmV0dXJuIG1ldGFkYXRhO1xuIH07XG4gZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKSA/IGl0W1NUQVRFXSA6IHt9O1xuIH07XG4gaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBvYmplY3RIYXMoaXQsIFNUQVRFKTtcbiB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gc2V0OiBzZXQsXG4gZ2V0OiBnZXQsXG4gaGFzOiBoYXMsXG4gZW5mb3JjZTogZW5mb3JjZSxcbiBnZXR0ZXJGb3I6IGdldHRlckZvclxufTtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzEpO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgJiYgL25hdGl2ZSBjb2RlLy50ZXN0KGluc3BlY3RTb3VyY2UoV2Vha01hcCkpO1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBzaGFyZWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM2KTtcbnZhciB1aWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM4KTtcbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBJU19QVVJFID0gX193X3BkZmpzX3JlcXVpcmVfXygzNyk7XG52YXIgc3RvcmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMyKTtcbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gcmV0dXJuIHN0b3JlW2tleV0gfHwgKHN0b3JlW2tleV0gPSB2YWx1ZSAhPT0gdW5kZWZpbmVkID8gdmFsdWUgOiB7fSk7XG59KSgndmVyc2lvbnMnLCBbXSkucHVzaCh7XG4gdmVyc2lvbjogJzMuNi41JyxcbiBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gY29weXJpZ2h0OiAnwqkgMjAyMCBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KSdcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuIHJldHVybiAnU3ltYm9sKCcgKyBTdHJpbmcoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSkgKyAnKV8nICsgKCsraWQgKyBwb3N0Zml4KS50b1N0cmluZygzNik7XG59O1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIG93bktleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQxKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiB2YXIga2V5cyA9IG93bktleXMoc291cmNlKTtcbiB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgdmFyIGtleSA9IGtleXNbaV07XG4gIGlmICghaGFzKHRhcmdldCwga2V5KSlcbiAgIGRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Mik7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNDQpO1xudmFyIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNTEpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiB2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZihhbk9iamVjdChpdCkpO1xuIHZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUuZjtcbiByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgcGF0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDMpO1xudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIGFGdW5jdGlvbiA9IGZ1bmN0aW9uICh2YXJpYWJsZSkge1xuIHJldHVybiB0eXBlb2YgdmFyaWFibGUgPT0gJ2Z1bmN0aW9uJyA/IHZhcmlhYmxlIDogdW5kZWZpbmVkO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWVzcGFjZSwgbWV0aG9kKSB7XG4gcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gYUZ1bmN0aW9uKHBhdGhbbmFtZXNwYWNlXSkgfHwgYUZ1bmN0aW9uKGdsb2JhbFtuYW1lc3BhY2VdKSA6IHBhdGhbbmFtZXNwYWNlXSAmJiBwYXRoW25hbWVzcGFjZV1bbWV0aG9kXSB8fCBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbDtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXyg0NSk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUwKTtcbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKE8pIHtcbiByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGhpZGRlbktleXMpO1xufTtcblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNyk7XG52YXIgaW5kZXhPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNDYpLmluZGV4T2Y7XG52YXIgaGlkZGVuS2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oMzkpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuIHZhciBPID0gdG9JbmRleGVkT2JqZWN0KG9iamVjdCk7XG4gdmFyIGkgPSAwO1xuIHZhciByZXN1bHQgPSBbXTtcbiB2YXIga2V5O1xuIGZvciAoa2V5IGluIE8pXG4gICFoYXMoaGlkZGVuS2V5cywga2V5KSAmJiBoYXMoTywga2V5KSAmJiByZXN1bHQucHVzaChrZXkpO1xuIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKVxuICBpZiAoaGFzKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3KTtcbnZhciB0b0xlbmd0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDkpO1xudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICB2YXIgdmFsdWU7XG4gIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbClcbiAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICBpZiAodmFsdWUgIT0gdmFsdWUpXG4gICAgIHJldHVybiB0cnVlO1xuICAgfVxuICBlbHNlXG4gICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICBpZiAoKElTX0lOQ0xVREVTIHx8IGluZGV4IGluIE8pICYmIE9baW5kZXhdID09PSBlbClcbiAgICAgcmV0dXJuIElTX0lOQ0xVREVTIHx8IGluZGV4IHx8IDA7XG4gICB9XG4gIHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gfTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuIGluZGV4T2Y6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oNDgpO1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDtcbn07XG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiByZXR1cm4gaXNOYU4oYXJndW1lbnQgPSArYXJndW1lbnQpID8gMCA6IChhcmd1bWVudCA+IDAgPyBmbG9vciA6IGNlaWwpKGFyZ3VtZW50KTtcbn07XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oNDgpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuIHZhciBpbnRlZ2VyID0gdG9JbnRlZ2VyKGluZGV4KTtcbiByZXR1cm4gaW50ZWdlciA8IDAgPyBtYXgoaW50ZWdlciArIGxlbmd0aCwgMCkgOiBtaW4oaW50ZWdlciwgbGVuZ3RoKTtcbn07XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gJ2NvbnN0cnVjdG9yJyxcbiAnaGFzT3duUHJvcGVydHknLFxuICdpc1Byb3RvdHlwZU9mJyxcbiAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICd0b0xvY2FsZVN0cmluZycsXG4gJ3RvU3RyaW5nJyxcbiAndmFsdWVPZidcbl07XG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG52YXIgaXNGb3JjZWQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZGV0ZWN0aW9uKSB7XG4gdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuIHJldHVybiB2YWx1ZSA9PSBQT0xZRklMTCA/IHRydWUgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZSA6IHR5cGVvZiBkZXRlY3Rpb24gPT0gJ2Z1bmN0aW9uJyA/IGZhaWxzKGRldGVjdGlvbikgOiAhIWRldGVjdGlvbjtcbn07XG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oNTQpO1xudmFyIGVudHJ5VW5iaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg2MSk7XG5tb2R1bGUuZXhwb3J0cyA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAnc3RhcnRzV2l0aCcpO1xuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpLmY7XG52YXIgdG9MZW5ndGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciBub3RBUmVnRXhwID0gX193X3BkZmpzX3JlcXVpcmVfXyg1NSk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gX193X3BkZmpzX3JlcXVpcmVfXyg2MCk7XG52YXIgSVNfUFVSRSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xudmFyIG5hdGl2ZVN0YXJ0c1dpdGggPSAnJy5zdGFydHNXaXRoO1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIENPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDID0gY29ycmVjdElzUmVnRXhwTG9naWMoJ3N0YXJ0c1dpdGgnKTtcbnZhciBNRE5fUE9MWUZJTExfQlVHID0gIUlTX1BVUkUgJiYgIUNPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDICYmICEhZnVuY3Rpb24gKCkge1xuIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFN0cmluZy5wcm90b3R5cGUsICdzdGFydHNXaXRoJyk7XG4gcmV0dXJuIGRlc2NyaXB0b3IgJiYgIWRlc2NyaXB0b3Iud3JpdGFibGU7XG59KCk7XG4kKHtcbiB0YXJnZXQ6ICdTdHJpbmcnLFxuIHByb3RvOiB0cnVlLFxuIGZvcmNlZDogIU1ETl9QT0xZRklMTF9CVUcgJiYgIUNPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDXG59LCB7XG4gc3RhcnRzV2l0aDogZnVuY3Rpb24gc3RhcnRzV2l0aChzZWFyY2hTdHJpbmcpIHtcbiAgdmFyIHRoYXQgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gIG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKTtcbiAgdmFyIGluZGV4ID0gdG9MZW5ndGgobWluKGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCB0aGF0Lmxlbmd0aCkpO1xuICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gIHJldHVybiBuYXRpdmVTdGFydHNXaXRoID8gbmF0aXZlU3RhcnRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgaW5kZXgpIDogdGhhdC5zbGljZShpbmRleCwgaW5kZXggKyBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1JlZ0V4cCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTYpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiBpZiAoaXNSZWdFeHAoaXQpKSB7XG4gIHRocm93IFR5cGVFcnJvcihcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtcbiB9XG4gcmV0dXJuIGl0O1xufTtcblxuLyoqKi8gfSksXG4vKiA1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBjbGFzc29mID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgTUFUQ0ggPSB3ZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIHZhciBpc1JlZ0V4cDtcbiByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY2xhc3NvZihpdCkgPT0gJ1JlZ0V4cCcpO1xufTtcblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgc2hhcmVkID0gX193X3BkZmpzX3JlcXVpcmVfXygzNik7XG52YXIgaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG52YXIgdWlkID0gX193X3BkZmpzX3JlcXVpcmVfXygzOCk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTgpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193X3BkZmpzX3JlcXVpcmVfXyg1OSk7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIGNyZWF0ZVdlbGxLbm93blN5bWJvbCA9IFVTRV9TWU1CT0xfQVNfVUlEID8gU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiBpZiAoIWhhcyhXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gIGlmIChOQVRJVkVfU1lNQk9MICYmIGhhcyhTeW1ib2wsIG5hbWUpKVxuICAgV2VsbEtub3duU3ltYm9sc1N0b3JlW25hbWVdID0gU3ltYm9sW25hbWVdO1xuICBlbHNlXG4gICBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV0gPSBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gfVxuIHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gIVN0cmluZyhTeW1ib2woKSk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTgpO1xubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfU1lNQk9MICYmICFTeW1ib2wuc2hhbSAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09ICdzeW1ib2wnO1xuXG4vKioqLyB9KSxcbi8qIDYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU3KTtcbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE1FVEhPRF9OQU1FKSB7XG4gdmFyIHJlZ2V4cCA9IC8uLztcbiB0cnkge1xuICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiB9IGNhdGNoIChlKSB7XG4gIHRyeSB7XG4gICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gIH0gY2F0Y2ggKGYpIHtcbiAgfVxuIH1cbiByZXR1cm4gZmFsc2U7XG59O1xuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExKTtcbnZhciBiaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Mik7XG52YXIgY2FsbCA9IEZ1bmN0aW9uLmNhbGw7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUiwgTUVUSE9ELCBsZW5ndGgpIHtcbiByZXR1cm4gYmluZChjYWxsLCBnbG9iYWxbQ09OU1RSVUNUT1JdLnByb3RvdHlwZVtNRVRIT0RdLCBsZW5ndGgpO1xufTtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgYUZ1bmN0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Myk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gYUZ1bmN0aW9uKGZuKTtcbiBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKVxuICByZXR1cm4gZm47XG4gc3dpdGNoIChsZW5ndGgpIHtcbiBjYXNlIDA6XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgfTtcbiBjYXNlIDE6XG4gIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgcmV0dXJuIGZuLmNhbGwodGhhdCwgYSk7XG4gIH07XG4gY2FzZSAyOlxuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICB9O1xuIGNhc2UgMzpcbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgfTtcbiB9XG4gcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gfTtcbn07XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHtcbiAgdGhyb3cgVHlwZUVycm9yKFN0cmluZyhpdCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gfVxuIHJldHVybiBpdDtcbn07XG5cbi8qKiovIH0pLFxuLyogNjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXyg2NSk7XG52YXIgZW50cnlVbmJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYxKTtcbm1vZHVsZS5leHBvcnRzID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdlbmRzV2l0aCcpO1xuXG4vKioqLyB9KSxcbi8qIDY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpLmY7XG52YXIgdG9MZW5ndGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciBub3RBUmVnRXhwID0gX193X3BkZmpzX3JlcXVpcmVfXyg1NSk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gX193X3BkZmpzX3JlcXVpcmVfXyg2MCk7XG52YXIgSVNfUFVSRSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xudmFyIG5hdGl2ZUVuZHNXaXRoID0gJycuZW5kc1dpdGg7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgQ09SUkVDVF9JU19SRUdFWFBfTE9HSUMgPSBjb3JyZWN0SXNSZWdFeHBMb2dpYygnZW5kc1dpdGgnKTtcbnZhciBNRE5fUE9MWUZJTExfQlVHID0gIUlTX1BVUkUgJiYgIUNPUlJFQ1RfSVNfUkVHRVhQX0xPR0lDICYmICEhZnVuY3Rpb24gKCkge1xuIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFN0cmluZy5wcm90b3R5cGUsICdlbmRzV2l0aCcpO1xuIHJldHVybiBkZXNjcmlwdG9yICYmICFkZXNjcmlwdG9yLndyaXRhYmxlO1xufSgpO1xuJCh7XG4gdGFyZ2V0OiAnU3RyaW5nJyxcbiBwcm90bzogdHJ1ZSxcbiBmb3JjZWQ6ICFNRE5fUE9MWUZJTExfQlVHICYmICFDT1JSRUNUX0lTX1JFR0VYUF9MT0dJQ1xufSwge1xuIGVuZHNXaXRoOiBmdW5jdGlvbiBlbmRzV2l0aChzZWFyY2hTdHJpbmcpIHtcbiAgdmFyIHRoYXQgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKSk7XG4gIG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKTtcbiAgdmFyIGVuZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gIHZhciBsZW4gPSB0b0xlbmd0aCh0aGF0Lmxlbmd0aCk7XG4gIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogbWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICByZXR1cm4gbmF0aXZlRW5kc1dpdGggPyBuYXRpdmVFbmRzV2l0aC5jYWxsKHRoYXQsIHNlYXJjaCwgZW5kKSA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oNjcpO1xudmFyIGVudHJ5VW5iaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg2MSk7XG5tb2R1bGUuZXhwb3J0cyA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAnaW5jbHVkZXMnKTtcblxuLyoqKi8gfSksXG4vKiA2NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBub3RBUmVnRXhwID0gX193X3BkZmpzX3JlcXVpcmVfXyg1NSk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gX193X3BkZmpzX3JlcXVpcmVfXyg2MCk7XG4kKHtcbiB0YXJnZXQ6ICdTdHJpbmcnLFxuIHByb3RvOiB0cnVlLFxuIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdpbmNsdWRlcycpXG59LCB7XG4gaW5jbHVkZXM6IGZ1bmN0aW9uIGluY2x1ZGVzKHNlYXJjaFN0cmluZykge1xuICByZXR1cm4gISF+U3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpLmluZGV4T2Yobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gfVxufSk7XG5cbi8qKiovIH0pLFxuLyogNjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXyg2OSk7XG52YXIgZW50cnlVbmJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYxKTtcbm1vZHVsZS5leHBvcnRzID0gZW50cnlVbmJpbmQoJ0FycmF5JywgJ2luY2x1ZGVzJyk7XG5cbi8qKiovIH0pLFxuLyogNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgJGluY2x1ZGVzID0gX193X3BkZmpzX3JlcXVpcmVfXyg0NikuaW5jbHVkZXM7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IF9fd19wZGZqc19yZXF1aXJlX18oNzApO1xudmFyIGFycmF5TWV0aG9kVXNlc1RvTGVuZ3RoID0gX193X3BkZmpzX3JlcXVpcmVfXyg3NSk7XG52YXIgVVNFU19UT19MRU5HVEggPSBhcnJheU1ldGhvZFVzZXNUb0xlbmd0aCgnaW5kZXhPZicsIHtcbiBBQ0NFU1NPUlM6IHRydWUsXG4gMTogMFxufSk7XG4kKHtcbiB0YXJnZXQ6ICdBcnJheScsXG4gcHJvdG86IHRydWUsXG4gZm9yY2VkOiAhVVNFU19UT19MRU5HVEhcbn0sIHtcbiBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwpIHtcbiAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuIH1cbn0pO1xuYWRkVG9VbnNjb3BhYmxlcygnaW5jbHVkZXMnKTtcblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgY3JlYXRlID0gX193X3BkZmpzX3JlcXVpcmVfXyg3MSk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcbnZhciBVTlNDT1BBQkxFUyA9IHdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogY3JlYXRlKG51bGwpXG4gfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcyKTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNTApO1xudmFyIGhpZGRlbktleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM5KTtcbnZhciBodG1sID0gX193X3BkZmpzX3JlcXVpcmVfXyg3NCk7XG52YXIgZG9jdW1lbnRDcmVhdGVFbGVtZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNSk7XG52YXIgc2hhcmVkS2V5ID0gX193X3BkZmpzX3JlcXVpcmVfXygzNSk7XG52YXIgR1QgPSAnPic7XG52YXIgTFQgPSAnPCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgU0NSSVBUID0gJ3NjcmlwdCc7XG52YXIgSUVfUFJPVE8gPSBzaGFyZWRLZXkoJ0lFX1BST1RPJyk7XG52YXIgRW1wdHlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbn07XG52YXIgc2NyaXB0VGFnID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiByZXR1cm4gTFQgKyBTQ1JJUFQgKyBHVCArIGNvbnRlbnQgKyBMVCArICcvJyArIFNDUklQVCArIEdUO1xufTtcbnZhciBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYID0gZnVuY3Rpb24gKGFjdGl2ZVhEb2N1bWVudCkge1xuIGFjdGl2ZVhEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJycpKTtcbiBhY3RpdmVYRG9jdW1lbnQuY2xvc2UoKTtcbiB2YXIgdGVtcCA9IGFjdGl2ZVhEb2N1bWVudC5wYXJlbnRXaW5kb3cuT2JqZWN0O1xuIGFjdGl2ZVhEb2N1bWVudCA9IG51bGw7XG4gcmV0dXJuIHRlbXA7XG59O1xudmFyIE51bGxQcm90b09iamVjdFZpYUlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiB2YXIgSlMgPSAnamF2YScgKyBTQ1JJUFQgKyAnOic7XG4gdmFyIGlmcmFtZURvY3VtZW50O1xuIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuIGh0bWwuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiBpZnJhbWUuc3JjID0gU3RyaW5nKEpTKTtcbiBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuIGlmcmFtZURvY3VtZW50Lm9wZW4oKTtcbiBpZnJhbWVEb2N1bWVudC53cml0ZShzY3JpcHRUYWcoJ2RvY3VtZW50LkY9T2JqZWN0JykpO1xuIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gcmV0dXJuIGlmcmFtZURvY3VtZW50LkY7XG59O1xudmFyIGFjdGl2ZVhEb2N1bWVudDtcbnZhciBOdWxsUHJvdG9PYmplY3QgPSBmdW5jdGlvbiAoKSB7XG4gdHJ5IHtcbiAgYWN0aXZlWERvY3VtZW50ID0gZG9jdW1lbnQuZG9tYWluICYmIG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gfVxuIE51bGxQcm90b09iamVjdCA9IGFjdGl2ZVhEb2N1bWVudCA/IE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVgoYWN0aXZlWERvY3VtZW50KSA6IE51bGxQcm90b09iamVjdFZpYUlGcmFtZSgpO1xuIHZhciBsZW5ndGggPSBlbnVtQnVnS2V5cy5sZW5ndGg7XG4gd2hpbGUgKGxlbmd0aC0tKVxuICBkZWxldGUgTnVsbFByb3RvT2JqZWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gcmV0dXJuIE51bGxQcm90b09iamVjdCgpO1xufTtcbmhpZGRlbktleXNbSUVfUFJPVE9dID0gdHJ1ZTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuIHZhciByZXN1bHQ7XG4gaWYgKE8gIT09IG51bGwpIHtcbiAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gIHJlc3VsdCA9IG5ldyBFbXB0eUNvbnN0cnVjdG9yKCk7XG4gIEVtcHR5Q29uc3RydWN0b3JbUFJPVE9UWVBFXSA9IG51bGw7XG4gIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuIH0gZWxzZVxuICByZXN1bHQgPSBOdWxsUHJvdG9PYmplY3QoKTtcbiByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjcpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgb2JqZWN0S2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNzMpO1xubW9kdWxlLmV4cG9ydHMgPSBERVNDUklQVE9SUyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzIDogZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gYW5PYmplY3QoTyk7XG4gdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiB2YXIgaW5kZXggPSAwO1xuIHZhciBrZXk7XG4gd2hpbGUgKGxlbmd0aCA+IGluZGV4KVxuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIFByb3BlcnRpZXNba2V5XSk7XG4gcmV0dXJuIE87XG59O1xuXG4vKioqLyB9KSxcbi8qIDczICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBpbnRlcm5hbE9iamVjdEtleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ1KTtcbnZhciBlbnVtQnVnS2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNTApO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiByZXR1cm4gaW50ZXJuYWxPYmplY3RLZXlzKE8sIGVudW1CdWdLZXlzKTtcbn07XG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQyKTtcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignZG9jdW1lbnQnLCAnZG9jdW1lbnRFbGVtZW50Jyk7XG5cbi8qKiovIH0pLFxuLyogNzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBoYXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIzKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBjYWNoZSA9IHt9O1xudmFyIHRocm93ZXIgPSBmdW5jdGlvbiAoaXQpIHtcbiB0aHJvdyBpdDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgb3B0aW9ucykge1xuIGlmIChoYXMoY2FjaGUsIE1FVEhPRF9OQU1FKSlcbiAgcmV0dXJuIGNhY2hlW01FVEhPRF9OQU1FXTtcbiBpZiAoIW9wdGlvbnMpXG4gIG9wdGlvbnMgPSB7fTtcbiB2YXIgbWV0aG9kID0gW11bTUVUSE9EX05BTUVdO1xuIHZhciBBQ0NFU1NPUlMgPSBoYXMob3B0aW9ucywgJ0FDQ0VTU09SUycpID8gb3B0aW9ucy5BQ0NFU1NPUlMgOiBmYWxzZTtcbiB2YXIgYXJndW1lbnQwID0gaGFzKG9wdGlvbnMsIDApID8gb3B0aW9uc1swXSA6IHRocm93ZXI7XG4gdmFyIGFyZ3VtZW50MSA9IGhhcyhvcHRpb25zLCAxKSA/IG9wdGlvbnNbMV0gOiB1bmRlZmluZWQ7XG4gcmV0dXJuIGNhY2hlW01FVEhPRF9OQU1FXSA9ICEhbWV0aG9kICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGlmIChBQ0NFU1NPUlMgJiYgIURFU0NSSVBUT1JTKVxuICAgcmV0dXJuIHRydWU7XG4gIHZhciBPID0geyBsZW5ndGg6IC0xIH07XG4gIGlmIChBQ0NFU1NPUlMpXG4gICBkZWZpbmVQcm9wZXJ0eShPLCAxLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IHRocm93ZXJcbiAgIH0pO1xuICBlbHNlXG4gICBPWzFdID0gMTtcbiAgbWV0aG9kLmNhbGwoTywgYXJndW1lbnQwLCBhcmd1bWVudDEpO1xuIH0pO1xufTtcblxuLyoqKi8gfSksXG4vKiA3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDc3KTtcbl9fd19wZGZqc19yZXF1aXJlX18oODkpO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5BcnJheS5mcm9tO1xuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY2hhckF0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg3OCkuY2hhckF0O1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMzKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNzkpO1xudmFyIFNUUklOR19JVEVSQVRPUiA9ICdTdHJpbmcgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1RSSU5HX0lURVJBVE9SKTtcbmRlZmluZUl0ZXJhdG9yKFN0cmluZywgJ1N0cmluZycsIGZ1bmN0aW9uIChpdGVyYXRlZCkge1xuIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICB0eXBlOiBTVFJJTkdfSVRFUkFUT1IsXG4gIHN0cmluZzogU3RyaW5nKGl0ZXJhdGVkKSxcbiAgaW5kZXg6IDBcbiB9KTtcbn0sIGZ1bmN0aW9uIG5leHQoKSB7XG4gdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiB2YXIgc3RyaW5nID0gc3RhdGUuc3RyaW5nO1xuIHZhciBpbmRleCA9IHN0YXRlLmluZGV4O1xuIHZhciBwb2ludDtcbiBpZiAoaW5kZXggPj0gc3RyaW5nLmxlbmd0aClcbiAgcmV0dXJuIHtcbiAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICBkb25lOiB0cnVlXG4gIH07XG4gcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gc3RhdGUuaW5kZXggKz0gcG9pbnQubGVuZ3RoO1xuIHJldHVybiB7XG4gIHZhbHVlOiBwb2ludCxcbiAgZG9uZTogZmFsc2VcbiB9O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHRvSW50ZWdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oNDgpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwKTtcbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoQ09OVkVSVF9UT19TVFJJTkcpIHtcbiByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgdmFyIFMgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICB2YXIgcG9zaXRpb24gPSB0b0ludGVnZXIocG9zKTtcbiAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgdmFyIGZpcnN0LCBzZWNvbmQ7XG4gIGlmIChwb3NpdGlvbiA8IDAgfHwgcG9zaXRpb24gPj0gc2l6ZSlcbiAgIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICBmaXJzdCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbik7XG4gIHJldHVybiBmaXJzdCA8IDB4RDgwMCB8fCBmaXJzdCA+IDB4REJGRiB8fCBwb3NpdGlvbiArIDEgPT09IHNpemUgfHwgKHNlY29uZCA9IFMuY2hhckNvZGVBdChwb3NpdGlvbiArIDEpKSA8IDB4REMwMCB8fCBzZWNvbmQgPiAweERGRkYgPyBDT05WRVJUX1RPX1NUUklORyA/IFMuY2hhckF0KHBvc2l0aW9uKSA6IGZpcnN0IDogQ09OVkVSVF9UT19TVFJJTkcgPyBTLnNsaWNlKHBvc2l0aW9uLCBwb3NpdGlvbiArIDIpIDogKGZpcnN0IC0gMHhEODAwIDw8IDEwKSArIChzZWNvbmQgLSAweERDMDApICsgMHgxMDAwMDtcbiB9O1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuIGNvZGVBdDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcblxuLyoqKi8gfSksXG4vKiA3OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg4MCk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgyKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oODcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193X3BkZmpzX3JlcXVpcmVfXyg4NSk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNik7XG52YXIgcmVkZWZpbmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU3KTtcbnZhciBJU19QVVJFID0gX193X3BkZmpzX3JlcXVpcmVfXygzNyk7XG52YXIgSXRlcmF0b3JzID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Nik7XG52YXIgSXRlcmF0b3JzQ29yZSA9IF9fd19wZGZqc19yZXF1aXJlX18oODEpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkge1xuIHJldHVybiB0aGlzO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEl0ZXJhYmxlLCBOQU1FLCBJdGVyYXRvckNvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuIGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoSXRlcmF0b3JDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gdmFyIGdldEl0ZXJhdGlvbk1ldGhvZCA9IGZ1bmN0aW9uIChLSU5EKSB7XG4gIGlmIChLSU5EID09PSBERUZBVUxUICYmIGRlZmF1bHRJdGVyYXRvcilcbiAgIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gIGlmICghQlVHR1lfU0FGQVJJX0lURVJBVE9SUyAmJiBLSU5EIGluIEl0ZXJhYmxlUHJvdG90eXBlKVxuICAgcmV0dXJuIEl0ZXJhYmxlUHJvdG90eXBlW0tJTkRdO1xuICBzd2l0Y2ggKEtJTkQpIHtcbiAgY2FzZSBLRVlTOlxuICAgcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7XG4gICAgcmV0dXJuIG5ldyBJdGVyYXRvckNvbnN0cnVjdG9yKHRoaXMsIEtJTkQpO1xuICAgfTtcbiAgY2FzZSBWQUxVRVM6XG4gICByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkge1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgIH07XG4gIGNhc2UgRU5UUklFUzpcbiAgIHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTtcbiAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzKTtcbiAgfTtcbiB9O1xuIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiB2YXIgSXRlcmFibGVQcm90b3R5cGUgPSBJdGVyYWJsZS5wcm90b3R5cGU7XG4gdmFyIG5hdGl2ZUl0ZXJhdG9yID0gSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdIHx8IEl0ZXJhYmxlUHJvdG90eXBlWydAQGl0ZXJhdG9yJ10gfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiB2YXIgZGVmYXVsdEl0ZXJhdG9yID0gIUJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgJiYgbmF0aXZlSXRlcmF0b3IgfHwgZ2V0SXRlcmF0aW9uTWV0aG9kKERFRkFVTFQpO1xuIHZhciBhbnlOYXRpdmVJdGVyYXRvciA9IE5BTUUgPT0gJ0FycmF5JyA/IEl0ZXJhYmxlUHJvdG90eXBlLmVudHJpZXMgfHwgbmF0aXZlSXRlcmF0b3IgOiBuYXRpdmVJdGVyYXRvcjtcbiB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG4gaWYgKGFueU5hdGl2ZUl0ZXJhdG9yKSB7XG4gIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGFueU5hdGl2ZUl0ZXJhdG9yLmNhbGwobmV3IEl0ZXJhYmxlKCkpKTtcbiAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICBpZiAoIUlTX1BVUkUgJiYgZ2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbiAgICB9XG4gICB9XG4gICBzZXRUb1N0cmluZ1RhZyhDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHRydWUsIHRydWUpO1xuICAgaWYgKElTX1BVUkUpXG4gICAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgfVxuIH1cbiBpZiAoREVGQVVMVCA9PSBWQUxVRVMgJiYgbmF0aXZlSXRlcmF0b3IgJiYgbmF0aXZlSXRlcmF0b3IubmFtZSAhPT0gVkFMVUVTKSB7XG4gIElOQ09SUkVDVF9WQUxVRVNfTkFNRSA9IHRydWU7XG4gIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHtcbiAgIHJldHVybiBuYXRpdmVJdGVyYXRvci5jYWxsKHRoaXMpO1xuICB9O1xuIH1cbiBpZiAoKCFJU19QVVJFIHx8IEZPUkNFRCkgJiYgSXRlcmFibGVQcm90b3R5cGVbSVRFUkFUT1JdICE9PSBkZWZhdWx0SXRlcmF0b3IpIHtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KEl0ZXJhYmxlUHJvdG90eXBlLCBJVEVSQVRPUiwgZGVmYXVsdEl0ZXJhdG9yKTtcbiB9XG4gSXRlcmF0b3JzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuIGlmIChERUZBVUxUKSB7XG4gIG1ldGhvZHMgPSB7XG4gICB2YWx1ZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChWQUxVRVMpLFxuICAga2V5czogSVNfU0VUID8gZGVmYXVsdEl0ZXJhdG9yIDogZ2V0SXRlcmF0aW9uTWV0aG9kKEtFWVMpLFxuICAgZW50cmllczogZ2V0SXRlcmF0aW9uTWV0aG9kKEVOVFJJRVMpXG4gIH07XG4gIGlmIChGT1JDRUQpXG4gICBmb3IgKEtFWSBpbiBtZXRob2RzKSB7XG4gICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgIH1cbiAgIH1cbiAgZWxzZVxuICAgJCh7XG4gICAgdGFyZ2V0OiBOQU1FLFxuICAgIHByb3RvOiB0cnVlLFxuICAgIGZvcmNlZDogQlVHR1lfU0FGQVJJX0lURVJBVE9SUyB8fCBJTkNPUlJFQ1RfVkFMVUVTX05BTUVcbiAgIH0sIG1ldGhvZHMpO1xuIH1cbiByZXR1cm4gbWV0aG9kcztcbn07XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBJdGVyYXRvclByb3RvdHlwZSA9IF9fd19wZGZqc19yZXF1aXJlX18oODEpLkl0ZXJhdG9yUHJvdG90eXBlO1xudmFyIGNyZWF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNzEpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193X3BkZmpzX3JlcXVpcmVfXyg4NSk7XG52YXIgSXRlcmF0b3JzID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Nik7XG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gdGhpcztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gSXRlcmF0b3JDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUsIHsgbmV4dDogY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIG5leHQpIH0pO1xuIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiBJdGVyYXRvcnNbVE9fU1RSSU5HX1RBR10gPSByZXR1cm5UaGlzO1xuIHJldHVybiBJdGVyYXRvckNvbnN0cnVjdG9yO1xufTtcblxuLyoqKi8gfSksXG4vKiA4MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdldFByb3RvdHlwZU9mID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Mik7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNik7XG52YXIgaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgSVNfUFVSRSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgPSBmYWxzZTtcbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkge1xuIHJldHVybiB0aGlzO1xufTtcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuaWYgKFtdLmtleXMpIHtcbiBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuIGlmICghKCduZXh0JyBpbiBhcnJheUl0ZXJhdG9yKSlcbiAgQlVHR1lfU0FGQVJJX0lURVJBVE9SUyA9IHRydWU7XG4gZWxzZSB7XG4gIFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKGdldFByb3RvdHlwZU9mKGFycmF5SXRlcmF0b3IpKTtcbiAgaWYgKFByb3RvdHlwZU9mQXJyYXlJdGVyYXRvclByb3RvdHlwZSAhPT0gT2JqZWN0LnByb3RvdHlwZSlcbiAgIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuIH1cbn1cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpXG4gSXRlcmF0b3JQcm90b3R5cGUgPSB7fTtcbmlmICghSVNfUFVSRSAmJiAhaGFzKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUikpIHtcbiBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoSXRlcmF0b3JQcm90b3R5cGUsIElURVJBVE9SLCByZXR1cm5UaGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuIEl0ZXJhdG9yUHJvdG90eXBlOiBJdGVyYXRvclByb3RvdHlwZSxcbiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTXG59O1xuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBoYXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIzKTtcbnZhciB0b09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oODMpO1xudmFyIHNoYXJlZEtleSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzUpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IF9fd19wZGZqc19yZXF1aXJlX18oODQpO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5tb2R1bGUuZXhwb3J0cyA9IENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIChPKSB7XG4gTyA9IHRvT2JqZWN0KE8pO1xuIGlmIChoYXMoTywgSUVfUFJPVE8pKVxuICByZXR1cm4gT1tJRV9QUk9UT107XG4gaWYgKHR5cGVvZiBPLmNvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgTyBpbnN0YW5jZW9mIE8uY29uc3RydWN0b3IpIHtcbiAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuIH1cbiByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxuLyoqKi8gfSksXG4vKiA4NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiBmdW5jdGlvbiBGKCkge1xuIH1cbiBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxuLyoqKi8gfSksXG4vKiA4NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KS5mO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTcpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgVEFHLCBTVEFUSUMpIHtcbiBpZiAoaXQgJiYgIWhhcyhpdCA9IFNUQVRJQyA/IGl0IDogaXQucHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICBkZWZpbmVQcm9wZXJ0eShpdCwgVE9fU1RSSU5HX1RBRywge1xuICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgdmFsdWU6IFRBR1xuICB9KTtcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gX193X3BkZmpzX3JlcXVpcmVfXyg4OCk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCAoJ19fcHJvdG9fXycgaW4ge30gPyBmdW5jdGlvbiAoKSB7XG4gdmFyIENPUlJFQ1RfU0VUVEVSID0gZmFsc2U7XG4gdmFyIHRlc3QgPSB7fTtcbiB2YXIgc2V0dGVyO1xuIHRyeSB7XG4gIHNldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSwgJ19fcHJvdG9fXycpLnNldDtcbiAgc2V0dGVyLmNhbGwodGVzdCwgW10pO1xuICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiB9IGNhdGNoIChlcnJvcikge1xuIH1cbiByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gIGlmIChDT1JSRUNUX1NFVFRFUilcbiAgIHNldHRlci5jYWxsKE8sIHByb3RvKTtcbiAgZWxzZVxuICAgTy5fX3Byb3RvX18gPSBwcm90bztcbiAgcmV0dXJuIE87XG4gfTtcbn0oKSA6IHVuZGVmaW5lZCk7XG5cbi8qKiovIH0pLFxuLyogODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIGlmICghaXNPYmplY3QoaXQpICYmIGl0ICE9PSBudWxsKSB7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gfVxuIHJldHVybiBpdDtcbn07XG5cbi8qKiovIH0pLFxuLyogODkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBmcm9tID0gX193X3BkZmpzX3JlcXVpcmVfXyg5MCk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXyg5Nyk7XG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9ICFjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24oZnVuY3Rpb24gKGl0ZXJhYmxlKSB7XG4gQXJyYXkuZnJvbShpdGVyYWJsZSk7XG59KTtcbiQoe1xuIHRhcmdldDogJ0FycmF5JyxcbiBzdGF0OiB0cnVlLFxuIGZvcmNlZDogSU5DT1JSRUNUX0lURVJBVElPTlxufSwgeyBmcm9tOiBmcm9tIH0pO1xuXG4vKioqLyB9KSxcbi8qIDkwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgYmluZCA9IF9fd19wZGZqc19yZXF1aXJlX18oNjIpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Myk7XG52YXIgY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyA9IF9fd19wZGZqc19yZXF1aXJlX18oOTEpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IF9fd19wZGZqc19yZXF1aXJlX18oOTIpO1xudmFyIHRvTGVuZ3RoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Nyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkzKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd19wZGZqc19yZXF1aXJlX18oOTQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmcm9tKGFycmF5TGlrZSkge1xuIHZhciBPID0gdG9PYmplY3QoYXJyYXlMaWtlKTtcbiB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoTyk7XG4gdmFyIGluZGV4ID0gMDtcbiB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yLCBuZXh0LCB2YWx1ZTtcbiBpZiAobWFwcGluZylcbiAgbWFwZm4gPSBiaW5kKG1hcGZuLCBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiBpZiAoaXRlcmF0b3JNZXRob2QgIT0gdW5kZWZpbmVkICYmICEoQyA9PSBBcnJheSAmJiBpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlcmF0b3JNZXRob2QpKSkge1xuICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoTyk7XG4gIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuICByZXN1bHQgPSBuZXcgQygpO1xuICBmb3IgKDsgIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZTsgaW5kZXgrKykge1xuICAgdmFsdWUgPSBtYXBwaW5nID8gY2FsbFdpdGhTYWZlSXRlcmF0aW9uQ2xvc2luZyhpdGVyYXRvciwgbWFwZm4sIFtcbiAgICBzdGVwLnZhbHVlLFxuICAgIGluZGV4XG4gICBdLCB0cnVlKSA6IHN0ZXAudmFsdWU7XG4gICBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCB2YWx1ZSk7XG4gIH1cbiB9IGVsc2Uge1xuICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHJlc3VsdCA9IG5ldyBDKGxlbmd0aCk7XG4gIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgdmFsdWUgPSBtYXBwaW5nID8gbWFwZm4oT1tpbmRleF0sIGluZGV4KSA6IE9baW5kZXhdO1xuICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgdmFsdWUpO1xuICB9XG4gfVxuIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqKi8gfSksXG4vKiA5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI4KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhdG9yLCBmbiwgdmFsdWUsIEVOVFJJRVMpIHtcbiB0cnkge1xuICByZXR1cm4gRU5UUklFUyA/IGZuKGFuT2JqZWN0KHZhbHVlKVswXSwgdmFsdWVbMV0pIDogZm4odmFsdWUpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gIHZhciByZXR1cm5NZXRob2QgPSBpdGVyYXRvclsncmV0dXJuJ107XG4gIGlmIChyZXR1cm5NZXRob2QgIT09IHVuZGVmaW5lZClcbiAgIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSk7XG4gIHRocm93IGVycm9yO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTcpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd19wZGZqc19yZXF1aXJlX18oODYpO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogOTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciB0b1ByaW1pdGl2ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxNik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiB2YXIgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShrZXkpO1xuIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpXG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gZWxzZVxuICBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG4vKioqLyB9KSxcbi8qIDk0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193X3BkZmpzX3JlcXVpcmVfXyg5NSk7XG52YXIgSXRlcmF0b3JzID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Nik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIGlmIChpdCAhPSB1bmRlZmluZWQpXG4gIHJldHVybiBpdFtJVEVSQVRPUl0gfHwgaXRbJ0BAaXRlcmF0b3InXSB8fCBJdGVyYXRvcnNbY2xhc3NvZihpdCldO1xufTtcblxuLyoqKi8gfSksXG4vKiA5NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193X3BkZmpzX3JlcXVpcmVfXyg5Nik7XG52YXIgY2xhc3NvZlJhdyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTcpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgQ09SUkVDVF9BUkdVTUVOVFMgPSBjbGFzc29mUmF3KGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gYXJndW1lbnRzO1xufSgpKSA9PSAnQXJndW1lbnRzJztcbnZhciB0cnlHZXQgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuIHRyeSB7XG4gIHJldHVybiBpdFtrZXldO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gfVxufTtcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8gY2xhc3NvZlJhdyA6IGZ1bmN0aW9uIChpdCkge1xuIHZhciBPLCB0YWcsIHJlc3VsdDtcbiByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/ICdVbmRlZmluZWQnIDogaXQgPT09IG51bGwgPyAnTnVsbCcgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnIDogQ09SUkVDVF9BUkdVTUVOVFMgPyBjbGFzc29mUmF3KE8pIDogKHJlc3VsdCA9IGNsYXNzb2ZSYXcoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU3KTtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcbnRlc3RbVE9fU1RSSU5HX1RBR10gPSAneic7XG5tb2R1bGUuZXhwb3J0cyA9IFN0cmluZyh0ZXN0KSA9PT0gJ1tvYmplY3Qgel0nO1xuXG4vKioqLyB9KSxcbi8qIDk3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU3KTtcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcbnRyeSB7XG4gdmFyIGNhbGxlZCA9IDA7XG4gdmFyIGl0ZXJhdG9yV2l0aFJldHVybiA9IHtcbiAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICB9LFxuICAncmV0dXJuJzogZnVuY3Rpb24gKCkge1xuICAgU0FGRV9DTE9TSU5HID0gdHJ1ZTtcbiAgfVxuIH07XG4gaXRlcmF0b3JXaXRoUmV0dXJuW0lURVJBVE9SXSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG4gfTtcbiBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkge1xuICB0aHJvdyAyO1xuIH0pO1xufSBjYXRjaCAoZXJyb3IpIHtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGV4ZWMsIFNLSVBfQ0xPU0lORykge1xuIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpXG4gIHJldHVybiBmYWxzZTtcbiB2YXIgSVRFUkFUSU9OX1NVUFBPUlQgPSBmYWxzZTtcbiB0cnkge1xuICB2YXIgb2JqZWN0ID0ge307XG4gIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4ge1xuICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgfVxuICAgfTtcbiAgfTtcbiAgZXhlYyhvYmplY3QpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gfVxuIHJldHVybiBJVEVSQVRJT05fU1VQUE9SVDtcbn07XG5cbi8qKiovIH0pLFxuLyogOTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXyg5OSk7XG52YXIgcGF0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDMpO1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoLk9iamVjdC5hc3NpZ247XG5cbi8qKiovIH0pLFxuLyogOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBhc3NpZ24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwMCk7XG4kKHtcbiB0YXJnZXQ6ICdPYmplY3QnLFxuIHN0YXQ6IHRydWUsXG4gZm9yY2VkOiBPYmplY3QuYXNzaWduICE9PSBhc3NpZ25cbn0sIHsgYXNzaWduOiBhc3NpZ24gfSk7XG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIG9iamVjdEtleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDczKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUxKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Myk7XG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgpO1xudmFyIG5hdGl2ZUFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG52YXIgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9ICFuYXRpdmVBc3NpZ24gfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuIGlmIChERVNDUklQVE9SUyAmJiBuYXRpdmVBc3NpZ24oeyBiOiAxIH0sIG5hdGl2ZUFzc2lnbihkZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgZGVmaW5lUHJvcGVydHkodGhpcywgJ2InLCB7XG4gICAgIHZhbHVlOiAzLFxuICAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICAgIH0pO1xuICAgfVxuICB9KSwgeyBiOiAyIH0pKS5iICE9PSAxKVxuICByZXR1cm4gdHJ1ZTtcbiB2YXIgQSA9IHt9O1xuIHZhciBCID0ge307XG4gdmFyIHN5bWJvbCA9IFN5bWJvbCgpO1xuIHZhciBhbHBoYWJldCA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdCc7XG4gQVtzeW1ib2xdID0gNztcbiBhbHBoYWJldC5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAoY2hyKSB7XG4gIEJbY2hyXSA9IGNocjtcbiB9KTtcbiByZXR1cm4gbmF0aXZlQXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cyhuYXRpdmVBc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7XG4gdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuIHZhciBpbmRleCA9IDE7XG4gdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuIHZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG4gd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSB7XG4gIHZhciBTID0gSW5kZXhlZE9iamVjdChhcmd1bWVudHNbaW5kZXgrK10pO1xuICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IG9iamVjdEtleXMoUykuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gIHZhciBqID0gMDtcbiAgdmFyIGtleTtcbiAgd2hpbGUgKGxlbmd0aCA+IGopIHtcbiAgIGtleSA9IGtleXNbaisrXTtcbiAgIGlmICghREVTQ1JJUFRPUlMgfHwgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChTLCBrZXkpKVxuICAgIFRba2V5XSA9IFNba2V5XTtcbiAgfVxuIH1cbiByZXR1cm4gVDtcbn0gOiBuYXRpdmVBc3NpZ247XG5cbi8qKiovIH0pLFxuLyogMTAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTAyKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTAzKTtcbnZhciBwYXRoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Myk7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmZyb21FbnRyaWVzO1xuXG4vKioqLyB9KSxcbi8qIDEwMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcwKTtcbnZhciBJdGVyYXRvcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg2KTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc5KTtcbnZhciBBUlJBWV9JVEVSQVRPUiA9ICdBcnJheSBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihBUlJBWV9JVEVSQVRPUik7XG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZUl0ZXJhdG9yKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgdHlwZTogQVJSQVlfSVRFUkFUT1IsXG4gIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSxcbiAgaW5kZXg6IDAsXG4gIGtpbmQ6IGtpbmRcbiB9KTtcbn0sIGZ1bmN0aW9uICgpIHtcbiB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gdmFyIGtpbmQgPSBzdGF0ZS5raW5kO1xuIHZhciBpbmRleCA9IHN0YXRlLmluZGV4Kys7XG4gaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gIHJldHVybiB7XG4gICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgZG9uZTogdHJ1ZVxuICB9O1xuIH1cbiBpZiAoa2luZCA9PSAna2V5cycpXG4gIHJldHVybiB7XG4gICB2YWx1ZTogaW5kZXgsXG4gICBkb25lOiBmYWxzZVxuICB9O1xuIGlmIChraW5kID09ICd2YWx1ZXMnKVxuICByZXR1cm4ge1xuICAgdmFsdWU6IHRhcmdldFtpbmRleF0sXG4gICBkb25lOiBmYWxzZVxuICB9O1xuIHJldHVybiB7XG4gIHZhbHVlOiBbXG4gICBpbmRleCxcbiAgIHRhcmdldFtpbmRleF1cbiAgXSxcbiAgZG9uZTogZmFsc2VcbiB9O1xufSwgJ3ZhbHVlcycpO1xuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGl0ZXJhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwNCk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkzKTtcbiQoe1xuIHRhcmdldDogJ09iamVjdCcsXG4gc3RhdDogdHJ1ZVxufSwge1xuIGZyb21FbnRyaWVzOiBmdW5jdGlvbiBmcm9tRW50cmllcyhpdGVyYWJsZSkge1xuICB2YXIgb2JqID0ge307XG4gIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChrLCB2KSB7XG4gICBjcmVhdGVQcm9wZXJ0eShvYmosIGssIHYpO1xuICB9LCB1bmRlZmluZWQsIHRydWUpO1xuICByZXR1cm4gb2JqO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI4KTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkyKTtcbnZhciB0b0xlbmd0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDcpO1xudmFyIGJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYyKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd19wZGZqc19yZXF1aXJlX18oOTQpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkxKTtcbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG52YXIgaXRlcmF0ZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCBmbiwgdGhhdCwgQVNfRU5UUklFUywgSVNfSVRFUkFUT1IpIHtcbiB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoZm4sIHRoYXQsIEFTX0VOVFJJRVMgPyAyIDogMSk7XG4gdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgbmV4dCwgc3RlcDtcbiBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiB9IGVsc2Uge1xuICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gIGlmICh0eXBlb2YgaXRlckZuICE9ICdmdW5jdGlvbicpXG4gICB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcbiAgaWYgKGlzQXJyYXlJdGVyYXRvck1ldGhvZChpdGVyRm4pKSB7XG4gICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdG9MZW5ndGgoaXRlcmFibGUubGVuZ3RoKTsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICByZXN1bHQgPSBBU19FTlRSSUVTID8gYm91bmRGdW5jdGlvbihhbk9iamVjdChzdGVwID0gaXRlcmFibGVbaW5kZXhdKVswXSwgc3RlcFsxXSkgOiBib3VuZEZ1bmN0aW9uKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQgaW5zdGFuY2VvZiBSZXN1bHQpXG4gICAgIHJldHVybiByZXN1bHQ7XG4gICB9XG4gICByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gIH1cbiAgaXRlcmF0b3IgPSBpdGVyRm4uY2FsbChpdGVyYWJsZSk7XG4gfVxuIG5leHQgPSBpdGVyYXRvci5uZXh0O1xuIHdoaWxlICghKHN0ZXAgPSBuZXh0LmNhbGwoaXRlcmF0b3IpKS5kb25lKSB7XG4gIHJlc3VsdCA9IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIGJvdW5kRnVuY3Rpb24sIHN0ZXAudmFsdWUsIEFTX0VOVFJJRVMpO1xuICBpZiAodHlwZW9mIHJlc3VsdCA9PSAnb2JqZWN0JyAmJiByZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KVxuICAgcmV0dXJuIHJlc3VsdDtcbiB9XG4gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcbml0ZXJhdGUuc3RvcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCByZXN1bHQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXygxMDYpO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5NYXRoLmxvZzI7XG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgbG9nID0gTWF0aC5sb2c7XG52YXIgTE4yID0gTWF0aC5MTjI7XG4kKHtcbiB0YXJnZXQ6ICdNYXRoJyxcbiBzdGF0OiB0cnVlXG59LCB7XG4gbG9nMjogZnVuY3Rpb24gbG9nMih4KSB7XG4gIHJldHVybiBsb2coeCkgLyBMTjI7XG4gfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTA4KTtcbnZhciBwYXRoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Myk7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguTnVtYmVyLmlzTmFOO1xuXG4vKioqLyB9KSxcbi8qIDEwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xuJCh7XG4gdGFyZ2V0OiAnTnVtYmVyJyxcbiBzdGF0OiB0cnVlXG59LCB7XG4gaXNOYU46IGZ1bmN0aW9uIGlzTmFOKG51bWJlcikge1xuICByZXR1cm4gbnVtYmVyICE9IG51bWJlcjtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXygxMTApO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5OdW1iZXIuaXNJbnRlZ2VyO1xuXG4vKioqLyB9KSxcbi8qIDExMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGlzSW50ZWdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTExKTtcbiQoe1xuIHRhcmdldDogJ051bWJlcicsXG4gc3RhdDogdHJ1ZVxufSwgeyBpc0ludGVnZXI6IGlzSW50ZWdlciB9KTtcblxuLyoqKi8gfSksXG4vKiAxMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0ludGVnZXIoaXQpIHtcbiByZXR1cm4gIWlzT2JqZWN0KGl0KSAmJiBpc0Zpbml0ZShpdCkgJiYgZmxvb3IoaXQpID09PSBpdDtcbn07XG5cbi8qKiovIH0pLFxuLyogMTEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTEzKTtcblxuLyoqKi8gfSksXG4vKiAxMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTQpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE2KTtcbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG52YXIgJHNsaWNlID0gW10uc2xpY2U7XG52YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuIG5ldyBJbnQ4QXJyYXkoMSkuc2xpY2UoKTtcbn0pO1xuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgnc2xpY2UnLCBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gdmFyIGxpc3QgPSAkc2xpY2UuY2FsbChhVHlwZWRBcnJheSh0aGlzKSwgc3RhcnQsIGVuZCk7XG4gdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gdmFyIGluZGV4ID0gMDtcbiB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gdmFyIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihDKSkobGVuZ3RoKTtcbiB3aGlsZSAobGVuZ3RoID4gaW5kZXgpXG4gIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuIHJldHVybiByZXN1bHQ7XG59LCBGT1JDRUQpO1xuXG4vKioqLyB9KSxcbi8qIDExNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExNSk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExKTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk1KTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI2KTtcbnZhciByZWRlZmluZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjkpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNykuZjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oODIpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Nyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgdWlkID0gX193X3BkZmpzX3JlcXVpcmVfXygzOCk7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkgJiYgSW50OEFycmF5LnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IGdsb2JhbC5VaW50OENsYW1wZWRBcnJheTtcbnZhciBVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSA9IFVpbnQ4Q2xhbXBlZEFycmF5ICYmIFVpbnQ4Q2xhbXBlZEFycmF5LnByb3RvdHlwZTtcbnZhciBUeXBlZEFycmF5ID0gSW50OEFycmF5ICYmIGdldFByb3RvdHlwZU9mKEludDhBcnJheSk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEludDhBcnJheVByb3RvdHlwZSAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXlQcm90b3R5cGUpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaXNQcm90b3R5cGVPZiA9IE9iamVjdFByb3RvdHlwZS5pc1Byb3RvdHlwZU9mO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgVFlQRURfQVJSQVlfVEFHID0gdWlkKCdUWVBFRF9BUlJBWV9UQUcnKTtcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gTkFUSVZFX0FSUkFZX0JVRkZFUiAmJiAhIXNldFByb3RvdHlwZU9mICYmIGNsYXNzb2YoZ2xvYmFsLm9wZXJhKSAhPT0gJ09wZXJhJztcbnZhciBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IGZhbHNlO1xudmFyIE5BTUU7XG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QgPSB7XG4gSW50OEFycmF5OiAxLFxuIFVpbnQ4QXJyYXk6IDEsXG4gVWludDhDbGFtcGVkQXJyYXk6IDEsXG4gSW50MTZBcnJheTogMixcbiBVaW50MTZBcnJheTogMixcbiBJbnQzMkFycmF5OiA0LFxuIFVpbnQzMkFycmF5OiA0LFxuIEZsb2F0MzJBcnJheTogNCxcbiBGbG9hdDY0QXJyYXk6IDhcbn07XG52YXIgaXNWaWV3ID0gZnVuY3Rpb24gaXNWaWV3KGl0KSB7XG4gdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG4gcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnIHx8IGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcbnZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcbiByZXR1cm4gaXNPYmplY3QoaXQpICYmIGhhcyhUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwgY2xhc3NvZihpdCkpO1xufTtcbnZhciBhVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuIGlmIChpc1R5cGVkQXJyYXkoaXQpKVxuICByZXR1cm4gaXQ7XG4gdGhyb3cgVHlwZUVycm9yKCdUYXJnZXQgaXMgbm90IGEgdHlwZWQgYXJyYXknKTtcbn07XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChDKSB7XG4gaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gIGlmIChpc1Byb3RvdHlwZU9mLmNhbGwoVHlwZWRBcnJheSwgQykpXG4gICByZXR1cm4gQztcbiB9IGVsc2VcbiAgZm9yICh2YXIgQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpXG4gICBpZiAoaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBOQU1FKSkge1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxbQVJSQVldO1xuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgKEMgPT09IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB8fCBpc1Byb3RvdHlwZU9mLmNhbGwoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBDKSkpIHtcbiAgICAgcmV0dXJuIEM7XG4gICAgfVxuICAgfVxuIHRocm93IFR5cGVFcnJvcignVGFyZ2V0IGlzIG5vdCBhIHR5cGVkIGFycmF5IGNvbnN0cnVjdG9yJyk7XG59O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XG4gaWYgKCFERVNDUklQVE9SUylcbiAgcmV0dXJuO1xuIGlmIChmb3JjZWQpXG4gIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICB2YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIEtFWSkpIHtcbiAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZVtLRVldO1xuICAgfVxuICB9XG4gaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlW0tFWV0gfHwgZm9yY2VkKSB7XG4gIHJlZGVmaW5lKFR5cGVkQXJyYXlQcm90b3R5cGUsIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheVByb3RvdHlwZVtLRVldIHx8IHByb3BlcnR5KTtcbiB9XG59O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XG4gdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gaWYgKCFERVNDUklQVE9SUylcbiAgcmV0dXJuO1xuIGlmIChzZXRQcm90b3R5cGVPZikge1xuICBpZiAoZm9yY2VkKVxuICAgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKSB7XG4gICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3JbS0VZXTtcbiAgICB9XG4gICB9XG4gIGlmICghVHlwZWRBcnJheVtLRVldIHx8IGZvcmNlZCkge1xuICAgdHJ5IHtcbiAgICByZXR1cm4gcmVkZWZpbmUoVHlwZWRBcnJheSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eSA6IE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgSW50OEFycmF5W0tFWV0gfHwgcHJvcGVydHkpO1xuICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgIH1cbiAgfSBlbHNlXG4gICByZXR1cm47XG4gfVxuIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoIVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldIHx8IGZvcmNlZCkpIHtcbiAgIHJlZGVmaW5lKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZLCBwcm9wZXJ0eSk7XG4gIH1cbiB9XG59O1xuZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gaWYgKCFnbG9iYWxbTkFNRV0pXG4gIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBmYWxzZTtcbn1cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCB0eXBlb2YgVHlwZWRBcnJheSAhPSAnZnVuY3Rpb24nIHx8IFR5cGVkQXJyYXkgPT09IEZ1bmN0aW9uLnByb3RvdHlwZSkge1xuIFR5cGVkQXJyYXkgPSBmdW5jdGlvbiBUeXBlZEFycmF5KCkge1xuICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBpbnZvY2F0aW9uJyk7XG4gfTtcbiBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUylcbiAgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICBpZiAoZ2xvYmFsW05BTUVdKVxuICAgIHNldFByb3RvdHlwZU9mKGdsb2JhbFtOQU1FXSwgVHlwZWRBcnJheSk7XG4gIH1cbn1cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhVHlwZWRBcnJheVByb3RvdHlwZSB8fCBUeXBlZEFycmF5UHJvdG90eXBlID09PSBPYmplY3RQcm90b3R5cGUpIHtcbiBUeXBlZEFycmF5UHJvdG90eXBlID0gVHlwZWRBcnJheS5wcm90b3R5cGU7XG4gaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpXG4gIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgaWYgKGdsb2JhbFtOQU1FXSlcbiAgICBzZXRQcm90b3R5cGVPZihnbG9iYWxbTkFNRV0ucHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcbiAgfVxufVxuaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgJiYgZ2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUpICE9PSBUeXBlZEFycmF5UHJvdG90eXBlKSB7XG4gc2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xufVxuaWYgKERFU0NSSVBUT1JTICYmICFoYXMoVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRykpIHtcbiBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IHRydWU7XG4gZGVmaW5lUHJvcGVydHkoVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiBpc09iamVjdCh0aGlzKSA/IHRoaXNbVFlQRURfQVJSQVlfVEFHXSA6IHVuZGVmaW5lZDtcbiAgfVxuIH0pO1xuIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdClcbiAgaWYgKGdsb2JhbFtOQU1FXSkge1xuICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGdsb2JhbFtOQU1FXSwgVFlQRURfQVJSQVlfVEFHLCBOQU1FKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUzogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyxcbiBUWVBFRF9BUlJBWV9UQUc6IFRZUEVEX0FSUkFZX1RBR19SRVFJUkVEICYmIFRZUEVEX0FSUkFZX1RBRyxcbiBhVHlwZWRBcnJheTogYVR5cGVkQXJyYXksXG4gYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiBleHBvcnRUeXBlZEFycmF5TWV0aG9kOiBleHBvcnRUeXBlZEFycmF5TWV0aG9kLFxuIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QsXG4gaXNWaWV3OiBpc1ZpZXcsXG4gaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG4gVHlwZWRBcnJheTogVHlwZWRBcnJheSxcbiBUeXBlZEFycmF5UHJvdG90eXBlOiBUeXBlZEFycmF5UHJvdG90eXBlXG59O1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIERhdGFWaWV3ICE9PSAndW5kZWZpbmVkJztcblxuLyoqKi8gfSksXG4vKiAxMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgYUZ1bmN0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Myk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgZGVmYXVsdENvbnN0cnVjdG9yKSB7XG4gdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiB2YXIgUztcbiByZXR1cm4gQyA9PT0gdW5kZWZpbmVkIHx8IChTID0gYW5PYmplY3QoQylbU1BFQ0lFU10pID09IHVuZGVmaW5lZCA/IGRlZmF1bHRDb25zdHJ1Y3RvciA6IGFGdW5jdGlvbihTKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTE4KTtcbl9fd19wZGZqc19yZXF1aXJlX18oNzcpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjApO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjIpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMzYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMzcpO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5Qcm9taXNlO1xuXG4vKioqLyB9KSxcbi8qIDExOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgVE9fU1RSSU5HX1RBR19TVVBQT1JUID0gX193X3BkZmpzX3JlcXVpcmVfXyg5Nik7XG52YXIgcmVkZWZpbmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciB0b1N0cmluZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE5KTtcbmlmICghVE9fU1RSSU5HX1RBR19TVVBQT1JUKSB7XG4gcmVkZWZpbmUoT2JqZWN0LnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG4vKioqLyB9KSxcbi8qIDExOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd19wZGZqc19yZXF1aXJlX18oOTYpO1xudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk1KTtcbm1vZHVsZS5leHBvcnRzID0gVE9fU1RSSU5HX1RBR19TVVBQT1JUID8ge30udG9TdHJpbmcgOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgRE9NSXRlcmFibGVzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjEpO1xudmFyIEFycmF5SXRlcmF0b3JNZXRob2RzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTcpO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5mb3IgKHZhciBDT0xMRUNUSU9OX05BTUUgaW4gRE9NSXRlcmFibGVzKSB7XG4gdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXTtcbiB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gaWYgKENvbGxlY3Rpb25Qcm90b3R5cGUpIHtcbiAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdICE9PSBBcnJheVZhbHVlcylcbiAgIHRyeSB7XG4gICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICB9IGNhdGNoIChlcnJvcikge1xuICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICB9XG4gIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkge1xuICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KENvbGxlY3Rpb25Qcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIENPTExFQ1RJT05fTkFNRSk7XG4gIH1cbiAgaWYgKERPTUl0ZXJhYmxlc1tDT0xMRUNUSU9OX05BTUVdKVxuICAgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZVtNRVRIT0RfTkFNRV0gIT09IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSlcbiAgICAgdHJ5IHtcbiAgICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShDb2xsZWN0aW9uUHJvdG90eXBlLCBNRVRIT0RfTkFNRSwgQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdKTtcbiAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdID0gQXJyYXlJdGVyYXRvck1ldGhvZHNbTUVUSE9EX05BTUVdO1xuICAgICB9XG4gICB9XG4gfVxufVxuXG4vKioqLyB9KSxcbi8qIDEyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiBDU1NSdWxlTGlzdDogMCxcbiBDU1NTdHlsZURlY2xhcmF0aW9uOiAwLFxuIENTU1ZhbHVlTGlzdDogMCxcbiBDbGllbnRSZWN0TGlzdDogMCxcbiBET01SZWN0TGlzdDogMCxcbiBET01TdHJpbmdMaXN0OiAwLFxuIERPTVRva2VuTGlzdDogMSxcbiBEYXRhVHJhbnNmZXJJdGVtTGlzdDogMCxcbiBGaWxlTGlzdDogMCxcbiBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiBIVE1MQ29sbGVjdGlvbjogMCxcbiBIVE1MRm9ybUVsZW1lbnQ6IDAsXG4gSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gTWVkaWFMaXN0OiAwLFxuIE1pbWVUeXBlQXJyYXk6IDAsXG4gTmFtZWROb2RlTWFwOiAwLFxuIE5vZGVMaXN0OiAxLFxuIFBhaW50UmVxdWVzdExpc3Q6IDAsXG4gUGx1Z2luOiAwLFxuIFBsdWdpbkFycmF5OiAwLFxuIFNWR0xlbmd0aExpc3Q6IDAsXG4gU1ZHTnVtYmVyTGlzdDogMCxcbiBTVkdQYXRoU2VnTGlzdDogMCxcbiBTVkdQb2ludExpc3Q6IDAsXG4gU1ZHU3RyaW5nTGlzdDogMCxcbiBTVkdUcmFuc2Zvcm1MaXN0OiAwLFxuIFNvdXJjZUJ1ZmZlckxpc3Q6IDAsXG4gU3R5bGVTaGVldExpc3Q6IDAsXG4gVGV4dFRyYWNrQ3VlTGlzdDogMCxcbiBUZXh0VHJhY2tMaXN0OiAwLFxuIFRvdWNoTGlzdDogMFxufTtcblxuLyoqKi8gfSksXG4vKiAxMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgSVNfUFVSRSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQyKTtcbnZhciBOYXRpdmVQcm9taXNlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjMpO1xudmFyIHJlZGVmaW5lID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG52YXIgcmVkZWZpbmVBbGwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNCk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg1KTtcbnZhciBzZXRTcGVjaWVzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjUpO1xudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgYUZ1bmN0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Myk7XG52YXIgYW5JbnN0YW5jZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI2KTtcbnZhciBjbGFzc29mID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzEpO1xudmFyIGl0ZXJhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwNCk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXyg5Nyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTYpO1xudmFyIHRhc2sgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNykuc2V0O1xudmFyIG1pY3JvdGFzayA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMwKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMxKTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzMpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzIpO1xudmFyIHBlcmZvcm0gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzNCk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzMpO1xudmFyIGlzRm9yY2VkID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Mik7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgVjhfVkVSU0lPTiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTM1KTtcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgUFJPTUlTRSA9ICdQcm9taXNlJztcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsUHJvbWlzZVN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoUFJPTUlTRSk7XG52YXIgUHJvbWlzZUNvbnN0cnVjdG9yID0gTmF0aXZlUHJvbWlzZTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciAkZmV0Y2ggPSBnZXRCdWlsdEluKCdmZXRjaCcpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZjtcbnZhciBuZXdHZW5lcmljUHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eTtcbnZhciBJU19OT0RFID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG52YXIgRElTUEFUQ0hfRVZFTlQgPSAhIShkb2N1bWVudCAmJiBkb2N1bWVudC5jcmVhdGVFdmVudCAmJiBnbG9iYWwuZGlzcGF0Y2hFdmVudCk7XG52YXIgVU5IQU5ETEVEX1JFSkVDVElPTiA9ICd1bmhhbmRsZWRyZWplY3Rpb24nO1xudmFyIFJFSkVDVElPTl9IQU5ETEVEID0gJ3JlamVjdGlvbmhhbmRsZWQnO1xudmFyIFBFTkRJTkcgPSAwO1xudmFyIEZVTEZJTExFRCA9IDE7XG52YXIgUkVKRUNURUQgPSAyO1xudmFyIEhBTkRMRUQgPSAxO1xudmFyIFVOSEFORExFRCA9IDI7XG52YXIgSW50ZXJuYWwsIE93blByb21pc2VDYXBhYmlsaXR5LCBQcm9taXNlV3JhcHBlciwgbmF0aXZlVGhlbjtcbnZhciBGT1JDRUQgPSBpc0ZvcmNlZChQUk9NSVNFLCBmdW5jdGlvbiAoKSB7XG4gdmFyIEdMT0JBTF9DT1JFX0pTX1BST01JU0UgPSBpbnNwZWN0U291cmNlKFByb21pc2VDb25zdHJ1Y3RvcikgIT09IFN0cmluZyhQcm9taXNlQ29uc3RydWN0b3IpO1xuIGlmICghR0xPQkFMX0NPUkVfSlNfUFJPTUlTRSkge1xuICBpZiAoVjhfVkVSU0lPTiA9PT0gNjYpXG4gICByZXR1cm4gdHJ1ZTtcbiAgaWYgKCFJU19OT0RFICYmIHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgIT0gJ2Z1bmN0aW9uJylcbiAgIHJldHVybiB0cnVlO1xuIH1cbiBpZiAoSVNfUFVSRSAmJiAhUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZVsnZmluYWxseSddKVxuICByZXR1cm4gdHJ1ZTtcbiBpZiAoVjhfVkVSU0lPTiA+PSA1MSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoUHJvbWlzZUNvbnN0cnVjdG9yKSlcbiAgcmV0dXJuIGZhbHNlO1xuIHZhciBwcm9taXNlID0gUHJvbWlzZUNvbnN0cnVjdG9yLnJlc29sdmUoMSk7XG4gdmFyIEZha2VQcm9taXNlID0gZnVuY3Rpb24gKGV4ZWMpIHtcbiAgZXhlYyhmdW5jdGlvbiAoKSB7XG4gIH0sIGZ1bmN0aW9uICgpIHtcbiAgfSk7XG4gfTtcbiB2YXIgY29uc3RydWN0b3IgPSBwcm9taXNlLmNvbnN0cnVjdG9yID0ge307XG4gY29uc3RydWN0b3JbU1BFQ0lFU10gPSBGYWtlUHJvbWlzZTtcbiByZXR1cm4gIShwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuIH0pIGluc3RhbmNlb2YgRmFrZVByb21pc2UpO1xufSk7XG52YXIgSU5DT1JSRUNUX0lURVJBVElPTiA9IEZPUkNFRCB8fCAhY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuIFByb21pc2VDb25zdHJ1Y3Rvci5hbGwoaXRlcmFibGUpWydjYXRjaCddKGZ1bmN0aW9uICgpIHtcbiB9KTtcbn0pO1xudmFyIGlzVGhlbmFibGUgPSBmdW5jdGlvbiAoaXQpIHtcbiB2YXIgdGhlbjtcbiByZXR1cm4gaXNPYmplY3QoaXQpICYmIHR5cGVvZiAodGhlbiA9IGl0LnRoZW4pID09ICdmdW5jdGlvbicgPyB0aGVuIDogZmFsc2U7XG59O1xudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgaXNSZWplY3QpIHtcbiBpZiAoc3RhdGUubm90aWZpZWQpXG4gIHJldHVybjtcbiBzdGF0ZS5ub3RpZmllZCA9IHRydWU7XG4gdmFyIGNoYWluID0gc3RhdGUucmVhY3Rpb25zO1xuIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICB2YXIgb2sgPSBzdGF0ZS5zdGF0ZSA9PSBGVUxGSUxMRUQ7XG4gIHZhciBpbmRleCA9IDA7XG4gIHdoaWxlIChjaGFpbi5sZW5ndGggPiBpbmRleCkge1xuICAgdmFyIHJlYWN0aW9uID0gY2hhaW5baW5kZXgrK107XG4gICB2YXIgaGFuZGxlciA9IG9rID8gcmVhY3Rpb24ub2sgOiByZWFjdGlvbi5mYWlsO1xuICAgdmFyIHJlc29sdmUgPSByZWFjdGlvbi5yZXNvbHZlO1xuICAgdmFyIHJlamVjdCA9IHJlYWN0aW9uLnJlamVjdDtcbiAgIHZhciBkb21haW4gPSByZWFjdGlvbi5kb21haW47XG4gICB2YXIgcmVzdWx0LCB0aGVuLCBleGl0ZWQ7XG4gICB0cnkge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgIGlmICghb2spIHtcbiAgICAgIGlmIChzdGF0ZS5yZWplY3Rpb24gPT09IFVOSEFORExFRClcbiAgICAgICBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlLCBzdGF0ZSk7XG4gICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICB9XG4gICAgIGlmIChoYW5kbGVyID09PSB0cnVlKVxuICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgIGVsc2Uge1xuICAgICAgaWYgKGRvbWFpbilcbiAgICAgICBkb21haW4uZW50ZXIoKTtcbiAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpO1xuICAgICAgaWYgKGRvbWFpbikge1xuICAgICAgIGRvbWFpbi5leGl0KCk7XG4gICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgfVxuICAgICBpZiAocmVzdWx0ID09PSByZWFjdGlvbi5wcm9taXNlKSB7XG4gICAgICByZWplY3QoVHlwZUVycm9yKCdQcm9taXNlLWNoYWluIGN5Y2xlJykpO1xuICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgIH0gZWxzZVxuICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgIH0gZWxzZVxuICAgICByZWplY3QodmFsdWUpO1xuICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpXG4gICAgIGRvbWFpbi5leGl0KCk7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgIH1cbiAgfVxuICBzdGF0ZS5yZWFjdGlvbnMgPSBbXTtcbiAgc3RhdGUubm90aWZpZWQgPSBmYWxzZTtcbiAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pXG4gICBvblVuaGFuZGxlZChwcm9taXNlLCBzdGF0ZSk7XG4gfSk7XG59O1xudmFyIGRpc3BhdGNoRXZlbnQgPSBmdW5jdGlvbiAobmFtZSwgcHJvbWlzZSwgcmVhc29uKSB7XG4gdmFyIGV2ZW50LCBoYW5kbGVyO1xuIGlmIChESVNQQVRDSF9FVkVOVCkge1xuICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICBldmVudC5wcm9taXNlID0gcHJvbWlzZTtcbiAgZXZlbnQucmVhc29uID0gcmVhc29uO1xuICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICBnbG9iYWwuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gfSBlbHNlXG4gIGV2ZW50ID0ge1xuICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgIHJlYXNvbjogcmVhc29uXG4gIH07XG4gaWYgKGhhbmRsZXIgPSBnbG9iYWxbJ29uJyArIG5hbWVdKVxuICBoYW5kbGVyKGV2ZW50KTtcbiBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKVxuICBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcbnZhciBvblVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSkge1xuIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgdmFyIHZhbHVlID0gc3RhdGUudmFsdWU7XG4gIHZhciBJU19VTkhBTkRMRUQgPSBpc1VuaGFuZGxlZChzdGF0ZSk7XG4gIHZhciByZXN1bHQ7XG4gIGlmIChJU19VTkhBTkRMRUQpIHtcbiAgIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgIGlmIChJU19OT0RFKSB7XG4gICAgIHByb2Nlc3MuZW1pdCgndW5oYW5kbGVkUmVqZWN0aW9uJywgdmFsdWUsIHByb21pc2UpO1xuICAgIH0gZWxzZVxuICAgICBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgIH0pO1xuICAgc3RhdGUucmVqZWN0aW9uID0gSVNfTk9ERSB8fCBpc1VuaGFuZGxlZChzdGF0ZSkgPyBVTkhBTkRMRUQgOiBIQU5ETEVEO1xuICAgaWYgKHJlc3VsdC5lcnJvcilcbiAgICB0aHJvdyByZXN1bHQudmFsdWU7XG4gIH1cbiB9KTtcbn07XG52YXIgaXNVbmhhbmRsZWQgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiByZXR1cm4gc3RhdGUucmVqZWN0aW9uICE9PSBIQU5ETEVEICYmICFzdGF0ZS5wYXJlbnQ7XG59O1xudmFyIG9uSGFuZGxlVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlKSB7XG4gdGFzay5jYWxsKGdsb2JhbCwgZnVuY3Rpb24gKCkge1xuICBpZiAoSVNfTk9ERSkge1xuICAgcHJvY2Vzcy5lbWl0KCdyZWplY3Rpb25IYW5kbGVkJywgcHJvbWlzZSk7XG4gIH0gZWxzZVxuICAgZGlzcGF0Y2hFdmVudChSRUpFQ1RJT05fSEFORExFRCwgcHJvbWlzZSwgc3RhdGUudmFsdWUpO1xuIH0pO1xufTtcbnZhciBiaW5kID0gZnVuY3Rpb24gKGZuLCBwcm9taXNlLCBzdGF0ZSwgdW53cmFwKSB7XG4gcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICBmbihwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCk7XG4gfTtcbn07XG52YXIgaW50ZXJuYWxSZWplY3QgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiBpZiAoc3RhdGUuZG9uZSlcbiAgcmV0dXJuO1xuIHN0YXRlLmRvbmUgPSB0cnVlO1xuIGlmICh1bndyYXApXG4gIHN0YXRlID0gdW53cmFwO1xuIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gc3RhdGUuc3RhdGUgPSBSRUpFQ1RFRDtcbiBub3RpZnkocHJvbWlzZSwgc3RhdGUsIHRydWUpO1xufTtcbnZhciBpbnRlcm5hbFJlc29sdmUgPSBmdW5jdGlvbiAocHJvbWlzZSwgc3RhdGUsIHZhbHVlLCB1bndyYXApIHtcbiBpZiAoc3RhdGUuZG9uZSlcbiAgcmV0dXJuO1xuIHN0YXRlLmRvbmUgPSB0cnVlO1xuIGlmICh1bndyYXApXG4gIHN0YXRlID0gdW53cmFwO1xuIHRyeSB7XG4gIGlmIChwcm9taXNlID09PSB2YWx1ZSlcbiAgIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICB2YXIgdGhlbiA9IGlzVGhlbmFibGUodmFsdWUpO1xuICBpZiAodGhlbikge1xuICAgbWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgd3JhcHBlciA9IHsgZG9uZTogZmFsc2UgfTtcbiAgICB0cnkge1xuICAgICB0aGVuLmNhbGwodmFsdWUsIGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSksIGJpbmQoaW50ZXJuYWxSZWplY3QsIHByb21pc2UsIHdyYXBwZXIsIHN0YXRlKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgaW50ZXJuYWxSZWplY3QocHJvbWlzZSwgd3JhcHBlciwgZXJyb3IsIHN0YXRlKTtcbiAgICB9XG4gICB9KTtcbiAgfSBlbHNlIHtcbiAgIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gICBzdGF0ZS5zdGF0ZSA9IEZVTEZJTExFRDtcbiAgIG5vdGlmeShwcm9taXNlLCBzdGF0ZSwgZmFsc2UpO1xuICB9XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgaW50ZXJuYWxSZWplY3QocHJvbWlzZSwgeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuIH1cbn07XG5pZiAoRk9SQ0VEKSB7XG4gUHJvbWlzZUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICBhbkluc3RhbmNlKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvciwgUFJPTUlTRSk7XG4gIGFGdW5jdGlvbihleGVjdXRvcik7XG4gIEludGVybmFsLmNhbGwodGhpcyk7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHRyeSB7XG4gICBleGVjdXRvcihiaW5kKGludGVybmFsUmVzb2x2ZSwgdGhpcywgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB0aGlzLCBzdGF0ZSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgaW50ZXJuYWxSZWplY3QodGhpcywgc3RhdGUsIGVycm9yKTtcbiAgfVxuIH07XG4gSW50ZXJuYWwgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgdHlwZTogUFJPTUlTRSxcbiAgIGRvbmU6IGZhbHNlLFxuICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgcGFyZW50OiBmYWxzZSxcbiAgIHJlYWN0aW9uczogW10sXG4gICByZWplY3Rpb246IGZhbHNlLFxuICAgc3RhdGU6IFBFTkRJTkcsXG4gICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xuIH07XG4gSW50ZXJuYWwucHJvdG90eXBlID0gcmVkZWZpbmVBbGwoUHJvbWlzZUNvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICB0aGVuOiBmdW5jdGlvbiB0aGVuKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFByb21pc2VTdGF0ZSh0aGlzKTtcbiAgIHZhciByZWFjdGlvbiA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IpKTtcbiAgIHJlYWN0aW9uLm9rID0gdHlwZW9mIG9uRnVsZmlsbGVkID09ICdmdW5jdGlvbicgPyBvbkZ1bGZpbGxlZCA6IHRydWU7XG4gICByZWFjdGlvbi5mYWlsID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT0gJ2Z1bmN0aW9uJyAmJiBvblJlamVjdGVkO1xuICAgcmVhY3Rpb24uZG9tYWluID0gSVNfTk9ERSA/IHByb2Nlc3MuZG9tYWluIDogdW5kZWZpbmVkO1xuICAgc3RhdGUucGFyZW50ID0gdHJ1ZTtcbiAgIHN0YXRlLnJlYWN0aW9ucy5wdXNoKHJlYWN0aW9uKTtcbiAgIGlmIChzdGF0ZS5zdGF0ZSAhPSBQRU5ESU5HKVxuICAgIG5vdGlmeSh0aGlzLCBzdGF0ZSwgZmFsc2UpO1xuICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gIH0sXG4gICdjYXRjaCc6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgb25SZWplY3RlZCk7XG4gIH1cbiB9KTtcbiBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHByb21pc2UgPSBuZXcgSW50ZXJuYWwoKTtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZShwcm9taXNlKTtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgdGhpcy5yZXNvbHZlID0gYmluZChpbnRlcm5hbFJlc29sdmUsIHByb21pc2UsIHN0YXRlKTtcbiAgdGhpcy5yZWplY3QgPSBiaW5kKGludGVybmFsUmVqZWN0LCBwcm9taXNlLCBzdGF0ZSk7XG4gfTtcbiBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gQyA9PT0gUHJvbWlzZUNvbnN0cnVjdG9yIHx8IEMgPT09IFByb21pc2VXcmFwcGVyID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpIDogbmV3R2VuZXJpY1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuIH07XG4gaWYgKCFJU19QVVJFICYmIHR5cGVvZiBOYXRpdmVQcm9taXNlID09ICdmdW5jdGlvbicpIHtcbiAgbmF0aXZlVGhlbiA9IE5hdGl2ZVByb21pc2UucHJvdG90eXBlLnRoZW47XG4gIHJlZGVmaW5lKE5hdGl2ZVByb21pc2UucHJvdG90eXBlLCAndGhlbicsIGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgIHZhciB0aGF0ID0gdGhpcztcbiAgIHJldHVybiBuZXcgUHJvbWlzZUNvbnN0cnVjdG9yKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBuYXRpdmVUaGVuLmNhbGwodGhhdCwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgIH0pLnRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICB9LCB7IHVuc2FmZTogdHJ1ZSB9KTtcbiAgaWYgKHR5cGVvZiAkZmV0Y2ggPT0gJ2Z1bmN0aW9uJylcbiAgICQoe1xuICAgIGdsb2JhbDogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGZvcmNlZDogdHJ1ZVxuICAgfSwge1xuICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaChpbnB1dCkge1xuICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoUHJvbWlzZUNvbnN0cnVjdG9yLCAkZmV0Y2guYXBwbHkoZ2xvYmFsLCBhcmd1bWVudHMpKTtcbiAgICB9XG4gICB9KTtcbiB9XG59XG4kKHtcbiBnbG9iYWw6IHRydWUsXG4gd3JhcDogdHJ1ZSxcbiBmb3JjZWQ6IEZPUkNFRFxufSwgeyBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3IgfSk7XG5zZXRUb1N0cmluZ1RhZyhQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UsIGZhbHNlLCB0cnVlKTtcbnNldFNwZWNpZXMoUFJPTUlTRSk7XG5Qcm9taXNlV3JhcHBlciA9IGdldEJ1aWx0SW4oUFJPTUlTRSk7XG4kKHtcbiB0YXJnZXQ6IFBST01JU0UsXG4gc3RhdDogdHJ1ZSxcbiBmb3JjZWQ6IEZPUkNFRFxufSwge1xuIHJlamVjdDogZnVuY3Rpb24gcmVqZWN0KHIpIHtcbiAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgY2FwYWJpbGl0eS5yZWplY3QuY2FsbCh1bmRlZmluZWQsIHIpO1xuICByZXR1cm4gY2FwYWJpbGl0eS5wcm9taXNlO1xuIH1cbn0pO1xuJCh7XG4gdGFyZ2V0OiBQUk9NSVNFLFxuIHN0YXQ6IHRydWUsXG4gZm9yY2VkOiBJU19QVVJFIHx8IEZPUkNFRFxufSwge1xuIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICByZXR1cm4gcHJvbWlzZVJlc29sdmUoSVNfUFVSRSAmJiB0aGlzID09PSBQcm9taXNlV3JhcHBlciA/IFByb21pc2VDb25zdHJ1Y3RvciA6IHRoaXMsIHgpO1xuIH1cbn0pO1xuJCh7XG4gdGFyZ2V0OiBQUk9NSVNFLFxuIHN0YXQ6IHRydWUsXG4gZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OXG59LCB7XG4gYWxsOiBmdW5jdGlvbiBhbGwoaXRlcmFibGUpIHtcbiAgdmFyIEMgPSB0aGlzO1xuICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB2YXIgcmVzb2x2ZSA9IGNhcGFiaWxpdHkucmVzb2x2ZTtcbiAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uKEMucmVzb2x2ZSk7XG4gICB2YXIgdmFsdWVzID0gW107XG4gICB2YXIgY291bnRlciA9IDA7XG4gICB2YXIgcmVtYWluaW5nID0gMTtcbiAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICByZW1haW5pbmcrKztcbiAgICAkcHJvbWlzZVJlc29sdmUuY2FsbChDLCBwcm9taXNlKS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICBpZiAoYWxyZWFkeUNhbGxlZClcbiAgICAgIHJldHVybjtcbiAgICAgYWxyZWFkeUNhbGxlZCA9IHRydWU7XG4gICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0sIHJlamVjdCk7XG4gICB9KTtcbiAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgfSk7XG4gIGlmIChyZXN1bHQuZXJyb3IpXG4gICByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiB9LFxuIHJhY2U6IGZ1bmN0aW9uIHJhY2UoaXRlcmFibGUpIHtcbiAgdmFyIEMgPSB0aGlzO1xuICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICB2YXIgcmVqZWN0ID0gY2FwYWJpbGl0eS5yZWplY3Q7XG4gIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhRnVuY3Rpb24oQy5yZXNvbHZlKTtcbiAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgJHByb21pc2VSZXNvbHZlLmNhbGwoQywgcHJvbWlzZSkudGhlbihjYXBhYmlsaXR5LnJlc29sdmUsIHJlamVjdCk7XG4gICB9KTtcbiAgfSk7XG4gIGlmIChyZXN1bHQuZXJyb3IpXG4gICByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuUHJvbWlzZTtcblxuLyoqKi8gfSksXG4vKiAxMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHJlZGVmaW5lID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuIGZvciAodmFyIGtleSBpbiBzcmMpXG4gIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzcmNba2V5XSwgb3B0aW9ucyk7XG4gcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKiovIH0pLFxuLyogMTI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2V0QnVpbHRJbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNDIpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDT05TVFJVQ1RPUl9OQU1FKSB7XG4gdmFyIENvbnN0cnVjdG9yID0gZ2V0QnVpbHRJbihDT05TVFJVQ1RPUl9OQU1FKTtcbiB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcbiAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFNQRUNJRVMsIHtcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICAgfVxuICB9KTtcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiBpZiAoIShpdCBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiB9XG4gcmV0dXJuIGl0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgY2xhc3NvZiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xudmFyIGJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYyKTtcbnZhciBodG1sID0gX193X3BkZmpzX3JlcXVpcmVfXyg3NCk7XG52YXIgY3JlYXRlRWxlbWVudCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xudmFyIElTX0lPUyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI4KTtcbnZhciBsb2NhdGlvbiA9IGdsb2JhbC5sb2NhdGlvbjtcbnZhciBzZXQgPSBnbG9iYWwuc2V0SW1tZWRpYXRlO1xudmFyIGNsZWFyID0gZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBNZXNzYWdlQ2hhbm5lbCA9IGdsb2JhbC5NZXNzYWdlQ2hhbm5lbDtcbnZhciBEaXNwYXRjaCA9IGdsb2JhbC5EaXNwYXRjaDtcbnZhciBjb3VudGVyID0gMDtcbnZhciBxdWV1ZSA9IHt9O1xudmFyIE9OUkVBRFlTVEFURUNIQU5HRSA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xudmFyIGRlZmVyLCBjaGFubmVsLCBwb3J0O1xudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgdmFyIGZuID0gcXVldWVbaWRdO1xuICBkZWxldGUgcXVldWVbaWRdO1xuICBmbigpO1xuIH1cbn07XG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgcnVuKGlkKTtcbiB9O1xufTtcbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuIHJ1bihldmVudC5kYXRhKTtcbn07XG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuIGdsb2JhbC5wb3N0TWVzc2FnZShpZCArICcnLCBsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0KTtcbn07XG5pZiAoIXNldCB8fCAhY2xlYXIpIHtcbiBzZXQgPSBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoZm4pIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgdmFyIGkgPSAxO1xuICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGkpXG4gICBhcmdzLnB1c2goYXJndW1lbnRzW2krK10pO1xuICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgKHR5cGVvZiBmbiA9PSAnZnVuY3Rpb24nID8gZm4gOiBGdW5jdGlvbihmbikpLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gIH07XG4gIGRlZmVyKGNvdW50ZXIpO1xuICByZXR1cm4gY291bnRlcjtcbiB9O1xuIGNsZWFyID0gZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaWQpIHtcbiAgZGVsZXRlIHF1ZXVlW2lkXTtcbiB9O1xuIGlmIChjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgcHJvY2Vzcy5uZXh0VGljayhydW5uZXIoaWQpKTtcbiAgfTtcbiB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICBkZWZlciA9IGZ1bmN0aW9uIChpZCkge1xuICAgRGlzcGF0Y2gubm93KHJ1bm5lcihpZCkpO1xuICB9O1xuIH0gZWxzZSBpZiAoTWVzc2FnZUNoYW5uZWwgJiYgIUlTX0lPUykge1xuICBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGxpc3RlbmVyO1xuICBkZWZlciA9IGJpbmQocG9ydC5wb3N0TWVzc2FnZSwgcG9ydCwgMSk7XG4gfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMgJiYgIWZhaWxzKHBvc3QpICYmIGxvY2F0aW9uLnByb3RvY29sICE9PSAnZmlsZTonKSB7XG4gIGRlZmVyID0gcG9zdDtcbiAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBsaXN0ZW5lciwgZmFsc2UpO1xuIH0gZWxzZSBpZiAoT05SRUFEWVNUQVRFQ0hBTkdFIGluIGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKSB7XG4gIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICBodG1sLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgIGh0bWwucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgcnVuKGlkKTtcbiAgIH07XG4gIH07XG4gfSBlbHNlIHtcbiAgZGVmZXIgPSBmdW5jdGlvbiAoaWQpIHtcbiAgIHNldFRpbWVvdXQocnVubmVyKGlkKSwgMCk7XG4gIH07XG4gfVxufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gc2V0OiBzZXQsXG4gY2xlYXI6IGNsZWFyXG59O1xuXG4vKioqLyB9KSxcbi8qIDEyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgdXNlckFnZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjkpO1xubW9kdWxlLmV4cG9ydHMgPSAvKGlwaG9uZXxpcG9kfGlwYWQpLiphcHBsZXdlYmtpdC9pLnRlc3QodXNlckFnZW50KTtcblxuLyoqKi8gfSksXG4vKiAxMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQyKTtcbm1vZHVsZS5leHBvcnRzID0gZ2V0QnVpbHRJbignbmF2aWdhdG9yJywgJ3VzZXJBZ2VudCcpIHx8ICcnO1xuXG4vKioqLyB9KSxcbi8qIDEzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxMikuZjtcbnZhciBjbGFzc29mID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG52YXIgbWFjcm90YXNrID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjcpLnNldDtcbnZhciBJU19JT1MgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyOCk7XG52YXIgTXV0YXRpb25PYnNlcnZlciA9IGdsb2JhbC5NdXRhdGlvbk9ic2VydmVyIHx8IGdsb2JhbC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciBQcm9taXNlID0gZ2xvYmFsLlByb21pc2U7XG52YXIgSVNfTk9ERSA9IGNsYXNzb2YocHJvY2VzcykgPT0gJ3Byb2Nlc3MnO1xudmFyIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihnbG9iYWwsICdxdWV1ZU1pY3JvdGFzaycpO1xudmFyIHF1ZXVlTWljcm90YXNrID0gcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yICYmIHF1ZXVlTWljcm90YXNrRGVzY3JpcHRvci52YWx1ZTtcbnZhciBmbHVzaCwgaGVhZCwgbGFzdCwgbm90aWZ5LCB0b2dnbGUsIG5vZGUsIHByb21pc2UsIHRoZW47XG5pZiAoIXF1ZXVlTWljcm90YXNrKSB7XG4gZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBwYXJlbnQsIGZuO1xuICBpZiAoSVNfTk9ERSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKVxuICAgcGFyZW50LmV4aXQoKTtcbiAgd2hpbGUgKGhlYWQpIHtcbiAgIGZuID0gaGVhZC5mbjtcbiAgIGhlYWQgPSBoZWFkLm5leHQ7XG4gICB0cnkge1xuICAgIGZuKCk7XG4gICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChoZWFkKVxuICAgICBub3RpZnkoKTtcbiAgICBlbHNlXG4gICAgIGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgdGhyb3cgZXJyb3I7XG4gICB9XG4gIH1cbiAgbGFzdCA9IHVuZGVmaW5lZDtcbiAgaWYgKHBhcmVudClcbiAgIHBhcmVudC5lbnRlcigpO1xuIH07XG4gaWYgKElTX05PREUpIHtcbiAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgcHJvY2Vzcy5uZXh0VGljayhmbHVzaCk7XG4gIH07XG4gfSBlbHNlIGlmIChNdXRhdGlvbk9ic2VydmVyICYmICFJU19JT1MpIHtcbiAgdG9nZ2xlID0gdHJ1ZTtcbiAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZmx1c2gpLm9ic2VydmUobm9kZSwgeyBjaGFyYWN0ZXJEYXRhOiB0cnVlIH0pO1xuICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICBub2RlLmRhdGEgPSB0b2dnbGUgPSAhdG9nZ2xlO1xuICB9O1xuIH0gZWxzZSBpZiAoUHJvbWlzZSAmJiBQcm9taXNlLnJlc29sdmUpIHtcbiAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh1bmRlZmluZWQpO1xuICB0aGVuID0gcHJvbWlzZS50aGVuO1xuICBub3RpZnkgPSBmdW5jdGlvbiAoKSB7XG4gICB0aGVuLmNhbGwocHJvbWlzZSwgZmx1c2gpO1xuICB9O1xuIH0gZWxzZSB7XG4gIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgIG1hY3JvdGFzay5jYWxsKGdsb2JhbCwgZmx1c2gpO1xuICB9O1xuIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gcXVldWVNaWNyb3Rhc2sgfHwgZnVuY3Rpb24gKGZuKSB7XG4gdmFyIHRhc2sgPSB7XG4gIGZuOiBmbixcbiAgbmV4dDogdW5kZWZpbmVkXG4gfTtcbiBpZiAobGFzdClcbiAgbGFzdC5uZXh0ID0gdGFzaztcbiBpZiAoIWhlYWQpIHtcbiAgaGVhZCA9IHRhc2s7XG4gIG5vdGlmeSgpO1xuIH1cbiBsYXN0ID0gdGFzaztcbn07XG5cbi8qKiovIH0pLFxuLyogMTMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzMik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChDLCB4KSB7XG4gYW5PYmplY3QoQyk7XG4gaWYgKGlzT2JqZWN0KHgpICYmIHguY29uc3RydWN0b3IgPT09IEMpXG4gIHJldHVybiB4O1xuIHZhciBwcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5LmYoQyk7XG4gdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuIHJlc29sdmUoeCk7XG4gcmV0dXJuIHByb21pc2VDYXBhYmlsaXR5LnByb21pc2U7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFGdW5jdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNjMpO1xudmFyIFByb21pc2VDYXBhYmlsaXR5ID0gZnVuY3Rpb24gKEMpIHtcbiB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuIHRoaXMucHJvbWlzZSA9IG5ldyBDKGZ1bmN0aW9uICgkJHJlc29sdmUsICQkcmVqZWN0KSB7XG4gIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpXG4gICB0aHJvdyBUeXBlRXJyb3IoJ0JhZCBQcm9taXNlIGNvbnN0cnVjdG9yJyk7XG4gIHJlc29sdmUgPSAkJHJlc29sdmU7XG4gIHJlamVjdCA9ICQkcmVqZWN0O1xuIH0pO1xuIHRoaXMucmVzb2x2ZSA9IGFGdW5jdGlvbihyZXNvbHZlKTtcbiB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuIHJldHVybiBuZXcgUHJvbWlzZUNhcGFiaWxpdHkoQyk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gdmFyIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZTtcbiBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gdHJ5IHtcbiAgcmV0dXJuIHtcbiAgIGVycm9yOiBmYWxzZSxcbiAgIHZhbHVlOiBleGVjKClcbiAgfTtcbiB9IGNhdGNoIChlcnJvcikge1xuICByZXR1cm4ge1xuICAgZXJyb3I6IHRydWUsXG4gICB2YWx1ZTogZXJyb3JcbiAgfTtcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgdXNlckFnZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjkpO1xudmFyIHByb2Nlc3MgPSBnbG9iYWwucHJvY2VzcztcbnZhciB2ZXJzaW9ucyA9IHByb2Nlc3MgJiYgcHJvY2Vzcy52ZXJzaW9ucztcbnZhciB2OCA9IHZlcnNpb25zICYmIHZlcnNpb25zLnY4O1xudmFyIG1hdGNoLCB2ZXJzaW9uO1xuaWYgKHY4KSB7XG4gbWF0Y2ggPSB2OC5zcGxpdCgnLicpO1xuIHZlcnNpb24gPSBtYXRjaFswXSArIG1hdGNoWzFdO1xufSBlbHNlIGlmICh1c2VyQWdlbnQpIHtcbiBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICBpZiAobWF0Y2gpXG4gICB2ZXJzaW9uID0gbWF0Y2hbMV07XG4gfVxufVxubW9kdWxlLmV4cG9ydHMgPSB2ZXJzaW9uICYmICt2ZXJzaW9uO1xuXG4vKioqLyB9KSxcbi8qIDEzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBhRnVuY3Rpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYzKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMyKTtcbnZhciBwZXJmb3JtID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzQpO1xudmFyIGl0ZXJhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwNCk7XG4kKHtcbiB0YXJnZXQ6ICdQcm9taXNlJyxcbiBzdGF0OiB0cnVlXG59LCB7XG4gYWxsU2V0dGxlZDogZnVuY3Rpb24gYWxsU2V0dGxlZChpdGVyYWJsZSkge1xuICB2YXIgQyA9IHRoaXM7XG4gIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHlNb2R1bGUuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBjYXBhYmlsaXR5LnJlc29sdmU7XG4gIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgdmFyIHJlc3VsdCA9IHBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgdmFyIHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uKEMucmVzb2x2ZSk7XG4gICB2YXIgdmFsdWVzID0gW107XG4gICB2YXIgY291bnRlciA9IDA7XG4gICB2YXIgcmVtYWluaW5nID0gMTtcbiAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgdmFyIGluZGV4ID0gY291bnRlcisrO1xuICAgIHZhciBhbHJlYWR5Q2FsbGVkID0gZmFsc2U7XG4gICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICByZW1haW5pbmcrKztcbiAgICBwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgIGlmIChhbHJlYWR5Q2FsbGVkKVxuICAgICAgcmV0dXJuO1xuICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgdmFsdWVzW2luZGV4XSA9IHtcbiAgICAgIHN0YXR1czogJ2Z1bGZpbGxlZCcsXG4gICAgICB2YWx1ZTogdmFsdWVcbiAgICAgfTtcbiAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgIH0sIGZ1bmN0aW9uIChlKSB7XG4gICAgIGlmIChhbHJlYWR5Q2FsbGVkKVxuICAgICAgcmV0dXJuO1xuICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgdmFsdWVzW2luZGV4XSA9IHtcbiAgICAgIHN0YXR1czogJ3JlamVjdGVkJyxcbiAgICAgIHJlYXNvbjogZVxuICAgICB9O1xuICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICB9KTtcbiAgIC0tcmVtYWluaW5nIHx8IHJlc29sdmUodmFsdWVzKTtcbiAgfSk7XG4gIGlmIChyZXN1bHQuZXJyb3IpXG4gICByZWplY3QocmVzdWx0LnZhbHVlKTtcbiAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgSVNfUFVSRSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xudmFyIE5hdGl2ZVByb21pc2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Mik7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTYpO1xudmFyIHByb21pc2VSZXNvbHZlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzEpO1xudmFyIHJlZGVmaW5lID0gX193X3BkZmpzX3JlcXVpcmVfXygyOSk7XG52YXIgTk9OX0dFTkVSSUMgPSAhIU5hdGl2ZVByb21pc2UgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuIE5hdGl2ZVByb21pc2UucHJvdG90eXBlWydmaW5hbGx5J10uY2FsbCh7XG4gIHRoZW46IGZ1bmN0aW9uICgpIHtcbiAgfVxuIH0sIGZ1bmN0aW9uICgpIHtcbiB9KTtcbn0pO1xuJCh7XG4gdGFyZ2V0OiAnUHJvbWlzZScsXG4gcHJvdG86IHRydWUsXG4gcmVhbDogdHJ1ZSxcbiBmb3JjZWQ6IE5PTl9HRU5FUklDXG59LCB7XG4gJ2ZpbmFsbHknOiBmdW5jdGlvbiAob25GaW5hbGx5KSB7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIGdldEJ1aWx0SW4oJ1Byb21pc2UnKSk7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICByZXR1cm4gdGhpcy50aGVuKGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoeCkge1xuICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geDtcbiAgIH0pO1xuICB9IDogb25GaW5hbGx5LCBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKGUpIHtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShDLCBvbkZpbmFsbHkoKSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgZTtcbiAgIH0pO1xuICB9IDogb25GaW5hbGx5KTtcbiB9XG59KTtcbmlmICghSVNfUFVSRSAmJiB0eXBlb2YgTmF0aXZlUHJvbWlzZSA9PSAnZnVuY3Rpb24nICYmICFOYXRpdmVQcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddKSB7XG4gcmVkZWZpbmUoTmF0aXZlUHJvbWlzZS5wcm90b3R5cGUsICdmaW5hbGx5JywgZ2V0QnVpbHRJbignUHJvbWlzZScpLnByb3RvdHlwZVsnZmluYWxseSddKTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXygxMzkpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDQpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDIpO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5VUkw7XG5cbi8qKiovIH0pLFxuLyogMTM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDc3KTtcbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQwKTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Mik7XG52YXIgcmVkZWZpbmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciBhbkluc3RhbmNlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjYpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIGFzc2lnbiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTAwKTtcbnZhciBhcnJheUZyb20gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkwKTtcbnZhciBjb2RlQXQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc4KS5jb2RlQXQ7XG52YXIgdG9BU0NJSSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQxKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IF9fd19wZGZqc19yZXF1aXJlX18oODUpO1xudmFyIFVSTFNlYXJjaFBhcmFtc01vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQyKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMyk7XG52YXIgTmF0aXZlVVJMID0gZ2xvYmFsLlVSTDtcbnZhciBVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuVVJMU2VhcmNoUGFyYW1zO1xudmFyIGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUgPSBVUkxTZWFyY2hQYXJhbXNNb2R1bGUuZ2V0U3RhdGU7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsVVJMU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcignVVJMJyk7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIElOVkFMSURfQVVUSE9SSVRZID0gJ0ludmFsaWQgYXV0aG9yaXR5JztcbnZhciBJTlZBTElEX1NDSEVNRSA9ICdJbnZhbGlkIHNjaGVtZSc7XG52YXIgSU5WQUxJRF9IT1NUID0gJ0ludmFsaWQgaG9zdCc7XG52YXIgSU5WQUxJRF9QT1JUID0gJ0ludmFsaWQgcG9ydCc7XG52YXIgQUxQSEEgPSAvW0EtWmEtel0vO1xudmFyIEFMUEhBTlVNRVJJQyA9IC9bXFxkKy0uQS1aYS16XS87XG52YXIgRElHSVQgPSAvXFxkLztcbnZhciBIRVhfU1RBUlQgPSAvXigweHwwWCkvO1xudmFyIE9DVCA9IC9eWzAtN10rJC87XG52YXIgREVDID0gL15cXGQrJC87XG52YXIgSEVYID0gL15bXFxkQS1GYS1mXSskLztcbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UID0gL1tcXHUwMDAwXFx1MDAwOVxcdTAwMEFcXHUwMDBEICMlLzo/QFtcXFxcXV0vO1xudmFyIEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQgPSAvW1xcdTAwMDBcXHUwMDA5XFx1MDAwQVxcdTAwMEQgIy86P0BbXFxcXF1dLztcbnZhciBMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFID0gL15bXFx1MDAwMC1cXHUwMDFGIF0rfFtcXHUwMDAwLVxcdTAwMUYgXSskL2c7XG52YXIgVEFCX0FORF9ORVdfTElORSA9IC9bXFx1MDAwOVxcdTAwMEFcXHUwMDBEXS9nO1xudmFyIEVPRjtcbnZhciBwYXJzZUhvc3QgPSBmdW5jdGlvbiAodXJsLCBpbnB1dCkge1xuIHZhciByZXN1bHQsIGNvZGVQb2ludHMsIGluZGV4O1xuIGlmIChpbnB1dC5jaGFyQXQoMCkgPT0gJ1snKSB7XG4gIGlmIChpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT0gJ10nKVxuICAgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgcmVzdWx0ID0gcGFyc2VJUHY2KGlucHV0LnNsaWNlKDEsIC0xKSk7XG4gIGlmICghcmVzdWx0KVxuICAgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gfSBlbHNlIGlmICghaXNTcGVjaWFsKHVybCkpIHtcbiAgaWYgKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlRfRVhDTFVESU5HX1BFUkNFTlQudGVzdChpbnB1dCkpXG4gICByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICByZXN1bHQgPSAnJztcbiAgY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvZGVQb2ludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICByZXN1bHQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2luZGV4XSwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gIH1cbiAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gfSBlbHNlIHtcbiAgaW5wdXQgPSB0b0FTQ0lJKGlucHV0KTtcbiAgaWYgKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlQudGVzdChpbnB1dCkpXG4gICByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICByZXN1bHQgPSBwYXJzZUlQdjQoaW5wdXQpO1xuICBpZiAocmVzdWx0ID09PSBudWxsKVxuICAgcmV0dXJuIElOVkFMSURfSE9TVDtcbiAgdXJsLmhvc3QgPSByZXN1bHQ7XG4gfVxufTtcbnZhciBwYXJzZUlQdjQgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiB2YXIgcGFydHMgPSBpbnB1dC5zcGxpdCgnLicpO1xuIHZhciBwYXJ0c0xlbmd0aCwgbnVtYmVycywgaW5kZXgsIHBhcnQsIHJhZGl4LCBudW1iZXIsIGlwdjQ7XG4gaWYgKHBhcnRzLmxlbmd0aCAmJiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSA9PSAnJykge1xuICBwYXJ0cy5wb3AoKTtcbiB9XG4gcGFydHNMZW5ndGggPSBwYXJ0cy5sZW5ndGg7XG4gaWYgKHBhcnRzTGVuZ3RoID4gNClcbiAgcmV0dXJuIGlucHV0O1xuIG51bWJlcnMgPSBbXTtcbiBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0c0xlbmd0aDsgaW5kZXgrKykge1xuICBwYXJ0ID0gcGFydHNbaW5kZXhdO1xuICBpZiAocGFydCA9PSAnJylcbiAgIHJldHVybiBpbnB1dDtcbiAgcmFkaXggPSAxMDtcbiAgaWYgKHBhcnQubGVuZ3RoID4gMSAmJiBwYXJ0LmNoYXJBdCgwKSA9PSAnMCcpIHtcbiAgIHJhZGl4ID0gSEVYX1NUQVJULnRlc3QocGFydCkgPyAxNiA6IDg7XG4gICBwYXJ0ID0gcGFydC5zbGljZShyYWRpeCA9PSA4ID8gMSA6IDIpO1xuICB9XG4gIGlmIChwYXJ0ID09PSAnJykge1xuICAgbnVtYmVyID0gMDtcbiAgfSBlbHNlIHtcbiAgIGlmICghKHJhZGl4ID09IDEwID8gREVDIDogcmFkaXggPT0gOCA/IE9DVCA6IEhFWCkudGVzdChwYXJ0KSlcbiAgICByZXR1cm4gaW5wdXQ7XG4gICBudW1iZXIgPSBwYXJzZUludChwYXJ0LCByYWRpeCk7XG4gIH1cbiAgbnVtYmVycy5wdXNoKG51bWJlcik7XG4gfVxuIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBhcnRzTGVuZ3RoOyBpbmRleCsrKSB7XG4gIG51bWJlciA9IG51bWJlcnNbaW5kZXhdO1xuICBpZiAoaW5kZXggPT0gcGFydHNMZW5ndGggLSAxKSB7XG4gICBpZiAobnVtYmVyID49IHBvdygyNTYsIDUgLSBwYXJ0c0xlbmd0aCkpXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAobnVtYmVyID4gMjU1KVxuICAgcmV0dXJuIG51bGw7XG4gfVxuIGlwdjQgPSBudW1iZXJzLnBvcCgpO1xuIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IG51bWJlcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gIGlwdjQgKz0gbnVtYmVyc1tpbmRleF0gKiBwb3coMjU2LCAzIC0gaW5kZXgpO1xuIH1cbiByZXR1cm4gaXB2NDtcbn07XG52YXIgcGFyc2VJUHY2ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gdmFyIGFkZHJlc3MgPSBbXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDAsXG4gIDBcbiBdO1xuIHZhciBwaWVjZUluZGV4ID0gMDtcbiB2YXIgY29tcHJlc3MgPSBudWxsO1xuIHZhciBwb2ludGVyID0gMDtcbiB2YXIgdmFsdWUsIGxlbmd0aCwgbnVtYmVyc1NlZW4sIGlwdjRQaWVjZSwgbnVtYmVyLCBzd2Fwcywgc3dhcDtcbiB2YXIgY2hhciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGlucHV0LmNoYXJBdChwb2ludGVyKTtcbiB9O1xuIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gIGlmIChpbnB1dC5jaGFyQXQoMSkgIT0gJzonKVxuICAgcmV0dXJuO1xuICBwb2ludGVyICs9IDI7XG4gIHBpZWNlSW5kZXgrKztcbiAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuIH1cbiB3aGlsZSAoY2hhcigpKSB7XG4gIGlmIChwaWVjZUluZGV4ID09IDgpXG4gICByZXR1cm47XG4gIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gICBpZiAoY29tcHJlc3MgIT09IG51bGwpXG4gICAgcmV0dXJuO1xuICAgcG9pbnRlcisrO1xuICAgcGllY2VJbmRleCsrO1xuICAgY29tcHJlc3MgPSBwaWVjZUluZGV4O1xuICAgY29udGludWU7XG4gIH1cbiAgdmFsdWUgPSBsZW5ndGggPSAwO1xuICB3aGlsZSAobGVuZ3RoIDwgNCAmJiBIRVgudGVzdChjaGFyKCkpKSB7XG4gICB2YWx1ZSA9IHZhbHVlICogMTYgKyBwYXJzZUludChjaGFyKCksIDE2KTtcbiAgIHBvaW50ZXIrKztcbiAgIGxlbmd0aCsrO1xuICB9XG4gIGlmIChjaGFyKCkgPT0gJy4nKSB7XG4gICBpZiAobGVuZ3RoID09IDApXG4gICAgcmV0dXJuO1xuICAgcG9pbnRlciAtPSBsZW5ndGg7XG4gICBpZiAocGllY2VJbmRleCA+IDYpXG4gICAgcmV0dXJuO1xuICAgbnVtYmVyc1NlZW4gPSAwO1xuICAgd2hpbGUgKGNoYXIoKSkge1xuICAgIGlwdjRQaWVjZSA9IG51bGw7XG4gICAgaWYgKG51bWJlcnNTZWVuID4gMCkge1xuICAgICBpZiAoY2hhcigpID09ICcuJyAmJiBudW1iZXJzU2VlbiA8IDQpXG4gICAgICBwb2ludGVyKys7XG4gICAgIGVsc2VcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFESUdJVC50ZXN0KGNoYXIoKSkpXG4gICAgIHJldHVybjtcbiAgICB3aGlsZSAoRElHSVQudGVzdChjaGFyKCkpKSB7XG4gICAgIG51bWJlciA9IHBhcnNlSW50KGNoYXIoKSwgMTApO1xuICAgICBpZiAoaXB2NFBpZWNlID09PSBudWxsKVxuICAgICAgaXB2NFBpZWNlID0gbnVtYmVyO1xuICAgICBlbHNlIGlmIChpcHY0UGllY2UgPT0gMClcbiAgICAgIHJldHVybjtcbiAgICAgZWxzZVxuICAgICAgaXB2NFBpZWNlID0gaXB2NFBpZWNlICogMTAgKyBudW1iZXI7XG4gICAgIGlmIChpcHY0UGllY2UgPiAyNTUpXG4gICAgICByZXR1cm47XG4gICAgIHBvaW50ZXIrKztcbiAgICB9XG4gICAgYWRkcmVzc1twaWVjZUluZGV4XSA9IGFkZHJlc3NbcGllY2VJbmRleF0gKiAyNTYgKyBpcHY0UGllY2U7XG4gICAgbnVtYmVyc1NlZW4rKztcbiAgICBpZiAobnVtYmVyc1NlZW4gPT0gMiB8fCBudW1iZXJzU2VlbiA9PSA0KVxuICAgICBwaWVjZUluZGV4Kys7XG4gICB9XG4gICBpZiAobnVtYmVyc1NlZW4gIT0gNClcbiAgICByZXR1cm47XG4gICBicmVhaztcbiAgfSBlbHNlIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gICBwb2ludGVyKys7XG4gICBpZiAoIWNoYXIoKSlcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAoY2hhcigpKVxuICAgcmV0dXJuO1xuICBhZGRyZXNzW3BpZWNlSW5kZXgrK10gPSB2YWx1ZTtcbiB9XG4gaWYgKGNvbXByZXNzICE9PSBudWxsKSB7XG4gIHN3YXBzID0gcGllY2VJbmRleCAtIGNvbXByZXNzO1xuICBwaWVjZUluZGV4ID0gNztcbiAgd2hpbGUgKHBpZWNlSW5kZXggIT0gMCAmJiBzd2FwcyA+IDApIHtcbiAgIHN3YXAgPSBhZGRyZXNzW3BpZWNlSW5kZXhdO1xuICAgYWRkcmVzc1twaWVjZUluZGV4LS1dID0gYWRkcmVzc1tjb21wcmVzcyArIHN3YXBzIC0gMV07XG4gICBhZGRyZXNzW2NvbXByZXNzICsgLS1zd2Fwc10gPSBzd2FwO1xuICB9XG4gfSBlbHNlIGlmIChwaWVjZUluZGV4ICE9IDgpXG4gIHJldHVybjtcbiByZXR1cm4gYWRkcmVzcztcbn07XG52YXIgZmluZExvbmdlc3RaZXJvU2VxdWVuY2UgPSBmdW5jdGlvbiAoaXB2Nikge1xuIHZhciBtYXhJbmRleCA9IG51bGw7XG4gdmFyIG1heExlbmd0aCA9IDE7XG4gdmFyIGN1cnJTdGFydCA9IG51bGw7XG4gdmFyIGN1cnJMZW5ndGggPSAwO1xuIHZhciBpbmRleCA9IDA7XG4gZm9yICg7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICBpZiAoaXB2NltpbmRleF0gIT09IDApIHtcbiAgIGlmIChjdXJyTGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgbWF4TGVuZ3RoID0gY3Vyckxlbmd0aDtcbiAgIH1cbiAgIGN1cnJTdGFydCA9IG51bGw7XG4gICBjdXJyTGVuZ3RoID0gMDtcbiAgfSBlbHNlIHtcbiAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpXG4gICAgY3VyclN0YXJ0ID0gaW5kZXg7XG4gICArK2N1cnJMZW5ndGg7XG4gIH1cbiB9XG4gaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gfVxuIHJldHVybiBtYXhJbmRleDtcbn07XG52YXIgc2VyaWFsaXplSG9zdCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gdmFyIHJlc3VsdCwgaW5kZXgsIGNvbXByZXNzLCBpZ25vcmUwO1xuIGlmICh0eXBlb2YgaG9zdCA9PSAnbnVtYmVyJykge1xuICByZXN1bHQgPSBbXTtcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNDsgaW5kZXgrKykge1xuICAgcmVzdWx0LnVuc2hpZnQoaG9zdCAlIDI1Nik7XG4gICBob3N0ID0gZmxvb3IoaG9zdCAvIDI1Nik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5qb2luKCcuJyk7XG4gfSBlbHNlIGlmICh0eXBlb2YgaG9zdCA9PSAnb2JqZWN0Jykge1xuICByZXN1bHQgPSAnJztcbiAgY29tcHJlc3MgPSBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZShob3N0KTtcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICAgaWYgKGlnbm9yZTAgJiYgaG9zdFtpbmRleF0gPT09IDApXG4gICAgY29udGludWU7XG4gICBpZiAoaWdub3JlMClcbiAgICBpZ25vcmUwID0gZmFsc2U7XG4gICBpZiAoY29tcHJlc3MgPT09IGluZGV4KSB7XG4gICAgcmVzdWx0ICs9IGluZGV4ID8gJzonIDogJzo6JztcbiAgICBpZ25vcmUwID0gdHJ1ZTtcbiAgIH0gZWxzZSB7XG4gICAgcmVzdWx0ICs9IGhvc3RbaW5kZXhdLnRvU3RyaW5nKDE2KTtcbiAgICBpZiAoaW5kZXggPCA3KVxuICAgICByZXN1bHQgKz0gJzonO1xuICAgfVxuICB9XG4gIHJldHVybiAnWycgKyByZXN1bHQgKyAnXSc7XG4gfVxuIHJldHVybiBob3N0O1xufTtcbnZhciBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0ID0ge307XG52YXIgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBDMENvbnRyb2xQZXJjZW50RW5jb2RlU2V0LCB7XG4gJyAnOiAxLFxuICdcIic6IDEsXG4gJzwnOiAxLFxuICc+JzogMSxcbiAnYCc6IDFcbn0pO1xudmFyIHBhdGhQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAnIyc6IDEsXG4gJz8nOiAxLFxuICd7JzogMSxcbiAnfSc6IDFcbn0pO1xudmFyIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgcGF0aFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAnLyc6IDEsXG4gJzonOiAxLFxuICc7JzogMSxcbiAnPSc6IDEsXG4gJ0AnOiAxLFxuICdbJzogMSxcbiAnXFxcXCc6IDEsXG4gJ10nOiAxLFxuICdeJzogMSxcbiAnfCc6IDFcbn0pO1xudmFyIHBlcmNlbnRFbmNvZGUgPSBmdW5jdGlvbiAoY2hhciwgc2V0KSB7XG4gdmFyIGNvZGUgPSBjb2RlQXQoY2hhciwgMCk7XG4gcmV0dXJuIGNvZGUgPiAweDIwICYmIGNvZGUgPCAweDdGICYmICFoYXMoc2V0LCBjaGFyKSA/IGNoYXIgOiBlbmNvZGVVUklDb21wb25lbnQoY2hhcik7XG59O1xudmFyIHNwZWNpYWxTY2hlbWVzID0ge1xuIGZ0cDogMjEsXG4gZmlsZTogbnVsbCxcbiBodHRwOiA4MCxcbiBodHRwczogNDQzLFxuIHdzOiA4MCxcbiB3c3M6IDQ0M1xufTtcbnZhciBpc1NwZWNpYWwgPSBmdW5jdGlvbiAodXJsKSB7XG4gcmV0dXJuIGhhcyhzcGVjaWFsU2NoZW1lcywgdXJsLnNjaGVtZSk7XG59O1xudmFyIGluY2x1ZGVzQ3JlZGVudGlhbHMgPSBmdW5jdGlvbiAodXJsKSB7XG4gcmV0dXJuIHVybC51c2VybmFtZSAhPSAnJyB8fCB1cmwucGFzc3dvcmQgIT0gJyc7XG59O1xudmFyIGNhbm5vdEhhdmVVc2VybmFtZVBhc3N3b3JkUG9ydCA9IGZ1bmN0aW9uICh1cmwpIHtcbiByZXR1cm4gIXVybC5ob3N0IHx8IHVybC5jYW5ub3RCZUFCYXNlVVJMIHx8IHVybC5zY2hlbWUgPT0gJ2ZpbGUnO1xufTtcbnZhciBpc1dpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcsIG5vcm1hbGl6ZWQpIHtcbiB2YXIgc2Vjb25kO1xuIHJldHVybiBzdHJpbmcubGVuZ3RoID09IDIgJiYgQUxQSEEudGVzdChzdHJpbmcuY2hhckF0KDApKSAmJiAoKHNlY29uZCA9IHN0cmluZy5jaGFyQXQoMSkpID09ICc6JyB8fCAhbm9ybWFsaXplZCAmJiBzZWNvbmQgPT0gJ3wnKTtcbn07XG52YXIgc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiB2YXIgdGhpcmQ7XG4gcmV0dXJuIHN0cmluZy5sZW5ndGggPiAxICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKHN0cmluZy5zbGljZSgwLCAyKSkgJiYgKHN0cmluZy5sZW5ndGggPT0gMiB8fCAoKHRoaXJkID0gc3RyaW5nLmNoYXJBdCgyKSkgPT09ICcvJyB8fCB0aGlyZCA9PT0gJ1xcXFwnIHx8IHRoaXJkID09PSAnPycgfHwgdGhpcmQgPT09ICcjJykpO1xufTtcbnZhciBzaG9ydGVuVVJMc1BhdGggPSBmdW5jdGlvbiAodXJsKSB7XG4gdmFyIHBhdGggPSB1cmwucGF0aDtcbiB2YXIgcGF0aFNpemUgPSBwYXRoLmxlbmd0aDtcbiBpZiAocGF0aFNpemUgJiYgKHVybC5zY2hlbWUgIT0gJ2ZpbGUnIHx8IHBhdGhTaXplICE9IDEgfHwgIWlzV2luZG93c0RyaXZlTGV0dGVyKHBhdGhbMF0sIHRydWUpKSkge1xuICBwYXRoLnBvcCgpO1xuIH1cbn07XG52YXIgaXNTaW5nbGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuIHJldHVybiBzZWdtZW50ID09PSAnLicgfHwgc2VnbWVudC50b0xvd2VyQ2FzZSgpID09PSAnJTJlJztcbn07XG52YXIgaXNEb3VibGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuIHNlZ21lbnQgPSBzZWdtZW50LnRvTG93ZXJDYXNlKCk7XG4gcmV0dXJuIHNlZ21lbnQgPT09ICcuLicgfHwgc2VnbWVudCA9PT0gJyUyZS4nIHx8IHNlZ21lbnQgPT09ICcuJTJlJyB8fCBzZWdtZW50ID09PSAnJTJlJTJlJztcbn07XG52YXIgU0NIRU1FX1NUQVJUID0ge307XG52YXIgU0NIRU1FID0ge307XG52YXIgTk9fU0NIRU1FID0ge307XG52YXIgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFkgPSB7fTtcbnZhciBQQVRIX09SX0FVVEhPUklUWSA9IHt9O1xudmFyIFJFTEFUSVZFID0ge307XG52YXIgUkVMQVRJVkVfU0xBU0ggPSB7fTtcbnZhciBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTID0ge307XG52YXIgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVMgPSB7fTtcbnZhciBBVVRIT1JJVFkgPSB7fTtcbnZhciBIT1NUID0ge307XG52YXIgSE9TVE5BTUUgPSB7fTtcbnZhciBQT1JUID0ge307XG52YXIgRklMRSA9IHt9O1xudmFyIEZJTEVfU0xBU0ggPSB7fTtcbnZhciBGSUxFX0hPU1QgPSB7fTtcbnZhciBQQVRIX1NUQVJUID0ge307XG52YXIgUEFUSCA9IHt9O1xudmFyIENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEggPSB7fTtcbnZhciBRVUVSWSA9IHt9O1xudmFyIEZSQUdNRU5UID0ge307XG52YXIgcGFyc2VVUkwgPSBmdW5jdGlvbiAodXJsLCBpbnB1dCwgc3RhdGVPdmVycmlkZSwgYmFzZSkge1xuIHZhciBzdGF0ZSA9IHN0YXRlT3ZlcnJpZGUgfHwgU0NIRU1FX1NUQVJUO1xuIHZhciBwb2ludGVyID0gMDtcbiB2YXIgYnVmZmVyID0gJyc7XG4gdmFyIHNlZW5BdCA9IGZhbHNlO1xuIHZhciBzZWVuQnJhY2tldCA9IGZhbHNlO1xuIHZhciBzZWVuUGFzc3dvcmRUb2tlbiA9IGZhbHNlO1xuIHZhciBjb2RlUG9pbnRzLCBjaGFyLCBidWZmZXJDb2RlUG9pbnRzLCBmYWlsdXJlO1xuIGlmICghc3RhdGVPdmVycmlkZSkge1xuICB1cmwuc2NoZW1lID0gJyc7XG4gIHVybC51c2VybmFtZSA9ICcnO1xuICB1cmwucGFzc3dvcmQgPSAnJztcbiAgdXJsLmhvc3QgPSBudWxsO1xuICB1cmwucG9ydCA9IG51bGw7XG4gIHVybC5wYXRoID0gW107XG4gIHVybC5xdWVyeSA9IG51bGw7XG4gIHVybC5mcmFnbWVudCA9IG51bGw7XG4gIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gZmFsc2U7XG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZShMRUFESU5HX0FORF9UUkFJTElOR19DMF9DT05UUk9MX09SX1NQQUNFLCAnJyk7XG4gfVxuIGlucHV0ID0gaW5wdXQucmVwbGFjZShUQUJfQU5EX05FV19MSU5FLCAnJyk7XG4gY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG4gd2hpbGUgKHBvaW50ZXIgPD0gY29kZVBvaW50cy5sZW5ndGgpIHtcbiAgY2hhciA9IGNvZGVQb2ludHNbcG9pbnRlcl07XG4gIHN3aXRjaCAoc3RhdGUpIHtcbiAgY2FzZSBTQ0hFTUVfU1RBUlQ6XG4gICBpZiAoY2hhciAmJiBBTFBIQS50ZXN0KGNoYXIpKSB7XG4gICAgYnVmZmVyICs9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICBzdGF0ZSA9IFNDSEVNRTtcbiAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcbiAgICBjb250aW51ZTtcbiAgIH0gZWxzZVxuICAgIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgIGJyZWFrO1xuICBjYXNlIFNDSEVNRTpcbiAgIGlmIChjaGFyICYmIChBTFBIQU5VTUVSSUMudGVzdChjaGFyKSB8fCBjaGFyID09ICcrJyB8fCBjaGFyID09ICctJyB8fCBjaGFyID09ICcuJykpIHtcbiAgICBidWZmZXIgKz0gY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgfSBlbHNlIGlmIChjaGFyID09ICc6Jykge1xuICAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIChpc1NwZWNpYWwodXJsKSAhPSBoYXMoc3BlY2lhbFNjaGVtZXMsIGJ1ZmZlcikgfHwgYnVmZmVyID09ICdmaWxlJyAmJiAoaW5jbHVkZXNDcmVkZW50aWFscyh1cmwpIHx8IHVybC5wb3J0ICE9PSBudWxsKSB8fCB1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAhdXJsLmhvc3QpKVxuICAgICByZXR1cm47XG4gICAgdXJsLnNjaGVtZSA9IGJ1ZmZlcjtcbiAgICBpZiAoc3RhdGVPdmVycmlkZSkge1xuICAgICBpZiAoaXNTcGVjaWFsKHVybCkgJiYgc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0gPT0gdXJsLnBvcnQpXG4gICAgICB1cmwucG9ydCA9IG51bGw7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgYnVmZmVyID0gJyc7XG4gICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgIHN0YXRlID0gRklMRTtcbiAgICB9IGVsc2UgaWYgKGlzU3BlY2lhbCh1cmwpICYmIGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gdXJsLnNjaGVtZSkge1xuICAgICBzdGF0ZSA9IFNQRUNJQUxfUkVMQVRJVkVfT1JfQVVUSE9SSVRZO1xuICAgIH0gZWxzZSBpZiAoaXNTcGVjaWFsKHVybCkpIHtcbiAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9TTEFTSEVTO1xuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgIHN0YXRlID0gUEFUSF9PUl9BVVRIT1JJVFk7XG4gICAgIHBvaW50ZXIrKztcbiAgICB9IGVsc2Uge1xuICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICBzdGF0ZSA9IENBTk5PVF9CRV9BX0JBU0VfVVJMX1BBVEg7XG4gICAgfVxuICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgIHBvaW50ZXIgPSAwO1xuICAgIGNvbnRpbnVlO1xuICAgfSBlbHNlXG4gICAgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgYnJlYWs7XG4gIGNhc2UgTk9fU0NIRU1FOlxuICAgaWYgKCFiYXNlIHx8IGJhc2UuY2Fubm90QmVBQmFzZVVSTCAmJiBjaGFyICE9ICcjJylcbiAgICByZXR1cm4gSU5WQUxJRF9TQ0hFTUU7XG4gICBpZiAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNoYXIgPT0gJyMnKSB7XG4gICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICBicmVhaztcbiAgIH1cbiAgIHN0YXRlID0gYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnID8gRklMRSA6IFJFTEFUSVZFO1xuICAgY29udGludWU7XG4gIGNhc2UgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk6XG4gICBpZiAoY2hhciA9PSAnLycgJiYgY29kZVBvaW50c1twb2ludGVyICsgMV0gPT0gJy8nKSB7XG4gICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICBwb2ludGVyKys7XG4gICB9IGVsc2Uge1xuICAgIHN0YXRlID0gUkVMQVRJVkU7XG4gICAgY29udGludWU7XG4gICB9XG4gICBicmVhaztcbiAgY2FzZSBQQVRIX09SX0FVVEhPUklUWTpcbiAgIGlmIChjaGFyID09ICcvJykge1xuICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgIGJyZWFrO1xuICAgfSBlbHNlIHtcbiAgICBzdGF0ZSA9IFBBVEg7XG4gICAgY29udGludWU7XG4gICB9XG4gIGNhc2UgUkVMQVRJVkU6XG4gICB1cmwuc2NoZW1lID0gYmFzZS5zY2hlbWU7XG4gICBpZiAoY2hhciA9PSBFT0YpIHtcbiAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgfSBlbHNlIGlmIChjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkge1xuICAgIHN0YXRlID0gUkVMQVRJVkVfU0xBU0g7XG4gICB9IGVsc2UgaWYgKGNoYXIgPT0gJz8nKSB7XG4gICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgc3RhdGUgPSBRVUVSWTtcbiAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICB9IGVsc2Uge1xuICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgIHVybC5wYXRoLnBvcCgpO1xuICAgIHN0YXRlID0gUEFUSDtcbiAgICBjb250aW51ZTtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlIFJFTEFUSVZFX1NMQVNIOlxuICAgaWYgKGlzU3BlY2lhbCh1cmwpICYmIChjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJykpIHtcbiAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgfSBlbHNlIGlmIChjaGFyID09ICcvJykge1xuICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgfSBlbHNlIHtcbiAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgc3RhdGUgPSBQQVRIO1xuICAgIGNvbnRpbnVlO1xuICAgfVxuICAgYnJlYWs7XG4gIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUzpcbiAgIHN0YXRlID0gU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM7XG4gICBpZiAoY2hhciAhPSAnLycgfHwgYnVmZmVyLmNoYXJBdChwb2ludGVyICsgMSkgIT0gJy8nKVxuICAgIGNvbnRpbnVlO1xuICAgcG9pbnRlcisrO1xuICAgYnJlYWs7XG4gIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM6XG4gICBpZiAoY2hhciAhPSAnLycgJiYgY2hhciAhPSAnXFxcXCcpIHtcbiAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICBjb250aW51ZTtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlIEFVVEhPUklUWTpcbiAgIGlmIChjaGFyID09ICdAJykge1xuICAgIGlmIChzZWVuQXQpXG4gICAgIGJ1ZmZlciA9ICclNDAnICsgYnVmZmVyO1xuICAgIHNlZW5BdCA9IHRydWU7XG4gICAgYnVmZmVyQ29kZVBvaW50cyA9IGFycmF5RnJvbShidWZmZXIpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyQ29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICB2YXIgY29kZVBvaW50ID0gYnVmZmVyQ29kZVBvaW50c1tpXTtcbiAgICAgaWYgKGNvZGVQb2ludCA9PSAnOicgJiYgIXNlZW5QYXNzd29yZFRva2VuKSB7XG4gICAgICBzZWVuUGFzc3dvcmRUb2tlbiA9IHRydWU7XG4gICAgICBjb250aW51ZTtcbiAgICAgfVxuICAgICB2YXIgZW5jb2RlZENvZGVQb2ludHMgPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludCwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgaWYgKHNlZW5QYXNzd29yZFRva2VuKVxuICAgICAgdXJsLnBhc3N3b3JkICs9IGVuY29kZWRDb2RlUG9pbnRzO1xuICAgICBlbHNlXG4gICAgICB1cmwudXNlcm5hbWUgKz0gZW5jb2RlZENvZGVQb2ludHM7XG4gICAgfVxuICAgIGJ1ZmZlciA9ICcnO1xuICAgfSBlbHNlIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fCBjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkge1xuICAgIGlmIChzZWVuQXQgJiYgYnVmZmVyID09ICcnKVxuICAgICByZXR1cm4gSU5WQUxJRF9BVVRIT1JJVFk7XG4gICAgcG9pbnRlciAtPSBhcnJheUZyb20oYnVmZmVyKS5sZW5ndGggKyAxO1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHN0YXRlID0gSE9TVDtcbiAgIH0gZWxzZVxuICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgYnJlYWs7XG4gIGNhc2UgSE9TVDpcbiAgY2FzZSBIT1NUTkFNRTpcbiAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIHVybC5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgc3RhdGUgPSBGSUxFX0hPU1Q7XG4gICAgY29udGludWU7XG4gICB9IGVsc2UgaWYgKGNoYXIgPT0gJzonICYmICFzZWVuQnJhY2tldCkge1xuICAgIGlmIChidWZmZXIgPT0gJycpXG4gICAgIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgZmFpbHVyZSA9IHBhcnNlSG9zdCh1cmwsIGJ1ZmZlcik7XG4gICAgaWYgKGZhaWx1cmUpXG4gICAgIHJldHVybiBmYWlsdXJlO1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHN0YXRlID0gUE9SVDtcbiAgICBpZiAoc3RhdGVPdmVycmlkZSA9PSBIT1NUTkFNRSlcbiAgICAgcmV0dXJuO1xuICAgfSBlbHNlIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fCBjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkge1xuICAgIGlmIChpc1NwZWNpYWwodXJsKSAmJiBidWZmZXIgPT0gJycpXG4gICAgIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgaWYgKHN0YXRlT3ZlcnJpZGUgJiYgYnVmZmVyID09ICcnICYmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkgfHwgdXJsLnBvcnQgIT09IG51bGwpKVxuICAgICByZXR1cm47XG4gICAgZmFpbHVyZSA9IHBhcnNlSG9zdCh1cmwsIGJ1ZmZlcik7XG4gICAgaWYgKGZhaWx1cmUpXG4gICAgIHJldHVybiBmYWlsdXJlO1xuICAgIGJ1ZmZlciA9ICcnO1xuICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICBpZiAoc3RhdGVPdmVycmlkZSlcbiAgICAgcmV0dXJuO1xuICAgIGNvbnRpbnVlO1xuICAgfSBlbHNlIHtcbiAgICBpZiAoY2hhciA9PSAnWycpXG4gICAgIHNlZW5CcmFja2V0ID0gdHJ1ZTtcbiAgICBlbHNlIGlmIChjaGFyID09ICddJylcbiAgICAgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICBidWZmZXIgKz0gY2hhcjtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlIFBPUlQ6XG4gICBpZiAoRElHSVQudGVzdChjaGFyKSkge1xuICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgfSBlbHNlIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fCBjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSB8fCBzdGF0ZU92ZXJyaWRlKSB7XG4gICAgaWYgKGJ1ZmZlciAhPSAnJykge1xuICAgICB2YXIgcG9ydCA9IHBhcnNlSW50KGJ1ZmZlciwgMTApO1xuICAgICBpZiAocG9ydCA+IDB4RkZGRilcbiAgICAgIHJldHVybiBJTlZBTElEX1BPUlQ7XG4gICAgIHVybC5wb3J0ID0gaXNTcGVjaWFsKHVybCkgJiYgcG9ydCA9PT0gc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0gPyBudWxsIDogcG9ydDtcbiAgICAgYnVmZmVyID0gJyc7XG4gICAgfVxuICAgIGlmIChzdGF0ZU92ZXJyaWRlKVxuICAgICByZXR1cm47XG4gICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgIGNvbnRpbnVlO1xuICAgfSBlbHNlXG4gICAgcmV0dXJuIElOVkFMSURfUE9SVDtcbiAgIGJyZWFrO1xuICBjYXNlIEZJTEU6XG4gICB1cmwuc2NoZW1lID0gJ2ZpbGUnO1xuICAgaWYgKGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFwnKVxuICAgIHN0YXRlID0gRklMRV9TTEFTSDtcbiAgIGVsc2UgaWYgKGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gJ2ZpbGUnKSB7XG4gICAgaWYgKGNoYXIgPT0gRU9GKSB7XG4gICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnPycpIHtcbiAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgIHVybC5xdWVyeSA9ICcnO1xuICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgIH0gZWxzZSB7XG4gICAgIGlmICghc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xuICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICAgc2hvcnRlblVSTHNQYXRoKHVybCk7XG4gICAgIH1cbiAgICAgc3RhdGUgPSBQQVRIO1xuICAgICBjb250aW51ZTtcbiAgICB9XG4gICB9IGVsc2Uge1xuICAgIHN0YXRlID0gUEFUSDtcbiAgICBjb250aW51ZTtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlIEZJTEVfU0xBU0g6XG4gICBpZiAoY2hhciA9PSAnLycgfHwgY2hhciA9PSAnXFxcXCcpIHtcbiAgICBzdGF0ZSA9IEZJTEVfSE9TVDtcbiAgICBicmVhaztcbiAgIH1cbiAgIGlmIChiYXNlICYmIGJhc2Uuc2NoZW1lID09ICdmaWxlJyAmJiAhc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xuICAgIGlmIChpc1dpbmRvd3NEcml2ZUxldHRlcihiYXNlLnBhdGhbMF0sIHRydWUpKVxuICAgICB1cmwucGF0aC5wdXNoKGJhc2UucGF0aFswXSk7XG4gICAgZWxzZVxuICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgIH1cbiAgIHN0YXRlID0gUEFUSDtcbiAgIGNvbnRpbnVlO1xuICBjYXNlIEZJTEVfSE9TVDpcbiAgIGlmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykge1xuICAgIGlmICghc3RhdGVPdmVycmlkZSAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgIHN0YXRlID0gUEFUSDtcbiAgICB9IGVsc2UgaWYgKGJ1ZmZlciA9PSAnJykge1xuICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICBpZiAoc3RhdGVPdmVycmlkZSlcbiAgICAgIHJldHVybjtcbiAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgIH0gZWxzZSB7XG4gICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xuICAgICBpZiAoZmFpbHVyZSlcbiAgICAgIHJldHVybiBmYWlsdXJlO1xuICAgICBpZiAodXJsLmhvc3QgPT0gJ2xvY2FsaG9zdCcpXG4gICAgICB1cmwuaG9zdCA9ICcnO1xuICAgICBpZiAoc3RhdGVPdmVycmlkZSlcbiAgICAgIHJldHVybjtcbiAgICAgYnVmZmVyID0gJyc7XG4gICAgIHN0YXRlID0gUEFUSF9TVEFSVDtcbiAgICB9XG4gICAgY29udGludWU7XG4gICB9IGVsc2VcbiAgICBidWZmZXIgKz0gY2hhcjtcbiAgIGJyZWFrO1xuICBjYXNlIFBBVEhfU1RBUlQ6XG4gICBpZiAoaXNTcGVjaWFsKHVybCkpIHtcbiAgICBzdGF0ZSA9IFBBVEg7XG4gICAgaWYgKGNoYXIgIT0gJy8nICYmIGNoYXIgIT0gJ1xcXFwnKVxuICAgICBjb250aW51ZTtcbiAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnPycpIHtcbiAgICB1cmwucXVlcnkgPSAnJztcbiAgICBzdGF0ZSA9IFFVRVJZO1xuICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSAmJiBjaGFyID09ICcjJykge1xuICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICB9IGVsc2UgaWYgKGNoYXIgIT0gRU9GKSB7XG4gICAgc3RhdGUgPSBQQVRIO1xuICAgIGlmIChjaGFyICE9ICcvJylcbiAgICAgY29udGludWU7XG4gICB9XG4gICBicmVhaztcbiAgY2FzZSBQQVRIOlxuICAgaWYgKGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFwnICYmIGlzU3BlY2lhbCh1cmwpIHx8ICFzdGF0ZU92ZXJyaWRlICYmIChjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykpIHtcbiAgICBpZiAoaXNEb3VibGVEb3QoYnVmZmVyKSkge1xuICAgICBzaG9ydGVuVVJMc1BhdGgodXJsKTtcbiAgICAgaWYgKGNoYXIgIT0gJy8nICYmICEoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpKSB7XG4gICAgICB1cmwucGF0aC5wdXNoKCcnKTtcbiAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVEb3QoYnVmZmVyKSkge1xuICAgICBpZiAoY2hhciAhPSAnLycgJiYgIShjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkpIHtcbiAgICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmICF1cmwucGF0aC5sZW5ndGggJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoYnVmZmVyKSkge1xuICAgICAgaWYgKHVybC5ob3N0KVxuICAgICAgIHVybC5ob3N0ID0gJyc7XG4gICAgICBidWZmZXIgPSBidWZmZXIuY2hhckF0KDApICsgJzonO1xuICAgICB9XG4gICAgIHVybC5wYXRoLnB1c2goYnVmZmVyKTtcbiAgICB9XG4gICAgYnVmZmVyID0gJyc7XG4gICAgaWYgKHVybC5zY2hlbWUgPT0gJ2ZpbGUnICYmIChjaGFyID09IEVPRiB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJykpIHtcbiAgICAgd2hpbGUgKHVybC5wYXRoLmxlbmd0aCA+IDEgJiYgdXJsLnBhdGhbMF0gPT09ICcnKSB7XG4gICAgICB1cmwucGF0aC5zaGlmdCgpO1xuICAgICB9XG4gICAgfVxuICAgIGlmIChjaGFyID09ICc/Jykge1xuICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJyMnKSB7XG4gICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgIH1cbiAgIH0gZWxzZSB7XG4gICAgYnVmZmVyICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgcGF0aFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgfVxuICAgYnJlYWs7XG4gIGNhc2UgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSDpcbiAgIGlmIChjaGFyID09ICc/Jykge1xuICAgIHVybC5xdWVyeSA9ICcnO1xuICAgIHN0YXRlID0gUVVFUlk7XG4gICB9IGVsc2UgaWYgKGNoYXIgPT0gJyMnKSB7XG4gICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgIH0gZWxzZSBpZiAoY2hhciAhPSBFT0YpIHtcbiAgICB1cmwucGF0aFswXSArPSBwZXJjZW50RW5jb2RlKGNoYXIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgfVxuICAgYnJlYWs7XG4gIGNhc2UgUVVFUlk6XG4gICBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnIycpIHtcbiAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgfSBlbHNlIGlmIChjaGFyICE9IEVPRikge1xuICAgIGlmIChjaGFyID09IFwiJ1wiICYmIGlzU3BlY2lhbCh1cmwpKVxuICAgICB1cmwucXVlcnkgKz0gJyUyNyc7XG4gICAgZWxzZSBpZiAoY2hhciA9PSAnIycpXG4gICAgIHVybC5xdWVyeSArPSAnJTIzJztcbiAgICBlbHNlXG4gICAgIHVybC5xdWVyeSArPSBwZXJjZW50RW5jb2RlKGNoYXIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgfVxuICAgYnJlYWs7XG4gIGNhc2UgRlJBR01FTlQ6XG4gICBpZiAoY2hhciAhPSBFT0YpXG4gICAgdXJsLmZyYWdtZW50ICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0KTtcbiAgIGJyZWFrO1xuICB9XG4gIHBvaW50ZXIrKztcbiB9XG59O1xudmFyIFVSTENvbnN0cnVjdG9yID0gZnVuY3Rpb24gVVJMKHVybCkge1xuIHZhciB0aGF0ID0gYW5JbnN0YW5jZSh0aGlzLCBVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xuIHZhciBiYXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQ7XG4gdmFyIHVybFN0cmluZyA9IFN0cmluZyh1cmwpO1xuIHZhciBzdGF0ZSA9IHNldEludGVybmFsU3RhdGUodGhhdCwgeyB0eXBlOiAnVVJMJyB9KTtcbiB2YXIgYmFzZVN0YXRlLCBmYWlsdXJlO1xuIGlmIChiYXNlICE9PSB1bmRlZmluZWQpIHtcbiAgaWYgKGJhc2UgaW5zdGFuY2VvZiBVUkxDb25zdHJ1Y3RvcilcbiAgIGJhc2VTdGF0ZSA9IGdldEludGVybmFsVVJMU3RhdGUoYmFzZSk7XG4gIGVsc2Uge1xuICAgZmFpbHVyZSA9IHBhcnNlVVJMKGJhc2VTdGF0ZSA9IHt9LCBTdHJpbmcoYmFzZSkpO1xuICAgaWYgKGZhaWx1cmUpXG4gICAgdGhyb3cgVHlwZUVycm9yKGZhaWx1cmUpO1xuICB9XG4gfVxuIGZhaWx1cmUgPSBwYXJzZVVSTChzdGF0ZSwgdXJsU3RyaW5nLCBudWxsLCBiYXNlU3RhdGUpO1xuIGlmIChmYWlsdXJlKVxuICB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gdmFyIHNlYXJjaFBhcmFtcyA9IHN0YXRlLnNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiB2YXIgc2VhcmNoUGFyYW1zU3RhdGUgPSBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHNlYXJjaFBhcmFtcyk7XG4gc2VhcmNoUGFyYW1zU3RhdGUudXBkYXRlU2VhcmNoUGFyYW1zKHN0YXRlLnF1ZXJ5KTtcbiBzZWFyY2hQYXJhbXNTdGF0ZS51cGRhdGVVUkwgPSBmdW5jdGlvbiAoKSB7XG4gIHN0YXRlLnF1ZXJ5ID0gU3RyaW5nKHNlYXJjaFBhcmFtcykgfHwgbnVsbDtcbiB9O1xuIGlmICghREVTQ1JJUFRPUlMpIHtcbiAgdGhhdC5ocmVmID0gc2VyaWFsaXplVVJMLmNhbGwodGhhdCk7XG4gIHRoYXQub3JpZ2luID0gZ2V0T3JpZ2luLmNhbGwodGhhdCk7XG4gIHRoYXQucHJvdG9jb2wgPSBnZXRQcm90b2NvbC5jYWxsKHRoYXQpO1xuICB0aGF0LnVzZXJuYW1lID0gZ2V0VXNlcm5hbWUuY2FsbCh0aGF0KTtcbiAgdGhhdC5wYXNzd29yZCA9IGdldFBhc3N3b3JkLmNhbGwodGhhdCk7XG4gIHRoYXQuaG9zdCA9IGdldEhvc3QuY2FsbCh0aGF0KTtcbiAgdGhhdC5ob3N0bmFtZSA9IGdldEhvc3RuYW1lLmNhbGwodGhhdCk7XG4gIHRoYXQucG9ydCA9IGdldFBvcnQuY2FsbCh0aGF0KTtcbiAgdGhhdC5wYXRobmFtZSA9IGdldFBhdGhuYW1lLmNhbGwodGhhdCk7XG4gIHRoYXQuc2VhcmNoID0gZ2V0U2VhcmNoLmNhbGwodGhhdCk7XG4gIHRoYXQuc2VhcmNoUGFyYW1zID0gZ2V0U2VhcmNoUGFyYW1zLmNhbGwodGhhdCk7XG4gIHRoYXQuaGFzaCA9IGdldEhhc2guY2FsbCh0aGF0KTtcbiB9XG59O1xudmFyIFVSTFByb3RvdHlwZSA9IFVSTENvbnN0cnVjdG9yLnByb3RvdHlwZTtcbnZhciBzZXJpYWxpemVVUkwgPSBmdW5jdGlvbiAoKSB7XG4gdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XG4gdmFyIHVzZXJuYW1lID0gdXJsLnVzZXJuYW1lO1xuIHZhciBwYXNzd29yZCA9IHVybC5wYXNzd29yZDtcbiB2YXIgaG9zdCA9IHVybC5ob3N0O1xuIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gdmFyIHBhdGggPSB1cmwucGF0aDtcbiB2YXIgcXVlcnkgPSB1cmwucXVlcnk7XG4gdmFyIGZyYWdtZW50ID0gdXJsLmZyYWdtZW50O1xuIHZhciBvdXRwdXQgPSBzY2hlbWUgKyAnOic7XG4gaWYgKGhvc3QgIT09IG51bGwpIHtcbiAgb3V0cHV0ICs9ICcvLyc7XG4gIGlmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkpIHtcbiAgIG91dHB1dCArPSB1c2VybmFtZSArIChwYXNzd29yZCA/ICc6JyArIHBhc3N3b3JkIDogJycpICsgJ0AnO1xuICB9XG4gIG91dHB1dCArPSBzZXJpYWxpemVIb3N0KGhvc3QpO1xuICBpZiAocG9ydCAhPT0gbnVsbClcbiAgIG91dHB1dCArPSAnOicgKyBwb3J0O1xuIH0gZWxzZSBpZiAoc2NoZW1lID09ICdmaWxlJylcbiAgb3V0cHV0ICs9ICcvLyc7XG4gb3V0cHV0ICs9IHVybC5jYW5ub3RCZUFCYXNlVVJMID8gcGF0aFswXSA6IHBhdGgubGVuZ3RoID8gJy8nICsgcGF0aC5qb2luKCcvJykgOiAnJztcbiBpZiAocXVlcnkgIT09IG51bGwpXG4gIG91dHB1dCArPSAnPycgKyBxdWVyeTtcbiBpZiAoZnJhZ21lbnQgIT09IG51bGwpXG4gIG91dHB1dCArPSAnIycgKyBmcmFnbWVudDtcbiByZXR1cm4gb3V0cHV0O1xufTtcbnZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbiAoKSB7XG4gdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gdmFyIHNjaGVtZSA9IHVybC5zY2hlbWU7XG4gdmFyIHBvcnQgPSB1cmwucG9ydDtcbiBpZiAoc2NoZW1lID09ICdibG9iJylcbiAgdHJ5IHtcbiAgIHJldHVybiBuZXcgVVJMKHNjaGVtZS5wYXRoWzBdKS5vcmlnaW47XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICByZXR1cm4gJ251bGwnO1xuICB9XG4gaWYgKHNjaGVtZSA9PSAnZmlsZScgfHwgIWlzU3BlY2lhbCh1cmwpKVxuICByZXR1cm4gJ251bGwnO1xuIHJldHVybiBzY2hlbWUgKyAnOi8vJyArIHNlcmlhbGl6ZUhvc3QodXJsLmhvc3QpICsgKHBvcnQgIT09IG51bGwgPyAnOicgKyBwb3J0IDogJycpO1xufTtcbnZhciBnZXRQcm90b2NvbCA9IGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5zY2hlbWUgKyAnOic7XG59O1xudmFyIGdldFVzZXJuYW1lID0gZnVuY3Rpb24gKCkge1xuIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnVzZXJuYW1lO1xufTtcbnZhciBnZXRQYXNzd29yZCA9IGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5wYXNzd29yZDtcbn07XG52YXIgZ2V0SG9zdCA9IGZ1bmN0aW9uICgpIHtcbiB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiB2YXIgaG9zdCA9IHVybC5ob3N0O1xuIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gcmV0dXJuIGhvc3QgPT09IG51bGwgPyAnJyA6IHBvcnQgPT09IG51bGwgPyBzZXJpYWxpemVIb3N0KGhvc3QpIDogc2VyaWFsaXplSG9zdChob3N0KSArICc6JyArIHBvcnQ7XG59O1xudmFyIGdldEhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuIHZhciBob3N0ID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5ob3N0O1xuIHJldHVybiBob3N0ID09PSBudWxsID8gJycgOiBzZXJpYWxpemVIb3N0KGhvc3QpO1xufTtcbnZhciBnZXRQb3J0ID0gZnVuY3Rpb24gKCkge1xuIHZhciBwb3J0ID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5wb3J0O1xuIHJldHVybiBwb3J0ID09PSBudWxsID8gJycgOiBTdHJpbmcocG9ydCk7XG59O1xudmFyIGdldFBhdGhuYW1lID0gZnVuY3Rpb24gKCkge1xuIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuIHZhciBwYXRoID0gdXJsLnBhdGg7XG4gcmV0dXJuIHVybC5jYW5ub3RCZUFCYXNlVVJMID8gcGF0aFswXSA6IHBhdGgubGVuZ3RoID8gJy8nICsgcGF0aC5qb2luKCcvJykgOiAnJztcbn07XG52YXIgZ2V0U2VhcmNoID0gZnVuY3Rpb24gKCkge1xuIHZhciBxdWVyeSA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcykucXVlcnk7XG4gcmV0dXJuIHF1ZXJ5ID8gJz8nICsgcXVlcnkgOiAnJztcbn07XG52YXIgZ2V0U2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKCkge1xuIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnNlYXJjaFBhcmFtcztcbn07XG52YXIgZ2V0SGFzaCA9IGZ1bmN0aW9uICgpIHtcbiB2YXIgZnJhZ21lbnQgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLmZyYWdtZW50O1xuIHJldHVybiBmcmFnbWVudCA/ICcjJyArIGZyYWdtZW50IDogJyc7XG59O1xudmFyIGFjY2Vzc29yRGVzY3JpcHRvciA9IGZ1bmN0aW9uIChnZXR0ZXIsIHNldHRlcikge1xuIHJldHVybiB7XG4gIGdldDogZ2V0dGVyLFxuICBzZXQ6IHNldHRlcixcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlXG4gfTtcbn07XG5pZiAoREVTQ1JJUFRPUlMpIHtcbiBkZWZpbmVQcm9wZXJ0aWVzKFVSTFByb3RvdHlwZSwge1xuICBocmVmOiBhY2Nlc3NvckRlc2NyaXB0b3Ioc2VyaWFsaXplVVJMLCBmdW5jdGlvbiAoaHJlZikge1xuICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICB2YXIgdXJsU3RyaW5nID0gU3RyaW5nKGhyZWYpO1xuICAgdmFyIGZhaWx1cmUgPSBwYXJzZVVSTCh1cmwsIHVybFN0cmluZyk7XG4gICBpZiAoZmFpbHVyZSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoZmFpbHVyZSk7XG4gICBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHVybC5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyh1cmwucXVlcnkpO1xuICB9KSxcbiAgb3JpZ2luOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0T3JpZ2luKSxcbiAgcHJvdG9jb2w6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRQcm90b2NvbCwgZnVuY3Rpb24gKHByb3RvY29sKSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIHBhcnNlVVJMKHVybCwgU3RyaW5nKHByb3RvY29sKSArICc6JywgU0NIRU1FX1NUQVJUKTtcbiAgfSksXG4gIHVzZXJuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0VXNlcm5hbWUsIGZ1bmN0aW9uICh1c2VybmFtZSkge1xuICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICB2YXIgY29kZVBvaW50cyA9IGFycmF5RnJvbShTdHJpbmcodXNlcm5hbWUpKTtcbiAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSlcbiAgICByZXR1cm47XG4gICB1cmwudXNlcm5hbWUgPSAnJztcbiAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZVBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgIHVybC51c2VybmFtZSArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaV0sIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICB9XG4gIH0pLFxuICBwYXNzd29yZDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBhc3N3b3JkLCBmdW5jdGlvbiAocGFzc3dvcmQpIHtcbiAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oU3RyaW5nKHBhc3N3b3JkKSk7XG4gICBpZiAoY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KHVybCkpXG4gICAgcmV0dXJuO1xuICAgdXJsLnBhc3N3b3JkID0gJyc7XG4gICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICB1cmwucGFzc3dvcmQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2ldLCB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQpO1xuICAgfVxuICB9KSxcbiAgaG9zdDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldEhvc3QsIGZ1bmN0aW9uIChob3N0KSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIGlmICh1cmwuY2Fubm90QmVBQmFzZVVSTClcbiAgICByZXR1cm47XG4gICBwYXJzZVVSTCh1cmwsIFN0cmluZyhob3N0KSwgSE9TVCk7XG4gIH0pLFxuICBob3N0bmFtZTogYWNjZXNzb3JEZXNjcmlwdG9yKGdldEhvc3RuYW1lLCBmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgaWYgKHVybC5jYW5ub3RCZUFCYXNlVVJMKVxuICAgIHJldHVybjtcbiAgIHBhcnNlVVJMKHVybCwgU3RyaW5nKGhvc3RuYW1lKSwgSE9TVE5BTUUpO1xuICB9KSxcbiAgcG9ydDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBvcnQsIGZ1bmN0aW9uIChwb3J0KSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSlcbiAgICByZXR1cm47XG4gICBwb3J0ID0gU3RyaW5nKHBvcnQpO1xuICAgaWYgKHBvcnQgPT0gJycpXG4gICAgdXJsLnBvcnQgPSBudWxsO1xuICAgZWxzZVxuICAgIHBhcnNlVVJMKHVybCwgcG9ydCwgUE9SVCk7XG4gIH0pLFxuICBwYXRobmFtZTogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBhdGhuYW1lLCBmdW5jdGlvbiAocGF0aG5hbWUpIHtcbiAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgaWYgKHVybC5jYW5ub3RCZUFCYXNlVVJMKVxuICAgIHJldHVybjtcbiAgIHVybC5wYXRoID0gW107XG4gICBwYXJzZVVSTCh1cmwsIHBhdGhuYW1lICsgJycsIFBBVEhfU1RBUlQpO1xuICB9KSxcbiAgc2VhcmNoOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0U2VhcmNoLCBmdW5jdGlvbiAoc2VhcmNoKSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIHNlYXJjaCA9IFN0cmluZyhzZWFyY2gpO1xuICAgaWYgKHNlYXJjaCA9PSAnJykge1xuICAgIHVybC5xdWVyeSA9IG51bGw7XG4gICB9IGVsc2Uge1xuICAgIGlmICgnPycgPT0gc2VhcmNoLmNoYXJBdCgwKSlcbiAgICAgc2VhcmNoID0gc2VhcmNoLnNsaWNlKDEpO1xuICAgIHVybC5xdWVyeSA9ICcnO1xuICAgIHBhcnNlVVJMKHVybCwgc2VhcmNoLCBRVUVSWSk7XG4gICB9XG4gICBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHVybC5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyh1cmwucXVlcnkpO1xuICB9KSxcbiAgc2VhcmNoUGFyYW1zOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0U2VhcmNoUGFyYW1zKSxcbiAgaGFzaDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldEhhc2gsIGZ1bmN0aW9uIChoYXNoKSB7XG4gICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgIGhhc2ggPSBTdHJpbmcoaGFzaCk7XG4gICBpZiAoaGFzaCA9PSAnJykge1xuICAgIHVybC5mcmFnbWVudCA9IG51bGw7XG4gICAgcmV0dXJuO1xuICAgfVxuICAgaWYgKCcjJyA9PSBoYXNoLmNoYXJBdCgwKSlcbiAgICBoYXNoID0gaGFzaC5zbGljZSgxKTtcbiAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgcGFyc2VVUkwodXJsLCBoYXNoLCBGUkFHTUVOVCk7XG4gIH0pXG4gfSk7XG59XG5yZWRlZmluZShVUkxQcm90b3R5cGUsICd0b0pTT04nLCBmdW5jdGlvbiB0b0pTT04oKSB7XG4gcmV0dXJuIHNlcmlhbGl6ZVVSTC5jYWxsKHRoaXMpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xucmVkZWZpbmUoVVJMUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiByZXR1cm4gc2VyaWFsaXplVVJMLmNhbGwodGhpcyk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5pZiAoTmF0aXZlVVJMKSB7XG4gdmFyIG5hdGl2ZUNyZWF0ZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5jcmVhdGVPYmplY3RVUkw7XG4gdmFyIG5hdGl2ZVJldm9rZU9iamVjdFVSTCA9IE5hdGl2ZVVSTC5yZXZva2VPYmplY3RVUkw7XG4gaWYgKG5hdGl2ZUNyZWF0ZU9iamVjdFVSTClcbiAgcmVkZWZpbmUoVVJMQ29uc3RydWN0b3IsICdjcmVhdGVPYmplY3RVUkwnLCBmdW5jdGlvbiBjcmVhdGVPYmplY3RVUkwoYmxvYikge1xuICAgcmV0dXJuIG5hdGl2ZUNyZWF0ZU9iamVjdFVSTC5hcHBseShOYXRpdmVVUkwsIGFyZ3VtZW50cyk7XG4gIH0pO1xuIGlmIChuYXRpdmVSZXZva2VPYmplY3RVUkwpXG4gIHJlZGVmaW5lKFVSTENvbnN0cnVjdG9yLCAncmV2b2tlT2JqZWN0VVJMJywgZnVuY3Rpb24gcmV2b2tlT2JqZWN0VVJMKHVybCkge1xuICAgcmV0dXJuIG5hdGl2ZVJldm9rZU9iamVjdFVSTC5hcHBseShOYXRpdmVVUkwsIGFyZ3VtZW50cyk7XG4gIH0pO1xufVxuc2V0VG9TdHJpbmdUYWcoVVJMQ29uc3RydWN0b3IsICdVUkwnKTtcbiQoe1xuIGdsb2JhbDogdHJ1ZSxcbiBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCxcbiBzaGFtOiAhREVTQ1JJUFRPUlNcbn0sIHsgVVJMOiBVUkxDb25zdHJ1Y3RvciB9KTtcblxuLyoqKi8gfSksXG4vKiAxNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgSVNfUFVSRSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuIHZhciB1cmwgPSBuZXcgVVJMKCdiP2E9MSZiPTImYz0zJywgJ2h0dHA6Ly9hJyk7XG4gdmFyIHNlYXJjaFBhcmFtcyA9IHVybC5zZWFyY2hQYXJhbXM7XG4gdmFyIHJlc3VsdCA9ICcnO1xuIHVybC5wYXRobmFtZSA9ICdjJTIwZCc7XG4gc2VhcmNoUGFyYW1zLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcbiAgc2VhcmNoUGFyYW1zWydkZWxldGUnXSgnYicpO1xuICByZXN1bHQgKz0ga2V5ICsgdmFsdWU7XG4gfSk7XG4gcmV0dXJuIElTX1BVUkUgJiYgIXVybC50b0pTT04gfHwgIXNlYXJjaFBhcmFtcy5zb3J0IHx8IHVybC5ocmVmICE9PSAnaHR0cDovL2EvYyUyMGQ/YT0xJmM9MycgfHwgc2VhcmNoUGFyYW1zLmdldCgnYycpICE9PSAnMycgfHwgU3RyaW5nKG5ldyBVUkxTZWFyY2hQYXJhbXMoJz9hPTEnKSkgIT09ICdhPTEnIHx8ICFzZWFyY2hQYXJhbXNbSVRFUkFUT1JdIHx8IG5ldyBVUkwoJ2h0dHBzOi8vYUBiJykudXNlcm5hbWUgIT09ICdhJyB8fCBuZXcgVVJMU2VhcmNoUGFyYW1zKG5ldyBVUkxTZWFyY2hQYXJhbXMoJ2E9YicpKS5nZXQoJ2EnKSAhPT0gJ2InIHx8IG5ldyBVUkwoJ2h0dHA6Ly/RgtC10YHRgicpLmhvc3QgIT09ICd4bi0tZTFheWJjJyB8fCBuZXcgVVJMKCdodHRwOi8vYSPQsScpLmhhc2ggIT09ICcjJUQwJUIxJyB8fCByZXN1bHQgIT09ICdhMWMzJyB8fCBuZXcgVVJMKCdodHRwOi8veCcsIHVuZGVmaW5lZCkuaG9zdCAhPT0gJ3gnO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMTQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgbWF4SW50ID0gMjE0NzQ4MzY0NztcbnZhciBiYXNlID0gMzY7XG52YXIgdE1pbiA9IDE7XG52YXIgdE1heCA9IDI2O1xudmFyIHNrZXcgPSAzODtcbnZhciBkYW1wID0gNzAwO1xudmFyIGluaXRpYWxCaWFzID0gNzI7XG52YXIgaW5pdGlhbE4gPSAxMjg7XG52YXIgZGVsaW1pdGVyID0gJy0nO1xudmFyIHJlZ2V4Tm9uQVNDSUkgPSAvW15cXDAtXFx1MDA3RV0vO1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bLlxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZztcbnZhciBPVkVSRkxPV19FUlJPUiA9ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2Vzcyc7XG52YXIgYmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIHVjczJkZWNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gdmFyIG91dHB1dCA9IFtdO1xuIHZhciBjb3VudGVyID0gMDtcbiB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICB2YXIgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICB2YXIgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7XG4gICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgIH0gZWxzZSB7XG4gICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgIGNvdW50ZXItLTtcbiAgIH1cbiAgfSBlbHNlIHtcbiAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgfVxuIH1cbiByZXR1cm4gb3V0cHV0O1xufTtcbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiAoZGlnaXQpIHtcbiByZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpO1xufTtcbnZhciBhZGFwdCA9IGZ1bmN0aW9uIChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcbiB2YXIgayA9IDA7XG4gZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiBkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG4gZm9yICg7IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG4gIGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcbiB9XG4gcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xudmFyIGVuY29kZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuIHZhciBvdXRwdXQgPSBbXTtcbiBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiB2YXIgbiA9IGluaXRpYWxOO1xuIHZhciBkZWx0YSA9IDA7XG4gdmFyIGJpYXMgPSBpbml0aWFsQmlhcztcbiB2YXIgaSwgY3VycmVudFZhbHVlO1xuIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgaWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcbiAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShjdXJyZW50VmFsdWUpKTtcbiAgfVxuIH1cbiB2YXIgYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuIHZhciBoYW5kbGVkQ1BDb3VudCA9IGJhc2ljTGVuZ3RoO1xuIGlmIChiYXNpY0xlbmd0aCkge1xuICBvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuIH1cbiB3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuICB2YXIgbSA9IG1heEludDtcbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgIGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG4gICAgbSA9IGN1cnJlbnRWYWx1ZTtcbiAgIH1cbiAgfVxuICB2YXIgaGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgdGhyb3cgUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gIH1cbiAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcbiAgbiA9IG07XG4gIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgdGhyb3cgUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gICB9XG4gICBpZiAoY3VycmVudFZhbHVlID09IG4pIHtcbiAgICB2YXIgcSA9IGRlbHRhO1xuICAgIGZvciAodmFyIGsgPSBiYXNlOzsgayArPSBiYXNlKSB7XG4gICAgIHZhciB0ID0gayA8PSBiaWFzID8gdE1pbiA6IGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXM7XG4gICAgIGlmIChxIDwgdClcbiAgICAgIGJyZWFrO1xuICAgICB2YXIgcU1pbnVzVCA9IHEgLSB0O1xuICAgICB2YXIgYmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuICAgICBvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCkpKTtcbiAgICAgcSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcbiAgICB9XG4gICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyhxKSkpO1xuICAgIGJpYXMgPSBhZGFwdChkZWx0YSwgaGFuZGxlZENQQ291bnRQbHVzT25lLCBoYW5kbGVkQ1BDb3VudCA9PSBiYXNpY0xlbmd0aCk7XG4gICAgZGVsdGEgPSAwO1xuICAgICsraGFuZGxlZENQQ291bnQ7XG4gICB9XG4gIH1cbiAgKytkZWx0YTtcbiAgKytuO1xuIH1cbiByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xufTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gdmFyIGVuY29kZWQgPSBbXTtcbiB2YXIgbGFiZWxzID0gaW5wdXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xcdTAwMkUnKS5zcGxpdCgnLicpO1xuIHZhciBpLCBsYWJlbDtcbiBmb3IgKGkgPSAwOyBpIDwgbGFiZWxzLmxlbmd0aDsgaSsrKSB7XG4gIGxhYmVsID0gbGFiZWxzW2ldO1xuICBlbmNvZGVkLnB1c2gocmVnZXhOb25BU0NJSS50ZXN0KGxhYmVsKSA/ICd4bi0tJyArIGVuY29kZShsYWJlbCkgOiBsYWJlbCk7XG4gfVxuIHJldHVybiBlbmNvZGVkLmpvaW4oJy4nKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTQyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQyKTtcbnZhciBVU0VfTkFUSVZFX1VSTCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQwKTtcbnZhciByZWRlZmluZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjkpO1xudmFyIHJlZGVmaW5lQWxsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjQpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gX193X3BkZmpzX3JlcXVpcmVfXyg4NSk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IF9fd19wZGZqc19yZXF1aXJlX18oODApO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMzKTtcbnZhciBhbkluc3RhbmNlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjYpO1xudmFyIGhhc093biA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIGJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYyKTtcbnZhciBjbGFzc29mID0gX193X3BkZmpzX3JlcXVpcmVfXyg5NSk7XG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI4KTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIGNyZWF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNzEpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYpO1xudmFyIGdldEl0ZXJhdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxNDMpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193X3BkZmpzX3JlcXVpcmVfXyg5NCk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgJGZldGNoID0gZ2V0QnVpbHRJbignZmV0Y2gnKTtcbnZhciBIZWFkZXJzID0gZ2V0QnVpbHRJbignSGVhZGVycycpO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TID0gJ1VSTFNlYXJjaFBhcmFtcyc7XG52YXIgVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IgPSBVUkxfU0VBUkNIX1BBUkFNUyArICdJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsUGFyYW1zU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNUyk7XG52YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IpO1xudmFyIHBsdXMgPSAvXFwrL2c7XG52YXIgc2VxdWVuY2VzID0gQXJyYXkoNCk7XG52YXIgcGVyY2VudFNlcXVlbmNlID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gcmV0dXJuIHNlcXVlbmNlc1tieXRlcyAtIDFdIHx8IChzZXF1ZW5jZXNbYnl0ZXMgLSAxXSA9IFJlZ0V4cCgnKCg/OiVbXFxcXGRhLWZdezJ9KXsnICsgYnl0ZXMgKyAnfSknLCAnZ2knKSk7XG59O1xudmFyIHBlcmNlbnREZWNvZGUgPSBmdW5jdGlvbiAoc2VxdWVuY2UpIHtcbiB0cnkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHNlcXVlbmNlKTtcbiB9IGNhdGNoIChlcnJvcikge1xuICByZXR1cm4gc2VxdWVuY2U7XG4gfVxufTtcbnZhciBkZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xuIHZhciByZXN1bHQgPSBpdC5yZXBsYWNlKHBsdXMsICcgJyk7XG4gdmFyIGJ5dGVzID0gNDtcbiB0cnkge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgd2hpbGUgKGJ5dGVzKSB7XG4gICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShwZXJjZW50U2VxdWVuY2UoYnl0ZXMtLSksIHBlcmNlbnREZWNvZGUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG4gfVxufTtcbnZhciBmaW5kID0gL1shJygpfl18JTIwL2c7XG52YXIgcmVwbGFjZSA9IHtcbiAnISc6ICclMjEnLFxuIFwiJ1wiOiAnJTI3JyxcbiAnKCc6ICclMjgnLFxuICcpJzogJyUyOScsXG4gJ34nOiAnJTdFJyxcbiAnJTIwJzogJysnXG59O1xudmFyIHJlcGxhY2VyID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gcmV0dXJuIHJlcGxhY2VbbWF0Y2hdO1xufTtcbnZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAoaXQpIHtcbiByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGl0KS5yZXBsYWNlKGZpbmQsIHJlcGxhY2VyKTtcbn07XG52YXIgcGFyc2VTZWFyY2hQYXJhbXMgPSBmdW5jdGlvbiAocmVzdWx0LCBxdWVyeSkge1xuIGlmIChxdWVyeSkge1xuICB2YXIgYXR0cmlidXRlcyA9IHF1ZXJ5LnNwbGl0KCcmJyk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBhdHRyaWJ1dGUsIGVudHJ5O1xuICB3aGlsZSAoaW5kZXggPCBhdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgYXR0cmlidXRlID0gYXR0cmlidXRlc1tpbmRleCsrXTtcbiAgIGlmIChhdHRyaWJ1dGUubGVuZ3RoKSB7XG4gICAgZW50cnkgPSBhdHRyaWJ1dGUuc3BsaXQoJz0nKTtcbiAgICByZXN1bHQucHVzaCh7XG4gICAgIGtleTogZGVzZXJpYWxpemUoZW50cnkuc2hpZnQoKSksXG4gICAgIHZhbHVlOiBkZXNlcmlhbGl6ZShlbnRyeS5qb2luKCc9JykpXG4gICAgfSk7XG4gICB9XG4gIH1cbiB9XG59O1xudmFyIHVwZGF0ZVNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uIChxdWVyeSkge1xuIHRoaXMuZW50cmllcy5sZW5ndGggPSAwO1xuIHBhcnNlU2VhcmNoUGFyYW1zKHRoaXMuZW50cmllcywgcXVlcnkpO1xufTtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gaWYgKHBhc3NlZCA8IHJlcXVpcmVkKVxuICB0aHJvdyBUeXBlRXJyb3IoJ05vdCBlbm91Z2ggYXJndW1lbnRzJyk7XG59O1xudmFyIFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihmdW5jdGlvbiBJdGVyYXRvcihwYXJhbXMsIGtpbmQpIHtcbiBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgdHlwZTogVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IsXG4gIGl0ZXJhdG9yOiBnZXRJdGVyYXRvcihnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHBhcmFtcykuZW50cmllcyksXG4gIGtpbmQ6IGtpbmRcbiB9KTtcbn0sICdJdGVyYXRvcicsIGZ1bmN0aW9uIG5leHQoKSB7XG4gdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuIHZhciBraW5kID0gc3RhdGUua2luZDtcbiB2YXIgc3RlcCA9IHN0YXRlLml0ZXJhdG9yLm5leHQoKTtcbiB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuIGlmICghc3RlcC5kb25lKSB7XG4gIHN0ZXAudmFsdWUgPSBraW5kID09PSAna2V5cycgPyBlbnRyeS5rZXkgOiBraW5kID09PSAndmFsdWVzJyA/IGVudHJ5LnZhbHVlIDogW1xuICAgZW50cnkua2V5LFxuICAgZW50cnkudmFsdWVcbiAgXTtcbiB9XG4gcmV0dXJuIHN0ZXA7XG59KTtcbnZhciBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcygpIHtcbiBhbkluc3RhbmNlKHRoaXMsIFVSTFNlYXJjaFBhcmFtc0NvbnN0cnVjdG9yLCBVUkxfU0VBUkNIX1BBUkFNUyk7XG4gdmFyIGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiB2YXIgdGhhdCA9IHRoaXM7XG4gdmFyIGVudHJpZXMgPSBbXTtcbiB2YXIgaXRlcmF0b3JNZXRob2QsIGl0ZXJhdG9yLCBuZXh0LCBzdGVwLCBlbnRyeUl0ZXJhdG9yLCBlbnRyeU5leHQsIGZpcnN0LCBzZWNvbmQsIGtleTtcbiBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgdHlwZTogVVJMX1NFQVJDSF9QQVJBTVMsXG4gIGVudHJpZXM6IGVudHJpZXMsXG4gIHVwZGF0ZVVSTDogZnVuY3Rpb24gKCkge1xuICB9LFxuICB1cGRhdGVTZWFyY2hQYXJhbXM6IHVwZGF0ZVNlYXJjaFBhcmFtc1xuIH0pO1xuIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgaWYgKGlzT2JqZWN0KGluaXQpKSB7XG4gICBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKGluaXQpO1xuICAgaWYgKHR5cGVvZiBpdGVyYXRvck1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGl0ZXJhdG9yID0gaXRlcmF0b3JNZXRob2QuY2FsbChpbml0KTtcbiAgICBuZXh0ID0gaXRlcmF0b3IubmV4dDtcbiAgICB3aGlsZSAoIShzdGVwID0gbmV4dC5jYWxsKGl0ZXJhdG9yKSkuZG9uZSkge1xuICAgICBlbnRyeUl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoYW5PYmplY3Qoc3RlcC52YWx1ZSkpO1xuICAgICBlbnRyeU5leHQgPSBlbnRyeUl0ZXJhdG9yLm5leHQ7XG4gICAgIGlmICgoZmlyc3QgPSBlbnRyeU5leHQuY2FsbChlbnRyeUl0ZXJhdG9yKSkuZG9uZSB8fCAoc2Vjb25kID0gZW50cnlOZXh0LmNhbGwoZW50cnlJdGVyYXRvcikpLmRvbmUgfHwgIWVudHJ5TmV4dC5jYWxsKGVudHJ5SXRlcmF0b3IpLmRvbmUpXG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDInKTtcbiAgICAgZW50cmllcy5wdXNoKHtcbiAgICAgIGtleTogZmlyc3QudmFsdWUgKyAnJyxcbiAgICAgIHZhbHVlOiBzZWNvbmQudmFsdWUgKyAnJ1xuICAgICB9KTtcbiAgICB9XG4gICB9IGVsc2VcbiAgICBmb3IgKGtleSBpbiBpbml0KVxuICAgICBpZiAoaGFzT3duKGluaXQsIGtleSkpXG4gICAgICBlbnRyaWVzLnB1c2goe1xuICAgICAgIGtleToga2V5LFxuICAgICAgIHZhbHVlOiBpbml0W2tleV0gKyAnJ1xuICAgICAgfSk7XG4gIH0gZWxzZSB7XG4gICBwYXJzZVNlYXJjaFBhcmFtcyhlbnRyaWVzLCB0eXBlb2YgaW5pdCA9PT0gJ3N0cmluZycgPyBpbml0LmNoYXJBdCgwKSA9PT0gJz8nID8gaW5pdC5zbGljZSgxKSA6IGluaXQgOiBpbml0ICsgJycpO1xuICB9XG4gfVxufTtcbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5yZWRlZmluZUFsbChVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsIHtcbiBhcHBlbmQ6IGZ1bmN0aW9uIGFwcGVuZChuYW1lLCB2YWx1ZSkge1xuICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAyKTtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgc3RhdGUuZW50cmllcy5wdXNoKHtcbiAgIGtleTogbmFtZSArICcnLFxuICAgdmFsdWU6IHZhbHVlICsgJydcbiAgfSk7XG4gIHN0YXRlLnVwZGF0ZVVSTCgpO1xuIH0sXG4gJ2RlbGV0ZSc6IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gIHZhciBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICBpZiAoZW50cmllc1tpbmRleF0ua2V5ID09PSBrZXkpXG4gICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgZWxzZVxuICAgIGluZGV4Kys7XG4gIH1cbiAgc3RhdGUudXBkYXRlVVJMKCk7XG4gfSxcbiBnZXQ6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgIGlmIChlbnRyaWVzW2luZGV4XS5rZXkgPT09IGtleSlcbiAgICByZXR1cm4gZW50cmllc1tpbmRleF0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG4gfSxcbiBnZXRBbGw6IGZ1bmN0aW9uIGdldEFsbChuYW1lKSB7XG4gIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB2YXIgaW5kZXggPSAwO1xuICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KVxuICAgIHJlc3VsdC5wdXNoKGVudHJpZXNbaW5kZXhdLnZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xuIH0sXG4gaGFzOiBmdW5jdGlvbiBoYXMobmFtZSkge1xuICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gIHZhciBpbmRleCA9IDA7XG4gIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICBpZiAoZW50cmllc1tpbmRleCsrXS5rZXkgPT09IGtleSlcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG4gfSxcbiBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgdmFyIGVudHJpZXMgPSBzdGF0ZS5lbnRyaWVzO1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgdmFyIHZhbCA9IHZhbHVlICsgJyc7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBlbnRyeTtcbiAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICBpZiAoZW50cnkua2V5ID09PSBrZXkpIHtcbiAgICBpZiAoZm91bmQpXG4gICAgIGVudHJpZXMuc3BsaWNlKGluZGV4LS0sIDEpO1xuICAgIGVsc2Uge1xuICAgICBmb3VuZCA9IHRydWU7XG4gICAgIGVudHJ5LnZhbHVlID0gdmFsO1xuICAgIH1cbiAgIH1cbiAgfVxuICBpZiAoIWZvdW5kKVxuICAgZW50cmllcy5wdXNoKHtcbiAgICBrZXk6IGtleSxcbiAgICB2YWx1ZTogdmFsXG4gICB9KTtcbiAgc3RhdGUudXBkYXRlVVJMKCk7XG4gfSxcbiBzb3J0OiBmdW5jdGlvbiBzb3J0KCkge1xuICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gIHZhciBzbGljZSA9IGVudHJpZXMuc2xpY2UoKTtcbiAgdmFyIGVudHJ5LCBlbnRyaWVzSW5kZXgsIHNsaWNlSW5kZXg7XG4gIGVudHJpZXMubGVuZ3RoID0gMDtcbiAgZm9yIChzbGljZUluZGV4ID0gMDsgc2xpY2VJbmRleCA8IHNsaWNlLmxlbmd0aDsgc2xpY2VJbmRleCsrKSB7XG4gICBlbnRyeSA9IHNsaWNlW3NsaWNlSW5kZXhdO1xuICAgZm9yIChlbnRyaWVzSW5kZXggPSAwOyBlbnRyaWVzSW5kZXggPCBzbGljZUluZGV4OyBlbnRyaWVzSW5kZXgrKykge1xuICAgIGlmIChlbnRyaWVzW2VudHJpZXNJbmRleF0ua2V5ID4gZW50cnkua2V5KSB7XG4gICAgIGVudHJpZXMuc3BsaWNlKGVudHJpZXNJbmRleCwgMCwgZW50cnkpO1xuICAgICBicmVhaztcbiAgICB9XG4gICB9XG4gICBpZiAoZW50cmllc0luZGV4ID09PSBzbGljZUluZGV4KVxuICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cbiAgc3RhdGUudXBkYXRlVVJMKCk7XG4gfSxcbiBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2ssIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGVudHJ5O1xuICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgZW50cnkgPSBlbnRyaWVzW2luZGV4KytdO1xuICAgYm91bmRGdW5jdGlvbihlbnRyeS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTtcbiAgfVxuIH0sXG4ga2V5czogZnVuY3Rpb24ga2V5cygpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAna2V5cycpO1xuIH0sXG4gdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ3ZhbHVlcycpO1xuIH0sXG4gZW50cmllczogZnVuY3Rpb24gZW50cmllcygpIHtcbiAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAnZW50cmllcycpO1xuIH1cbn0sIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbnJlZGVmaW5lKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgSVRFUkFUT1IsIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5lbnRyaWVzKTtcbnJlZGVmaW5lKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gdmFyIHJlc3VsdCA9IFtdO1xuIHZhciBpbmRleCA9IDA7XG4gdmFyIGVudHJ5O1xuIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgcmVzdWx0LnB1c2goc2VyaWFsaXplKGVudHJ5LmtleSkgKyAnPScgKyBzZXJpYWxpemUoZW50cnkudmFsdWUpKTtcbiB9XG4gcmV0dXJuIHJlc3VsdC5qb2luKCcmJyk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5zZXRUb1N0cmluZ1RhZyhVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciwgVVJMX1NFQVJDSF9QQVJBTVMpO1xuJCh7XG4gZ2xvYmFsOiB0cnVlLFxuIGZvcmNlZDogIVVTRV9OQVRJVkVfVVJMXG59LCB7IFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IgfSk7XG5pZiAoIVVTRV9OQVRJVkVfVVJMICYmIHR5cGVvZiAkZmV0Y2ggPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSGVhZGVycyA9PSAnZnVuY3Rpb24nKSB7XG4gJCh7XG4gIGdsb2JhbDogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZm9yY2VkOiB0cnVlXG4gfSwge1xuICBmZXRjaDogZnVuY3Rpb24gZmV0Y2goaW5wdXQpIHtcbiAgIHZhciBhcmdzID0gW2lucHV0XTtcbiAgIHZhciBpbml0LCBib2R5LCBoZWFkZXJzO1xuICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgaW5pdCA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoaXNPYmplY3QoaW5pdCkpIHtcbiAgICAgYm9keSA9IGluaXQuYm9keTtcbiAgICAgaWYgKGNsYXNzb2YoYm9keSkgPT09IFVSTF9TRUFSQ0hfUEFSQU1TKSB7XG4gICAgICBoZWFkZXJzID0gaW5pdC5oZWFkZXJzID8gbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKSA6IG5ldyBIZWFkZXJzKCk7XG4gICAgICBpZiAoIWhlYWRlcnMuaGFzKCdjb250ZW50LXR5cGUnKSkge1xuICAgICAgIGhlYWRlcnMuc2V0KCdjb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgIH1cbiAgICAgIGluaXQgPSBjcmVhdGUoaW5pdCwge1xuICAgICAgIGJvZHk6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBTdHJpbmcoYm9keSkpLFxuICAgICAgIGhlYWRlcnM6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBoZWFkZXJzKVxuICAgICAgfSk7XG4gICAgIH1cbiAgICB9XG4gICAgYXJncy5wdXNoKGluaXQpO1xuICAgfVxuICAgcmV0dXJuICRmZXRjaC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuIH0pO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gVVJMU2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvcixcbiBnZXRTdGF0ZTogZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZVxufTtcblxuLyoqKi8gfSksXG4vKiAxNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyOCk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk0KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gdmFyIGl0ZXJhdG9yTWV0aG9kID0gZ2V0SXRlcmF0b3JNZXRob2QoaXQpO1xuIGlmICh0eXBlb2YgaXRlcmF0b3JNZXRob2QgIT0gJ2Z1bmN0aW9uJykge1xuICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGl0ZXJhYmxlJyk7XG4gfVxuIHJldHVybiBhbk9iamVjdChpdGVyYXRvck1ldGhvZC5jYWxsKGl0KSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbiQoe1xuIHRhcmdldDogJ1VSTCcsXG4gcHJvdG86IHRydWUsXG4gZW51bWVyYWJsZTogdHJ1ZVxufSwge1xuIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gVVJMLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRoaXMpO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0cnVlID8gZmFjdG9yeShleHBvcnRzKSA6IHVuZGVmaW5lZDtcbn0odGhpcywgZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAndXNlIHN0cmljdCc7XG4gdmFyIFN5bWJvbFBvbHlmaWxsID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJyA/IFN5bWJvbCA6IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICByZXR1cm4gXCJTeW1ib2woXCIgKyBkZXNjcmlwdGlvbiArIFwiKVwiO1xuIH07XG4gZnVuY3Rpb24gbm9vcCgpIHtcbiB9XG4gdmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uICh4KSB7XG4gIHJldHVybiB4ICE9PSB4O1xuIH07XG4gdmFyIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbiA9IG5vb3A7XG4gZnVuY3Rpb24gdHlwZUlzT2JqZWN0KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9PSBudWxsIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nO1xuIH1cbiBmdW5jdGlvbiBjcmVhdGVBcnJheUZyb21MaXN0KGVsZW1lbnRzKSB7XG4gIHJldHVybiBlbGVtZW50cy5zbGljZSgpO1xuIH1cbiBmdW5jdGlvbiBBcnJheUJ1ZmZlckNvcHkoZGVzdCwgZGVzdE9mZnNldCwgc3JjLCBzcmNPZmZzZXQsIG4pIHtcbiAgbmV3IFVpbnQ4QXJyYXkoZGVzdCkuc2V0KG5ldyBVaW50OEFycmF5KHNyYywgc3JjT2Zmc2V0LCBuKSwgZGVzdE9mZnNldCk7XG4gfVxuIGZ1bmN0aW9uIElzRmluaXRlTm9uTmVnYXRpdmVOdW1iZXIodikge1xuICBpZiAoSXNOb25OZWdhdGl2ZU51bWJlcih2KSA9PT0gZmFsc2UpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodiA9PT0gSW5maW5pdHkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gSXNOb25OZWdhdGl2ZU51bWJlcih2KSB7XG4gIGlmICh0eXBlb2YgdiAhPT0gJ251bWJlcicpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoTnVtYmVySXNOYU4odikpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodiA8IDApIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gQ2FsbChGLCBWLCBhcmdzKSB7XG4gIGlmICh0eXBlb2YgRiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfVxuICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoRiwgViwgYXJncyk7XG4gfVxuIGZ1bmN0aW9uIENyZWF0ZUFsZ29yaXRobUZyb21VbmRlcmx5aW5nTWV0aG9kKHVuZGVybHlpbmdPYmplY3QsIG1ldGhvZE5hbWUsIGFsZ29BcmdDb3VudCwgZXh0cmFBcmdzKSB7XG4gIHZhciBtZXRob2QgPSB1bmRlcmx5aW5nT2JqZWN0W21ldGhvZE5hbWVdO1xuICBpZiAobWV0aG9kICE9PSB1bmRlZmluZWQpIHtcbiAgIGlmICh0eXBlb2YgbWV0aG9kICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtZXRob2QgKyBcIiBpcyBub3QgYSBtZXRob2RcIik7XG4gICB9XG4gICBzd2l0Y2ggKGFsZ29BcmdDb3VudCkge1xuICAgY2FzZSAwOiB7XG4gICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZUNhbGwobWV0aG9kLCB1bmRlcmx5aW5nT2JqZWN0LCBleHRyYUFyZ3MpO1xuICAgICB9O1xuICAgIH1cbiAgIGNhc2UgMToge1xuICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgICAgdmFyIGZ1bGxBcmdzID0gW2FyZ10uY29uY2F0KGV4dHJhQXJncyk7XG4gICAgICByZXR1cm4gUHJvbWlzZUNhbGwobWV0aG9kLCB1bmRlcmx5aW5nT2JqZWN0LCBmdWxsQXJncyk7XG4gICAgIH07XG4gICAgfVxuICAgfVxuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICB9O1xuIH1cbiBmdW5jdGlvbiBJbnZva2VPck5vb3AoTywgUCwgYXJncykge1xuICB2YXIgbWV0aG9kID0gT1tQXTtcbiAgaWYgKG1ldGhvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBDYWxsKG1ldGhvZCwgTywgYXJncyk7XG4gfVxuIGZ1bmN0aW9uIFByb21pc2VDYWxsKEYsIFYsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKENhbGwoRiwgViwgYXJncykpO1xuICB9IGNhdGNoICh2YWx1ZSkge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgodmFsdWUpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFRyYW5zZmVyQXJyYXlCdWZmZXIoTykge1xuICByZXR1cm4gTztcbiB9XG4gZnVuY3Rpb24gSXNEZXRhY2hlZEJ1ZmZlcihPKSB7XG4gIHJldHVybiBmYWxzZTtcbiB9XG4gZnVuY3Rpb24gVmFsaWRhdGVBbmROb3JtYWxpemVIaWdoV2F0ZXJNYXJrKGhpZ2hXYXRlck1hcmspIHtcbiAgaGlnaFdhdGVyTWFyayA9IE51bWJlcihoaWdoV2F0ZXJNYXJrKTtcbiAgaWYgKE51bWJlcklzTmFOKGhpZ2hXYXRlck1hcmspIHx8IGhpZ2hXYXRlck1hcmsgPCAwKSB7XG4gICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaGlnaFdhdGVyTWFyayBwcm9wZXJ0eSBvZiBhIHF1ZXVpbmcgc3RyYXRlZ3kgbXVzdCBiZSBub24tbmVnYXRpdmUgYW5kIG5vbi1OYU4nKTtcbiAgfVxuICByZXR1cm4gaGlnaFdhdGVyTWFyaztcbiB9XG4gZnVuY3Rpb24gTWFrZVNpemVBbGdvcml0aG1Gcm9tU2l6ZUZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gMTtcbiAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnZnVuY3Rpb24nKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplIHByb3BlcnR5IG9mIGEgcXVldWluZyBzdHJhdGVneSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24gKGNodW5rKSB7XG4gICByZXR1cm4gc2l6ZShjaHVuayk7XG4gIH07XG4gfVxuIHZhciBvcmlnaW5hbFByb21pc2UgPSBQcm9taXNlO1xuIHZhciBvcmlnaW5hbFByb21pc2VUaGVuID0gUHJvbWlzZS5wcm90b3R5cGUudGhlbjtcbiB2YXIgb3JpZ2luYWxQcm9taXNlUmVzb2x2ZSA9IFByb21pc2UucmVzb2x2ZS5iaW5kKG9yaWdpbmFsUHJvbWlzZSk7XG4gdmFyIG9yaWdpbmFsUHJvbWlzZVJlamVjdCA9IFByb21pc2UucmVqZWN0LmJpbmQob3JpZ2luYWxQcm9taXNlKTtcbiBmdW5jdGlvbiBuZXdQcm9taXNlKGV4ZWN1dG9yKSB7XG4gIHJldHVybiBuZXcgb3JpZ2luYWxQcm9taXNlKGV4ZWN1dG9yKTtcbiB9XG4gZnVuY3Rpb24gcHJvbWlzZVJlc29sdmVkV2l0aCh2YWx1ZSkge1xuICByZXR1cm4gb3JpZ2luYWxQcm9taXNlUmVzb2x2ZSh2YWx1ZSk7XG4gfVxuIGZ1bmN0aW9uIHByb21pc2VSZWplY3RlZFdpdGgocmVhc29uKSB7XG4gIHJldHVybiBvcmlnaW5hbFByb21pc2VSZWplY3QocmVhc29uKTtcbiB9XG4gZnVuY3Rpb24gUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIHJldHVybiBvcmlnaW5hbFByb21pc2VUaGVuLmNhbGwocHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuIH1cbiBmdW5jdGlvbiB1cG9uUHJvbWlzZShwcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICBQZXJmb3JtUHJvbWlzZVRoZW4oUGVyZm9ybVByb21pc2VUaGVuKHByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSwgdW5kZWZpbmVkLCByZXRocm93QXNzZXJ0aW9uRXJyb3JSZWplY3Rpb24pO1xuIH1cbiBmdW5jdGlvbiB1cG9uRnVsZmlsbG1lbnQocHJvbWlzZSwgb25GdWxmaWxsZWQpIHtcbiAgdXBvblByb21pc2UocHJvbWlzZSwgb25GdWxmaWxsZWQpO1xuIH1cbiBmdW5jdGlvbiB1cG9uUmVqZWN0aW9uKHByb21pc2UsIG9uUmVqZWN0ZWQpIHtcbiAgdXBvblByb21pc2UocHJvbWlzZSwgdW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiB9XG4gZnVuY3Rpb24gdHJhbnNmb3JtUHJvbWlzZVdpdGgocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKSB7XG4gIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4ocHJvbWlzZSwgZnVsZmlsbG1lbnRIYW5kbGVyLCByZWplY3Rpb25IYW5kbGVyKTtcbiB9XG4gZnVuY3Rpb24gc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShwcm9taXNlKSB7XG4gIFBlcmZvcm1Qcm9taXNlVGhlbihwcm9taXNlLCB1bmRlZmluZWQsIHJldGhyb3dBc3NlcnRpb25FcnJvclJlamVjdGlvbik7XG4gfVxuIHZhciBRVUVVRV9NQVhfQVJSQVlfU0laRSA9IDE2Mzg0O1xuIHZhciBTaW1wbGVRdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gU2ltcGxlUXVldWUoKSB7XG4gICB0aGlzLl9jdXJzb3IgPSAwO1xuICAgdGhpcy5fc2l6ZSA9IDA7XG4gICB0aGlzLl9mcm9udCA9IHtcbiAgICBfZWxlbWVudHM6IFtdLFxuICAgIF9uZXh0OiB1bmRlZmluZWRcbiAgIH07XG4gICB0aGlzLl9iYWNrID0gdGhpcy5fZnJvbnQ7XG4gICB0aGlzLl9jdXJzb3IgPSAwO1xuICAgdGhpcy5fc2l6ZSA9IDA7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNpbXBsZVF1ZXVlLnByb3RvdHlwZSwgXCJsZW5ndGhcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICB9LFxuICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgU2ltcGxlUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgdmFyIG9sZEJhY2sgPSB0aGlzLl9iYWNrO1xuICAgdmFyIG5ld0JhY2sgPSBvbGRCYWNrO1xuICAgaWYgKG9sZEJhY2suX2VsZW1lbnRzLmxlbmd0aCA9PT0gUVVFVUVfTUFYX0FSUkFZX1NJWkUgLSAxKSB7XG4gICAgbmV3QmFjayA9IHtcbiAgICAgX2VsZW1lbnRzOiBbXSxcbiAgICAgX25leHQ6IHVuZGVmaW5lZFxuICAgIH07XG4gICB9XG4gICBvbGRCYWNrLl9lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgaWYgKG5ld0JhY2sgIT09IG9sZEJhY2spIHtcbiAgICB0aGlzLl9iYWNrID0gbmV3QmFjaztcbiAgICBvbGRCYWNrLl9uZXh0ID0gbmV3QmFjaztcbiAgIH1cbiAgICsrdGhpcy5fc2l6ZTtcbiAgfTtcbiAgU2ltcGxlUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgdmFyIG9sZEZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICB2YXIgbmV3RnJvbnQgPSBvbGRGcm9udDtcbiAgIHZhciBvbGRDdXJzb3IgPSB0aGlzLl9jdXJzb3I7XG4gICB2YXIgbmV3Q3Vyc29yID0gb2xkQ3Vyc29yICsgMTtcbiAgIHZhciBlbGVtZW50cyA9IG9sZEZyb250Ll9lbGVtZW50cztcbiAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNbb2xkQ3Vyc29yXTtcbiAgIGlmIChuZXdDdXJzb3IgPT09IFFVRVVFX01BWF9BUlJBWV9TSVpFKSB7XG4gICAgbmV3RnJvbnQgPSBvbGRGcm9udC5fbmV4dDtcbiAgICBuZXdDdXJzb3IgPSAwO1xuICAgfVxuICAgLS10aGlzLl9zaXplO1xuICAgdGhpcy5fY3Vyc29yID0gbmV3Q3Vyc29yO1xuICAgaWYgKG9sZEZyb250ICE9PSBuZXdGcm9udCkge1xuICAgIHRoaXMuX2Zyb250ID0gbmV3RnJvbnQ7XG4gICB9XG4gICBlbGVtZW50c1tvbGRDdXJzb3JdID0gdW5kZWZpbmVkO1xuICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH07XG4gIFNpbXBsZVF1ZXVlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICB2YXIgaSA9IHRoaXMuX2N1cnNvcjtcbiAgIHZhciBub2RlID0gdGhpcy5fZnJvbnQ7XG4gICB2YXIgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcbiAgIHdoaWxlIChpICE9PSBlbGVtZW50cy5sZW5ndGggfHwgbm9kZS5fbmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGkgPT09IGVsZW1lbnRzLmxlbmd0aCkge1xuICAgICBub2RlID0gbm9kZS5fbmV4dDtcbiAgICAgZWxlbWVudHMgPSBub2RlLl9lbGVtZW50cztcbiAgICAgaSA9IDA7XG4gICAgIGlmIChlbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgICB9XG4gICAgfVxuICAgIGNhbGxiYWNrKGVsZW1lbnRzW2ldKTtcbiAgICArK2k7XG4gICB9XG4gIH07XG4gIFNpbXBsZVF1ZXVlLnByb3RvdHlwZS5wZWVrID0gZnVuY3Rpb24gKCkge1xuICAgdmFyIGZyb250ID0gdGhpcy5fZnJvbnQ7XG4gICB2YXIgY3Vyc29yID0gdGhpcy5fY3Vyc29yO1xuICAgcmV0dXJuIGZyb250Ll9lbGVtZW50c1tjdXJzb3JdO1xuICB9O1xuICByZXR1cm4gU2ltcGxlUXVldWU7XG4gfSgpO1xuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ3JlYXRlUmVhZFJlc3VsdCh2YWx1ZSwgZG9uZSwgZm9yQXV0aG9yQ29kZSkge1xuICB2YXIgcHJvdG90eXBlID0gbnVsbDtcbiAgaWYgKGZvckF1dGhvckNvZGUgPT09IHRydWUpIHtcbiAgIHByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG4gIH1cbiAgdmFyIG9iaiA9IE9iamVjdC5jcmVhdGUocHJvdG90eXBlKTtcbiAgb2JqLnZhbHVlID0gdmFsdWU7XG4gIG9iai5kb25lID0gZG9uZTtcbiAgcmV0dXJuIG9iajtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljSW5pdGlhbGl6ZShyZWFkZXIsIHN0cmVhbSkge1xuICByZWFkZXIuX2ZvckF1dGhvckNvZGUgPSB0cnVlO1xuICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPSBzdHJlYW07XG4gIHN0cmVhbS5fcmVhZGVyID0gcmVhZGVyO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ3JlYWRhYmxlJykge1xuICAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcik7XG4gIH0gZWxzZSBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKTtcbiAgfSBlbHNlIHtcbiAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQocmVhZGVyLCBzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCByZWFzb24pIHtcbiAgdmFyIHN0cmVhbSA9IHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbTtcbiAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgcmVhc29uKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpIHtcbiAgaWYgKHJlYWRlci5fb3duZXJSZWFkYWJsZVN0cmVhbS5fc3RhdGUgPT09ICdyZWFkYWJsZScpIHtcbiAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVqZWN0KHJlYWRlciwgbmV3IFR5cGVFcnJvcignUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbVxcJ3MgY2xvc2VkbmVzcycpKTtcbiAgfSBlbHNlIHtcbiAgIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHJlYWRlciwgbmV3IFR5cGVFcnJvcignUmVhZGVyIHdhcyByZWxlYXNlZCBhbmQgY2FuIG5vIGxvbmdlciBiZSB1c2VkIHRvIG1vbml0b3IgdGhlIHN0cmVhbVxcJ3MgY2xvc2VkbmVzcycpKTtcbiAgfVxuICByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0uX3JlYWRlciA9IHVuZGVmaW5lZDtcbiAgcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiByZWFkZXJMb2NrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCAnICsgbmFtZSArICcgYSBzdHJlYW0gdXNpbmcgYSByZWxlYXNlZCByZWFkZXInKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHJlYWRlcikge1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2UgPSBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKSB7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlamVjdChyZWFkZXIsIHJlYXNvbik7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQocmVhZGVyKSB7XG4gIGRlZmF1bHRSZWFkZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZShyZWFkZXIpO1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCByZWFzb24pIHtcbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZShyZWFkZXIuX2Nsb3NlZFByb21pc2UpO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHJlYWRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc2V0VG9SZWplY3RlZChyZWFkZXIsIHJlYXNvbikge1xuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHJlYWRlciwgcmVhc29uKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZXNvbHZlKHJlYWRlcikge1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICByZWFkZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHVuZGVmaW5lZDtcbiAgcmVhZGVyLl9jbG9zZWRQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiB9XG4gdmFyIENhbmNlbFN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbQ2FuY2VsU3RlcHNdXScpO1xuIHZhciBQdWxsU3RlcHMgPSBTeW1ib2xQb2x5ZmlsbCgnW1tQdWxsU3RlcHNdXScpO1xuIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIoc3RyZWFtLCBmb3JBdXRob3JDb2RlKSB7XG4gIGlmIChmb3JBdXRob3JDb2RlID09PSB2b2lkIDApIHtcbiAgIGZvckF1dGhvckNvZGUgPSBmYWxzZTtcbiAgfVxuICB2YXIgcmVhZGVyID0gbmV3IFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICByZWFkZXIuX2ZvckF1dGhvckNvZGUgPSBmb3JBdXRob3JDb2RlO1xuICByZXR1cm4gcmVhZGVyO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSkge1xuICB2YXIgcHJvbWlzZSA9IG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgdmFyIHJlYWRSZXF1ZXN0ID0ge1xuICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgIF9yZWplY3Q6IHJlamVjdFxuICAgfTtcbiAgIHN0cmVhbS5fcmVhZGVyLl9yZWFkUmVxdWVzdHMucHVzaChyZWFkUmVxdWVzdCk7XG4gIH0pO1xuICByZXR1cm4gcHJvbWlzZTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1GdWxmaWxsUmVhZFJlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZG9uZSkge1xuICB2YXIgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gIHZhciByZWFkUmVxdWVzdCA9IHJlYWRlci5fcmVhZFJlcXVlc3RzLnNoaWZ0KCk7XG4gIHJlYWRSZXF1ZXN0Ll9yZXNvbHZlKFJlYWRhYmxlU3RyZWFtQ3JlYXRlUmVhZFJlc3VsdChjaHVuaywgZG9uZSwgcmVhZGVyLl9mb3JBdXRob3JDb2RlKSk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLl9yZWFkZXIuX3JlYWRSZXF1ZXN0cy5sZW5ndGg7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pIHtcbiAgdmFyIHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIUlzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gdmFyIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSkge1xuICAgaWYgKElzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIgY2FuIG9ubHkgYmUgY29uc3RydWN0ZWQgd2l0aCBhIFJlYWRhYmxlU3RyZWFtIGluc3RhbmNlJyk7XG4gICB9XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSByZWFkaW5nIGJ5IGFub3RoZXIgcmVhZGVyJyk7XG4gICB9XG4gICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNJbml0aWFsaXplKHRoaXMsIHN0cmVhbSk7XG4gICB0aGlzLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZSwgXCJjbG9zZWRcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIodGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0UmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgfVxuICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgIH1cbiAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkJykpO1xuICAgfVxuICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ3JlYWQgZnJvbScpKTtcbiAgIH1cbiAgIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHRoaXMpO1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIucHJvdG90eXBlLnJlbGVhc2VMb2NrID0gZnVuY3Rpb24gKCkge1xuICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzKSkge1xuICAgIHRocm93IGRlZmF1bHRSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgfVxuICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgIH1cbiAgIGlmICh0aGlzLl9yZWFkUmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyaWVkIHRvIHJlbGVhc2UgYSByZWFkZXIgbG9jayB3aGVuIHRoYXQgcmVhZGVyIGhhcyBwZW5kaW5nIHJlYWQoKSBjYWxscyB1bi1zZXR0bGVkJyk7XG4gICB9XG4gICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHRoaXMpO1xuICB9O1xuICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyO1xuIH0oKTtcbiBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih4KSB7XG4gIGlmICghdHlwZUlzT2JqZWN0KHgpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ19yZWFkUmVxdWVzdHMnKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXJSZWFkKHJlYWRlcikge1xuICB2YXIgc3RyZWFtID0gcmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtO1xuICBzdHJlYW0uX2Rpc3R1cmJlZCA9IHRydWU7XG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgoUmVhZGFibGVTdHJlYW1DcmVhdGVSZWFkUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSwgcmVhZGVyLl9mb3JBdXRob3JDb2RlKSk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiAgcmV0dXJuIHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW1B1bGxTdGVwc10oKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFJlYWRlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlci5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclwiKTtcbiB9XG4gdmFyIF9hO1xuIHZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlO1xuIGlmICh0eXBlb2YgU3ltYm9sUG9seWZpbGwuYXN5bmNJdGVyYXRvciA9PT0gJ3N5bWJvbCcpIHtcbiAgQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IChfYSA9IHt9LCBfYVtTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB0aGlzO1xuICB9LCBfYSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBTeW1ib2xQb2x5ZmlsbC5hc3luY0l0ZXJhdG9yLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuIH1cbiB2YXIgUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlID0ge1xuICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IodGhpcykgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtQXN5bmNJdGVyYXRvckJyYW5kQ2hlY2tFeGNlcHRpb24oJ25leHQnKSk7XG4gICB9XG4gICB2YXIgcmVhZGVyID0gdGhpcy5fYXN5bmNJdGVyYXRvclJlYWRlcjtcbiAgIGlmIChyZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2l0ZXJhdGUnKSk7XG4gICB9XG4gICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIpLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgdmFyIGRvbmUgPSByZXN1bHQuZG9uZTtcbiAgICBpZiAoZG9uZSkge1xuICAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DcmVhdGVSZWFkUmVzdWx0KHZhbHVlLCBkb25lLCB0cnVlKTtcbiAgIH0pO1xuICB9LFxuICByZXR1cm46IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgaWYgKElzUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKCduZXh0JykpO1xuICAgfVxuICAgdmFyIHJlYWRlciA9IHRoaXMuX2FzeW5jSXRlcmF0b3JSZWFkZXI7XG4gICBpZiAocmVhZGVyLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdmaW5pc2ggaXRlcmF0aW5nJykpO1xuICAgfVxuICAgaWYgKHJlYWRlci5fcmVhZFJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdUcmllZCB0byByZWxlYXNlIGEgcmVhZGVyIGxvY2sgd2hlbiB0aGF0IHJlYWRlciBoYXMgcGVuZGluZyByZWFkKCkgY2FsbHMgdW4tc2V0dGxlZCcpKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9wcmV2ZW50Q2FuY2VsID09PSBmYWxzZSkge1xuICAgIHZhciByZXN1bHQgPSBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwocmVhZGVyLCB2YWx1ZSk7XG4gICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZShyZWFkZXIpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1Qcm9taXNlV2l0aChyZXN1bHQsIGZ1bmN0aW9uICgpIHtcbiAgICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ3JlYXRlUmVhZFJlc3VsdCh2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfSk7XG4gICB9XG4gICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChSZWFkYWJsZVN0cmVhbUNyZWF0ZVJlYWRSZXN1bHQodmFsdWUsIHRydWUsIHRydWUpKTtcbiAgfVxuIH07XG4gaWYgKEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgIT09IHVuZGVmaW5lZCkge1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcbiB9XG4gT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgJ25leHQnLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUsICdyZXR1cm4nLCB7IGVudW1lcmFibGU6IGZhbHNlIH0pO1xuIGZ1bmN0aW9uIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtLCBwcmV2ZW50Q2FuY2VsKSB7XG4gIGlmIChwcmV2ZW50Q2FuY2VsID09PSB2b2lkIDApIHtcbiAgIHByZXZlbnRDYW5jZWwgPSBmYWxzZTtcbiAgfVxuICB2YXIgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzdHJlYW0pO1xuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG4gIGl0ZXJhdG9yLl9hc3luY0l0ZXJhdG9yUmVhZGVyID0gcmVhZGVyO1xuICBpdGVyYXRvci5fcHJldmVudENhbmNlbCA9IEJvb2xlYW4ocHJldmVudENhbmNlbCk7XG4gIHJldHVybiBpdGVyYXRvcjtcbiB9XG4gZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IoeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXN5bmNJdGVyYXRvclJlYWRlcicpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIHN0cmVhbUFzeW5jSXRlcmF0b3JCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RlYW1Bc3luY0l0ZXJhdG9yXCIpO1xuIH1cbiBmdW5jdGlvbiBEZXF1ZXVlVmFsdWUoY29udGFpbmVyKSB7XG4gIHZhciBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5zaGlmdCgpO1xuICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplIC09IHBhaXIuc2l6ZTtcbiAgaWYgKGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPCAwKSB7XG4gICBjb250YWluZXIuX3F1ZXVlVG90YWxTaXplID0gMDtcbiAgfVxuICByZXR1cm4gcGFpci52YWx1ZTtcbiB9XG4gZnVuY3Rpb24gRW5xdWV1ZVZhbHVlV2l0aFNpemUoY29udGFpbmVyLCB2YWx1ZSwgc2l6ZSkge1xuICBzaXplID0gTnVtYmVyKHNpemUpO1xuICBpZiAoIUlzRmluaXRlTm9uTmVnYXRpdmVOdW1iZXIoc2l6ZSkpIHtcbiAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdTaXplIG11c3QgYmUgYSBmaW5pdGUsIG5vbi1OYU4sIG5vbi1uZWdhdGl2ZSBudW1iZXIuJyk7XG4gIH1cbiAgY29udGFpbmVyLl9xdWV1ZS5wdXNoKHtcbiAgIHZhbHVlOiB2YWx1ZSxcbiAgIHNpemU6IHNpemVcbiAgfSk7XG4gIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgKz0gc2l6ZTtcbiB9XG4gZnVuY3Rpb24gUGVla1F1ZXVlVmFsdWUoY29udGFpbmVyKSB7XG4gIHZhciBwYWlyID0gY29udGFpbmVyLl9xdWV1ZS5wZWVrKCk7XG4gIHJldHVybiBwYWlyLnZhbHVlO1xuIH1cbiBmdW5jdGlvbiBSZXNldFF1ZXVlKGNvbnRhaW5lcikge1xuICBjb250YWluZXIuX3F1ZXVlID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIGNvbnRhaW5lci5fcXVldWVUb3RhbFNpemUgPSAwO1xuIH1cbiB2YXIgQWJvcnRTdGVwcyA9IFN5bWJvbFBvbHlmaWxsKCdbW0Fib3J0U3RlcHNdXScpO1xuIHZhciBFcnJvclN0ZXBzID0gU3ltYm9sUG9seWZpbGwoJ1tbRXJyb3JTdGVwc11dJyk7XG4gdmFyIFdyaXRhYmxlU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbSh1bmRlcmx5aW5nU2luaywgc3RyYXRlZ3kpIHtcbiAgIGlmICh1bmRlcmx5aW5nU2luayA9PT0gdm9pZCAwKSB7XG4gICAgdW5kZXJseWluZ1NpbmsgPSB7fTtcbiAgIH1cbiAgIGlmIChzdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgc3RyYXRlZ3kgPSB7fTtcbiAgIH1cbiAgIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbSh0aGlzKTtcbiAgIHZhciBzaXplID0gc3RyYXRlZ3kuc2l6ZTtcbiAgIHZhciBoaWdoV2F0ZXJNYXJrID0gc3RyYXRlZ3kuaGlnaFdhdGVyTWFyaztcbiAgIHZhciB0eXBlID0gdW5kZXJseWluZ1NpbmsudHlwZTtcbiAgIGlmICh0eXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlIGlzIHNwZWNpZmllZCcpO1xuICAgfVxuICAgdmFyIHNpemVBbGdvcml0aG0gPSBNYWtlU2l6ZUFsZ29yaXRobUZyb21TaXplRnVuY3Rpb24oc2l6ZSk7XG4gICBpZiAoaGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaGlnaFdhdGVyTWFyayA9IDE7XG4gICB9XG4gICBoaWdoV2F0ZXJNYXJrID0gVmFsaWRhdGVBbmROb3JtYWxpemVIaWdoV2F0ZXJNYXJrKGhpZ2hXYXRlck1hcmspO1xuICAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTaW5rKHRoaXMsIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW0ucHJvdG90eXBlLCBcImxvY2tlZFwiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbignbG9ja2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IHRydWUsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Fib3J0JykpO1xuICAgfVxuICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykgPT09IHRydWUpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgYWJvcnQgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcbiAgIH1cbiAgIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHRoaXMsIHJlYXNvbik7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Nsb3NlJykpO1xuICAgfVxuICAgaWYgKElzV3JpdGFibGVTdHJlYW1Mb2NrZWQodGhpcykgPT09IHRydWUpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdDYW5ub3QgY2xvc2UgYSBzdHJlYW0gdGhhdCBhbHJlYWR5IGhhcyBhIHdyaXRlcicpKTtcbiAgIH1cbiAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjbG9zZSBhbiBhbHJlYWR5LWNsb3Npbmcgc3RyZWFtJykpO1xuICAgfVxuICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQ2xvc2UodGhpcyk7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRXcml0ZXIgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoSXNXcml0YWJsZVN0cmVhbSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKCdnZXRXcml0ZXInKTtcbiAgIH1cbiAgIHJldHVybiBBY3F1aXJlV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpO1xuICB9O1xuICByZXR1cm4gV3JpdGFibGVTdHJlYW07XG4gfSgpO1xuIGZ1bmN0aW9uIEFjcXVpcmVXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoc3RyZWFtKSB7XG4gIHJldHVybiBuZXcgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSk7XG4gfVxuIGZ1bmN0aW9uIENyZWF0ZVdyaXRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gIGlmIChoaWdoV2F0ZXJNYXJrID09PSB2b2lkIDApIHtcbiAgIGhpZ2hXYXRlck1hcmsgPSAxO1xuICB9XG4gIGlmIChzaXplQWxnb3JpdGhtID09PSB2b2lkIDApIHtcbiAgIHNpemVBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gICB9O1xuICB9XG4gIHZhciBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFdyaXRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pO1xuICB2YXIgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICBTZXRVcFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgd3JpdGVBbGdvcml0aG0sIGNsb3NlQWxnb3JpdGhtLCBhYm9ydEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gIHJldHVybiBzdHJlYW07XG4gfVxuIGZ1bmN0aW9uIEluaXRpYWxpemVXcml0YWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgc3RyZWFtLl9zdGF0ZSA9ICd3cml0YWJsZSc7XG4gIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fd3JpdGVyID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlciA9IHVuZGVmaW5lZDtcbiAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlID0gZmFsc2U7XG4gfVxuIGZ1bmN0aW9uIElzV3JpdGFibGVTdHJlYW0oeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfd3JpdGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbS5fd3JpdGVyID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1BYm9ydChzdHJlYW0sIHJlYXNvbikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICByZXR1cm4gc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0Ll9wcm9taXNlO1xuICB9XG4gIHZhciB3YXNBbHJlYWR5RXJyb3JpbmcgPSBmYWxzZTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICB3YXNBbHJlYWR5RXJyb3JpbmcgPSB0cnVlO1xuICAgcmVhc29uID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciBwcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB7XG4gICAgX3Byb21pc2U6IHVuZGVmaW5lZCxcbiAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICBfcmVqZWN0OiByZWplY3QsXG4gICAgX3JlYXNvbjogcmVhc29uLFxuICAgIF93YXNBbHJlYWR5RXJyb3Jpbmc6IHdhc0FscmVhZHlFcnJvcmluZ1xuICAgfTtcbiAgfSk7XG4gIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdC5fcHJvbWlzZSA9IHByb21pc2U7XG4gIGlmICh3YXNBbHJlYWR5RXJyb3JpbmcgPT09IGZhbHNlKSB7XG4gICBXcml0YWJsZVN0cmVhbVN0YXJ0RXJyb3Jpbmcoc3RyZWFtLCByZWFzb24pO1xuICB9XG4gIHJldHVybiBwcm9taXNlO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnIHx8IHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoXCJUaGUgc3RyZWFtIChpbiBcIiArIHN0YXRlICsgXCIgc3RhdGUpIGlzIG5vdCBpbiB0aGUgd3JpdGFibGUgc3RhdGUgYW5kIGNhbm5vdCBiZSBjbG9zZWRcIikpO1xuICB9XG4gIHZhciBwcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICB2YXIgY2xvc2VSZXF1ZXN0ID0ge1xuICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgIF9yZWplY3Q6IHJlamVjdFxuICAgfTtcbiAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gY2xvc2VSZXF1ZXN0O1xuICB9KTtcbiAgdmFyIHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQgJiYgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPT09IHRydWUgJiYgc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gIH1cbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgcmV0dXJuIHByb21pc2U7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSkge1xuICB2YXIgcHJvbWlzZSA9IG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgdmFyIHdyaXRlUmVxdWVzdCA9IHtcbiAgICBfcmVzb2x2ZTogcmVzb2x2ZSxcbiAgICBfcmVqZWN0OiByZWplY3RcbiAgIH07XG4gICBzdHJlYW0uX3dyaXRlUmVxdWVzdHMucHVzaCh3cml0ZVJlcXVlc3QpO1xuICB9KTtcbiAgcmV0dXJuIHByb21pc2U7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIGVycm9yKTtcbiAgIHJldHVybjtcbiAgfVxuICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtU3RhcnRFcnJvcmluZyhzdHJlYW0sIHJlYXNvbikge1xuICB2YXIgY29udHJvbGxlciA9IHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyO1xuICBzdHJlYW0uX3N0YXRlID0gJ2Vycm9yaW5nJztcbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgdmFyIHdyaXRlciA9IHN0cmVhbS5fd3JpdGVyO1xuICBpZiAod3JpdGVyICE9PSB1bmRlZmluZWQpIHtcbiAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVhc29uKTtcbiAgfVxuICBpZiAoV3JpdGFibGVTdHJlYW1IYXNPcGVyYXRpb25NYXJrZWRJbkZsaWdodChzdHJlYW0pID09PSBmYWxzZSAmJiBjb250cm9sbGVyLl9zdGFydGVkID09PSB0cnVlKSB7XG4gICBXcml0YWJsZVN0cmVhbUZpbmlzaEVycm9yaW5nKHN0cmVhbSk7XG4gIH1cbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hFcnJvcmluZyhzdHJlYW0pIHtcbiAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXJbRXJyb3JTdGVwc10oKTtcbiAgdmFyIHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgc3RyZWFtLl93cml0ZVJlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHdyaXRlUmVxdWVzdCkge1xuICAgd3JpdGVSZXF1ZXN0Ll9yZWplY3Qoc3RvcmVkRXJyb3IpO1xuICB9KTtcbiAgc3RyZWFtLl93cml0ZVJlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIGlmIChzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICAgcmV0dXJuO1xuICB9XG4gIHZhciBhYm9ydFJlcXVlc3QgPSBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3Q7XG4gIHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgaWYgKGFib3J0UmVxdWVzdC5fd2FzQWxyZWFkeUVycm9yaW5nID09PSB0cnVlKSB7XG4gICBhYm9ydFJlcXVlc3QuX3JlamVjdChzdG9yZWRFcnJvcik7XG4gICBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSk7XG4gICByZXR1cm47XG4gIH1cbiAgdmFyIHByb21pc2UgPSBzdHJlYW0uX3dyaXRhYmxlU3RyZWFtQ29udHJvbGxlcltBYm9ydFN0ZXBzXShhYm9ydFJlcXVlc3QuX3JlYXNvbik7XG4gIHVwb25Qcm9taXNlKHByb21pc2UsIGZ1bmN0aW9uICgpIHtcbiAgIGFib3J0UmVxdWVzdC5fcmVzb2x2ZSgpO1xuICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICBhYm9ydFJlcXVlc3QuX3JlamVjdChyZWFzb24pO1xuICAgV3JpdGFibGVTdHJlYW1SZWplY3RDbG9zZUFuZENsb3NlZFByb21pc2VJZk5lZWRlZChzdHJlYW0pO1xuICB9KTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlKHN0cmVhbSkge1xuICBzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0Ll9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZVdpdGhFcnJvcihzdHJlYW0sIGVycm9yKSB7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gIHN0cmVhbS5faW5GbGlnaHRXcml0ZVJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCBlcnJvcik7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZShzdHJlYW0pIHtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdC5fcmVzb2x2ZSh1bmRlZmluZWQpO1xuICBzdHJlYW0uX2luRmxpZ2h0Q2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICBpZiAoc3RyZWFtLl9wZW5kaW5nQWJvcnRSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3Jlc29sdmUoKTtcbiAgICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gICB9XG4gIH1cbiAgc3RyZWFtLl9zdGF0ZSA9ICdjbG9zZWQnO1xuICB2YXIgd3JpdGVyID0gc3RyZWFtLl93cml0ZXI7XG4gIGlmICh3cml0ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZXNvbHZlKHdyaXRlcik7XG4gIH1cbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlV2l0aEVycm9yKHN0cmVhbSwgZXJyb3IpIHtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdC5fcmVqZWN0KGVycm9yKTtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgaWYgKHN0cmVhbS5fcGVuZGluZ0Fib3J0UmVxdWVzdCAhPT0gdW5kZWZpbmVkKSB7XG4gICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QuX3JlamVjdChlcnJvcik7XG4gICBzdHJlYW0uX3BlbmRpbmdBYm9ydFJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIH1cbiAgV3JpdGFibGVTdHJlYW1EZWFsV2l0aFJlamVjdGlvbihzdHJlYW0sIGVycm9yKTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1DbG9zZVF1ZXVlZE9ySW5GbGlnaHQoc3RyZWFtKSB7XG4gIGlmIChzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbUhhc09wZXJhdGlvbk1hcmtlZEluRmxpZ2h0KHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9PT0gdW5kZWZpbmVkICYmIHN0cmVhbS5faW5GbGlnaHRDbG9zZVJlcXVlc3QgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcbiAgc3RyZWFtLl9pbkZsaWdodENsb3NlUmVxdWVzdCA9IHN0cmVhbS5fY2xvc2VSZXF1ZXN0O1xuICBzdHJlYW0uX2Nsb3NlUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1NYXJrRmlyc3RXcml0ZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pIHtcbiAgc3RyZWFtLl9pbkZsaWdodFdyaXRlUmVxdWVzdCA9IHN0cmVhbS5fd3JpdGVSZXF1ZXN0cy5zaGlmdCgpO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbVJlamVjdENsb3NlQW5kQ2xvc2VkUHJvbWlzZUlmTmVlZGVkKHN0cmVhbSkge1xuICBpZiAoc3RyZWFtLl9jbG9zZVJlcXVlc3QgIT09IHVuZGVmaW5lZCkge1xuICAgc3RyZWFtLl9jbG9zZVJlcXVlc3QuX3JlamVjdChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgIHN0cmVhbS5fY2xvc2VSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICB9XG4gIHZhciB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XG4gIHZhciB3cml0ZXIgPSBzdHJlYW0uX3dyaXRlcjtcbiAgaWYgKHdyaXRlciAhPT0gdW5kZWZpbmVkICYmIGJhY2twcmVzc3VyZSAhPT0gc3RyZWFtLl9iYWNrcHJlc3N1cmUpIHtcbiAgIGlmIChiYWNrcHJlc3N1cmUgPT09IHRydWUpIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzZXQod3JpdGVyKTtcbiAgIH0gZWxzZSB7XG4gICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiAgIH1cbiAgfVxuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbiB9XG4gdmFyIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHN0cmVhbSkge1xuICAgaWYgKElzV3JpdGFibGVTdHJlYW0oc3RyZWFtKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIgY2FuIG9ubHkgYmUgY29uc3RydWN0ZWQgd2l0aCBhIFdyaXRhYmxlU3RyZWFtIGluc3RhbmNlJyk7XG4gICB9XG4gICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBzdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBsb2NrZWQgZm9yIGV4Y2x1c2l2ZSB3cml0aW5nIGJ5IGFub3RoZXIgd3JpdGVyJyk7XG4gICB9XG4gICB0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICAgc3RyZWFtLl93cml0ZXIgPSB0aGlzO1xuICAgdmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgIGlmIChzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pID09PSBmYWxzZSAmJiBzdHJlYW0uX2JhY2twcmVzc3VyZSA9PT0gdHJ1ZSkge1xuICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgfVxuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh0aGlzKTtcbiAgIH0gZWxzZSBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplKHRoaXMpO1xuICAgfSBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQodGhpcyk7XG4gICAgZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh0aGlzKTtcbiAgIH0gZWxzZSB7XG4gICAgdmFyIHN0b3JlZEVycm9yID0gc3RyZWFtLl9zdG9yZWRFcnJvcjtcbiAgICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQodGhpcywgc3RvcmVkRXJyb3IpO1xuICAgfVxuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBcImNsb3NlZFwiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZWQnKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jbG9zZWRQcm9taXNlO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IHRydWUsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLCBcImRlc2lyZWRTaXplXCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICAgdGhyb3cgZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ2Rlc2lyZWRTaXplJyk7XG4gICAgfVxuICAgIHJldHVybiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZSwgXCJyZWFkeVwiLCB7XG4gICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWFkeScpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5UHJvbWlzZTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgaWYgKElzV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdhYm9ydCcpKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9vd25lcldyaXRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignYWJvcnQnKSk7XG4gICB9XG4gICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQWJvcnQodGhpcywgcmVhc29uKTtcbiAgfTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2UnKSk7XG4gICB9XG4gICB2YXIgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGRlZmF1bHRXcml0ZXJMb2NrRXhjZXB0aW9uKCdjbG9zZScpKTtcbiAgIH1cbiAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNsb3NlIGFuIGFscmVhZHktY2xvc2luZyBzdHJlYW0nKSk7XG4gICB9XG4gICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2UodGhpcyk7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUucmVsZWFzZUxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgZGVmYXVsdFdyaXRlckJyYW5kQ2hlY2tFeGNlcHRpb24oJ3JlbGVhc2VMb2NrJyk7XG4gICB9XG4gICB2YXIgc3RyZWFtID0gdGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgIGlmIChzdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgIH1cbiAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2UodGhpcyk7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcih0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbignd3JpdGUnKSk7XG4gICB9XG4gICBpZiAodGhpcy5fb3duZXJXcml0YWJsZVN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoZGVmYXVsdFdyaXRlckxvY2tFeGNlcHRpb24oJ3dyaXRlIHRvJykpO1xuICAgfVxuICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcldyaXRlKHRoaXMsIGNodW5rKTtcbiAgfTtcbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcjtcbiB9KCk7XG4gZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXIoeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfb3duZXJXcml0YWJsZVN0cmVhbScpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckFib3J0KHdyaXRlciwgcmVhc29uKSB7XG4gIHZhciBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIHJldHVybiBXcml0YWJsZVN0cmVhbUFib3J0KHN0cmVhbSwgcmVhc29uKTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2Uod3JpdGVyKSB7XG4gIHZhciBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIHJldHVybiBXcml0YWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlV2l0aEVycm9yUHJvcGFnYXRpb24od3JpdGVyKSB7XG4gIHZhciBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pID09PSB0cnVlIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckNsb3NlKHdyaXRlcik7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIGVycm9yKSB7XG4gIGlmICh3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9PT0gJ3BlbmRpbmcnKSB7XG4gICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgZXJyb3IpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgZXJyb3IpIHtcbiAgaWYgKHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPT09ICdwZW5kaW5nJykge1xuICAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIGVycm9yKTtcbiAgfSBlbHNlIHtcbiAgIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldFRvUmVqZWN0ZWQod3JpdGVyLCBlcnJvcik7XG4gIH1cbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyR2V0RGVzaXJlZFNpemUod3JpdGVyKSB7XG4gIHZhciBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnIHx8IHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHN0cmVhbS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyUmVsZWFzZSh3cml0ZXIpIHtcbiAgdmFyIHN0cmVhbSA9IHdyaXRlci5fb3duZXJXcml0YWJsZVN0cmVhbTtcbiAgdmFyIHJlbGVhc2VkRXJyb3IgPSBuZXcgVHlwZUVycm9yKCdXcml0ZXIgd2FzIHJlbGVhc2VkIGFuZCBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgdG8gbW9uaXRvciB0aGUgc3RyZWFtXFwncyBjbG9zZWRuZXNzJyk7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZVJlYWR5UHJvbWlzZVJlamVjdGVkKHdyaXRlciwgcmVsZWFzZWRFcnJvcik7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlckVuc3VyZUNsb3NlZFByb21pc2VSZWplY3RlZCh3cml0ZXIsIHJlbGVhc2VkRXJyb3IpO1xuICBzdHJlYW0uX3dyaXRlciA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIGNodW5rKSB7XG4gIHZhciBzdHJlYW0gPSB3cml0ZXIuX293bmVyV3JpdGFibGVTdHJlYW07XG4gIHZhciBjb250cm9sbGVyID0gc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXI7XG4gIHZhciBjaHVua1NpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKTtcbiAgaWYgKHN0cmVhbSAhPT0gd3JpdGVyLl9vd25lcldyaXRhYmxlU3RyZWFtKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbignd3JpdGUgdG8nKSk7XG4gIH1cbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHN0cmVhbS5fc3RvcmVkRXJyb3IpO1xuICB9XG4gIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pID09PSB0cnVlIHx8IHN0YXRlID09PSAnY2xvc2VkJykge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBpcyBjbG9zaW5nIG9yIGNsb3NlZCBhbmQgY2Fubm90IGJlIHdyaXR0ZW4gdG8nKSk7XG4gIH1cbiAgaWYgKHN0YXRlID09PSAnZXJyb3JpbmcnKSB7XG4gICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgfVxuICB2YXIgcHJvbWlzZSA9IFdyaXRhYmxlU3RyZWFtQWRkV3JpdGVSZXF1ZXN0KHN0cmVhbSk7XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJXcml0ZShjb250cm9sbGVyLCBjaHVuaywgY2h1bmtTaXplKTtcbiAgcmV0dXJuIHByb21pc2U7XG4gfVxuIHZhciBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKCkge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlciBjYW5ub3QgYmUgY29uc3RydWN0ZWQgZXhwbGljaXRseScpO1xuICB9XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVycm9yID0gZnVuY3Rpb24gKGUpIHtcbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXInKTtcbiAgIH1cbiAgIHZhciBzdGF0ZSA9IHRoaXMuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbS5fc3RhdGU7XG4gICBpZiAoc3RhdGUgIT09ICd3cml0YWJsZScpIHtcbiAgICByZXR1cm47XG4gICB9XG4gICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgZSk7XG4gIH07XG4gIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlW0Fib3J0U3RlcHNdID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgdmFyIHJlc3VsdCA9IHRoaXMuX2Fib3J0QWxnb3JpdGhtKHJlYXNvbik7XG4gICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKHRoaXMpO1xuICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGVbRXJyb3JTdGVwc10gPSBmdW5jdGlvbiAoKSB7XG4gICBSZXNldFF1ZXVlKHRoaXMpO1xuICB9O1xuICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjtcbiB9KCk7XG4gZnVuY3Rpb24gSXNXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbScpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbSA9IHN0cmVhbTtcbiAgc3RyZWFtLl93cml0YWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQ7XG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuICBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobSA9IHdyaXRlQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9jbG9zZUFsZ29yaXRobSA9IGNsb3NlQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IGFib3J0QWxnb3JpdGhtO1xuICB2YXIgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgV3JpdGFibGVTdHJlYW1VcGRhdGVCYWNrcHJlc3N1cmUoc3RyZWFtLCBiYWNrcHJlc3N1cmUpO1xuICB2YXIgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICB2YXIgc3RhcnRQcm9taXNlID0gcHJvbWlzZVJlc29sdmVkV2l0aChzdGFydFJlc3VsdCk7XG4gIHVwb25Qcm9taXNlKHN0YXJ0UHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gIH0sIGZ1bmN0aW9uIChyKSB7XG4gICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgIFdyaXRhYmxlU3RyZWFtRGVhbFdpdGhSZWplY3Rpb24oc3RyZWFtLCByKTtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIFNldFVwV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21VbmRlcmx5aW5nU2luayhzdHJlYW0sIHVuZGVybHlpbmdTaW5rLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gIHZhciBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICAgcmV0dXJuIEludm9rZU9yTm9vcCh1bmRlcmx5aW5nU2luaywgJ3N0YXJ0JywgW2NvbnRyb2xsZXJdKTtcbiAgfVxuICB2YXIgd3JpdGVBbGdvcml0aG0gPSBDcmVhdGVBbGdvcml0aG1Gcm9tVW5kZXJseWluZ01ldGhvZCh1bmRlcmx5aW5nU2luaywgJ3dyaXRlJywgMSwgW2NvbnRyb2xsZXJdKTtcbiAgdmFyIGNsb3NlQWxnb3JpdGhtID0gQ3JlYXRlQWxnb3JpdGhtRnJvbVVuZGVybHlpbmdNZXRob2QodW5kZXJseWluZ1NpbmssICdjbG9zZScsIDAsIFtdKTtcbiAgdmFyIGFib3J0QWxnb3JpdGhtID0gQ3JlYXRlQWxnb3JpdGhtRnJvbVVuZGVybHlpbmdNZXRob2QodW5kZXJseWluZ1NpbmssICdhYm9ydCcsIDEsIFtdKTtcbiAgU2V0VXBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHdyaXRlQWxnb3JpdGhtLCBjbG9zZUFsZ29yaXRobSwgYWJvcnRBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fd3JpdGVBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2Nsb3NlQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9hYm9ydEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoY29udHJvbGxlcikge1xuICBFbnF1ZXVlVmFsdWVXaXRoU2l6ZShjb250cm9sbGVyLCAnY2xvc2UnLCAwKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckFkdmFuY2VRdWV1ZUlmTmVlZGVkKGNvbnRyb2xsZXIpO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0Q2h1bmtTaXplKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gIHRyeSB7XG4gICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtKGNodW5rKTtcbiAgfSBjYXRjaCAoY2h1bmtTaXplRSkge1xuICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgY2h1bmtTaXplRSk7XG4gICByZXR1cm4gMTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcikge1xuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbiB9XG4gZnVuY3Rpb24gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcldyaXRlKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpIHtcbiAgdmFyIHdyaXRlUmVjb3JkID0geyBjaHVuazogY2h1bmsgfTtcbiAgdHJ5IHtcbiAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIHdyaXRlUmVjb3JkLCBjaHVua1NpemUpO1xuICB9IGNhdGNoIChlbnF1ZXVlRSkge1xuICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgcmV0dXJuO1xuICB9XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pID09PSBmYWxzZSAmJiBzdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICB2YXIgYmFja3ByZXNzdXJlID0gV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldEJhY2twcmVzc3VyZShjb250cm9sbGVyKTtcbiAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgfVxuICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQWR2YW5jZVF1ZXVlSWZOZWVkZWQoY29udHJvbGxlcik7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gIGlmIChjb250cm9sbGVyLl9zdGFydGVkID09PSBmYWxzZSkge1xuICAgcmV0dXJuO1xuICB9XG4gIGlmIChzdHJlYW0uX2luRmxpZ2h0V3JpdGVSZXF1ZXN0ICE9PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybjtcbiAgfVxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3N0YXRlO1xuICBpZiAoc3RhdGUgPT09ICdlcnJvcmluZycpIHtcbiAgIFdyaXRhYmxlU3RyZWFtRmluaXNoRXJyb3Jpbmcoc3RyZWFtKTtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICByZXR1cm47XG4gIH1cbiAgdmFyIHdyaXRlUmVjb3JkID0gUGVla1F1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIGlmICh3cml0ZVJlY29yZCA9PT0gJ2Nsb3NlJykge1xuICAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlclByb2Nlc3NDbG9zZShjb250cm9sbGVyKTtcbiAgfSBlbHNlIHtcbiAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzV3JpdGUoY29udHJvbGxlciwgd3JpdGVSZWNvcmQuY2h1bmspO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcklmTmVlZGVkKGNvbnRyb2xsZXIsIGVycm9yKSB7XG4gIGlmIChjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW0uX3N0YXRlID09PSAnd3JpdGFibGUnKSB7XG4gICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJQcm9jZXNzQ2xvc2UoY29udHJvbGxlcikge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFdyaXRhYmxlU3RyZWFtO1xuICBXcml0YWJsZVN0cmVhbU1hcmtDbG9zZVJlcXVlc3RJbkZsaWdodChzdHJlYW0pO1xuICBEZXF1ZXVlVmFsdWUoY29udHJvbGxlcik7XG4gIHZhciBzaW5rQ2xvc2VQcm9taXNlID0gY29udHJvbGxlci5fY2xvc2VBbGdvcml0aG0oKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgdXBvblByb21pc2Uoc2lua0Nsb3NlUHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodENsb3NlKHN0cmVhbSk7XG4gIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRDbG9zZVdpdGhFcnJvcihzdHJlYW0sIHJlYXNvbik7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyUHJvY2Vzc1dyaXRlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkV3JpdGFibGVTdHJlYW07XG4gIFdyaXRhYmxlU3RyZWFtTWFya0ZpcnN0V3JpdGVSZXF1ZXN0SW5GbGlnaHQoc3RyZWFtKTtcbiAgdmFyIHNpbmtXcml0ZVByb21pc2UgPSBjb250cm9sbGVyLl93cml0ZUFsZ29yaXRobShjaHVuayk7XG4gIHVwb25Qcm9taXNlKHNpbmtXcml0ZVByb21pc2UsIGZ1bmN0aW9uICgpIHtcbiAgIFdyaXRhYmxlU3RyZWFtRmluaXNoSW5GbGlnaHRXcml0ZShzdHJlYW0pO1xuICAgdmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgIERlcXVldWVWYWx1ZShjb250cm9sbGVyKTtcbiAgIGlmIChXcml0YWJsZVN0cmVhbUNsb3NlUXVldWVkT3JJbkZsaWdodChzdHJlYW0pID09PSBmYWxzZSAmJiBzdGF0ZSA9PT0gJ3dyaXRhYmxlJykge1xuICAgIHZhciBiYWNrcHJlc3N1cmUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0QmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpO1xuICAgIFdyaXRhYmxlU3RyZWFtVXBkYXRlQmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKTtcbiAgIH1cbiAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJBZHZhbmNlUXVldWVJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgfVxuICAgV3JpdGFibGVTdHJlYW1GaW5pc2hJbkZsaWdodFdyaXRlV2l0aEVycm9yKHN0cmVhbSwgcmVhc29uKTtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIFdyaXRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXRCYWNrcHJlc3N1cmUoY29udHJvbGxlcikge1xuICB2YXIgZGVzaXJlZFNpemUgPSBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gIHJldHVybiBkZXNpcmVkU2l6ZSA8PSAwO1xuIH1cbiBmdW5jdGlvbiBXcml0YWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZXJyb3IpIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRXcml0YWJsZVN0cmVhbTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgV3JpdGFibGVTdHJlYW1TdGFydEVycm9yaW5nKHN0cmVhbSwgZXJyb3IpO1xuIH1cbiBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJXcml0YWJsZVN0cmVhbS5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFdyaXRhYmxlU3RyZWFtXCIpO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyLnByb3RvdHlwZS5cIiArIG5hbWUgKyBcIiBjYW4gb25seSBiZSB1c2VkIG9uIGEgV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyXCIpO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyTG9ja0V4Y2VwdGlvbihuYW1lKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKCdDYW5ub3QgJyArIG5hbWUgKyAnIGEgc3RyZWFtIHVzaW5nIGEgcmVsZWFzZWQgd3JpdGVyJyk7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpIHtcbiAgd3JpdGVyLl9jbG9zZWRQcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gcmVqZWN0O1xuICAgd3JpdGVyLl9jbG9zZWRQcm9taXNlU3RhdGUgPSAncGVuZGluZyc7XG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZUluaXRpYWxpemVBc1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVzb2x2ZWQod3JpdGVyKSB7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZSh3cml0ZXIpO1xuICBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFdyaXRlckNsb3NlZFByb21pc2VSZWplY3Qod3JpdGVyLCByZWFzb24pIHtcbiAgc2V0UHJvbWlzZUlzSGFuZGxlZFRvVHJ1ZSh3cml0ZXIuX2Nsb3NlZFByb21pc2UpO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlUmVzZXRUb1JlamVjdGVkKHdyaXRlciwgcmVhc29uKSB7XG4gIGRlZmF1bHRXcml0ZXJDbG9zZWRQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUod3JpdGVyKSB7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIHdyaXRlci5fY2xvc2VkUHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VfcmVqZWN0ID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX2Nsb3NlZFByb21pc2VTdGF0ZSA9ICdyZXNvbHZlZCc7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplKHdyaXRlcikge1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZSA9IG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSByZWplY3Q7XG4gIH0pO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZVN0YXRlID0gJ3BlbmRpbmcnO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbik7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VJbml0aWFsaXplQXNSZXNvbHZlZCh3cml0ZXIpIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc29sdmUod3JpdGVyKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlamVjdCh3cml0ZXIsIHJlYXNvbikge1xuICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHdyaXRlci5fcmVhZHlQcm9taXNlKTtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVqZWN0KHJlYXNvbik7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlX3JlamVjdCA9IHVuZGVmaW5lZDtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VTdGF0ZSA9ICdyZWplY3RlZCc7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRXcml0ZXJSZWFkeVByb21pc2VSZXNldCh3cml0ZXIpIHtcbiAgZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZUluaXRpYWxpemUod3JpdGVyKTtcbiB9XG4gZnVuY3Rpb24gZGVmYXVsdFdyaXRlclJlYWR5UHJvbWlzZVJlc2V0VG9SZWplY3RlZCh3cml0ZXIsIHJlYXNvbikge1xuICBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlSW5pdGlhbGl6ZUFzUmVqZWN0ZWQod3JpdGVyLCByZWFzb24pO1xuIH1cbiBmdW5jdGlvbiBkZWZhdWx0V3JpdGVyUmVhZHlQcm9taXNlUmVzb2x2ZSh3cml0ZXIpIHtcbiAgd3JpdGVyLl9yZWFkeVByb21pc2VfcmVzb2x2ZSh1bmRlZmluZWQpO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZXNvbHZlID0gdW5kZWZpbmVkO1xuICB3cml0ZXIuX3JlYWR5UHJvbWlzZV9yZWplY3QgPSB1bmRlZmluZWQ7XG4gIHdyaXRlci5fcmVhZHlQcm9taXNlU3RhdGUgPSAnZnVsZmlsbGVkJztcbiB9XG4gZnVuY3Rpb24gaXNBYm9ydFNpZ25hbCh2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0JyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHRyeSB7XG4gICByZXR1cm4gdHlwZW9mIHZhbHVlLmFib3J0ZWQgPT09ICdib29sZWFuJztcbiAgfSBjYXRjaCAoX2EpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuIH1cbiB2YXIgTmF0aXZlRE9NRXhjZXB0aW9uID0gdHlwZW9mIERPTUV4Y2VwdGlvbiAhPT0gJ3VuZGVmaW5lZCcgPyBET01FeGNlcHRpb24gOiB1bmRlZmluZWQ7XG4gZnVuY3Rpb24gaXNET01FeGNlcHRpb25Db25zdHJ1Y3RvcihjdG9yKSB7XG4gIGlmICghKHR5cGVvZiBjdG9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBjdG9yID09PSAnb2JqZWN0JykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB0cnkge1xuICAgbmV3IGN0b3IoKTtcbiAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChfYSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gfVxuIGZ1bmN0aW9uIGNyZWF0ZURPTUV4Y2VwdGlvblBvbHlmaWxsKCkge1xuICB2YXIgY3RvciA9IGZ1bmN0aW9uIERPTUV4Y2VwdGlvbihtZXNzYWdlLCBuYW1lKSB7XG4gICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuICAgdGhpcy5uYW1lID0gbmFtZSB8fCAnRXJyb3InO1xuICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gICB9XG4gIH07XG4gIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3Rvci5wcm90b3R5cGUsICdjb25zdHJ1Y3RvcicsIHtcbiAgIHZhbHVlOiBjdG9yLFxuICAgd3JpdGFibGU6IHRydWUsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIHJldHVybiBjdG9yO1xuIH1cbiB2YXIgRE9NRXhjZXB0aW9uJDEgPSBpc0RPTUV4Y2VwdGlvbkNvbnN0cnVjdG9yKE5hdGl2ZURPTUV4Y2VwdGlvbikgPyBOYXRpdmVET01FeGNlcHRpb24gOiBjcmVhdGVET01FeGNlcHRpb25Qb2x5ZmlsbCgpO1xuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtUGlwZVRvKHNvdXJjZSwgZGVzdCwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCkge1xuICB2YXIgcmVhZGVyID0gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcihzb3VyY2UpO1xuICB2YXIgd3JpdGVyID0gQWNxdWlyZVdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlcihkZXN0KTtcbiAgc291cmNlLl9kaXN0dXJiZWQgPSB0cnVlO1xuICB2YXIgc2h1dHRpbmdEb3duID0gZmFsc2U7XG4gIHZhciBjdXJyZW50V3JpdGUgPSBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIHJldHVybiBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgIHZhciBhYm9ydEFsZ29yaXRobTtcbiAgIGlmIChzaWduYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIGFib3J0QWxnb3JpdGhtID0gZnVuY3Rpb24gKCkge1xuICAgICB2YXIgZXJyb3IgPSBuZXcgRE9NRXhjZXB0aW9uJDEoJ0Fib3J0ZWQnLCAnQWJvcnRFcnJvcicpO1xuICAgICB2YXIgYWN0aW9ucyA9IFtdO1xuICAgICBpZiAocHJldmVudEFib3J0ID09PSBmYWxzZSkge1xuICAgICAgYWN0aW9ucy5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICBpZiAoZGVzdC5fc3RhdGUgPT09ICd3cml0YWJsZScpIHtcbiAgICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgZXJyb3IpO1xuICAgICAgIH1cbiAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuICAgICAgfSk7XG4gICAgIH1cbiAgICAgaWYgKHByZXZlbnRDYW5jZWwgPT09IGZhbHNlKSB7XG4gICAgICBhY3Rpb25zLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgIGlmIChzb3VyY2UuX3N0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGVycm9yKTtcbiAgICAgICB9XG4gICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgICAgIH0pO1xuICAgICB9XG4gICAgIHNodXRkb3duV2l0aEFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYWN0aW9ucy5tYXAoZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgIHJldHVybiBhY3Rpb24oKTtcbiAgICAgIH0pKTtcbiAgICAgfSwgdHJ1ZSwgZXJyb3IpO1xuICAgIH07XG4gICAgaWYgKHNpZ25hbC5hYm9ydGVkID09PSB0cnVlKSB7XG4gICAgIGFib3J0QWxnb3JpdGhtKCk7XG4gICAgIHJldHVybjtcbiAgICB9XG4gICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRBbGdvcml0aG0pO1xuICAgfVxuICAgZnVuY3Rpb24gcGlwZUxvb3AoKSB7XG4gICAgcmV0dXJuIG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmVMb29wLCByZWplY3RMb29wKSB7XG4gICAgIGZ1bmN0aW9uIG5leHQoZG9uZSkge1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICByZXNvbHZlTG9vcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICBQZXJmb3JtUHJvbWlzZVRoZW4ocGlwZVN0ZXAoKSwgbmV4dCwgcmVqZWN0TG9vcCk7XG4gICAgICB9XG4gICAgIH1cbiAgICAgbmV4dChmYWxzZSk7XG4gICAgfSk7XG4gICB9XG4gICBmdW5jdGlvbiBwaXBlU3RlcCgpIHtcbiAgICBpZiAoc2h1dHRpbmdEb3duID09PSB0cnVlKSB7XG4gICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gUGVyZm9ybVByb21pc2VUaGVuKHdyaXRlci5fcmVhZHlQcm9taXNlLCBmdW5jdGlvbiAoKSB7XG4gICAgIHJldHVybiBQZXJmb3JtUHJvbWlzZVRoZW4oUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyUmVhZChyZWFkZXIpLCBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICBpZiAocmVzdWx0LmRvbmUgPT09IHRydWUpIHtcbiAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnRXcml0ZSA9IFBlcmZvcm1Qcm9taXNlVGhlbihXcml0YWJsZVN0cmVhbURlZmF1bHRXcml0ZXJXcml0ZSh3cml0ZXIsIHJlc3VsdC52YWx1ZSksIHVuZGVmaW5lZCwgbm9vcCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgIH0pO1xuICAgIH0pO1xuICAgfVxuICAgaXNPckJlY29tZXNFcnJvcmVkKHNvdXJjZSwgcmVhZGVyLl9jbG9zZWRQcm9taXNlLCBmdW5jdGlvbiAoc3RvcmVkRXJyb3IpIHtcbiAgICBpZiAocHJldmVudEFib3J0ID09PSBmYWxzZSkge1xuICAgICBzaHV0ZG93bldpdGhBY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIFdyaXRhYmxlU3RyZWFtQWJvcnQoZGVzdCwgc3RvcmVkRXJyb3IpO1xuICAgICB9LCB0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgc2h1dGRvd24odHJ1ZSwgc3RvcmVkRXJyb3IpO1xuICAgIH1cbiAgIH0pO1xuICAgaXNPckJlY29tZXNFcnJvcmVkKGRlc3QsIHdyaXRlci5fY2xvc2VkUHJvbWlzZSwgZnVuY3Rpb24gKHN0b3JlZEVycm9yKSB7XG4gICAgaWYgKHByZXZlbnRDYW5jZWwgPT09IGZhbHNlKSB7XG4gICAgIHNodXRkb3duV2l0aEFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1DYW5jZWwoc291cmNlLCBzdG9yZWRFcnJvcik7XG4gICAgIH0sIHRydWUsIHN0b3JlZEVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICBzaHV0ZG93bih0cnVlLCBzdG9yZWRFcnJvcik7XG4gICAgfVxuICAgfSk7XG4gICBpc09yQmVjb21lc0Nsb3NlZChzb3VyY2UsIHJlYWRlci5fY2xvc2VkUHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgIGlmIChwcmV2ZW50Q2xvc2UgPT09IGZhbHNlKSB7XG4gICAgIHNodXRkb3duV2l0aEFjdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gV3JpdGFibGVTdHJlYW1EZWZhdWx0V3JpdGVyQ2xvc2VXaXRoRXJyb3JQcm9wYWdhdGlvbih3cml0ZXIpO1xuICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICBzaHV0ZG93bigpO1xuICAgIH1cbiAgIH0pO1xuICAgaWYgKFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpID09PSB0cnVlIHx8IGRlc3QuX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgIHZhciBkZXN0Q2xvc2VkXzEgPSBuZXcgVHlwZUVycm9yKCd0aGUgZGVzdGluYXRpb24gd3JpdGFibGUgc3RyZWFtIGNsb3NlZCBiZWZvcmUgYWxsIGRhdGEgY291bGQgYmUgcGlwZWQgdG8gaXQnKTtcbiAgICBpZiAocHJldmVudENhbmNlbCA9PT0gZmFsc2UpIHtcbiAgICAgc2h1dGRvd25XaXRoQWN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUNhbmNlbChzb3VyY2UsIGRlc3RDbG9zZWRfMSk7XG4gICAgIH0sIHRydWUsIGRlc3RDbG9zZWRfMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgc2h1dGRvd24odHJ1ZSwgZGVzdENsb3NlZF8xKTtcbiAgICB9XG4gICB9XG4gICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHBpcGVMb29wKCkpO1xuICAgZnVuY3Rpb24gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkge1xuICAgIHZhciBvbGRDdXJyZW50V3JpdGUgPSBjdXJyZW50V3JpdGU7XG4gICAgcmV0dXJuIFBlcmZvcm1Qcm9taXNlVGhlbihjdXJyZW50V3JpdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgcmV0dXJuIG9sZEN1cnJlbnRXcml0ZSAhPT0gY3VycmVudFdyaXRlID8gd2FpdEZvcldyaXRlc1RvRmluaXNoKCkgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICB9XG4gICBmdW5jdGlvbiBpc09yQmVjb21lc0Vycm9yZWQoc3RyZWFtLCBwcm9taXNlLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICAgIGFjdGlvbihzdHJlYW0uX3N0b3JlZEVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICB1cG9uUmVqZWN0aW9uKHByb21pc2UsIGFjdGlvbik7XG4gICAgfVxuICAgfVxuICAgZnVuY3Rpb24gaXNPckJlY29tZXNDbG9zZWQoc3RyZWFtLCBwcm9taXNlLCBhY3Rpb24pIHtcbiAgICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgYWN0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgdXBvbkZ1bGZpbGxtZW50KHByb21pc2UsIGFjdGlvbik7XG4gICAgfVxuICAgfVxuICAgZnVuY3Rpb24gc2h1dGRvd25XaXRoQWN0aW9uKGFjdGlvbiwgb3JpZ2luYWxJc0Vycm9yLCBvcmlnaW5hbEVycm9yKSB7XG4gICAgaWYgKHNodXR0aW5nRG93biA9PT0gdHJ1ZSkge1xuICAgICByZXR1cm47XG4gICAgfVxuICAgIHNodXR0aW5nRG93biA9IHRydWU7XG4gICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpID09PSBmYWxzZSkge1xuICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGRvVGhlUmVzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgZG9UaGVSZXN0KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRvVGhlUmVzdCgpIHtcbiAgICAgdXBvblByb21pc2UoYWN0aW9uKCksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmaW5hbGl6ZShvcmlnaW5hbElzRXJyb3IsIG9yaWdpbmFsRXJyb3IpO1xuICAgICB9LCBmdW5jdGlvbiAobmV3RXJyb3IpIHtcbiAgICAgIHJldHVybiBmaW5hbGl6ZSh0cnVlLCBuZXdFcnJvcik7XG4gICAgIH0pO1xuICAgIH1cbiAgIH1cbiAgIGZ1bmN0aW9uIHNodXRkb3duKGlzRXJyb3IsIGVycm9yKSB7XG4gICAgaWYgKHNodXR0aW5nRG93biA9PT0gdHJ1ZSkge1xuICAgICByZXR1cm47XG4gICAgfVxuICAgIHNodXR0aW5nRG93biA9IHRydWU7XG4gICAgaWYgKGRlc3QuX3N0YXRlID09PSAnd3JpdGFibGUnICYmIFdyaXRhYmxlU3RyZWFtQ2xvc2VRdWV1ZWRPckluRmxpZ2h0KGRlc3QpID09PSBmYWxzZSkge1xuICAgICB1cG9uRnVsZmlsbG1lbnQod2FpdEZvcldyaXRlc1RvRmluaXNoKCksIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcik7XG4gICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgIGZpbmFsaXplKGlzRXJyb3IsIGVycm9yKTtcbiAgICB9XG4gICB9XG4gICBmdW5jdGlvbiBmaW5hbGl6ZShpc0Vycm9yLCBlcnJvcikge1xuICAgIFdyaXRhYmxlU3RyZWFtRGVmYXVsdFdyaXRlclJlbGVhc2Uod3JpdGVyKTtcbiAgICBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNSZWxlYXNlKHJlYWRlcik7XG4gICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgIHNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0QWxnb3JpdGhtKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IpIHtcbiAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgfVxuICB9KTtcbiB9XG4gdmFyIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKCk7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLCBcImRlc2lyZWRTaXplXCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmIChJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgZGVmYXVsdENvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgfVxuICAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBjbG9zZScpO1xuICAgfVxuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKHRoaXMpO1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuICAgfVxuICAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgc3RyZWFtIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG4gICB9XG4gICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgIH1cbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGVbQ2FuY2VsU3RlcHNdID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgIHZhciByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZVtQdWxsU3RlcHNdID0gZnVuY3Rpb24gKCkge1xuICAgdmFyIHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNodW5rID0gRGVxdWV1ZVZhbHVlKHRoaXMpO1xuICAgIGlmICh0aGlzLl9jbG9zZVJlcXVlc3RlZCA9PT0gdHJ1ZSAmJiB0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyh0aGlzKTtcbiAgICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aChSZWFkYWJsZVN0cmVhbUNyZWF0ZVJlYWRSZXN1bHQoY2h1bmssIGZhbHNlLCBzdHJlYW0uX3JlYWRlci5fZm9yQXV0aG9yQ29kZSkpO1xuICAgfVxuICAgdmFyIHBlbmRpbmdQcm9taXNlID0gUmVhZGFibGVTdHJlYW1BZGRSZWFkUmVxdWVzdChzdHJlYW0pO1xuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQodGhpcyk7XG4gICByZXR1cm4gcGVuZGluZ1Byb21pc2U7XG4gIH07XG4gIHJldHVybiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyO1xuIH0oKTtcbiBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcikge1xuICB2YXIgc2hvdWxkUHVsbCA9IFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKTtcbiAgaWYgKHNob3VsZFB1bGwgPT09IGZhbHNlKSB7XG4gICByZXR1cm47XG4gIH1cbiAgaWYgKGNvbnRyb2xsZXIuX3B1bGxpbmcgPT09IHRydWUpIHtcbiAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IHRydWU7XG4gICByZXR1cm47XG4gIH1cbiAgY29udHJvbGxlci5fcHVsbGluZyA9IHRydWU7XG4gIHZhciBwdWxsUHJvbWlzZSA9IGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0oKTtcbiAgdXBvblByb21pc2UocHVsbFByb21pc2UsIGZ1bmN0aW9uICgpIHtcbiAgIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcbiAgIGlmIChjb250cm9sbGVyLl9wdWxsQWdhaW4gPT09IHRydWUpIHtcbiAgICBjb250cm9sbGVyLl9wdWxsQWdhaW4gPSBmYWxzZTtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgIH1cbiAgfSwgZnVuY3Rpb24gKGUpIHtcbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKTtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gIGlmIChSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikgPT09IGZhbHNlKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPT09IGZhbHNlKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQoc3RyZWFtKSA9PT0gdHJ1ZSAmJiBSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGRlc2lyZWRTaXplID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpO1xuICBpZiAoZGVzaXJlZFNpemUgPiAwKSB7XG4gICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcikge1xuICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9jYW5jZWxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSB0cnVlO1xuICBpZiAoY29udHJvbGxlci5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICB9XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW07XG4gIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkgPT09IHRydWUgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkUmVxdWVzdHMoc3RyZWFtKSA+IDApIHtcbiAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgY2h1bmssIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgIHZhciBjaHVua1NpemUgPSB2b2lkIDA7XG4gICB0cnkge1xuICAgIGNodW5rU2l6ZSA9IGNvbnRyb2xsZXIuX3N0cmF0ZWd5U2l6ZUFsZ29yaXRobShjaHVuayk7XG4gICB9IGNhdGNoIChjaHVua1NpemVFKSB7XG4gICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGNodW5rU2l6ZUUpO1xuICAgIHRocm93IGNodW5rU2l6ZUU7XG4gICB9XG4gICB0cnkge1xuICAgIEVucXVldWVWYWx1ZVdpdGhTaXplKGNvbnRyb2xsZXIsIGNodW5rLCBjaHVua1NpemUpO1xuICAgfSBjYXRjaCAoZW5xdWV1ZUUpIHtcbiAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZW5xdWV1ZUUpO1xuICAgIHRocm93IGVucXVldWVFO1xuICAgfVxuICB9XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSkge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgcmV0dXJuO1xuICB9XG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZVN0cmVhbTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9zdGF0ZTtcbiAgaWYgKHN0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmIChzdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBjb250cm9sbGVyLl9zdHJhdGVneUhXTSAtIGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVySGFzQmFja3ByZXNzdXJlKGNvbnRyb2xsZXIpIHtcbiAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJTaG91bGRDYWxsUHVsbChjb250cm9sbGVyKSA9PT0gdHJ1ZSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUoY29udHJvbGxlcikge1xuICB2YXIgc3RhdGUgPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVTdHJlYW0uX3N0YXRlO1xuICBpZiAoY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPT09IGZhbHNlICYmIHN0YXRlID09PSAncmVhZGFibGUnKSB7XG4gICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG4gfVxuIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcihzdHJlYW0sIGNvbnRyb2xsZXIsIHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIGhpZ2hXYXRlck1hcmssIHNpemVBbGdvcml0aG0pIHtcbiAgY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlU3RyZWFtID0gc3RyZWFtO1xuICBjb250cm9sbGVyLl9xdWV1ZSA9IHVuZGVmaW5lZDtcbiAgY29udHJvbGxlci5fcXVldWVUb3RhbFNpemUgPSB1bmRlZmluZWQ7XG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gIGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fY2xvc2VSZXF1ZXN0ZWQgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fcHVsbEFnYWluID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3B1bGxpbmcgPSBmYWxzZTtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lTaXplQWxnb3JpdGhtID0gc2l6ZUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fc3RyYXRlZ3lIV00gPSBoaWdoV2F0ZXJNYXJrO1xuICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gcHVsbEFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xuICBzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gIHZhciBzdGFydFJlc3VsdCA9IHN0YXJ0QWxnb3JpdGhtKCk7XG4gIHVwb25Qcm9taXNlKHByb21pc2VSZXNvbHZlZFdpdGgoc3RhcnRSZXN1bHQpLCBmdW5jdGlvbiAoKSB7XG4gICBjb250cm9sbGVyLl9zdGFydGVkID0gdHJ1ZTtcbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICB9LCBmdW5jdGlvbiAocikge1xuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIHIpO1xuICB9KTtcbiB9XG4gZnVuY3Rpb24gU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2Uoc3RyZWFtLCB1bmRlcmx5aW5nU291cmNlLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gIHZhciBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyLnByb3RvdHlwZSk7XG4gIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICAgcmV0dXJuIEludm9rZU9yTm9vcCh1bmRlcmx5aW5nU291cmNlLCAnc3RhcnQnLCBbY29udHJvbGxlcl0pO1xuICB9XG4gIHZhciBwdWxsQWxnb3JpdGhtID0gQ3JlYXRlQWxnb3JpdGhtRnJvbVVuZGVybHlpbmdNZXRob2QodW5kZXJseWluZ1NvdXJjZSwgJ3B1bGwnLCAwLCBbY29udHJvbGxlcl0pO1xuICB2YXIgY2FuY2VsQWxnb3JpdGhtID0gQ3JlYXRlQWxnb3JpdGhtRnJvbVVuZGVybHlpbmdNZXRob2QodW5kZXJseWluZ1NvdXJjZSwgJ2NhbmNlbCcsIDEsIFtdKTtcbiAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbihuYW1lKSB7XG4gIHJldHVybiBuZXcgVHlwZUVycm9yKFwiUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJcIik7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtVGVlKHN0cmVhbSwgY2xvbmVGb3JCcmFuY2gyKSB7XG4gIHZhciByZWFkZXIgPSBBY3F1aXJlUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHN0cmVhbSk7XG4gIHZhciByZWFkaW5nID0gZmFsc2U7XG4gIHZhciBjYW5jZWxlZDEgPSBmYWxzZTtcbiAgdmFyIGNhbmNlbGVkMiA9IGZhbHNlO1xuICB2YXIgcmVhc29uMTtcbiAgdmFyIHJlYXNvbjI7XG4gIHZhciBicmFuY2gxO1xuICB2YXIgYnJhbmNoMjtcbiAgdmFyIHJlc29sdmVDYW5jZWxQcm9taXNlO1xuICB2YXIgY2FuY2VsUHJvbWlzZSA9IG5ld1Byb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgIHJlc29sdmVDYW5jZWxQcm9taXNlID0gcmVzb2x2ZTtcbiAgfSk7XG4gIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG4gICBpZiAocmVhZGluZyA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gICB9XG4gICByZWFkaW5nID0gdHJ1ZTtcbiAgIHZhciByZWFkUHJvbWlzZSA9IHRyYW5zZm9ybVByb21pc2VXaXRoKFJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlclJlYWQocmVhZGVyKSwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgIHJlYWRpbmcgPSBmYWxzZTtcbiAgICB2YXIgZG9uZSA9IHJlc3VsdC5kb25lO1xuICAgIGlmIChkb25lID09PSB0cnVlKSB7XG4gICAgIGlmIChjYW5jZWxlZDEgPT09IGZhbHNlKSB7XG4gICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UoYnJhbmNoMS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKTtcbiAgICAgfVxuICAgICBpZiAoY2FuY2VsZWQyID09PSBmYWxzZSkge1xuICAgICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNsb3NlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcik7XG4gICAgIH1cbiAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgdmFyIHZhbHVlMSA9IHZhbHVlO1xuICAgIHZhciB2YWx1ZTIgPSB2YWx1ZTtcbiAgICBpZiAoY2FuY2VsZWQxID09PSBmYWxzZSkge1xuICAgICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShicmFuY2gxLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIsIHZhbHVlMSk7XG4gICAgfVxuICAgIGlmIChjYW5jZWxlZDIgPT09IGZhbHNlKSB7XG4gICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGJyYW5jaDIuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgdmFsdWUyKTtcbiAgICB9XG4gICB9KTtcbiAgIHNldFByb21pc2VJc0hhbmRsZWRUb1RydWUocmVhZFByb21pc2UpO1xuICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWwxQWxnb3JpdGhtKHJlYXNvbikge1xuICAgY2FuY2VsZWQxID0gdHJ1ZTtcbiAgIHJlYXNvbjEgPSByZWFzb247XG4gICBpZiAoY2FuY2VsZWQyID09PSB0cnVlKSB7XG4gICAgdmFyIGNvbXBvc2l0ZVJlYXNvbiA9IGNyZWF0ZUFycmF5RnJvbUxpc3QoW1xuICAgICByZWFzb24xLFxuICAgICByZWFzb24yXG4gICAgXSk7XG4gICAgdmFyIGNhbmNlbFJlc3VsdCA9IFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHN0cmVhbSwgY29tcG9zaXRlUmVhc29uKTtcbiAgICByZXNvbHZlQ2FuY2VsUHJvbWlzZShjYW5jZWxSZXN1bHQpO1xuICAgfVxuICAgcmV0dXJuIGNhbmNlbFByb21pc2U7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsMkFsZ29yaXRobShyZWFzb24pIHtcbiAgIGNhbmNlbGVkMiA9IHRydWU7XG4gICByZWFzb24yID0gcmVhc29uO1xuICAgaWYgKGNhbmNlbGVkMSA9PT0gdHJ1ZSkge1xuICAgIHZhciBjb21wb3NpdGVSZWFzb24gPSBjcmVhdGVBcnJheUZyb21MaXN0KFtcbiAgICAgcmVhc29uMSxcbiAgICAgcmVhc29uMlxuICAgIF0pO1xuICAgIHZhciBjYW5jZWxSZXN1bHQgPSBSZWFkYWJsZVN0cmVhbUNhbmNlbChzdHJlYW0sIGNvbXBvc2l0ZVJlYXNvbik7XG4gICAgcmVzb2x2ZUNhbmNlbFByb21pc2UoY2FuY2VsUmVzdWx0KTtcbiAgIH1cbiAgIHJldHVybiBjYW5jZWxQcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIHN0YXJ0QWxnb3JpdGhtKCkge1xuICB9XG4gIGJyYW5jaDEgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMUFsZ29yaXRobSk7XG4gIGJyYW5jaDIgPSBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsMkFsZ29yaXRobSk7XG4gIHVwb25SZWplY3Rpb24ocmVhZGVyLl9jbG9zZWRQcm9taXNlLCBmdW5jdGlvbiAocikge1xuICAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKGJyYW5jaDEuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgcik7XG4gICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IoYnJhbmNoMi5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyLCByKTtcbiAgfSk7XG4gIHJldHVybiBbXG4gICBicmFuY2gxLFxuICAgYnJhbmNoMlxuICBdO1xuIH1cbiB2YXIgTnVtYmVySXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsdWUpICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZTtcbiB9O1xuIHZhciBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0KCkge1xuICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCBjYW5ub3QgYmUgdXNlZCBkaXJlY3RseScpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZSwgXCJ2aWV3XCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykgPT09IGZhbHNlKSB7XG4gICAgIHRocm93IGJ5b2JSZXF1ZXN0QnJhbmRDaGVja0V4Y2VwdGlvbigndmlldycpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdmlldztcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0LnByb3RvdHlwZS5yZXNwb25kID0gZnVuY3Rpb24gKGJ5dGVzV3JpdHRlbikge1xuICAgaWYgKElzUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24oJ3Jlc3BvbmQnKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhpcyBCWU9CIHJlcXVlc3QgaGFzIGJlZW4gaW52YWxpZGF0ZWQnKTtcbiAgIH1cbiAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHRoaXMuX3ZpZXcuYnVmZmVyKSA9PT0gdHJ1ZSk7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZCh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgYnl0ZXNXcml0dGVuKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUucmVzcG9uZFdpdGhOZXdWaWV3ID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgIGlmIChJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QodGhpcykgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgYnlvYlJlcXVlc3RCcmFuZENoZWNrRXhjZXB0aW9uKCdyZXNwb25kJyk7XG4gICB9XG4gICBpZiAodGhpcy5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXMgQllPQiByZXF1ZXN0IGhhcyBiZWVuIGludmFsaWRhdGVkJyk7XG4gICB9XG4gICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBjYW4gb25seSByZXNwb25kIHdpdGggYXJyYXkgYnVmZmVyIHZpZXdzJyk7XG4gICB9XG4gICBpZiAoSXNEZXRhY2hlZEJ1ZmZlcih2aWV3LmJ1ZmZlcikgPT09IHRydWUpO1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRXaXRoTmV3Vmlldyh0aGlzLl9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciwgdmlldyk7XG4gIH07XG4gIHJldHVybiBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0O1xuIH0oKTtcbiB2YXIgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcigpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgY29uc3RydWN0b3IgY2Fubm90IGJlIHVzZWQgZGlyZWN0bHknKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGUsIFwiYnlvYlJlcXVlc3RcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKElzUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcih0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdieW9iUmVxdWVzdCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYnlvYlJlcXVlc3QgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgICAgdmFyIGZpcnN0RGVzY3JpcHRvciA9IHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGZpcnN0RGVzY3JpcHRvci5idWZmZXIsIGZpcnN0RGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgZmlyc3REZXNjcmlwdG9yLmJ5dGVzRmlsbGVkLCBmaXJzdERlc2NyaXB0b3IuYnl0ZUxlbmd0aCAtIGZpcnN0RGVzY3JpcHRvci5ieXRlc0ZpbGxlZCk7XG4gICAgIHZhciBieW9iUmVxdWVzdCA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1CWU9CUmVxdWVzdC5wcm90b3R5cGUpO1xuICAgICBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoYnlvYlJlcXVlc3QsIHRoaXMsIHZpZXcpO1xuICAgICB0aGlzLl9ieW9iUmVxdWVzdCA9IGJ5b2JSZXF1ZXN0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYnlvYlJlcXVlc3Q7XG4gICB9LFxuICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLCBcImRlc2lyZWRTaXplXCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZGVzaXJlZFNpemUnKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJHZXREZXNpcmVkU2l6ZSh0aGlzKTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmIChJc1JlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgYnl0ZVN0cmVhbUNvbnRyb2xsZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdjbG9zZScpO1xuICAgfVxuICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZDsgZG8gbm90IGNsb3NlIGl0IGFnYWluIScpO1xuICAgfVxuICAgdmFyIHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHN0cmVhbSAoaW4gXCIgKyBzdGF0ZSArIFwiIHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgY2xvc2VkXCIpO1xuICAgfVxuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKHRoaXMpO1xuICB9O1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5lbnF1ZXVlID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICBpZiAoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZW5xdWV1ZScpO1xuICAgfVxuICAgaWYgKHRoaXMuX2Nsb3NlUmVxdWVzdGVkID09PSB0cnVlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3RyZWFtIGlzIGNsb3NlZCBvciBkcmFpbmluZycpO1xuICAgfVxuICAgdmFyIHN0YXRlID0gdGhpcy5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbS5fc3RhdGU7XG4gICBpZiAoc3RhdGUgIT09ICdyZWFkYWJsZScpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIHN0cmVhbSAoaW4gXCIgKyBzdGF0ZSArIFwiIHN0YXRlKSBpcyBub3QgaW4gdGhlIHJlYWRhYmxlIHN0YXRlIGFuZCBjYW5ub3QgYmUgZW5xdWV1ZWQgdG9cIik7XG4gICB9XG4gICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyhjaHVuaykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgY2FuIG9ubHkgZW5xdWV1ZSBhcnJheSBidWZmZXIgdmlld3Mgd2hlbiB1c2luZyBhIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKTtcbiAgIH1cbiAgIGlmIChJc0RldGFjaGVkQnVmZmVyKGNodW5rLmJ1ZmZlcikgPT09IHRydWUpO1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9O1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICBpZiAoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHRocm93IGJ5dGVTdHJlYW1Db250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbignZXJyb3InKTtcbiAgIH1cbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcih0aGlzLCBlKTtcbiAgfTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlci5wcm90b3R5cGVbQ2FuY2VsU3RlcHNdID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgaWYgKHRoaXMuX3BlbmRpbmdQdWxsSW50b3MubGVuZ3RoID4gMCkge1xuICAgIHZhciBmaXJzdERlc2NyaXB0b3IgPSB0aGlzLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgICBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPSAwO1xuICAgfVxuICAgUmVzZXRRdWV1ZSh0aGlzKTtcbiAgIHZhciByZXN1bHQgPSB0aGlzLl9jYW5jZWxBbGdvcml0aG0ocmVhc29uKTtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXModGhpcyk7XG4gICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyLnByb3RvdHlwZVtQdWxsU3RlcHNdID0gZnVuY3Rpb24gKCkge1xuICAgdmFyIHN0cmVhbSA9IHRoaXMuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gICBpZiAodGhpcy5fcXVldWVUb3RhbFNpemUgPiAwKSB7XG4gICAgdmFyIGVudHJ5ID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICB0aGlzLl9xdWV1ZVRvdGFsU2l6ZSAtPSBlbnRyeS5ieXRlTGVuZ3RoO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJIYW5kbGVRdWV1ZURyYWluKHRoaXMpO1xuICAgIHZhciB2aWV3ID0gdm9pZCAwO1xuICAgIHRyeSB7XG4gICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShlbnRyeS5idWZmZXIsIGVudHJ5LmJ5dGVPZmZzZXQsIGVudHJ5LmJ5dGVMZW5ndGgpO1xuICAgIH0gY2F0Y2ggKHZpZXdFKSB7XG4gICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHZpZXdFKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgoUmVhZGFibGVTdHJlYW1DcmVhdGVSZWFkUmVzdWx0KHZpZXcsIGZhbHNlLCBzdHJlYW0uX3JlYWRlci5fZm9yQXV0aG9yQ29kZSkpO1xuICAgfVxuICAgdmFyIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IHRoaXMuX2F1dG9BbGxvY2F0ZUNodW5rU2l6ZTtcbiAgIGlmIChhdXRvQWxsb2NhdGVDaHVua1NpemUgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBidWZmZXIgPSB2b2lkIDA7XG4gICAgdHJ5IHtcbiAgICAgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSk7XG4gICAgfSBjYXRjaCAoYnVmZmVyRSkge1xuICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChidWZmZXJFKTtcbiAgICB9XG4gICAgdmFyIHB1bGxJbnRvRGVzY3JpcHRvciA9IHtcbiAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgIGJ5dGVPZmZzZXQ6IDAsXG4gICAgIGJ5dGVMZW5ndGg6IGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSxcbiAgICAgYnl0ZXNGaWxsZWQ6IDAsXG4gICAgIGVsZW1lbnRTaXplOiAxLFxuICAgICBjdG9yOiBVaW50OEFycmF5LFxuICAgICByZWFkZXJUeXBlOiAnZGVmYXVsdCdcbiAgICB9O1xuICAgIHRoaXMuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICAgfVxuICAgdmFyIHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbUFkZFJlYWRSZXF1ZXN0KHN0cmVhbSk7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZCh0aGlzKTtcbiAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuICByZXR1cm4gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlcjtcbiB9KCk7XG4gZnVuY3Rpb24gSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0nKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBJc1JlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QoeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKSB7XG4gIHZhciBzaG91bGRQdWxsID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpO1xuICBpZiAoc2hvdWxkUHVsbCA9PT0gZmFsc2UpIHtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoY29udHJvbGxlci5fcHVsbGluZyA9PT0gdHJ1ZSkge1xuICAgY29udHJvbGxlci5fcHVsbEFnYWluID0gdHJ1ZTtcbiAgIHJldHVybjtcbiAgfVxuICBjb250cm9sbGVyLl9wdWxsaW5nID0gdHJ1ZTtcbiAgdmFyIHB1bGxQcm9taXNlID0gY29udHJvbGxlci5fcHVsbEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShwdWxsUHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgY29udHJvbGxlci5fcHVsbGluZyA9IGZhbHNlO1xuICAgaWYgKGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9PT0gdHJ1ZSkge1xuICAgIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICAgfVxuICB9LCBmdW5jdGlvbiAoZSkge1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICB9KTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyUGVuZGluZ1B1bGxJbnRvcyhjb250cm9sbGVyKSB7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcikge1xuICB2YXIgZG9uZSA9IGZhbHNlO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIGRvbmUgPSB0cnVlO1xuICB9XG4gIHZhciBmaWxsZWRWaWV3ID0gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbnZlcnRQdWxsSW50b0Rlc2NyaXB0b3IocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5yZWFkZXJUeXBlID09PSAnZGVmYXVsdCcpIHtcbiAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgZmlsbGVkVmlldywgZG9uZSk7XG4gIH0gZWxzZSB7XG4gICBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBmaWxsZWRWaWV3LCBkb25lKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ29udmVydFB1bGxJbnRvRGVzY3JpcHRvcihwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgdmFyIGJ5dGVzRmlsbGVkID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICB2YXIgZWxlbWVudFNpemUgPSBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemU7XG4gIHJldHVybiBuZXcgcHVsbEludG9EZXNjcmlwdG9yLmN0b3IocHVsbEludG9EZXNjcmlwdG9yLmJ1ZmZlciwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVPZmZzZXQsIGJ5dGVzRmlsbGVkIC8gZWxlbWVudFNpemUpO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCBidWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgY29udHJvbGxlci5fcXVldWUucHVzaCh7XG4gICBidWZmZXI6IGJ1ZmZlcixcbiAgIGJ5dGVPZmZzZXQ6IGJ5dGVPZmZzZXQsXG4gICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoXG4gIH0pO1xuICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSArPSBieXRlTGVuZ3RoO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgdmFyIGVsZW1lbnRTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICB2YXIgY3VycmVudEFsaWduZWRCeXRlcyA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAtIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCAlIGVsZW1lbnRTaXplO1xuICB2YXIgbWF4Qnl0ZXNUb0NvcHkgPSBNYXRoLm1pbihjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVMZW5ndGggLSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQpO1xuICB2YXIgbWF4Qnl0ZXNGaWxsZWQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgKyBtYXhCeXRlc1RvQ29weTtcbiAgdmFyIG1heEFsaWduZWRCeXRlcyA9IG1heEJ5dGVzRmlsbGVkIC0gbWF4Qnl0ZXNGaWxsZWQgJSBlbGVtZW50U2l6ZTtcbiAgdmFyIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgPSBtYXhCeXRlc1RvQ29weTtcbiAgdmFyIHJlYWR5ID0gZmFsc2U7XG4gIGlmIChtYXhBbGlnbmVkQnl0ZXMgPiBjdXJyZW50QWxpZ25lZEJ5dGVzKSB7XG4gICB0b3RhbEJ5dGVzVG9Db3B5UmVtYWluaW5nID0gbWF4QWxpZ25lZEJ5dGVzIC0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgcmVhZHkgPSB0cnVlO1xuICB9XG4gIHZhciBxdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlO1xuICB3aGlsZSAodG90YWxCeXRlc1RvQ29weVJlbWFpbmluZyA+IDApIHtcbiAgIHZhciBoZWFkT2ZRdWV1ZSA9IHF1ZXVlLnBlZWsoKTtcbiAgIHZhciBieXRlc1RvQ29weSA9IE1hdGgubWluKHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcsIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGgpO1xuICAgdmFyIGRlc3RTdGFydCA9IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0ICsgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkO1xuICAgQXJyYXlCdWZmZXJDb3B5KHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIGRlc3RTdGFydCwgaGVhZE9mUXVldWUuYnVmZmVyLCBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0LCBieXRlc1RvQ29weSk7XG4gICBpZiAoaGVhZE9mUXVldWUuYnl0ZUxlbmd0aCA9PT0gYnl0ZXNUb0NvcHkpIHtcbiAgICBxdWV1ZS5zaGlmdCgpO1xuICAgfSBlbHNlIHtcbiAgICBoZWFkT2ZRdWV1ZS5ieXRlT2Zmc2V0ICs9IGJ5dGVzVG9Db3B5O1xuICAgIGhlYWRPZlF1ZXVlLmJ5dGVMZW5ndGggLT0gYnl0ZXNUb0NvcHk7XG4gICB9XG4gICBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSAtPSBieXRlc1RvQ29weTtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1RvQ29weSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgIHRvdGFsQnl0ZXNUb0NvcHlSZW1haW5pbmcgLT0gYnl0ZXNUb0NvcHk7XG4gIH1cbiAgcmV0dXJuIHJlYWR5O1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbEhlYWRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlciwgc2l6ZSwgcHVsbEludG9EZXNjcmlwdG9yKSB7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJJbnZhbGlkYXRlQllPQlJlcXVlc3QoY29udHJvbGxlcik7XG4gIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArPSBzaXplO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySGFuZGxlUXVldWVEcmFpbihjb250cm9sbGVyKSB7XG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCAmJiBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9PT0gdHJ1ZSkge1xuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKTtcbiAgIFJlYWRhYmxlU3RyZWFtQ2xvc2UoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgfVxuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpIHtcbiAgaWYgKGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybjtcbiAgfVxuICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdC5fYXNzb2NpYXRlZFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0Ll92aWV3ID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9ieW9iUmVxdWVzdCA9IHVuZGVmaW5lZDtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKSB7XG4gIHdoaWxlIChjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLmxlbmd0aCA+IDApIHtcbiAgIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgIH1cbiAgIHZhciBwdWxsSW50b0Rlc2NyaXB0b3IgPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgIGlmIChSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRmlsbFB1bGxJbnRvRGVzY3JpcHRvckZyb21RdWV1ZShjb250cm9sbGVyLCBwdWxsSW50b0Rlc2NyaXB0b3IpID09PSB0cnVlKSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNoaWZ0UGVuZGluZ1B1bGxJbnRvKGNvbnRyb2xsZXIpO1xuICAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgIH1cbiAgfVxuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUHVsbEludG8oY29udHJvbGxlciwgdmlldykge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgdmFyIGVsZW1lbnRTaXplID0gMTtcbiAgaWYgKHZpZXcuY29uc3RydWN0b3IgIT09IERhdGFWaWV3KSB7XG4gICBlbGVtZW50U2l6ZSA9IHZpZXcuY29uc3RydWN0b3IuQllURVNfUEVSX0VMRU1FTlQ7XG4gIH1cbiAgdmFyIGN0b3IgPSB2aWV3LmNvbnN0cnVjdG9yO1xuICB2YXIgYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcih2aWV3LmJ1ZmZlcik7XG4gIHZhciBwdWxsSW50b0Rlc2NyaXB0b3IgPSB7XG4gICBidWZmZXI6IGJ1ZmZlcixcbiAgIGJ5dGVPZmZzZXQ6IHZpZXcuYnl0ZU9mZnNldCxcbiAgIGJ5dGVMZW5ndGg6IHZpZXcuYnl0ZUxlbmd0aCxcbiAgIGJ5dGVzRmlsbGVkOiAwLFxuICAgZWxlbWVudFNpemU6IGVsZW1lbnRTaXplLFxuICAgY3RvcjogY3RvcixcbiAgIHJlYWRlclR5cGU6ICdieW9iJ1xuICB9O1xuICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnB1c2gocHVsbEludG9EZXNjcmlwdG9yKTtcbiAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUFkZFJlYWRJbnRvUmVxdWVzdChzdHJlYW0pO1xuICB9XG4gIGlmIChzdHJlYW0uX3N0YXRlID09PSAnY2xvc2VkJykge1xuICAgdmFyIGVtcHR5VmlldyA9IG5ldyBjdG9yKHB1bGxJbnRvRGVzY3JpcHRvci5idWZmZXIsIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlT2Zmc2V0LCAwKTtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKFJlYWRhYmxlU3RyZWFtQ3JlYXRlUmVhZFJlc3VsdChlbXB0eVZpZXcsIHRydWUsIHN0cmVhbS5fcmVhZGVyLl9mb3JBdXRob3JDb2RlKSk7XG4gIH1cbiAgaWYgKGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID4gMCkge1xuICAgaWYgKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsUHVsbEludG9EZXNjcmlwdG9yRnJvbVF1ZXVlKGNvbnRyb2xsZXIsIHB1bGxJbnRvRGVzY3JpcHRvcikgPT09IHRydWUpIHtcbiAgICB2YXIgZmlsbGVkVmlldyA9IFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb252ZXJ0UHVsbEludG9EZXNjcmlwdG9yKHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckhhbmRsZVF1ZXVlRHJhaW4oY29udHJvbGxlcik7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgoUmVhZGFibGVTdHJlYW1DcmVhdGVSZWFkUmVzdWx0KGZpbGxlZFZpZXcsIGZhbHNlLCBzdHJlYW0uX3JlYWRlci5fZm9yQXV0aG9yQ29kZSkpO1xuICAgfVxuICAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID09PSB0cnVlKSB7XG4gICAgdmFyIGUgPSBuZXcgVHlwZUVycm9yKCdJbnN1ZmZpY2llbnQgYnl0ZXMgdG8gZmlsbCBlbGVtZW50cyBpbiB0aGUgZ2l2ZW4gYnVmZmVyJyk7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVycm9yKGNvbnRyb2xsZXIsIGUpO1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKGUpO1xuICAgfVxuICB9XG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucHVzaChwdWxsSW50b0Rlc2NyaXB0b3IpO1xuICB2YXIgcHJvbWlzZSA9IFJlYWRhYmxlU3RyZWFtQWRkUmVhZEludG9SZXF1ZXN0KHN0cmVhbSk7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDYWxsUHVsbElmTmVlZGVkKGNvbnRyb2xsZXIpO1xuICByZXR1cm4gcHJvbWlzZTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIsIGZpcnN0RGVzY3JpcHRvcikge1xuICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihmaXJzdERlc2NyaXB0b3IuYnVmZmVyKTtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIGlmIChSZWFkYWJsZVN0cmVhbUhhc0JZT0JSZWFkZXIoc3RyZWFtKSA9PT0gdHJ1ZSkge1xuICAgd2hpbGUgKFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pID4gMCkge1xuICAgIHZhciBwdWxsSW50b0Rlc2NyaXB0b3IgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNvbW1pdFB1bGxJbnRvRGVzY3JpcHRvcihzdHJlYW0sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gICB9XG4gIH1cbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJblJlYWRhYmxlU3RhdGUoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuLCBwdWxsSW50b0Rlc2NyaXB0b3IpIHtcbiAgaWYgKHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZCArIGJ5dGVzV3JpdHRlbiA+IHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlTGVuZ3RoKSB7XG4gICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignYnl0ZXNXcml0dGVuIG91dCBvZiByYW5nZScpO1xuICB9XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJGaWxsSGVhZFB1bGxJbnRvRGVzY3JpcHRvcihjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIHB1bGxJbnRvRGVzY3JpcHRvcik7XG4gIGlmIChwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgPCBwdWxsSW50b0Rlc2NyaXB0b3IuZWxlbWVudFNpemUpIHtcbiAgIHJldHVybjtcbiAgfVxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyU2hpZnRQZW5kaW5nUHVsbEludG8oY29udHJvbGxlcik7XG4gIHZhciByZW1haW5kZXJTaXplID0gcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkICUgcHVsbEludG9EZXNjcmlwdG9yLmVsZW1lbnRTaXplO1xuICBpZiAocmVtYWluZGVyU2l6ZSA+IDApIHtcbiAgIHZhciBlbmQgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnl0ZU9mZnNldCArIHB1bGxJbnRvRGVzY3JpcHRvci5ieXRlc0ZpbGxlZDtcbiAgIHZhciByZW1haW5kZXIgPSBwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyLnNsaWNlKGVuZCAtIHJlbWFpbmRlclNpemUsIGVuZCk7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCByZW1haW5kZXIsIDAsIHJlbWFpbmRlci5ieXRlTGVuZ3RoKTtcbiAgfVxuICBwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihwdWxsSW50b0Rlc2NyaXB0b3IuYnVmZmVyKTtcbiAgcHVsbEludG9EZXNjcmlwdG9yLmJ5dGVzRmlsbGVkIC09IHJlbWFpbmRlclNpemU7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDb21taXRQdWxsSW50b0Rlc2NyaXB0b3IoY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbSwgcHVsbEludG9EZXNjcmlwdG9yKTtcbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclByb2Nlc3NQdWxsSW50b0Rlc2NyaXB0b3JzVXNpbmdRdWV1ZShjb250cm9sbGVyKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pIHtcbiAgdmFyIGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFJlYWRhYmxlQnl0ZVN0cmVhbTtcbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICBpZiAoYnl0ZXNXcml0dGVuICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYnl0ZXNXcml0dGVuIG11c3QgYmUgMCB3aGVuIGNhbGxpbmcgcmVzcG9uZCgpIG9uIGEgY2xvc2VkIHN0cmVhbScpO1xuICAgfVxuICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbkNsb3NlZFN0YXRlKGNvbnRyb2xsZXIsIGZpcnN0RGVzY3JpcHRvcik7XG4gIH0gZWxzZSB7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZEluUmVhZGFibGVTdGF0ZShjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4sIGZpcnN0RGVzY3JpcHRvcik7XG4gIH1cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJTaGlmdFBlbmRpbmdQdWxsSW50byhjb250cm9sbGVyKSB7XG4gIHZhciBkZXNjcmlwdG9yID0gY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5zaGlmdCgpO1xuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVySW52YWxpZGF0ZUJZT0JSZXF1ZXN0KGNvbnRyb2xsZXIpO1xuICByZXR1cm4gZGVzY3JpcHRvcjtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclNob3VsZENhbGxQdWxsKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIGlmIChzdHJlYW0uX3N0YXRlICE9PSAncmVhZGFibGUnKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID09PSB0cnVlKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKGNvbnRyb2xsZXIuX3N0YXJ0ZWQgPT09IGZhbHNlKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKFJlYWRhYmxlU3RyZWFtSGFzRGVmYXVsdFJlYWRlcihzdHJlYW0pID09PSB0cnVlICYmIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZFJlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkgPT09IHRydWUgJiYgUmVhZGFibGVTdHJlYW1HZXROdW1SZWFkSW50b1JlcXVlc3RzKHN0cmVhbSkgPiAwKSB7XG4gICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgZGVzaXJlZFNpemUgPSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyR2V0RGVzaXJlZFNpemUoY29udHJvbGxlcik7XG4gIGlmIChkZXNpcmVkU2l6ZSA+IDApIHtcbiAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsZWFyQWxnb3JpdGhtcyhjb250cm9sbGVyKSB7XG4gIGNvbnRyb2xsZXIuX3B1bGxBbGdvcml0aG0gPSB1bmRlZmluZWQ7XG4gIGNvbnRyb2xsZXIuX2NhbmNlbEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNsb3NlKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIGlmIChjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZSA+IDApIHtcbiAgIGNvbnRyb2xsZXIuX2Nsb3NlUmVxdWVzdGVkID0gdHJ1ZTtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoY29udHJvbGxlci5fcGVuZGluZ1B1bGxJbnRvcy5sZW5ndGggPiAwKSB7XG4gICB2YXIgZmlyc3RQZW5kaW5nUHVsbEludG8gPSBjb250cm9sbGVyLl9wZW5kaW5nUHVsbEludG9zLnBlZWsoKTtcbiAgIGlmIChmaXJzdFBlbmRpbmdQdWxsSW50by5ieXRlc0ZpbGxlZCA+IDApIHtcbiAgICB2YXIgZSA9IG5ldyBUeXBlRXJyb3IoJ0luc3VmZmljaWVudCBieXRlcyB0byBmaWxsIGVsZW1lbnRzIGluIHRoZSBnaXZlbiBidWZmZXInKTtcbiAgICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRXJyb3IoY29udHJvbGxlciwgZSk7XG4gICAgdGhyb3cgZTtcbiAgIH1cbiAgfVxuICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICBSZWFkYWJsZVN0cmVhbUNsb3NlKHN0cmVhbSk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICB2YXIgYnVmZmVyID0gY2h1bmsuYnVmZmVyO1xuICB2YXIgYnl0ZU9mZnNldCA9IGNodW5rLmJ5dGVPZmZzZXQ7XG4gIHZhciBieXRlTGVuZ3RoID0gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgdmFyIHRyYW5zZmVycmVkQnVmZmVyID0gVHJhbnNmZXJBcnJheUJ1ZmZlcihidWZmZXIpO1xuICBpZiAoUmVhZGFibGVTdHJlYW1IYXNEZWZhdWx0UmVhZGVyKHN0cmVhbSkgPT09IHRydWUpIHtcbiAgIGlmIChSZWFkYWJsZVN0cmVhbUdldE51bVJlYWRSZXF1ZXN0cyhzdHJlYW0pID09PSAwKSB7XG4gICAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckVucXVldWVDaHVua1RvUXVldWUoY29udHJvbGxlciwgdHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgfSBlbHNlIHtcbiAgICB2YXIgdHJhbnNmZXJyZWRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkodHJhbnNmZXJyZWRCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGgpO1xuICAgIFJlYWRhYmxlU3RyZWFtRnVsZmlsbFJlYWRSZXF1ZXN0KHN0cmVhbSwgdHJhbnNmZXJyZWRWaWV3LCBmYWxzZSk7XG4gICB9XG4gIH0gZWxzZSBpZiAoUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkgPT09IHRydWUpIHtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFbnF1ZXVlQ2h1bmtUb1F1ZXVlKGNvbnRyb2xsZXIsIHRyYW5zZmVycmVkQnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoKTtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQcm9jZXNzUHVsbEludG9EZXNjcmlwdG9yc1VzaW5nUXVldWUoY29udHJvbGxlcik7XG4gIH0gZWxzZSB7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRW5xdWV1ZUNodW5rVG9RdWV1ZShjb250cm9sbGVyLCB0cmFuc2ZlcnJlZEJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCk7XG4gIH1cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckNhbGxQdWxsSWZOZWVkZWQoY29udHJvbGxlcik7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkUmVhZGFibGVCeXRlU3RyZWFtO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSAhPT0gJ3JlYWRhYmxlJykge1xuICAgcmV0dXJuO1xuICB9XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhclBlbmRpbmdQdWxsSW50b3MoY29udHJvbGxlcik7XG4gIFJlc2V0UXVldWUoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoY29udHJvbGxlcik7XG4gIFJlYWRhYmxlU3RyZWFtRXJyb3Ioc3RyZWFtLCBlKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckdldERlc2lyZWRTaXplKGNvbnRyb2xsZXIpIHtcbiAgdmFyIHN0cmVhbSA9IGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW07XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fc3RhdGU7XG4gIGlmIChzdGF0ZSA9PT0gJ2Vycm9yZWQnKSB7XG4gICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoc3RhdGUgPT09ICdjbG9zZWQnKSB7XG4gICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gY29udHJvbGxlci5fc3RyYXRlZ3lIV00gLSBjb250cm9sbGVyLl9xdWV1ZVRvdGFsU2l6ZTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmQoY29udHJvbGxlciwgYnl0ZXNXcml0dGVuKSB7XG4gIGJ5dGVzV3JpdHRlbiA9IE51bWJlcihieXRlc1dyaXR0ZW4pO1xuICBpZiAoSXNGaW5pdGVOb25OZWdhdGl2ZU51bWJlcihieXRlc1dyaXR0ZW4pID09PSBmYWxzZSkge1xuICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2J5dGVzV3JpdHRlbiBtdXN0IGJlIGEgZmluaXRlJyk7XG4gIH1cbiAgUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlclJlc3BvbmRJbnRlcm5hbChjb250cm9sbGVyLCBieXRlc1dyaXR0ZW4pO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyUmVzcG9uZFdpdGhOZXdWaWV3KGNvbnRyb2xsZXIsIHZpZXcpIHtcbiAgdmFyIGZpcnN0RGVzY3JpcHRvciA9IGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MucGVlaygpO1xuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVPZmZzZXQgKyBmaXJzdERlc2NyaXB0b3IuYnl0ZXNGaWxsZWQgIT09IHZpZXcuYnl0ZU9mZnNldCkge1xuICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSByZWdpb24gc3BlY2lmaWVkIGJ5IHZpZXcgZG9lcyBub3QgbWF0Y2ggYnlvYlJlcXVlc3QnKTtcbiAgfVxuICBpZiAoZmlyc3REZXNjcmlwdG9yLmJ5dGVMZW5ndGggIT09IHZpZXcuYnl0ZUxlbmd0aCkge1xuICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBidWZmZXIgb2YgdmlldyBoYXMgZGlmZmVyZW50IGNhcGFjaXR5IHRoYW4gYnlvYlJlcXVlc3QnKTtcbiAgfVxuICBmaXJzdERlc2NyaXB0b3IuYnVmZmVyID0gdmlldy5idWZmZXI7XG4gIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJSZXNwb25kSW50ZXJuYWwoY29udHJvbGxlciwgdmlldy5ieXRlTGVuZ3RoKTtcbiB9XG4gZnVuY3Rpb24gU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgc3RhcnRBbGdvcml0aG0sIHB1bGxBbGdvcml0aG0sIGNhbmNlbEFsZ29yaXRobSwgaGlnaFdhdGVyTWFyaywgYXV0b0FsbG9jYXRlQ2h1bmtTaXplKSB7XG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRSZWFkYWJsZUJ5dGVTdHJlYW0gPSBzdHJlYW07XG4gIGNvbnRyb2xsZXIuX3B1bGxBZ2FpbiA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9wdWxsaW5nID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX2J5b2JSZXF1ZXN0ID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9xdWV1ZSA9IGNvbnRyb2xsZXIuX3F1ZXVlVG90YWxTaXplID0gdW5kZWZpbmVkO1xuICBSZXNldFF1ZXVlKGNvbnRyb2xsZXIpO1xuICBjb250cm9sbGVyLl9jbG9zZVJlcXVlc3RlZCA9IGZhbHNlO1xuICBjb250cm9sbGVyLl9zdGFydGVkID0gZmFsc2U7XG4gIGNvbnRyb2xsZXIuX3N0cmF0ZWd5SFdNID0gVmFsaWRhdGVBbmROb3JtYWxpemVIaWdoV2F0ZXJNYXJrKGhpZ2hXYXRlck1hcmspO1xuICBjb250cm9sbGVyLl9wdWxsQWxnb3JpdGhtID0gcHVsbEFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fY2FuY2VsQWxnb3JpdGhtID0gY2FuY2VsQWxnb3JpdGhtO1xuICBjb250cm9sbGVyLl9hdXRvQWxsb2NhdGVDaHVua1NpemUgPSBhdXRvQWxsb2NhdGVDaHVua1NpemU7XG4gIGNvbnRyb2xsZXIuX3BlbmRpbmdQdWxsSW50b3MgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgc3RyZWFtLl9yZWFkYWJsZVN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICB2YXIgc3RhcnRSZXN1bHQgPSBzdGFydEFsZ29yaXRobSgpO1xuICB1cG9uUHJvbWlzZShwcm9taXNlUmVzb2x2ZWRXaXRoKHN0YXJ0UmVzdWx0KSwgZnVuY3Rpb24gKCkge1xuICAgY29udHJvbGxlci5fc3RhcnRlZCA9IHRydWU7XG4gICBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyQ2FsbFB1bGxJZk5lZWRlZChjb250cm9sbGVyKTtcbiAgfSwgZnVuY3Rpb24gKHIpIHtcbiAgIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCByKTtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIFNldFVwUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlckZyb21VbmRlcmx5aW5nU291cmNlKHN0cmVhbSwgdW5kZXJseWluZ0J5dGVTb3VyY2UsIGhpZ2hXYXRlck1hcmspIHtcbiAgdmFyIGNvbnRyb2xsZXIgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlKTtcbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICByZXR1cm4gSW52b2tlT3JOb29wKHVuZGVybHlpbmdCeXRlU291cmNlLCAnc3RhcnQnLCBbY29udHJvbGxlcl0pO1xuICB9XG4gIHZhciBwdWxsQWxnb3JpdGhtID0gQ3JlYXRlQWxnb3JpdGhtRnJvbVVuZGVybHlpbmdNZXRob2QodW5kZXJseWluZ0J5dGVTb3VyY2UsICdwdWxsJywgMCwgW2NvbnRyb2xsZXJdKTtcbiAgdmFyIGNhbmNlbEFsZ29yaXRobSA9IENyZWF0ZUFsZ29yaXRobUZyb21VbmRlcmx5aW5nTWV0aG9kKHVuZGVybHlpbmdCeXRlU291cmNlLCAnY2FuY2VsJywgMSwgW10pO1xuICB2YXIgYXV0b0FsbG9jYXRlQ2h1bmtTaXplID0gdW5kZXJseWluZ0J5dGVTb3VyY2UuYXV0b0FsbG9jYXRlQ2h1bmtTaXplO1xuICBpZiAoYXV0b0FsbG9jYXRlQ2h1bmtTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgIGF1dG9BbGxvY2F0ZUNodW5rU2l6ZSA9IE51bWJlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuICAgaWYgKE51bWJlcklzSW50ZWdlcihhdXRvQWxsb2NhdGVDaHVua1NpemUpID09PSBmYWxzZSB8fCBhdXRvQWxsb2NhdGVDaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhdXRvQWxsb2NhdGVDaHVua1NpemUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgIH1cbiAgfVxuICBTZXRVcFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBhdXRvQWxsb2NhdGVDaHVua1NpemUpO1xuIH1cbiBmdW5jdGlvbiBTZXRVcFJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QocmVxdWVzdCwgY29udHJvbGxlciwgdmlldykge1xuICByZXF1ZXN0Ll9hc3NvY2lhdGVkUmVhZGFibGVCeXRlU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gIHJlcXVlc3QuX3ZpZXcgPSB2aWV3O1xuIH1cbiBmdW5jdGlvbiBieW9iUmVxdWVzdEJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlU3RyZWFtQllPQlJlcXVlc3QucHJvdG90eXBlLlwiICsgbmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZXF1ZXN0XCIpO1xuIH1cbiBmdW5jdGlvbiBieXRlU3RyZWFtQ29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24obmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXIucHJvdG90eXBlLlwiICsgbmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyXCIpO1xuIH1cbiBmdW5jdGlvbiBBY3F1aXJlUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyKHN0cmVhbSwgZm9yQXV0aG9yQ29kZSkge1xuICBpZiAoZm9yQXV0aG9yQ29kZSA9PT0gdm9pZCAwKSB7XG4gICBmb3JBdXRob3JDb2RlID0gZmFsc2U7XG4gIH1cbiAgdmFyIHJlYWRlciA9IG5ldyBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKTtcbiAgcmVhZGVyLl9mb3JBdXRob3JDb2RlID0gZm9yQXV0aG9yQ29kZTtcbiAgcmV0dXJuIHJlYWRlcjtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1BZGRSZWFkSW50b1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHZhciBwcm9taXNlID0gbmV3UHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICB2YXIgcmVhZEludG9SZXF1ZXN0ID0ge1xuICAgIF9yZXNvbHZlOiByZXNvbHZlLFxuICAgIF9yZWplY3Q6IHJlamVjdFxuICAgfTtcbiAgIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLnB1c2gocmVhZEludG9SZXF1ZXN0KTtcbiAgfSk7XG4gIHJldHVybiBwcm9taXNlO1xuIH1cbiBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUZ1bGZpbGxSZWFkSW50b1JlcXVlc3Qoc3RyZWFtLCBjaHVuaywgZG9uZSkge1xuICB2YXIgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gIHZhciByZWFkSW50b1JlcXVlc3QgPSByZWFkZXIuX3JlYWRJbnRvUmVxdWVzdHMuc2hpZnQoKTtcbiAgcmVhZEludG9SZXF1ZXN0Ll9yZXNvbHZlKFJlYWRhYmxlU3RyZWFtQ3JlYXRlUmVhZFJlc3VsdChjaHVuaywgZG9uZSwgcmVhZGVyLl9mb3JBdXRob3JDb2RlKSk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtR2V0TnVtUmVhZEludG9SZXF1ZXN0cyhzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5fcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aDtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1IYXNCWU9CUmVhZGVyKHN0cmVhbSkge1xuICB2YXIgcmVhZGVyID0gc3RyZWFtLl9yZWFkZXI7XG4gIGlmIChyZWFkZXIgPT09IHVuZGVmaW5lZCkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIocmVhZGVyKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiB2YXIgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoc3RyZWFtKSB7XG4gICBpZiAoIUlzUmVhZGFibGVTdHJlYW0oc3RyZWFtKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlciBjYW4gb25seSBiZSBjb25zdHJ1Y3RlZCB3aXRoIGEgUmVhZGFibGVTdHJlYW0gaW5zdGFuY2UgZ2l2ZW4gYSAnICsgJ2J5dGUgc291cmNlJyk7XG4gICB9XG4gICBpZiAoSXNSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29uc3RydWN0IGEgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyIGZvciBhIHN0cmVhbSBub3QgY29uc3RydWN0ZWQgd2l0aCBhIGJ5dGUgJyArICdzb3VyY2UnKTtcbiAgIH1cbiAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHN0cmVhbSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGlzIHN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGxvY2tlZCBmb3IgZXhjbHVzaXZlIHJlYWRpbmcgYnkgYW5vdGhlciByZWFkZXInKTtcbiAgIH1cbiAgIFJlYWRhYmxlU3RyZWFtUmVhZGVyR2VuZXJpY0luaXRpYWxpemUodGhpcywgc3RyZWFtKTtcbiAgIHRoaXMuX3JlYWRJbnRvUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZSwgXCJjbG9zZWRcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2xvc2VkJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2xvc2VkUHJvbWlzZTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLmNhbmNlbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbignY2FuY2VsJykpO1xuICAgfVxuICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKHJlYWRlckxvY2tFeGNlcHRpb24oJ2NhbmNlbCcpKTtcbiAgIH1cbiAgIHJldHVybiBSZWFkYWJsZVN0cmVhbVJlYWRlckdlbmVyaWNDYW5jZWwodGhpcywgcmVhc29uKTtcbiAgfTtcbiAgUmVhZGFibGVTdHJlYW1CWU9CUmVhZGVyLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKHZpZXcpIHtcbiAgIGlmICghSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcykpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChieW9iUmVhZGVyQnJhbmRDaGVja0V4Y2VwdGlvbigncmVhZCcpKTtcbiAgIH1cbiAgIGlmICh0aGlzLl9vd25lclJlYWRhYmxlU3RyZWFtID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChyZWFkZXJMb2NrRXhjZXB0aW9uKCdyZWFkIGZyb20nKSk7XG4gICB9XG4gICBpZiAoIUFycmF5QnVmZmVyLmlzVmlldyh2aWV3KSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ3ZpZXcgbXVzdCBiZSBhbiBhcnJheSBidWZmZXIgdmlldycpKTtcbiAgIH1cbiAgIGlmIChJc0RldGFjaGVkQnVmZmVyKHZpZXcuYnVmZmVyKSA9PT0gdHJ1ZSk7XG4gICBpZiAodmlldy5ieXRlTGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcigndmlldyBtdXN0IGhhdmUgbm9uLXplcm8gYnl0ZUxlbmd0aCcpKTtcbiAgIH1cbiAgIHJldHVybiBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJSZWFkKHRoaXMsIHZpZXcpO1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLnJlbGVhc2VMb2NrID0gZnVuY3Rpb24gKCkge1xuICAgaWYgKCFJc1JlYWRhYmxlU3RyZWFtQllPQlJlYWRlcih0aGlzKSkge1xuICAgIHRocm93IGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKCdyZWxlYXNlTG9jaycpO1xuICAgfVxuICAgaWYgKHRoaXMuX293bmVyUmVhZGFibGVTdHJlYW0gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybjtcbiAgIH1cbiAgIGlmICh0aGlzLl9yZWFkSW50b1JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUcmllZCB0byByZWxlYXNlIGEgcmVhZGVyIGxvY2sgd2hlbiB0aGF0IHJlYWRlciBoYXMgcGVuZGluZyByZWFkKCkgY2FsbHMgdW4tc2V0dGxlZCcpO1xuICAgfVxuICAgUmVhZGFibGVTdHJlYW1SZWFkZXJHZW5lcmljUmVsZWFzZSh0aGlzKTtcbiAgfTtcbiAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlcjtcbiB9KCk7XG4gZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIoeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZEludG9SZXF1ZXN0cycpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQllPQlJlYWRlclJlYWQocmVhZGVyLCB2aWV3KSB7XG4gIHZhciBzdHJlYW0gPSByZWFkZXIuX293bmVyUmVhZGFibGVTdHJlYW07XG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gdHJ1ZTtcbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiAgcmV0dXJuIFJlYWRhYmxlQnl0ZVN0cmVhbUNvbnRyb2xsZXJQdWxsSW50byhzdHJlYW0uX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgdmlldyk7XG4gfVxuIGZ1bmN0aW9uIGJ5b2JSZWFkZXJCcmFuZENoZWNrRXhjZXB0aW9uKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIucHJvdG90eXBlLlwiICsgbmFtZSArIFwiIGNhbiBvbmx5IGJlIHVzZWQgb24gYSBSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXJcIik7XG4gfVxuIHZhciBSZWFkYWJsZVN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUmVhZGFibGVTdHJlYW0odW5kZXJseWluZ1NvdXJjZSwgc3RyYXRlZ3kpIHtcbiAgIGlmICh1bmRlcmx5aW5nU291cmNlID09PSB2b2lkIDApIHtcbiAgICB1bmRlcmx5aW5nU291cmNlID0ge307XG4gICB9XG4gICBpZiAoc3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIHN0cmF0ZWd5ID0ge307XG4gICB9XG4gICBJbml0aWFsaXplUmVhZGFibGVTdHJlYW0odGhpcyk7XG4gICB2YXIgc2l6ZSA9IHN0cmF0ZWd5LnNpemU7XG4gICB2YXIgaGlnaFdhdGVyTWFyayA9IHN0cmF0ZWd5LmhpZ2hXYXRlck1hcms7XG4gICB2YXIgdHlwZSA9IHVuZGVybHlpbmdTb3VyY2UudHlwZTtcbiAgIHZhciB0eXBlU3RyaW5nID0gU3RyaW5nKHR5cGUpO1xuICAgaWYgKHR5cGVTdHJpbmcgPT09ICdieXRlcycpIHtcbiAgICBpZiAoc2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgc3RyYXRlZ3kgZm9yIGEgYnl0ZSBzdHJlYW0gY2Fubm90IGhhdmUgYSBzaXplIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGlmIChoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQpIHtcbiAgICAgaGlnaFdhdGVyTWFyayA9IDA7XG4gICAgfVxuICAgIGhpZ2hXYXRlck1hcmsgPSBWYWxpZGF0ZUFuZE5vcm1hbGl6ZUhpZ2hXYXRlck1hcmsoaGlnaFdhdGVyTWFyayk7XG4gICAgU2V0VXBSZWFkYWJsZUJ5dGVTdHJlYW1Db250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyayk7XG4gICB9IGVsc2UgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBzaXplQWxnb3JpdGhtID0gTWFrZVNpemVBbGdvcml0aG1Gcm9tU2l6ZUZ1bmN0aW9uKHNpemUpO1xuICAgIGlmIChoaWdoV2F0ZXJNYXJrID09PSB1bmRlZmluZWQpIHtcbiAgICAgaGlnaFdhdGVyTWFyayA9IDE7XG4gICAgfVxuICAgIGhpZ2hXYXRlck1hcmsgPSBWYWxpZGF0ZUFuZE5vcm1hbGl6ZUhpZ2hXYXRlck1hcmsoaGlnaFdhdGVyTWFyayk7XG4gICAgU2V0VXBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyRnJvbVVuZGVybHlpbmdTb3VyY2UodGhpcywgdW5kZXJseWluZ1NvdXJjZSwgaGlnaFdhdGVyTWFyaywgc2l6ZUFsZ29yaXRobSk7XG4gICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGUgaXMgc3BlY2lmaWVkJyk7XG4gICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSwgXCJsb2NrZWRcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKElzUmVhZGFibGVTdHJlYW0odGhpcykgPT09IGZhbHNlKSB7XG4gICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnbG9ja2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpO1xuICAgfSxcbiAgIGVudW1lcmFibGU6IHRydWUsXG4gICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG4gIFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2NhbmNlbCcpKTtcbiAgIH1cbiAgIGlmIChJc1JlYWRhYmxlU3RyZWFtTG9ja2VkKHRoaXMpID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgobmV3IFR5cGVFcnJvcignQ2Fubm90IGNhbmNlbCBhIHN0cmVhbSB0aGF0IGFscmVhZHkgaGFzIGEgcmVhZGVyJykpO1xuICAgfVxuICAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtQ2FuY2VsKHRoaXMsIHJlYXNvbik7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRSZWFkZXIgPSBmdW5jdGlvbiAoX2EpIHtcbiAgIHZhciBtb2RlID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5tb2RlO1xuICAgaWYgKElzUmVhZGFibGVTdHJlYW0odGhpcykgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdnZXRSZWFkZXInKTtcbiAgIH1cbiAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtRGVmYXVsdFJlYWRlcih0aGlzLCB0cnVlKTtcbiAgIH1cbiAgIG1vZGUgPSBTdHJpbmcobW9kZSk7XG4gICBpZiAobW9kZSA9PT0gJ2J5b2InKSB7XG4gICAgcmV0dXJuIEFjcXVpcmVSZWFkYWJsZVN0cmVhbUJZT0JSZWFkZXIodGhpcywgdHJ1ZSk7XG4gICB9XG4gICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCBtb2RlIGlzIHNwZWNpZmllZCcpO1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggPSBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICB2YXIgd3JpdGFibGUgPSBfYS53cml0YWJsZSwgcmVhZGFibGUgPSBfYS5yZWFkYWJsZTtcbiAgIHZhciBfYyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iLCBwcmV2ZW50Q2xvc2UgPSBfYy5wcmV2ZW50Q2xvc2UsIHByZXZlbnRBYm9ydCA9IF9jLnByZXZlbnRBYm9ydCwgcHJldmVudENhbmNlbCA9IF9jLnByZXZlbnRDYW5jZWwsIHNpZ25hbCA9IF9jLnNpZ25hbDtcbiAgIGlmIChJc1JlYWRhYmxlU3RyZWFtKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHRocm93IHN0cmVhbUJyYW5kQ2hlY2tFeGNlcHRpb24kMSgncGlwZVRocm91Z2gnKTtcbiAgIH1cbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtKHdyaXRhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3cml0YWJsZSBhcmd1bWVudCB0byBwaXBlVGhyb3VnaCBtdXN0IGJlIGEgV3JpdGFibGVTdHJlYW0nKTtcbiAgIH1cbiAgIGlmIChJc1JlYWRhYmxlU3RyZWFtKHJlYWRhYmxlKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWFkYWJsZSBhcmd1bWVudCB0byBwaXBlVGhyb3VnaCBtdXN0IGJlIGEgUmVhZGFibGVTdHJlYW0nKTtcbiAgIH1cbiAgIHByZXZlbnRDbG9zZSA9IEJvb2xlYW4ocHJldmVudENsb3NlKTtcbiAgIHByZXZlbnRBYm9ydCA9IEJvb2xlYW4ocHJldmVudEFib3J0KTtcbiAgIHByZXZlbnRDYW5jZWwgPSBCb29sZWFuKHByZXZlbnRDYW5jZWwpO1xuICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkICYmICFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2hcXCdzIHNpZ25hbCBvcHRpb24gbXVzdCBiZSBhbiBBYm9ydFNpZ25hbCcpO1xuICAgfVxuICAgaWYgKElzUmVhZGFibGVTdHJlYW1Mb2NrZWQodGhpcykgPT09IHRydWUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRocm91Z2ggY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKTtcbiAgIH1cbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtTG9ja2VkKHdyaXRhYmxlKSA9PT0gdHJ1ZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVGhyb3VnaCBjYW5ub3QgYmUgdXNlZCBvbiBhIGxvY2tlZCBXcml0YWJsZVN0cmVhbScpO1xuICAgfVxuICAgdmFyIHByb21pc2UgPSBSZWFkYWJsZVN0cmVhbVBpcGVUbyh0aGlzLCB3cml0YWJsZSwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCk7XG4gICBzZXRQcm9taXNlSXNIYW5kbGVkVG9UcnVlKHByb21pc2UpO1xuICAgcmV0dXJuIHJlYWRhYmxlO1xuICB9O1xuICBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvID0gZnVuY3Rpb24gKGRlc3QsIF9hKSB7XG4gICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgcHJldmVudENsb3NlID0gX2IucHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQgPSBfYi5wcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwgPSBfYi5wcmV2ZW50Q2FuY2VsLCBzaWduYWwgPSBfYi5zaWduYWw7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3BpcGVUbycpKTtcbiAgIH1cbiAgIGlmIChJc1dyaXRhYmxlU3RyZWFtKGRlc3QpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG9cXCdzIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBXcml0YWJsZVN0cmVhbScpKTtcbiAgIH1cbiAgIHByZXZlbnRDbG9zZSA9IEJvb2xlYW4ocHJldmVudENsb3NlKTtcbiAgIHByZXZlbnRBYm9ydCA9IEJvb2xlYW4ocHJldmVudEFib3J0KTtcbiAgIHByZXZlbnRDYW5jZWwgPSBCb29sZWFuKHByZXZlbnRDYW5jZWwpO1xuICAgaWYgKHNpZ25hbCAhPT0gdW5kZWZpbmVkICYmICFpc0Fib3J0U2lnbmFsKHNpZ25hbCkpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aChuZXcgVHlwZUVycm9yKCdSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUucGlwZVRvXFwncyBzaWduYWwgb3B0aW9uIG11c3QgYmUgYW4gQWJvcnRTaWduYWwnKSk7XG4gICB9XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbUxvY2tlZCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgUmVhZGFibGVTdHJlYW0nKSk7XG4gICB9XG4gICBpZiAoSXNXcml0YWJsZVN0cmVhbUxvY2tlZChkZXN0KSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBwcm9taXNlUmVqZWN0ZWRXaXRoKG5ldyBUeXBlRXJyb3IoJ1JlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5waXBlVG8gY2Fubm90IGJlIHVzZWQgb24gYSBsb2NrZWQgV3JpdGFibGVTdHJlYW0nKSk7XG4gICB9XG4gICByZXR1cm4gUmVhZGFibGVTdHJlYW1QaXBlVG8odGhpcywgZGVzdCwgcHJldmVudENsb3NlLCBwcmV2ZW50QWJvcnQsIHByZXZlbnRDYW5jZWwsIHNpZ25hbCk7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS50ZWUgPSBmdW5jdGlvbiAoKSB7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ3RlZScpO1xuICAgfVxuICAgdmFyIGJyYW5jaGVzID0gUmVhZGFibGVTdHJlYW1UZWUodGhpcyk7XG4gICByZXR1cm4gY3JlYXRlQXJyYXlGcm9tTGlzdChicmFuY2hlcyk7XG4gIH07XG4gIFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZS5nZXRJdGVyYXRvciA9IGZ1bmN0aW9uIChfYSkge1xuICAgdmFyIF9iID0gKF9hID09PSB2b2lkIDAgPyB7fSA6IF9hKS5wcmV2ZW50Q2FuY2VsLCBwcmV2ZW50Q2FuY2VsID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICBpZiAoSXNSZWFkYWJsZVN0cmVhbSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDEoJ2dldEl0ZXJhdG9yJyk7XG4gICB9XG4gICByZXR1cm4gQWNxdWlyZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzLCBwcmV2ZW50Q2FuY2VsKTtcbiAgfTtcbiAgcmV0dXJuIFJlYWRhYmxlU3RyZWFtO1xuIH0oKTtcbiBpZiAodHlwZW9mIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IgPT09ICdzeW1ib2wnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUsIFN5bWJvbFBvbHlmaWxsLmFzeW5jSXRlcmF0b3IsIHtcbiAgIHZhbHVlOiBSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuZ2V0SXRlcmF0b3IsXG4gICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgIHdyaXRhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuIH1cbiBmdW5jdGlvbiBDcmVhdGVSZWFkYWJsZVN0cmVhbShzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKSB7XG4gIGlmIChoaWdoV2F0ZXJNYXJrID09PSB2b2lkIDApIHtcbiAgIGhpZ2hXYXRlck1hcmsgPSAxO1xuICB9XG4gIGlmIChzaXplQWxnb3JpdGhtID09PSB2b2lkIDApIHtcbiAgIHNpemVBbGdvcml0aG0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIDE7XG4gICB9O1xuICB9XG4gIHZhciBzdHJlYW0gPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtLnByb3RvdHlwZSk7XG4gIEluaXRpYWxpemVSZWFkYWJsZVN0cmVhbShzdHJlYW0pO1xuICB2YXIgY29udHJvbGxlciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICBTZXRVcFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCBzdGFydEFsZ29yaXRobSwgcHVsbEFsZ29yaXRobSwgY2FuY2VsQWxnb3JpdGhtLCBoaWdoV2F0ZXJNYXJrLCBzaXplQWxnb3JpdGhtKTtcbiAgcmV0dXJuIHN0cmVhbTtcbiB9XG4gZnVuY3Rpb24gSW5pdGlhbGl6ZVJlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICBzdHJlYW0uX3N0YXRlID0gJ3JlYWRhYmxlJztcbiAgc3RyZWFtLl9yZWFkZXIgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fZGlzdHVyYmVkID0gZmFsc2U7XG4gfVxuIGZ1bmN0aW9uIElzUmVhZGFibGVTdHJlYW0oeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfcmVhZGFibGVTdHJlYW1Db250cm9sbGVyJykpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gSXNSZWFkYWJsZVN0cmVhbUxvY2tlZChzdHJlYW0pIHtcbiAgaWYgKHN0cmVhbS5fcmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1DYW5jZWwoc3RyZWFtLCByZWFzb24pIHtcbiAgc3RyZWFtLl9kaXN0dXJiZWQgPSB0cnVlO1xuICBpZiAoc3RyZWFtLl9zdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgaWYgKHN0cmVhbS5fc3RhdGUgPT09ICdlcnJvcmVkJykge1xuICAgcmV0dXJuIHByb21pc2VSZWplY3RlZFdpdGgoc3RyZWFtLl9zdG9yZWRFcnJvcik7XG4gIH1cbiAgUmVhZGFibGVTdHJlYW1DbG9zZShzdHJlYW0pO1xuICB2YXIgc291cmNlQ2FuY2VsUHJvbWlzZSA9IHN0cmVhbS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyW0NhbmNlbFN0ZXBzXShyZWFzb24pO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoc291cmNlQ2FuY2VsUHJvbWlzZSwgbm9vcCk7XG4gfVxuIGZ1bmN0aW9uIFJlYWRhYmxlU3RyZWFtQ2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5fc3RhdGUgPSAnY2xvc2VkJztcbiAgdmFyIHJlYWRlciA9IHN0cmVhbS5fcmVhZGVyO1xuICBpZiAocmVhZGVyID09PSB1bmRlZmluZWQpIHtcbiAgIHJldHVybjtcbiAgfVxuICBpZiAoSXNSZWFkYWJsZVN0cmVhbURlZmF1bHRSZWFkZXIocmVhZGVyKSkge1xuICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVhZFJlcXVlc3QpIHtcbiAgICByZWFkUmVxdWVzdC5fcmVzb2x2ZShSZWFkYWJsZVN0cmVhbUNyZWF0ZVJlYWRSZXN1bHQodW5kZWZpbmVkLCB0cnVlLCByZWFkZXIuX2ZvckF1dGhvckNvZGUpKTtcbiAgIH0pO1xuICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfVxuICBkZWZhdWx0UmVhZGVyQ2xvc2VkUHJvbWlzZVJlc29sdmUocmVhZGVyKTtcbiB9XG4gZnVuY3Rpb24gUmVhZGFibGVTdHJlYW1FcnJvcihzdHJlYW0sIGUpIHtcbiAgc3RyZWFtLl9zdGF0ZSA9ICdlcnJvcmVkJztcbiAgc3RyZWFtLl9zdG9yZWRFcnJvciA9IGU7XG4gIHZhciByZWFkZXIgPSBzdHJlYW0uX3JlYWRlcjtcbiAgaWYgKHJlYWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICByZXR1cm47XG4gIH1cbiAgaWYgKElzUmVhZGFibGVTdHJlYW1EZWZhdWx0UmVhZGVyKHJlYWRlcikpIHtcbiAgIHJlYWRlci5fcmVhZFJlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlYWRSZXF1ZXN0KSB7XG4gICAgcmVhZFJlcXVlc3QuX3JlamVjdChlKTtcbiAgIH0pO1xuICAgcmVhZGVyLl9yZWFkUmVxdWVzdHMgPSBuZXcgU2ltcGxlUXVldWUoKTtcbiAgfSBlbHNlIHtcbiAgIHJlYWRlci5fcmVhZEludG9SZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZWFkSW50b1JlcXVlc3QpIHtcbiAgICByZWFkSW50b1JlcXVlc3QuX3JlamVjdChlKTtcbiAgIH0pO1xuICAgcmVhZGVyLl9yZWFkSW50b1JlcXVlc3RzID0gbmV3IFNpbXBsZVF1ZXVlKCk7XG4gIH1cbiAgZGVmYXVsdFJlYWRlckNsb3NlZFByb21pc2VSZWplY3QocmVhZGVyLCBlKTtcbiB9XG4gZnVuY3Rpb24gc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJSZWFkYWJsZVN0cmVhbS5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFJlYWRhYmxlU3RyZWFtXCIpO1xuIH1cbiB2YXIgQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneShfYSkge1xuICAgdmFyIGhpZ2hXYXRlck1hcmsgPSBfYS5oaWdoV2F0ZXJNYXJrO1xuICAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaGlnaFdhdGVyTWFyaztcbiAgfVxuICBCeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5LnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICByZXR1cm4gY2h1bmsuYnl0ZUxlbmd0aDtcbiAgfTtcbiAgcmV0dXJuIEJ5dGVMZW5ndGhRdWV1aW5nU3RyYXRlZ3k7XG4gfSgpO1xuIHZhciBDb3VudFF1ZXVpbmdTdHJhdGVneSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQ291bnRRdWV1aW5nU3RyYXRlZ3koX2EpIHtcbiAgIHZhciBoaWdoV2F0ZXJNYXJrID0gX2EuaGlnaFdhdGVyTWFyaztcbiAgIHRoaXMuaGlnaFdhdGVyTWFyayA9IGhpZ2hXYXRlck1hcms7XG4gIH1cbiAgQ291bnRRdWV1aW5nU3RyYXRlZ3kucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gMTtcbiAgfTtcbiAgcmV0dXJuIENvdW50UXVldWluZ1N0cmF0ZWd5O1xuIH0oKTtcbiB2YXIgVHJhbnNmb3JtU3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW0odHJhbnNmb3JtZXIsIHdyaXRhYmxlU3RyYXRlZ3ksIHJlYWRhYmxlU3RyYXRlZ3kpIHtcbiAgIGlmICh0cmFuc2Zvcm1lciA9PT0gdm9pZCAwKSB7XG4gICAgdHJhbnNmb3JtZXIgPSB7fTtcbiAgIH1cbiAgIGlmICh3cml0YWJsZVN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICB3cml0YWJsZVN0cmF0ZWd5ID0ge307XG4gICB9XG4gICBpZiAocmVhZGFibGVTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgcmVhZGFibGVTdHJhdGVneSA9IHt9O1xuICAgfVxuICAgdmFyIHdyaXRhYmxlU2l6ZUZ1bmN0aW9uID0gd3JpdGFibGVTdHJhdGVneS5zaXplO1xuICAgdmFyIHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlU3RyYXRlZ3kuaGlnaFdhdGVyTWFyaztcbiAgIHZhciByZWFkYWJsZVNpemVGdW5jdGlvbiA9IHJlYWRhYmxlU3RyYXRlZ3kuc2l6ZTtcbiAgIHZhciByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZVN0cmF0ZWd5LmhpZ2hXYXRlck1hcms7XG4gICB2YXIgd3JpdGFibGVUeXBlID0gdHJhbnNmb3JtZXIud3JpdGFibGVUeXBlO1xuICAgaWYgKHdyaXRhYmxlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgd3JpdGFibGUgdHlwZSBzcGVjaWZpZWQnKTtcbiAgIH1cbiAgIHZhciB3cml0YWJsZVNpemVBbGdvcml0aG0gPSBNYWtlU2l6ZUFsZ29yaXRobUZyb21TaXplRnVuY3Rpb24od3JpdGFibGVTaXplRnVuY3Rpb24pO1xuICAgaWYgKHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgd3JpdGFibGVIaWdoV2F0ZXJNYXJrID0gMTtcbiAgIH1cbiAgIHdyaXRhYmxlSGlnaFdhdGVyTWFyayA9IFZhbGlkYXRlQW5kTm9ybWFsaXplSGlnaFdhdGVyTWFyayh3cml0YWJsZUhpZ2hXYXRlck1hcmspO1xuICAgdmFyIHJlYWRhYmxlVHlwZSA9IHRyYW5zZm9ybWVyLnJlYWRhYmxlVHlwZTtcbiAgIGlmIChyZWFkYWJsZVR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHJlYWRhYmxlIHR5cGUgc3BlY2lmaWVkJyk7XG4gICB9XG4gICB2YXIgcmVhZGFibGVTaXplQWxnb3JpdGhtID0gTWFrZVNpemVBbGdvcml0aG1Gcm9tU2l6ZUZ1bmN0aW9uKHJlYWRhYmxlU2l6ZUZ1bmN0aW9uKTtcbiAgIGlmIChyZWFkYWJsZUhpZ2hXYXRlck1hcmsgPT09IHVuZGVmaW5lZCkge1xuICAgIHJlYWRhYmxlSGlnaFdhdGVyTWFyayA9IDA7XG4gICB9XG4gICByZWFkYWJsZUhpZ2hXYXRlck1hcmsgPSBWYWxpZGF0ZUFuZE5vcm1hbGl6ZUhpZ2hXYXRlck1hcmsocmVhZGFibGVIaWdoV2F0ZXJNYXJrKTtcbiAgIHZhciBzdGFydFByb21pc2VfcmVzb2x2ZTtcbiAgIHZhciBzdGFydFByb21pc2UgPSBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgc3RhcnRQcm9taXNlX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgfSk7XG4gICBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHRoaXMsIHN0YXJ0UHJvbWlzZSwgd3JpdGFibGVIaWdoV2F0ZXJNYXJrLCB3cml0YWJsZVNpemVBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcbiAgIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJGcm9tVHJhbnNmb3JtZXIodGhpcywgdHJhbnNmb3JtZXIpO1xuICAgdmFyIHN0YXJ0UmVzdWx0ID0gSW52b2tlT3JOb29wKHRyYW5zZm9ybWVyLCAnc3RhcnQnLCBbdGhpcy5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcl0pO1xuICAgc3RhcnRQcm9taXNlX3Jlc29sdmUoc3RhcnRSZXN1bHQpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW0ucHJvdG90eXBlLCBcInJlYWRhYmxlXCIsIHtcbiAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmIChJc1RyYW5zZm9ybVN0cmVhbSh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgdGhyb3cgc3RyZWFtQnJhbmRDaGVja0V4Y2VwdGlvbiQyKCdyZWFkYWJsZScpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGU7XG4gICB9LFxuICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUsIFwid3JpdGFibGVcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKElzVHJhbnNmb3JtU3RyZWFtKHRoaXMpID09PSBmYWxzZSkge1xuICAgICB0aHJvdyBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIoJ3dyaXRhYmxlJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZTtcbiAgIH0sXG4gICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtO1xuIH0oKTtcbiBmdW5jdGlvbiBJbml0aWFsaXplVHJhbnNmb3JtU3RyZWFtKHN0cmVhbSwgc3RhcnRQcm9taXNlLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSwgcmVhZGFibGVIaWdoV2F0ZXJNYXJrLCByZWFkYWJsZVNpemVBbGdvcml0aG0pIHtcbiAgZnVuY3Rpb24gc3RhcnRBbGdvcml0aG0oKSB7XG4gICByZXR1cm4gc3RhcnRQcm9taXNlO1xuICB9XG4gIGZ1bmN0aW9uIHdyaXRlQWxnb3JpdGhtKGNodW5rKSB7XG4gICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNpbmtXcml0ZUFsZ29yaXRobShzdHJlYW0sIGNodW5rKTtcbiAgfVxuICBmdW5jdGlvbiBhYm9ydEFsZ29yaXRobShyZWFzb24pIHtcbiAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Fib3J0QWxnb3JpdGhtKHN0cmVhbSwgcmVhc29uKTtcbiAgfVxuICBmdW5jdGlvbiBjbG9zZUFsZ29yaXRobSgpIHtcbiAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSk7XG4gIH1cbiAgc3RyZWFtLl93cml0YWJsZSA9IENyZWF0ZVdyaXRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCB3cml0ZUFsZ29yaXRobSwgY2xvc2VBbGdvcml0aG0sIGFib3J0QWxnb3JpdGhtLCB3cml0YWJsZUhpZ2hXYXRlck1hcmssIHdyaXRhYmxlU2l6ZUFsZ29yaXRobSk7XG4gIGZ1bmN0aW9uIHB1bGxBbGdvcml0aG0oKSB7XG4gICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdFNvdXJjZVB1bGxBbGdvcml0aG0oc3RyZWFtKTtcbiAgfVxuICBmdW5jdGlvbiBjYW5jZWxBbGdvcml0aG0ocmVhc29uKSB7XG4gICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgcmVhc29uKTtcbiAgIHJldHVybiBwcm9taXNlUmVzb2x2ZWRXaXRoKHVuZGVmaW5lZCk7XG4gIH1cbiAgc3RyZWFtLl9yZWFkYWJsZSA9IENyZWF0ZVJlYWRhYmxlU3RyZWFtKHN0YXJ0QWxnb3JpdGhtLCBwdWxsQWxnb3JpdGhtLCBjYW5jZWxBbGdvcml0aG0sIHJlYWRhYmxlSGlnaFdhdGVyTWFyaywgcmVhZGFibGVTaXplQWxnb3JpdGhtKTtcbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmUgPSB1bmRlZmluZWQ7XG4gIHN0cmVhbS5fYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSA9IHVuZGVmaW5lZDtcbiAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUgPSB1bmRlZmluZWQ7XG4gIFRyYW5zZm9ybVN0cmVhbVNldEJhY2twcmVzc3VyZShzdHJlYW0sIHRydWUpO1xuICBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gfVxuIGZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtKHgpIHtcbiAgaWYgKCF0eXBlSXNPYmplY3QoeCkpIHtcbiAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXInKSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xuIH1cbiBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1FcnJvcihzdHJlYW0sIGUpIHtcbiAgUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9yKHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlciwgZSk7XG4gIFRyYW5zZm9ybVN0cmVhbUVycm9yV3JpdGFibGVBbmRVbmJsb2NrV3JpdGUoc3RyZWFtLCBlKTtcbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRXJyb3JXcml0YWJsZUFuZFVuYmxvY2tXcml0ZShzdHJlYW0sIGUpIHtcbiAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbGVhckFsZ29yaXRobXMoc3RyZWFtLl90cmFuc2Zvcm1TdHJlYW1Db250cm9sbGVyKTtcbiAgV3JpdGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckVycm9ySWZOZWVkZWQoc3RyZWFtLl93cml0YWJsZS5fd3JpdGFibGVTdHJlYW1Db250cm9sbGVyLCBlKTtcbiAgaWYgKHN0cmVhbS5fYmFja3ByZXNzdXJlID09PSB0cnVlKSB7XG4gICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XG4gIH1cbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgYmFja3ByZXNzdXJlKSB7XG4gIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgIT09IHVuZGVmaW5lZCkge1xuICAgc3RyZWFtLl9iYWNrcHJlc3N1cmVDaGFuZ2VQcm9taXNlX3Jlc29sdmUoKTtcbiAgfVxuICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSBuZXdQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2VfcmVzb2x2ZSA9IHJlc29sdmU7XG4gIH0pO1xuICBzdHJlYW0uX2JhY2twcmVzc3VyZSA9IGJhY2twcmVzc3VyZTtcbiB9XG4gdmFyIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcigpIHtcbiAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyIGluc3RhbmNlcyBjYW5ub3QgYmUgY3JlYXRlZCBkaXJlY3RseScpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUsIFwiZGVzaXJlZFNpemVcIiwge1xuICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKElzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIodGhpcykgPT09IGZhbHNlKSB7XG4gICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdkZXNpcmVkU2l6ZScpO1xuICAgIH1cbiAgICB2YXIgcmVhZGFibGVDb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgICByZXR1cm4gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckdldERlc2lyZWRTaXplKHJlYWRhYmxlQ29udHJvbGxlcik7XG4gICB9LFxuICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgIGlmIChJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCdlbnF1ZXVlJyk7XG4gICB9XG4gICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckVucXVldWUodGhpcywgY2h1bmspO1xuICB9O1xuICBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuZXJyb3IgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICBpZiAoSXNUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcih0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBkZWZhdWx0Q29udHJvbGxlckJyYW5kQ2hlY2tFeGNlcHRpb24kMSgnZXJyb3InKTtcbiAgIH1cbiAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRXJyb3IodGhpcywgcmVhc29uKTtcbiAgfTtcbiAgVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIucHJvdG90eXBlLnRlcm1pbmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgIGlmIChJc1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHRoaXMpID09PSBmYWxzZSkge1xuICAgIHRocm93IGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKCd0ZXJtaW5hdGUnKTtcbiAgIH1cbiAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyVGVybWluYXRlKHRoaXMpO1xuICB9O1xuICByZXR1cm4gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXI7XG4gfSgpO1xuIGZ1bmN0aW9uIElzVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoeCkge1xuICBpZiAoIXR5cGVJc09iamVjdCh4KSkge1xuICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHgsICdfY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbScpKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG4gfVxuIGZ1bmN0aW9uIFNldFVwVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIoc3RyZWFtLCBjb250cm9sbGVyLCB0cmFuc2Zvcm1BbGdvcml0aG0sIGZsdXNoQWxnb3JpdGhtKSB7XG4gIGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0gPSBzdHJlYW07XG4gIHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gIGNvbnRyb2xsZXIuX3RyYW5zZm9ybUFsZ29yaXRobSA9IHRyYW5zZm9ybUFsZ29yaXRobTtcbiAgY29udHJvbGxlci5fZmx1c2hBbGdvcml0aG0gPSBmbHVzaEFsZ29yaXRobTtcbiB9XG4gZnVuY3Rpb24gU2V0VXBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlckZyb21UcmFuc2Zvcm1lcihzdHJlYW0sIHRyYW5zZm9ybWVyKSB7XG4gIHZhciBjb250cm9sbGVyID0gT2JqZWN0LmNyZWF0ZShUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUpO1xuICB2YXIgdHJhbnNmb3JtQWxnb3JpdGhtID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICB0cnkge1xuICAgIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyRW5xdWV1ZShjb250cm9sbGVyLCBjaHVuayk7XG4gICAgcmV0dXJuIHByb21pc2VSZXNvbHZlZFdpdGgodW5kZWZpbmVkKTtcbiAgIH0gY2F0Y2ggKHRyYW5zZm9ybVJlc3VsdEUpIHtcbiAgICByZXR1cm4gcHJvbWlzZVJlamVjdGVkV2l0aCh0cmFuc2Zvcm1SZXN1bHRFKTtcbiAgIH1cbiAgfTtcbiAgdmFyIHRyYW5zZm9ybU1ldGhvZCA9IHRyYW5zZm9ybWVyLnRyYW5zZm9ybTtcbiAgaWYgKHRyYW5zZm9ybU1ldGhvZCAhPT0gdW5kZWZpbmVkKSB7XG4gICBpZiAodHlwZW9mIHRyYW5zZm9ybU1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RyYW5zZm9ybSBpcyBub3QgYSBtZXRob2QnKTtcbiAgIH1cbiAgIHRyYW5zZm9ybUFsZ29yaXRobSA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIHJldHVybiBQcm9taXNlQ2FsbCh0cmFuc2Zvcm1NZXRob2QsIHRyYW5zZm9ybWVyLCBbXG4gICAgIGNodW5rLFxuICAgICBjb250cm9sbGVyXG4gICAgXSk7XG4gICB9O1xuICB9XG4gIHZhciBmbHVzaEFsZ29yaXRobSA9IENyZWF0ZUFsZ29yaXRobUZyb21VbmRlcmx5aW5nTWV0aG9kKHRyYW5zZm9ybWVyLCAnZmx1c2gnLCAwLCBbY29udHJvbGxlcl0pO1xuICBTZXRVcFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyKHN0cmVhbSwgY29udHJvbGxlciwgdHJhbnNmb3JtQWxnb3JpdGhtLCBmbHVzaEFsZ29yaXRobSk7XG4gfVxuIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpIHtcbiAgY29udHJvbGxlci5fdHJhbnNmb3JtQWxnb3JpdGhtID0gdW5kZWZpbmVkO1xuICBjb250cm9sbGVyLl9mbHVzaEFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKGNvbnRyb2xsZXIsIGNodW5rKSB7XG4gIHZhciBzdHJlYW0gPSBjb250cm9sbGVyLl9jb250cm9sbGVkVHJhbnNmb3JtU3RyZWFtO1xuICB2YXIgcmVhZGFibGVDb250cm9sbGVyID0gc3RyZWFtLl9yZWFkYWJsZS5fcmVhZGFibGVTdHJlYW1Db250cm9sbGVyO1xuICBpZiAoUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckNhbkNsb3NlT3JFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlcikgPT09IGZhbHNlKSB7XG4gICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWFkYWJsZSBzaWRlIGlzIG5vdCBpbiBhIHN0YXRlIHRoYXQgcGVybWl0cyBlbnF1ZXVlJyk7XG4gIH1cbiAgdHJ5IHtcbiAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFbnF1ZXVlKHJlYWRhYmxlQ29udHJvbGxlciwgY2h1bmspO1xuICB9IGNhdGNoIChlKSB7XG4gICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZSk7XG4gICB0aHJvdyBzdHJlYW0uX3JlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgfVxuICB2YXIgYmFja3ByZXNzdXJlID0gUmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlckhhc0JhY2twcmVzc3VyZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICBpZiAoYmFja3ByZXNzdXJlICE9PSBzdHJlYW0uX2JhY2twcmVzc3VyZSkge1xuICAgVHJhbnNmb3JtU3RyZWFtU2V0QmFja3ByZXNzdXJlKHN0cmVhbSwgdHJ1ZSk7XG4gIH1cbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJFcnJvcihjb250cm9sbGVyLCBlKSB7XG4gIFRyYW5zZm9ybVN0cmVhbUVycm9yKGNvbnRyb2xsZXIuX2NvbnRyb2xsZWRUcmFuc2Zvcm1TdHJlYW0sIGUpO1xuIH1cbiBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspIHtcbiAgdmFyIHRyYW5zZm9ybVByb21pc2UgPSBjb250cm9sbGVyLl90cmFuc2Zvcm1BbGdvcml0aG0oY2h1bmspO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgodHJhbnNmb3JtUHJvbWlzZSwgdW5kZWZpbmVkLCBmdW5jdGlvbiAocikge1xuICAgVHJhbnNmb3JtU3RyZWFtRXJyb3IoY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbSwgcik7XG4gICB0aHJvdyByO1xuICB9KTtcbiB9XG4gZnVuY3Rpb24gVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJUZXJtaW5hdGUoY29udHJvbGxlcikge1xuICB2YXIgc3RyZWFtID0gY29udHJvbGxlci5fY29udHJvbGxlZFRyYW5zZm9ybVN0cmVhbTtcbiAgdmFyIHJlYWRhYmxlQ29udHJvbGxlciA9IHN0cmVhbS5fcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgaWYgKFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDYW5DbG9zZU9yRW5xdWV1ZShyZWFkYWJsZUNvbnRyb2xsZXIpID09PSB0cnVlKSB7XG4gICBSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xvc2UocmVhZGFibGVDb250cm9sbGVyKTtcbiAgfVxuICB2YXIgZXJyb3IgPSBuZXcgVHlwZUVycm9yKCdUcmFuc2Zvcm1TdHJlYW0gdGVybWluYXRlZCcpO1xuICBUcmFuc2Zvcm1TdHJlYW1FcnJvcldyaXRhYmxlQW5kVW5ibG9ja1dyaXRlKHN0cmVhbSwgZXJyb3IpO1xuIH1cbiBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua1dyaXRlQWxnb3JpdGhtKHN0cmVhbSwgY2h1bmspIHtcbiAgdmFyIGNvbnRyb2xsZXIgPSBzdHJlYW0uX3RyYW5zZm9ybVN0cmVhbUNvbnRyb2xsZXI7XG4gIGlmIChzdHJlYW0uX2JhY2twcmVzc3VyZSA9PT0gdHJ1ZSkge1xuICAgdmFyIGJhY2twcmVzc3VyZUNoYW5nZVByb21pc2UgPSBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG4gICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoYmFja3ByZXNzdXJlQ2hhbmdlUHJvbWlzZSwgZnVuY3Rpb24gKCkge1xuICAgIHZhciB3cml0YWJsZSA9IHN0cmVhbS5fd3JpdGFibGU7XG4gICAgdmFyIHN0YXRlID0gd3JpdGFibGUuX3N0YXRlO1xuICAgIGlmIChzdGF0ZSA9PT0gJ2Vycm9yaW5nJykge1xuICAgICB0aHJvdyB3cml0YWJsZS5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIHJldHVybiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlclBlcmZvcm1UcmFuc2Zvcm0oY29udHJvbGxlciwgY2h1bmspO1xuICAgfSk7XG4gIH1cbiAgcmV0dXJuIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyUGVyZm9ybVRyYW5zZm9ybShjb250cm9sbGVyLCBjaHVuayk7XG4gfVxuIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTaW5rQWJvcnRBbGdvcml0aG0oc3RyZWFtLCByZWFzb24pIHtcbiAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByZWFzb24pO1xuICByZXR1cm4gcHJvbWlzZVJlc29sdmVkV2l0aCh1bmRlZmluZWQpO1xuIH1cbiBmdW5jdGlvbiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0U2lua0Nsb3NlQWxnb3JpdGhtKHN0cmVhbSkge1xuICB2YXIgcmVhZGFibGUgPSBzdHJlYW0uX3JlYWRhYmxlO1xuICB2YXIgY29udHJvbGxlciA9IHN0cmVhbS5fdHJhbnNmb3JtU3RyZWFtQ29udHJvbGxlcjtcbiAgdmFyIGZsdXNoUHJvbWlzZSA9IGNvbnRyb2xsZXIuX2ZsdXNoQWxnb3JpdGhtKCk7XG4gIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2xlYXJBbGdvcml0aG1zKGNvbnRyb2xsZXIpO1xuICByZXR1cm4gdHJhbnNmb3JtUHJvbWlzZVdpdGgoZmx1c2hQcm9taXNlLCBmdW5jdGlvbiAoKSB7XG4gICBpZiAocmVhZGFibGUuX3N0YXRlID09PSAnZXJyb3JlZCcpIHtcbiAgICB0aHJvdyByZWFkYWJsZS5fc3RvcmVkRXJyb3I7XG4gICB9XG4gICB2YXIgcmVhZGFibGVDb250cm9sbGVyID0gcmVhZGFibGUuX3JlYWRhYmxlU3RyZWFtQ29udHJvbGxlcjtcbiAgIGlmIChSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyQ2FuQ2xvc2VPckVucXVldWUocmVhZGFibGVDb250cm9sbGVyKSA9PT0gdHJ1ZSkge1xuICAgIFJlYWRhYmxlU3RyZWFtRGVmYXVsdENvbnRyb2xsZXJDbG9zZShyZWFkYWJsZUNvbnRyb2xsZXIpO1xuICAgfVxuICB9LCBmdW5jdGlvbiAocikge1xuICAgVHJhbnNmb3JtU3RyZWFtRXJyb3Ioc3RyZWFtLCByKTtcbiAgIHRocm93IHJlYWRhYmxlLl9zdG9yZWRFcnJvcjtcbiAgfSk7XG4gfVxuIGZ1bmN0aW9uIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRTb3VyY2VQdWxsQWxnb3JpdGhtKHN0cmVhbSkge1xuICBUcmFuc2Zvcm1TdHJlYW1TZXRCYWNrcHJlc3N1cmUoc3RyZWFtLCBmYWxzZSk7XG4gIHJldHVybiBzdHJlYW0uX2JhY2twcmVzc3VyZUNoYW5nZVByb21pc2U7XG4gfVxuIGZ1bmN0aW9uIGRlZmF1bHRDb250cm9sbGVyQnJhbmRDaGVja0V4Y2VwdGlvbiQxKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoXCJUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlci5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyXCIpO1xuIH1cbiBmdW5jdGlvbiBzdHJlYW1CcmFuZENoZWNrRXhjZXB0aW9uJDIobmFtZSkge1xuICByZXR1cm4gbmV3IFR5cGVFcnJvcihcIlRyYW5zZm9ybVN0cmVhbS5wcm90b3R5cGUuXCIgKyBuYW1lICsgXCIgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIFRyYW5zZm9ybVN0cmVhbVwiKTtcbiB9XG4gZXhwb3J0cy5CeXRlTGVuZ3RoUXVldWluZ1N0cmF0ZWd5ID0gQnl0ZUxlbmd0aFF1ZXVpbmdTdHJhdGVneTtcbiBleHBvcnRzLkNvdW50UXVldWluZ1N0cmF0ZWd5ID0gQ291bnRRdWV1aW5nU3RyYXRlZ3k7XG4gZXhwb3J0cy5SZWFkYWJsZVN0cmVhbSA9IFJlYWRhYmxlU3RyZWFtO1xuIGV4cG9ydHMuVHJhbnNmb3JtU3RyZWFtID0gVHJhbnNmb3JtU3RyZWFtO1xuIGV4cG9ydHMuV3JpdGFibGVTdHJlYW0gPSBXcml0YWJsZVN0cmVhbTtcbiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufSkpO1xuXG4vKioqLyB9KSxcbi8qIDE0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDE0Nyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExOCk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDc3KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTIwKTtcbnZhciBwYXRoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Myk7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguTWFwO1xuXG4vKioqLyB9KSxcbi8qIDE0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGNvbGxlY3Rpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0OCk7XG52YXIgY29sbGVjdGlvblN0cm9uZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUyKTtcbm1vZHVsZS5leHBvcnRzID0gY29sbGVjdGlvbignTWFwJywgZnVuY3Rpb24gKGluaXQpIHtcbiByZXR1cm4gZnVuY3Rpb24gTWFwKCkge1xuICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiB9O1xufSwgY29sbGVjdGlvblN0cm9uZyk7XG5cbi8qKiovIH0pLFxuLyogMTQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIGlzRm9yY2VkID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Mik7XG52YXIgcmVkZWZpbmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciBJbnRlcm5hbE1ldGFkYXRhTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxNDkpO1xudmFyIGl0ZXJhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwNCk7XG52YXIgYW5JbnN0YW5jZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI2KTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gX193X3BkZmpzX3JlcXVpcmVfXyg5Nyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg1KTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUxKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENPTlNUUlVDVE9SX05BTUUsIHdyYXBwZXIsIGNvbW1vbikge1xuIHZhciBJU19NQVAgPSBDT05TVFJVQ1RPUl9OQU1FLmluZGV4T2YoJ01hcCcpICE9PSAtMTtcbiB2YXIgSVNfV0VBSyA9IENPTlNUUlVDVE9SX05BTUUuaW5kZXhPZignV2VhaycpICE9PSAtMTtcbiB2YXIgQURERVIgPSBJU19NQVAgPyAnc2V0JyA6ICdhZGQnO1xuIHZhciBOYXRpdmVDb25zdHJ1Y3RvciA9IGdsb2JhbFtDT05TVFJVQ1RPUl9OQU1FXTtcbiB2YXIgTmF0aXZlUHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IgJiYgTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuIHZhciBDb25zdHJ1Y3RvciA9IE5hdGl2ZUNvbnN0cnVjdG9yO1xuIHZhciBleHBvcnRlZCA9IHt9O1xuIHZhciBmaXhNZXRob2QgPSBmdW5jdGlvbiAoS0VZKSB7XG4gIHZhciBuYXRpdmVNZXRob2QgPSBOYXRpdmVQcm90b3R5cGVbS0VZXTtcbiAgcmVkZWZpbmUoTmF0aXZlUHJvdG90eXBlLCBLRVksIEtFWSA9PSAnYWRkJyA/IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgbmF0aXZlTWV0aG9kLmNhbGwodGhpcywgdmFsdWUgPT09IDAgPyAwIDogdmFsdWUpO1xuICAgcmV0dXJuIHRoaXM7XG4gIH0gOiBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoa2V5KSB7XG4gICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IGZhbHNlIDogbmF0aXZlTWV0aG9kLmNhbGwodGhpcywga2V5ID09PSAwID8gMCA6IGtleSk7XG4gIH0gOiBLRVkgPT0gJ2dldCcgPyBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3Qoa2V5KSA/IHVuZGVmaW5lZCA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICB9IDogS0VZID09ICdoYXMnID8gZnVuY3Rpb24gaGFzKGtleSkge1xuICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGtleSkgPyBmYWxzZSA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXkpO1xuICB9IDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgIG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGtleSA9PT0gMCA/IDAgOiBrZXksIHZhbHVlKTtcbiAgIHJldHVybiB0aGlzO1xuICB9KTtcbiB9O1xuIGlmIChpc0ZvcmNlZChDT05TVFJVQ1RPUl9OQU1FLCB0eXBlb2YgTmF0aXZlQ29uc3RydWN0b3IgIT0gJ2Z1bmN0aW9uJyB8fCAhKElTX1dFQUsgfHwgTmF0aXZlUHJvdG90eXBlLmZvckVhY2ggJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgIG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLmVudHJpZXMoKS5uZXh0KCk7XG4gIH0pKSkpIHtcbiAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gIEludGVybmFsTWV0YWRhdGFNb2R1bGUuUkVRVUlSRUQgPSB0cnVlO1xuIH0gZWxzZSBpZiAoaXNGb3JjZWQoQ09OU1RSVUNUT1JfTkFNRSwgdHJ1ZSkpIHtcbiAgdmFyIGluc3RhbmNlID0gbmV3IENvbnN0cnVjdG9yKCk7XG4gIHZhciBIQVNOVF9DSEFJTklORyA9IGluc3RhbmNlW0FEREVSXShJU19XRUFLID8ge30gOiAtMCwgMSkgIT0gaW5zdGFuY2U7XG4gIHZhciBUSFJPV1NfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgIGluc3RhbmNlLmhhcygxKTtcbiAgfSk7XG4gIHZhciBBQ0NFUFRfSVRFUkFCTEVTID0gY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uKGZ1bmN0aW9uIChpdGVyYWJsZSkge1xuICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGl0ZXJhYmxlKTtcbiAgfSk7XG4gIHZhciBCVUdHWV9aRVJPID0gIUlTX1dFQUsgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgdmFyICRpbnN0YW5jZSA9IG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpO1xuICAgdmFyIGluZGV4ID0gNTtcbiAgIHdoaWxlIChpbmRleC0tKVxuICAgICRpbnN0YW5jZVtBRERFUl0oaW5kZXgsIGluZGV4KTtcbiAgIHJldHVybiAhJGluc3RhbmNlLmhhcygtMCk7XG4gIH0pO1xuICBpZiAoIUFDQ0VQVF9JVEVSQUJMRVMpIHtcbiAgIENvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAoZHVtbXksIGl0ZXJhYmxlKSB7XG4gICAgYW5JbnN0YW5jZShkdW1teSwgQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgIHZhciB0aGF0ID0gaW5oZXJpdElmUmVxdWlyZWQobmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCksIGR1bW15LCBDb25zdHJ1Y3Rvcik7XG4gICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClcbiAgICAgaXRlcmF0ZShpdGVyYWJsZSwgdGhhdFtBRERFUl0sIHRoYXQsIElTX01BUCk7XG4gICAgcmV0dXJuIHRoYXQ7XG4gICB9KTtcbiAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE5hdGl2ZVByb3RvdHlwZTtcbiAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICB9XG4gIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICB9XG4gIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKVxuICAgZml4TWV0aG9kKEFEREVSKTtcbiAgaWYgKElTX1dFQUsgJiYgTmF0aXZlUHJvdG90eXBlLmNsZWFyKVxuICAgZGVsZXRlIE5hdGl2ZVByb3RvdHlwZS5jbGVhcjtcbiB9XG4gZXhwb3J0ZWRbQ09OU1RSVUNUT1JfTkFNRV0gPSBDb25zdHJ1Y3RvcjtcbiAkKHtcbiAgZ2xvYmFsOiB0cnVlLFxuICBmb3JjZWQ6IENvbnN0cnVjdG9yICE9IE5hdGl2ZUNvbnN0cnVjdG9yXG4gfSwgZXhwb3J0ZWQpO1xuIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiBpZiAoIUlTX1dFQUspXG4gIGNvbW1vbi5zZXRTdHJvbmcoQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCk7XG4gcmV0dXJuIENvbnN0cnVjdG9yO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGhpZGRlbktleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM5KTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNykuZjtcbnZhciB1aWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM4KTtcbnZhciBGUkVFWklORyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUwKTtcbnZhciBNRVRBREFUQSA9IHVpZCgnbWV0YScpO1xudmFyIGlkID0gMDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlIHx8IGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gdHJ1ZTtcbn07XG52YXIgc2V0TWV0YWRhdGEgPSBmdW5jdGlvbiAoaXQpIHtcbiBkZWZpbmVQcm9wZXJ0eShpdCwgTUVUQURBVEEsIHtcbiAgdmFsdWU6IHtcbiAgIG9iamVjdElEOiAnTycgKyArK2lkLFxuICAgd2Vha0RhdGE6IHt9XG4gIH1cbiB9KTtcbn07XG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gaWYgKCFpc09iamVjdChpdCkpXG4gIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCcgPyBpdCA6ICh0eXBlb2YgaXQgPT0gJ3N0cmluZycgPyAnUycgOiAnUCcpICsgaXQ7XG4gaWYgKCFoYXMoaXQsIE1FVEFEQVRBKSkge1xuICBpZiAoIWlzRXh0ZW5zaWJsZShpdCkpXG4gICByZXR1cm4gJ0YnO1xuICBpZiAoIWNyZWF0ZSlcbiAgIHJldHVybiAnRSc7XG4gIHNldE1ldGFkYXRhKGl0KTtcbiB9XG4gcmV0dXJuIGl0W01FVEFEQVRBXS5vYmplY3RJRDtcbn07XG52YXIgZ2V0V2Vha0RhdGEgPSBmdW5jdGlvbiAoaXQsIGNyZWF0ZSkge1xuIGlmICghaGFzKGl0LCBNRVRBREFUQSkpIHtcbiAgaWYgKCFpc0V4dGVuc2libGUoaXQpKVxuICAgcmV0dXJuIHRydWU7XG4gIGlmICghY3JlYXRlKVxuICAgcmV0dXJuIGZhbHNlO1xuICBzZXRNZXRhZGF0YShpdCk7XG4gfVxuIHJldHVybiBpdFtNRVRBREFUQV0ud2Vha0RhdGE7XG59O1xudmFyIG9uRnJlZXplID0gZnVuY3Rpb24gKGl0KSB7XG4gaWYgKEZSRUVaSU5HICYmIG1ldGEuUkVRVUlSRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBREFUQSkpXG4gIHNldE1ldGFkYXRhKGl0KTtcbiByZXR1cm4gaXQ7XG59O1xudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiBSRVFVSVJFRDogZmFsc2UsXG4gZmFzdEtleTogZmFzdEtleSxcbiBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXG4gb25GcmVlemU6IG9uRnJlZXplXG59O1xuaGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuXG4vKioqLyB9KSxcbi8qIDE1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE1MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oODcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGR1bW15LCBXcmFwcGVyKSB7XG4gdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuIGlmIChzZXRQcm90b3R5cGVPZiAmJiB0eXBlb2YgKE5ld1RhcmdldCA9IGR1bW15LmNvbnN0cnVjdG9yKSA9PSAnZnVuY3Rpb24nICYmIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJiBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJiBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlKVxuICBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiByZXR1cm4gJHRoaXM7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGRlZmluZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNykuZjtcbnZhciBjcmVhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcxKTtcbnZhciByZWRlZmluZUFsbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI0KTtcbnZhciBiaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Mik7XG52YXIgYW5JbnN0YW5jZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI2KTtcbnZhciBpdGVyYXRlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDQpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXyg3OSk7XG52YXIgc2V0U3BlY2llcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI1KTtcbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xudmFyIGZhc3RLZXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0OSkuZmFzdEtleTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMyk7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGludGVybmFsU3RhdGVHZXR0ZXJGb3IgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcjtcbm1vZHVsZS5leHBvcnRzID0ge1xuIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICBhbkluc3RhbmNlKHRoYXQsIEMsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICBpbmRleDogY3JlYXRlKG51bGwpLFxuICAgIGZpcnN0OiB1bmRlZmluZWQsXG4gICAgbGFzdDogdW5kZWZpbmVkLFxuICAgIHNpemU6IDBcbiAgIH0pO1xuICAgaWYgKCFERVNDUklQVE9SUylcbiAgICB0aGF0LnNpemUgPSAwO1xuICAgaWYgKGl0ZXJhYmxlICE9IHVuZGVmaW5lZClcbiAgICBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgdGhhdCwgSVNfTUFQKTtcbiAgfSk7XG4gIHZhciBnZXRJbnRlcm5hbFN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgIHZhciBwcmV2aW91cywgaW5kZXg7XG4gICBpZiAoZW50cnkpIHtcbiAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sYXN0ID0gZW50cnkgPSB7XG4gICAgIGluZGV4OiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcbiAgICAga2V5OiBrZXksXG4gICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgcHJldmlvdXM6IHByZXZpb3VzID0gc3RhdGUubGFzdCxcbiAgICAgbmV4dDogdW5kZWZpbmVkLFxuICAgICByZW1vdmVkOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKCFzdGF0ZS5maXJzdClcbiAgICAgc3RhdGUuZmlyc3QgPSBlbnRyeTtcbiAgICBpZiAocHJldmlvdXMpXG4gICAgIHByZXZpb3VzLm5leHQgPSBlbnRyeTtcbiAgICBpZiAoREVTQ1JJUFRPUlMpXG4gICAgIHN0YXRlLnNpemUrKztcbiAgICBlbHNlXG4gICAgIHRoYXQuc2l6ZSsrO1xuICAgIGlmIChpbmRleCAhPT0gJ0YnKVxuICAgICBzdGF0ZS5pbmRleFtpbmRleF0gPSBlbnRyeTtcbiAgIH1cbiAgIHJldHVybiB0aGF0O1xuICB9O1xuICB2YXIgZ2V0RW50cnkgPSBmdW5jdGlvbiAodGhhdCwga2V5KSB7XG4gICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICAgdmFyIGVudHJ5O1xuICAgaWYgKGluZGV4ICE9PSAnRicpXG4gICAgcmV0dXJuIHN0YXRlLmluZGV4W2luZGV4XTtcbiAgIGZvciAoZW50cnkgPSBzdGF0ZS5maXJzdDsgZW50cnk7IGVudHJ5ID0gZW50cnkubmV4dCkge1xuICAgIGlmIChlbnRyeS5rZXkgPT0ga2V5KVxuICAgICByZXR1cm4gZW50cnk7XG4gICB9XG4gIH07XG4gIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCB7XG4gICBjbGVhcjogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICAgdmFyIGRhdGEgPSBzdGF0ZS5pbmRleDtcbiAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgIGlmIChlbnRyeS5wcmV2aW91cylcbiAgICAgIGVudHJ5LnByZXZpb3VzID0gZW50cnkucHJldmlvdXMubmV4dCA9IHVuZGVmaW5lZDtcbiAgICAgZGVsZXRlIGRhdGFbZW50cnkuaW5kZXhdO1xuICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgfVxuICAgIHN0YXRlLmZpcnN0ID0gc3RhdGUubGFzdCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoREVTQ1JJUFRPUlMpXG4gICAgIHN0YXRlLnNpemUgPSAwO1xuICAgIGVsc2VcbiAgICAgdGhhdC5zaXplID0gMDtcbiAgIH0sXG4gICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgIHZhciBlbnRyeSA9IGdldEVudHJ5KHRoYXQsIGtleSk7XG4gICAgaWYgKGVudHJ5KSB7XG4gICAgIHZhciBuZXh0ID0gZW50cnkubmV4dDtcbiAgICAgdmFyIHByZXYgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgZGVsZXRlIHN0YXRlLmluZGV4W2VudHJ5LmluZGV4XTtcbiAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgIGlmIChwcmV2KVxuICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgaWYgKG5leHQpXG4gICAgICBuZXh0LnByZXZpb3VzID0gcHJldjtcbiAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KVxuICAgICAgc3RhdGUuZmlyc3QgPSBuZXh0O1xuICAgICBpZiAoc3RhdGUubGFzdCA9PSBlbnRyeSlcbiAgICAgIHN0YXRlLmxhc3QgPSBwcmV2O1xuICAgICBpZiAoREVTQ1JJUFRPUlMpXG4gICAgICBzdGF0ZS5zaXplLS07XG4gICAgIGVsc2VcbiAgICAgIHRoYXQuc2l6ZS0tO1xuICAgIH1cbiAgICByZXR1cm4gISFlbnRyeTtcbiAgIH0sXG4gICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4pIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCwgMyk7XG4gICAgdmFyIGVudHJ5O1xuICAgIHdoaWxlIChlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLmZpcnN0KSB7XG4gICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgIHdoaWxlIChlbnRyeSAmJiBlbnRyeS5yZW1vdmVkKVxuICAgICAgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICB9XG4gICB9LFxuICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgcmV0dXJuICEhZ2V0RW50cnkodGhpcywga2V5KTtcbiAgIH1cbiAgfSk7XG4gIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeS52YWx1ZTtcbiAgIH0sXG4gICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gICB9XG4gIH0gOiB7XG4gICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgIHJldHVybiBkZWZpbmUodGhpcywgdmFsdWUgPSB2YWx1ZSA9PT0gMCA/IDAgOiB2YWx1ZSwgdmFsdWUpO1xuICAgfVxuICB9KTtcbiAgaWYgKERFU0NSSVBUT1JTKVxuICAgZGVmaW5lUHJvcGVydHkoQy5wcm90b3R5cGUsICdzaXplJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5zaXplO1xuICAgIH1cbiAgIH0pO1xuICByZXR1cm4gQztcbiB9LFxuIHNldFN0cm9uZzogZnVuY3Rpb24gKEMsIENPTlNUUlVDVE9SX05BTUUsIElTX01BUCkge1xuICB2YXIgSVRFUkFUT1JfTkFNRSA9IENPTlNUUlVDVE9SX05BTUUgKyAnIEl0ZXJhdG9yJztcbiAgdmFyIGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgdmFyIGdldEludGVybmFsSXRlcmF0b3JTdGF0ZSA9IGludGVybmFsU3RhdGVHZXR0ZXJGb3IoSVRFUkFUT1JfTkFNRSk7XG4gIGRlZmluZUl0ZXJhdG9yKEMsIENPTlNUUlVDVE9SX05BTUUsIGZ1bmN0aW9uIChpdGVyYXRlZCwga2luZCkge1xuICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogSVRFUkFUT1JfTkFNRSxcbiAgICB0YXJnZXQ6IGl0ZXJhdGVkLFxuICAgIHN0YXRlOiBnZXRJbnRlcm5hbENvbGxlY3Rpb25TdGF0ZShpdGVyYXRlZCksXG4gICAga2luZDoga2luZCxcbiAgICBsYXN0OiB1bmRlZmluZWRcbiAgIH0pO1xuICB9LCBmdW5jdGlvbiAoKSB7XG4gICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0O1xuICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpXG4gICAgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgIGlmICghc3RhdGUudGFyZ2V0IHx8ICEoc3RhdGUubGFzdCA9IGVudHJ5ID0gZW50cnkgPyBlbnRyeS5uZXh0IDogc3RhdGUuc3RhdGUuZmlyc3QpKSB7XG4gICAgc3RhdGUudGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiB7XG4gICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICAgfVxuICAgaWYgKGtpbmQgPT0gJ2tleXMnKVxuICAgIHJldHVybiB7XG4gICAgIHZhbHVlOiBlbnRyeS5rZXksXG4gICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgIGlmIChraW5kID09ICd2YWx1ZXMnKVxuICAgIHJldHVybiB7XG4gICAgIHZhbHVlOiBlbnRyeS52YWx1ZSxcbiAgICAgZG9uZTogZmFsc2VcbiAgICB9O1xuICAgcmV0dXJuIHtcbiAgICB2YWx1ZTogW1xuICAgICBlbnRyeS5rZXksXG4gICAgIGVudHJ5LnZhbHVlXG4gICAgXSxcbiAgICBkb25lOiBmYWxzZVxuICAgfTtcbiAgfSwgSVNfTUFQID8gJ2VudHJpZXMnIDogJ3ZhbHVlcycsICFJU19NQVAsIHRydWUpO1xuICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTUzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTU0KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTE4KTtcbl9fd19wZGZqc19yZXF1aXJlX18oNzcpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjApO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5TZXQ7XG5cbi8qKiovIH0pLFxuLyogMTU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29sbGVjdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQ4KTtcbnZhciBjb2xsZWN0aW9uU3Ryb25nID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTIpO1xubW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0aW9uKCdTZXQnLCBmdW5jdGlvbiAoaW5pdCkge1xuIHJldHVybiBmdW5jdGlvbiBTZXQoKSB7XG4gIHJldHVybiBpbml0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuIH07XG59LCBjb2xsZWN0aW9uU3Ryb25nKTtcblxuLyoqKi8gfSksXG4vKiAxNTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXygxMTgpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNTYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjApO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5XZWFrTWFwO1xuXG4vKioqLyB9KSxcbi8qIDE1NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIHJlZGVmaW5lQWxsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjQpO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0OSk7XG52YXIgY29sbGVjdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQ4KTtcbnZhciBjb2xsZWN0aW9uV2VhayA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU3KTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIGVuZm9yY2VJdGVybmFsU3RhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMzKS5lbmZvcmNlO1xudmFyIE5BVElWRV9XRUFLX01BUCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzQpO1xudmFyIElTX0lFMTEgPSAhZ2xvYmFsLkFjdGl2ZVhPYmplY3QgJiYgJ0FjdGl2ZVhPYmplY3QnIGluIGdsb2JhbDtcbnZhciBpc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIEludGVybmFsV2Vha01hcDtcbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGluaXQpIHtcbiByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgcmV0dXJuIGluaXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7XG4gfTtcbn07XG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3Rpb24oJ1dlYWtNYXAnLCB3cmFwcGVyLCBjb2xsZWN0aW9uV2Vhayk7XG5pZiAoTkFUSVZFX1dFQUtfTUFQICYmIElTX0lFMTEpIHtcbiBJbnRlcm5hbFdlYWtNYXAgPSBjb2xsZWN0aW9uV2Vhay5nZXRDb25zdHJ1Y3Rvcih3cmFwcGVyLCAnV2Vha01hcCcsIHRydWUpO1xuIEludGVybmFsTWV0YWRhdGFNb2R1bGUuUkVRVUlSRUQgPSB0cnVlO1xuIHZhciBXZWFrTWFwUHJvdG90eXBlID0gJFdlYWtNYXAucHJvdG90eXBlO1xuIHZhciBuYXRpdmVEZWxldGUgPSBXZWFrTWFwUHJvdG90eXBlWydkZWxldGUnXTtcbiB2YXIgbmF0aXZlSGFzID0gV2Vha01hcFByb3RvdHlwZS5oYXM7XG4gdmFyIG5hdGl2ZUdldCA9IFdlYWtNYXBQcm90b3R5cGUuZ2V0O1xuIHZhciBuYXRpdmVTZXQgPSBXZWFrTWFwUHJvdG90eXBlLnNldDtcbiByZWRlZmluZUFsbChXZWFrTWFwUHJvdG90eXBlLCB7XG4gICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuICAgIGlmICghc3RhdGUuZnJvemVuKVxuICAgICBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgcmV0dXJuIG5hdGl2ZURlbGV0ZS5jYWxsKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuWydkZWxldGUnXShrZXkpO1xuICAgfVxuICAgcmV0dXJuIG5hdGl2ZURlbGV0ZS5jYWxsKHRoaXMsIGtleSk7XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICBpZiAoIXN0YXRlLmZyb3plbilcbiAgICAgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgIHJldHVybiBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpIHx8IHN0YXRlLmZyb3plbi5oYXMoa2V5KTtcbiAgIH1cbiAgIHJldHVybiBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpO1xuICB9LFxuICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7XG4gICAgaWYgKCFzdGF0ZS5mcm96ZW4pXG4gICAgIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICByZXR1cm4gbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KSA/IG5hdGl2ZUdldC5jYWxsKHRoaXMsIGtleSkgOiBzdGF0ZS5mcm96ZW4uZ2V0KGtleSk7XG4gICB9XG4gICByZXR1cm4gbmF0aXZlR2V0LmNhbGwodGhpcywga2V5KTtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICBpZiAoIXN0YXRlLmZyb3plbilcbiAgICAgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSkgPyBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKSA6IHN0YXRlLmZyb3plbi5zZXQoa2V5LCB2YWx1ZSk7XG4gICB9IGVsc2VcbiAgICBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgIHJldHVybiB0aGlzO1xuICB9XG4gfSk7XG59XG5cbi8qKiovIH0pLFxuLyogMTU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgcmVkZWZpbmVBbGwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNCk7XG52YXIgZ2V0V2Vha0RhdGEgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0OSkuZ2V0V2Vha0RhdGE7XG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI4KTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIGFuSW5zdGFuY2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNik7XG52YXIgaXRlcmF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTA0KTtcbnZhciBBcnJheUl0ZXJhdGlvbk1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU4KTtcbnZhciAkaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzMpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XG52YXIgZmluZCA9IEFycmF5SXRlcmF0aW9uTW9kdWxlLmZpbmQ7XG52YXIgZmluZEluZGV4ID0gQXJyYXlJdGVyYXRpb25Nb2R1bGUuZmluZEluZGV4O1xudmFyIGlkID0gMDtcbnZhciB1bmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKHN0b3JlKSB7XG4gcmV0dXJuIHN0b3JlLmZyb3plbiB8fCAoc3RvcmUuZnJvemVuID0gbmV3IFVuY2F1Z2h0RnJvemVuU3RvcmUoKSk7XG59O1xudmFyIFVuY2F1Z2h0RnJvemVuU3RvcmUgPSBmdW5jdGlvbiAoKSB7XG4gdGhpcy5lbnRyaWVzID0gW107XG59O1xudmFyIGZpbmRVbmNhdWdodEZyb3plbiA9IGZ1bmN0aW9uIChzdG9yZSwga2V5KSB7XG4gcmV0dXJuIGZpbmQoc3RvcmUuZW50cmllcywgZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdFswXSA9PT0ga2V5O1xuIH0pO1xufTtcblVuY2F1Z2h0RnJvemVuU3RvcmUucHJvdG90eXBlID0ge1xuIGdldDogZnVuY3Rpb24gKGtleSkge1xuICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgaWYgKGVudHJ5KVxuICAgcmV0dXJuIGVudHJ5WzFdO1xuIH0sXG4gaGFzOiBmdW5jdGlvbiAoa2V5KSB7XG4gIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuIH0sXG4gc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB2YXIgZW50cnkgPSBmaW5kVW5jYXVnaHRGcm96ZW4odGhpcywga2V5KTtcbiAgaWYgKGVudHJ5KVxuICAgZW50cnlbMV0gPSB2YWx1ZTtcbiAgZWxzZVxuICAgdGhpcy5lbnRyaWVzLnB1c2goW1xuICAgIGtleSxcbiAgICB2YWx1ZVxuICAgXSk7XG4gfSxcbiAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICB2YXIgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICB9KTtcbiAgaWYgKH5pbmRleClcbiAgIHRoaXMuZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICByZXR1cm4gISF+aW5kZXg7XG4gfVxufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICB2YXIgQyA9IHdyYXBwZXIoZnVuY3Rpb24gKHRoYXQsIGl0ZXJhYmxlKSB7XG4gICBhbkluc3RhbmNlKHRoYXQsIEMsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICBpZDogaWQrKyxcbiAgICBmcm96ZW46IHVuZGVmaW5lZFxuICAgfSk7XG4gICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKVxuICAgIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB0aGF0LCBJU19NQVApO1xuICB9KTtcbiAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lID0gZnVuY3Rpb24gKHRoYXQsIGtleSwgdmFsdWUpIHtcbiAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhhdCk7XG4gICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGFuT2JqZWN0KGtleSksIHRydWUpO1xuICAgaWYgKGRhdGEgPT09IHRydWUpXG4gICAgdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuc2V0KGtleSwgdmFsdWUpO1xuICAgZWxzZVxuICAgIGRhdGFbc3RhdGUuaWRdID0gdmFsdWU7XG4gICByZXR1cm4gdGhhdDtcbiAgfTtcbiAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICBpZiAoIWlzT2JqZWN0KGtleSkpXG4gICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpXG4gICAgIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKVsnZGVsZXRlJ10oa2V5KTtcbiAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHN0YXRlLmlkKSAmJiBkZWxldGUgZGF0YVtzdGF0ZS5pZF07XG4gICB9LFxuICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICBpZiAoIWlzT2JqZWN0KGtleSkpXG4gICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgZGF0YSA9IGdldFdlYWtEYXRhKGtleSk7XG4gICAgaWYgKGRhdGEgPT09IHRydWUpXG4gICAgIHJldHVybiB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5oYXMoa2V5KTtcbiAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHN0YXRlLmlkKTtcbiAgIH1cbiAgfSk7XG4gIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICBnZXQ6IGZ1bmN0aW9uIGdldChrZXkpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgIHZhciBkYXRhID0gZ2V0V2Vha0RhdGEoa2V5KTtcbiAgICAgaWYgKGRhdGEgPT09IHRydWUpXG4gICAgICByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuZ2V0KGtleSk7XG4gICAgIHJldHVybiBkYXRhID8gZGF0YVtzdGF0ZS5pZF0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgfSxcbiAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgfVxuICB9IDoge1xuICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgIH1cbiAgfSk7XG4gIHJldHVybiBDO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBiaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Mik7XG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Myk7XG52YXIgdG9MZW5ndGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1OSk7XG52YXIgcHVzaCA9IFtdLnB1c2g7XG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiB2YXIgSVNfTUFQID0gVFlQRSA9PSAxO1xuIHZhciBJU19GSUxURVIgPSBUWVBFID09IDI7XG4gdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gdmFyIElTX0VWRVJZID0gVFlQRSA9PSA0O1xuIHZhciBJU19GSU5EX0lOREVYID0gVFlQRSA9PSA2O1xuIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ3JlYXRlKSB7XG4gIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChjYWxsYmFja2ZuLCB0aGF0LCAzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGNyZWF0ZSA9IHNwZWNpZmljQ3JlYXRlIHx8IGFycmF5U3BlY2llc0NyZWF0ZTtcbiAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gIHZhciB2YWx1ZSwgcmVzdWx0O1xuICBmb3IgKDsgbGVuZ3RoID4gaW5kZXg7IGluZGV4KyspXG4gICBpZiAoTk9fSE9MRVMgfHwgaW5kZXggaW4gc2VsZikge1xuICAgIHZhbHVlID0gc2VsZltpbmRleF07XG4gICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgIGlmIChUWVBFKSB7XG4gICAgIGlmIChJU19NQVApXG4gICAgICB0YXJnZXRbaW5kZXhdID0gcmVzdWx0O1xuICAgICBlbHNlIGlmIChyZXN1bHQpXG4gICAgICBzd2l0Y2ggKFRZUEUpIHtcbiAgICAgIGNhc2UgMzpcbiAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICBjYXNlIDY6XG4gICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgY2FzZSAyOlxuICAgICAgIHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgZWxzZSBpZiAoSVNfRVZFUlkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgfVxuICByZXR1cm4gSVNfRklORF9JTkRFWCA/IC0xIDogSVNfU09NRSB8fCBJU19FVkVSWSA/IElTX0VWRVJZIDogdGFyZ2V0O1xuIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuIG1hcDogY3JlYXRlTWV0aG9kKDEpLFxuIGZpbHRlcjogY3JlYXRlTWV0aG9kKDIpLFxuIHNvbWU6IGNyZWF0ZU1ldGhvZCgzKSxcbiBldmVyeTogY3JlYXRlTWV0aG9kKDQpLFxuIGZpbmQ6IGNyZWF0ZU1ldGhvZCg1KSxcbiBmaW5kSW5kZXg6IGNyZWF0ZU1ldGhvZCg2KVxufTtcblxuLyoqKi8gfSksXG4vKiAxNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMik7XG52YXIgaXNBcnJheSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYwKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU3KTtcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcmlnaW5hbEFycmF5LCBsZW5ndGgpIHtcbiB2YXIgQztcbiBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICBDID0gb3JpZ2luYWxBcnJheS5jb25zdHJ1Y3RvcjtcbiAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSlcbiAgIEMgPSB1bmRlZmluZWQ7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KEMpKSB7XG4gICBDID0gQ1tTUEVDSUVTXTtcbiAgIGlmIChDID09PSBudWxsKVxuICAgIEMgPSB1bmRlZmluZWQ7XG4gIH1cbiB9XG4gcmV0dXJuIG5ldyAoQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTYwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBjbGFzc29mID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiByZXR1cm4gY2xhc3NvZihhcmcpID09ICdBcnJheSc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDExOCk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE2Mik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMCk7XG52YXIgcGF0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDMpO1xubW9kdWxlLmV4cG9ydHMgPSBwYXRoLldlYWtTZXQ7XG5cbi8qKiovIH0pLFxuLyogMTYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgY29sbGVjdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQ4KTtcbnZhciBjb2xsZWN0aW9uV2VhayA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU3KTtcbmNvbGxlY3Rpb24oJ1dlYWtTZXQnLCBmdW5jdGlvbiAoaW5pdCkge1xuIHJldHVybiBmdW5jdGlvbiBXZWFrU2V0KCkge1xuICByZXR1cm4gaW5pdCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTtcbiB9O1xufSwgY29sbGVjdGlvbldlYWspO1xuXG4vKioqLyB9KSxcbi8qIDE2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDE2NCk7XG52YXIgZW50cnlVbmJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYxKTtcbm1vZHVsZS5leHBvcnRzID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdjb2RlUG9pbnRBdCcpO1xuXG4vKioqLyB9KSxcbi8qIDE2NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciBjb2RlQXQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc4KS5jb2RlQXQ7XG4kKHtcbiB0YXJnZXQ6ICdTdHJpbmcnLFxuIHByb3RvOiB0cnVlXG59LCB7XG4gY29kZVBvaW50QXQ6IGZ1bmN0aW9uIGNvZGVQb2ludEF0KHBvcykge1xuICByZXR1cm4gY29kZUF0KHRoaXMsIHBvcyk7XG4gfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMTY1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTY2KTtcbnZhciBwYXRoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Myk7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG5cbi8qKiovIH0pLFxuLyogMTY2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0OSk7XG52YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbnZhciBuYXRpdmVGcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnQ7XG52YXIgSU5DT1JSRUNUX0xFTkdUSCA9ICEhbmF0aXZlRnJvbUNvZGVQb2ludCAmJiBuYXRpdmVGcm9tQ29kZVBvaW50Lmxlbmd0aCAhPSAxO1xuJCh7XG4gdGFyZ2V0OiAnU3RyaW5nJyxcbiBzdGF0OiB0cnVlLFxuIGZvcmNlZDogSU5DT1JSRUNUX0xFTkdUSFxufSwge1xuIGZyb21Db2RlUG9pbnQ6IGZ1bmN0aW9uIGZyb21Db2RlUG9pbnQoeCkge1xuICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpID0gMDtcbiAgdmFyIGNvZGU7XG4gIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICBjb2RlID0gK2FyZ3VtZW50c1tpKytdO1xuICAgaWYgKHRvQWJzb2x1dGVJbmRleChjb2RlLCAweDEwRkZGRikgIT09IGNvZGUpXG4gICAgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICBlbGVtZW50cy5wdXNoKGNvZGUgPCAweDEwMDAwID8gZnJvbUNoYXJDb2RlKGNvZGUpIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsIGNvZGUgJSAweDQwMCArIDB4REMwMCkpO1xuICB9XG4gIHJldHVybiBlbGVtZW50cy5qb2luKCcnKTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXygxNjgpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMTgpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNzApO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNzQpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNzUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNzYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNzcpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNzgpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNzkpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODApO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODEpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODIpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODQpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODcpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODgpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxODkpO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5TeW1ib2w7XG5cbi8qKiovIH0pLFxuLyogMTY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgaXNBcnJheSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYwKTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Myk7XG52YXIgdG9MZW5ndGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oOTMpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU5KTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjkpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTcpO1xudmFyIFY4X1ZFUlNJT04gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzNSk7XG52YXIgSVNfQ09OQ0FUX1NQUkVBREFCTEUgPSB3ZWxsS25vd25TeW1ib2woJ2lzQ29uY2F0U3ByZWFkYWJsZScpO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCA9ICdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnO1xudmFyIElTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgPSBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gdmFyIGFycmF5ID0gW107XG4gYXJyYXlbSVNfQ09OQ0FUX1NQUkVBREFCTEVdID0gZmFsc2U7XG4gcmV0dXJuIGFycmF5LmNvbmNhdCgpWzBdICE9PSBhcnJheTtcbn0pO1xudmFyIFNQRUNJRVNfU1VQUE9SVCA9IGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQoJ2NvbmNhdCcpO1xudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gaWYgKCFpc09iamVjdChPKSlcbiAgcmV0dXJuIGZhbHNlO1xuIHZhciBzcHJlYWRhYmxlID0gT1tJU19DT05DQVRfU1BSRUFEQUJMRV07XG4gcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoTyk7XG59O1xudmFyIEZPUkNFRCA9ICFJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUIHx8ICFTUEVDSUVTX1NVUFBPUlQ7XG4kKHtcbiB0YXJnZXQ6ICdBcnJheScsXG4gcHJvdG86IHRydWUsXG4gZm9yY2VkOiBGT1JDRURcbn0sIHtcbiBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gIHZhciBuID0gMDtcbiAgdmFyIGksIGssIGxlbmd0aCwgbGVuLCBFO1xuICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICBFID0gaSA9PT0gLTEgPyBPIDogYXJndW1lbnRzW2ldO1xuICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgIGxlbiA9IHRvTGVuZ3RoKEUubGVuZ3RoKTtcbiAgICBpZiAobiArIGxlbiA+IE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKVxuICAgICBpZiAoayBpbiBFKVxuICAgICAgY3JlYXRlUHJvcGVydHkoQSwgbiwgRVtrXSk7XG4gICB9IGVsc2Uge1xuICAgIGlmIChuID49IE1BWF9TQUZFX0lOVEVHRVIpXG4gICAgIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgIGNyZWF0ZVByb3BlcnR5KEEsIG4rKywgRSk7XG4gICB9XG4gIH1cbiAgQS5sZW5ndGggPSBuO1xuICByZXR1cm4gQTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxNjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgVjhfVkVSU0lPTiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTM1KTtcbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuIHJldHVybiBWOF9WRVJTSU9OID49IDUxIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnJheSA9IFtdO1xuICB2YXIgY29uc3RydWN0b3IgPSBhcnJheS5jb25zdHJ1Y3RvciA9IHt9O1xuICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB7IGZvbzogMSB9O1xuICB9O1xuICByZXR1cm4gYXJyYXlbTUVUSE9EX05BTUVdKEJvb2xlYW4pLmZvbyAhPT0gMTtcbiB9KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTcwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQyKTtcbnZhciBJU19QVVJFID0gX193X3BkZmpzX3JlcXVpcmVfXygzNyk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciBOQVRJVkVfU1lNQk9MID0gX193X3BkZmpzX3JlcXVpcmVfXyg1OCk7XG52YXIgVVNFX1NZTUJPTF9BU19VSUQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU5KTtcbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIGlzQXJyYXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2MCk7XG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Myk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNyk7XG52YXIgdG9QcmltaXRpdmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2KTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcxKTtcbnZhciBvYmplY3RLZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Myk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc01vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNDQpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcxKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUxKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjcpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxNSk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyNik7XG52YXIgcmVkZWZpbmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciBzaGFyZWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM2KTtcbnZhciBzaGFyZWRLZXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM1KTtcbnZhciBoaWRkZW5LZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXygzOSk7XG52YXIgdWlkID0gX193X3BkZmpzX3JlcXVpcmVfXygzOCk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nyk7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcyKTtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Myk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg1KTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMyk7XG52YXIgJGZvckVhY2ggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1OCkuZm9yRWFjaDtcbnZhciBISURERU4gPSBzaGFyZWRLZXkoJ2hpZGRlbicpO1xudmFyIFNZTUJPTCA9ICdTeW1ib2wnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFRPX1BSSU1JVElWRSA9IHdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNZTUJPTCk7XG52YXIgT2JqZWN0UHJvdG90eXBlID0gT2JqZWN0W1BST1RPVFlQRV07XG52YXIgJFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgJHN0cmluZ2lmeSA9IGdldEJ1aWx0SW4oJ0pTT04nLCAnc3RyaW5naWZ5Jyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjtcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvdHlwZVN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xudmFyIFVTRV9TRVRURVIgPSAhUU9iamVjdCB8fCAhUU9iamVjdFtQUk9UT1RZUEVdIHx8ICFRT2JqZWN0W1BST1RPVFlQRV0uZmluZENoaWxkO1xudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIG5hdGl2ZU9iamVjdENyZWF0ZShuYXRpdmVEZWZpbmVQcm9wZXJ0eSh7fSwgJ2EnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoaXMsICdhJywgeyB2YWx1ZTogNyB9KS5hO1xuICB9XG4gfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiB2YXIgT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIFApO1xuIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yKVxuICBkZWxldGUgT2JqZWN0UHJvdG90eXBlW1BdO1xuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuIGlmIChPYmplY3RQcm90b3R5cGVEZXNjcmlwdG9yICYmIE8gIT09IE9iamVjdFByb3RvdHlwZSkge1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGUsIFAsIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuIH1cbn0gOiBuYXRpdmVEZWZpbmVQcm9wZXJ0eTtcbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiB2YXIgc3ltYm9sID0gQWxsU3ltYm9sc1t0YWddID0gbmF0aXZlT2JqZWN0Q3JlYXRlKCRTeW1ib2xbUFJPVE9UWVBFXSk7XG4gc2V0SW50ZXJuYWxTdGF0ZShzeW1ib2wsIHtcbiAgdHlwZTogU1lNQk9MLFxuICB0YWc6IHRhZyxcbiAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uXG4gfSk7XG4gaWYgKCFERVNDUklQVE9SUylcbiAgc3ltYm9sLmRlc2NyaXB0aW9uID0gZGVzY3JpcHRpb247XG4gcmV0dXJuIHN5bWJvbDtcbn07XG52YXIgaXNTeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiB0eXBlb2YgaXQgPT0gJ3N5bWJvbCc7XG59IDogZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIE9iamVjdChpdCkgaW5zdGFuY2VvZiAkU3ltYm9sO1xufTtcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gaWYgKE8gPT09IE9iamVjdFByb3RvdHlwZSlcbiAgJGRlZmluZVByb3BlcnR5KE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIFAsIEF0dHJpYnV0ZXMpO1xuIGFuT2JqZWN0KE8pO1xuIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgaWYgKCFBdHRyaWJ1dGVzLmVudW1lcmFibGUpIHtcbiAgIGlmICghaGFzKE8sIEhJRERFTikpXG4gICAgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgIGlmIChoYXMoTywgSElEREVOKSAmJiBPW0hJRERFTl1ba2V5XSlcbiAgICBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gIH1cbiAgcmV0dXJuIHNldFN5bWJvbERlc2NyaXB0b3IoTywga2V5LCBBdHRyaWJ1dGVzKTtcbiB9XG4gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIGtleSwgQXR0cmlidXRlcyk7XG59O1xudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gYW5PYmplY3QoTyk7XG4gdmFyIHByb3BlcnRpZXMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7XG4gdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAkZm9yRWFjaChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICghREVTQ1JJUFRPUlMgfHwgJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocHJvcGVydGllcywga2V5KSlcbiAgICRkZWZpbmVQcm9wZXJ0eShPLCBrZXksIHByb3BlcnRpZXNba2V5XSk7XG4gfSk7XG4gcmV0dXJuIE87XG59O1xudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyBuYXRpdmVPYmplY3RDcmVhdGUoTykgOiAkZGVmaW5lUHJvcGVydGllcyhuYXRpdmVPYmplY3RDcmVhdGUoTyksIFByb3BlcnRpZXMpO1xufTtcbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gdmFyIFAgPSB0b1ByaW1pdGl2ZShWLCB0cnVlKTtcbiB2YXIgZW51bWVyYWJsZSA9IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwodGhpcywgUCk7XG4gaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywgUCkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQKSlcbiAgcmV0dXJuIGZhbHNlO1xuIHJldHVybiBlbnVtZXJhYmxlIHx8ICFoYXModGhpcywgUCkgfHwgIWhhcyhBbGxTeW1ib2xzLCBQKSB8fCBoYXModGhpcywgSElEREVOKSAmJiB0aGlzW0hJRERFTl1bUF0gPyBlbnVtZXJhYmxlIDogdHJ1ZTtcbn07XG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gdmFyIGl0ID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpXG4gIHJldHVybjtcbiB2YXIgZGVzY3JpcHRvciA9IG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihpdCwga2V5KTtcbiBpZiAoZGVzY3JpcHRvciAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhKGhhcyhpdCwgSElEREVOKSAmJiBpdFtISURERU5dW2tleV0pKSB7XG4gIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IHRydWU7XG4gfVxuIHJldHVybiBkZXNjcmlwdG9yO1xufTtcbnZhciAkZ2V0T3duUHJvcGVydHlOYW1lcyA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoTykge1xuIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KE8pKTtcbiB2YXIgcmVzdWx0ID0gW107XG4gJGZvckVhY2gobmFtZXMsIGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKCFoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKGhpZGRlbktleXMsIGtleSkpXG4gICByZXN1bHQucHVzaChrZXkpO1xuIH0pO1xuIHJldHVybiByZXN1bHQ7XG59O1xudmFyICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoTykge1xuIHZhciBJU19PQkpFQ1RfUFJPVE9UWVBFID0gTyA9PT0gT2JqZWN0UHJvdG90eXBlO1xuIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuIHZhciByZXN1bHQgPSBbXTtcbiAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgKCFJU19PQkpFQ1RfUFJPVE9UWVBFIHx8IGhhcyhPYmplY3RQcm90b3R5cGUsIGtleSkpKSB7XG4gICByZXN1bHQucHVzaChBbGxTeW1ib2xzW2tleV0pO1xuICB9XG4gfSk7XG4gcmV0dXJuIHJlc3VsdDtcbn07XG5pZiAoIU5BVElWRV9TWU1CT0wpIHtcbiAkU3ltYm9sID0gZnVuY3Rpb24gU3ltYm9sKCkge1xuICBpZiAodGhpcyBpbnN0YW5jZW9mICRTeW1ib2wpXG4gICB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICB2YXIgZGVzY3JpcHRpb24gPSAhYXJndW1lbnRzLmxlbmd0aCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFN0cmluZyhhcmd1bWVudHNbMF0pO1xuICB2YXIgdGFnID0gdWlkKGRlc2NyaXB0aW9uKTtcbiAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSlcbiAgICBzZXR0ZXIuY2FsbChPYmplY3RQcm90b3R5cGVTeW1ib2xzLCB2YWx1ZSk7XG4gICBpZiAoaGFzKHRoaXMsIEhJRERFTikgJiYgaGFzKHRoaXNbSElEREVOXSwgdGFnKSlcbiAgICB0aGlzW0hJRERFTl1bdGFnXSA9IGZhbHNlO1xuICAgc2V0U3ltYm9sRGVzY3JpcHRvcih0aGlzLCB0YWcsIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigxLCB2YWx1ZSkpO1xuICB9O1xuICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUilcbiAgIHNldFN5bWJvbERlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlLCB0YWcsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXR0ZXJcbiAgIH0pO1xuICByZXR1cm4gd3JhcCh0YWcsIGRlc2NyaXB0aW9uKTtcbiB9O1xuIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLnRhZztcbiB9KTtcbiByZWRlZmluZSgkU3ltYm9sLCAnd2l0aG91dFNldHRlcicsIGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICByZXR1cm4gd3JhcCh1aWQoZGVzY3JpcHRpb24pLCBkZXNjcmlwdGlvbik7XG4gfSk7XG4gcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUuZiA9ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcbiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbiBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZiA9ICRnZXRPd25Qcm9wZXJ0eU5hbWVzO1xuIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcbiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gd3JhcCh3ZWxsS25vd25TeW1ib2wobmFtZSksIG5hbWUpO1xuIH07XG4gaWYgKERFU0NSSVBUT1JTKSB7XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgJ2Rlc2NyaXB0aW9uJywge1xuICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKS5kZXNjcmlwdGlvbjtcbiAgIH1cbiAgfSk7XG4gIGlmICghSVNfUFVSRSkge1xuICAgcmVkZWZpbmUoT2JqZWN0UHJvdG90eXBlLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICB9XG4gfVxufVxuJCh7XG4gZ2xvYmFsOiB0cnVlLFxuIHdyYXA6IHRydWUsXG4gZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCxcbiBzaGFtOiAhTkFUSVZFX1NZTUJPTFxufSwgeyBTeW1ib2w6ICRTeW1ib2wgfSk7XG4kZm9yRWFjaChvYmplY3RLZXlzKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gZGVmaW5lV2VsbEtub3duU3ltYm9sKG5hbWUpO1xufSk7XG4kKHtcbiB0YXJnZXQ6IFNZTUJPTCxcbiBzdGF0OiB0cnVlLFxuIGZvcmNlZDogIU5BVElWRV9TWU1CT0xcbn0sIHtcbiAnZm9yJzogZnVuY3Rpb24gKGtleSkge1xuICB2YXIgc3RyaW5nID0gU3RyaW5nKGtleSk7XG4gIGlmIChoYXMoU3RyaW5nVG9TeW1ib2xSZWdpc3RyeSwgc3RyaW5nKSlcbiAgIHJldHVybiBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5W3N0cmluZ107XG4gIHZhciBzeW1ib2wgPSAkU3ltYm9sKHN0cmluZyk7XG4gIFN0cmluZ1RvU3ltYm9sUmVnaXN0cnlbc3RyaW5nXSA9IHN5bWJvbDtcbiAgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1ib2xdID0gc3RyaW5nO1xuICByZXR1cm4gc3ltYm9sO1xuIH0sXG4ga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gIGlmICghaXNTeW1ib2woc3ltKSlcbiAgIHRocm93IFR5cGVFcnJvcihzeW0gKyAnIGlzIG5vdCBhIHN5bWJvbCcpO1xuICBpZiAoaGFzKFN5bWJvbFRvU3RyaW5nUmVnaXN0cnksIHN5bSkpXG4gICByZXR1cm4gU3ltYm9sVG9TdHJpbmdSZWdpc3RyeVtzeW1dO1xuIH0sXG4gdXNlU2V0dGVyOiBmdW5jdGlvbiAoKSB7XG4gIFVTRV9TRVRURVIgPSB0cnVlO1xuIH0sXG4gdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7XG4gIFVTRV9TRVRURVIgPSBmYWxzZTtcbiB9XG59KTtcbiQoe1xuIHRhcmdldDogJ09iamVjdCcsXG4gc3RhdDogdHJ1ZSxcbiBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLFxuIHNoYW06ICFERVNDUklQVE9SU1xufSwge1xuIGNyZWF0ZTogJGNyZWF0ZSxcbiBkZWZpbmVQcm9wZXJ0eTogJGRlZmluZVByb3BlcnR5LFxuIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSk7XG4kKHtcbiB0YXJnZXQ6ICdPYmplY3QnLFxuIHN0YXQ6IHRydWUsXG4gZm9yY2VkOiAhTkFUSVZFX1NZTUJPTFxufSwge1xuIGdldE93blByb3BlcnR5TmFtZXM6ICRnZXRPd25Qcm9wZXJ0eU5hbWVzLFxuIGdldE93blByb3BlcnR5U3ltYm9sczogJGdldE93blByb3BlcnR5U3ltYm9sc1xufSk7XG4kKHtcbiB0YXJnZXQ6ICdPYmplY3QnLFxuIHN0YXQ6IHRydWUsXG4gZm9yY2VkOiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mKDEpO1xuIH0pXG59LCB7XG4gZ2V0T3duUHJvcGVydHlTeW1ib2xzOiBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpIHtcbiAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mKHRvT2JqZWN0KGl0KSk7XG4gfVxufSk7XG5pZiAoJHN0cmluZ2lmeSkge1xuIHZhciBGT1JDRURfSlNPTl9TVFJJTkdJRlkgPSAhTkFUSVZFX1NZTUJPTCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7XG4gIHJldHVybiAkc3RyaW5naWZ5KFtzeW1ib2xdKSAhPSAnW251bGxdJyB8fCAkc3RyaW5naWZ5KHsgYTogc3ltYm9sIH0pICE9ICd7fScgfHwgJHN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9JztcbiB9KTtcbiAkKHtcbiAgdGFyZ2V0OiAnSlNPTicsXG4gIHN0YXQ6IHRydWUsXG4gIGZvcmNlZDogRk9SQ0VEX0pTT05fU1RSSU5HSUZZXG4gfSwge1xuICBzdHJpbmdpZnk6IGZ1bmN0aW9uIHN0cmluZ2lmeShpdCwgcmVwbGFjZXIsIHNwYWNlKSB7XG4gICB2YXIgYXJncyA9IFtpdF07XG4gICB2YXIgaW5kZXggPSAxO1xuICAgdmFyICRyZXBsYWNlcjtcbiAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaW5kZXgpXG4gICAgYXJncy5wdXNoKGFyZ3VtZW50c1tpbmRleCsrXSk7XG4gICAkcmVwbGFjZXIgPSByZXBsYWNlcjtcbiAgIGlmICghaXNPYmplY3QocmVwbGFjZXIpICYmIGl0ID09PSB1bmRlZmluZWQgfHwgaXNTeW1ib2woaXQpKVxuICAgIHJldHVybjtcbiAgIGlmICghaXNBcnJheShyZXBsYWNlcikpXG4gICAgcmVwbGFjZXIgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICBpZiAodHlwZW9mICRyZXBsYWNlciA9PSAnZnVuY3Rpb24nKVxuICAgICAgdmFsdWUgPSAkcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgaWYgKCFpc1N5bWJvbCh2YWx1ZSkpXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgIGFyZ3NbMV0gPSByZXBsYWNlcjtcbiAgIHJldHVybiAkc3RyaW5naWZ5LmFwcGx5KG51bGwsIGFyZ3MpO1xuICB9XG4gfSk7XG59XG5pZiAoISRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdKSB7XG4gY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG59XG5zZXRUb1N0cmluZ1RhZygkU3ltYm9sLCBTWU1CT0wpO1xuaGlkZGVuS2V5c1tISURERU5dID0gdHJ1ZTtcblxuLyoqKi8gfSksXG4vKiAxNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ0KS5mO1xudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG52YXIgd2luZG93TmFtZXMgPSB0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHdpbmRvdykgOiBbXTtcbnZhciBnZXRXaW5kb3dOYW1lcyA9IGZ1bmN0aW9uIChpdCkge1xuIHRyeSB7XG4gIHJldHVybiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KTtcbiB9IGNhdGNoIChlcnJvcikge1xuICByZXR1cm4gd2luZG93TmFtZXMuc2xpY2UoKTtcbiB9XG59O1xubW9kdWxlLmV4cG9ydHMuZiA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5TmFtZXMoaXQpIHtcbiByZXR1cm4gd2luZG93TmFtZXMgJiYgdG9TdHJpbmcuY2FsbChpdCkgPT0gJ1tvYmplY3QgV2luZG93XScgPyBnZXRXaW5kb3dOYW1lcyhpdCkgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNTcpO1xuZXhwb3J0cy5mID0gd2VsbEtub3duU3ltYm9sO1xuXG4vKioqLyB9KSxcbi8qIDE3MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgcGF0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDMpO1xudmFyIGhhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjMpO1xudmFyIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Mik7XG52YXIgZGVmaW5lUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KS5mO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTkFNRSkge1xuIHZhciBTeW1ib2wgPSBwYXRoLlN5bWJvbCB8fCAocGF0aC5TeW1ib2wgPSB7fSk7XG4gaWYgKCFoYXMoU3ltYm9sLCBOQU1FKSlcbiAgZGVmaW5lUHJvcGVydHkoU3ltYm9sLCBOQU1FLCB7IHZhbHVlOiB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlLmYoTkFNRSkgfSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE3NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXygxNzMpO1xuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdhc3luY0l0ZXJhdG9yJyk7XG5cbi8qKiovIH0pLFxuLyogMTc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgaGFzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjcpLmY7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd19wZGZqc19yZXF1aXJlX18oNDApO1xudmFyIE5hdGl2ZVN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG5pZiAoREVTQ1JJUFRPUlMgJiYgdHlwZW9mIE5hdGl2ZVN5bWJvbCA9PSAnZnVuY3Rpb24nICYmICghKCdkZXNjcmlwdGlvbicgaW4gTmF0aXZlU3ltYm9sLnByb3RvdHlwZSkgfHwgTmF0aXZlU3ltYm9sKCkuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZCkpIHtcbiB2YXIgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlID0ge307XG4gdmFyIFN5bWJvbFdyYXBwZXIgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gIHZhciBkZXNjcmlwdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAxIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gIHZhciByZXN1bHQgPSB0aGlzIGluc3RhbmNlb2YgU3ltYm9sV3JhcHBlciA/IG5ldyBOYXRpdmVTeW1ib2woZGVzY3JpcHRpb24pIDogZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IE5hdGl2ZVN5bWJvbCgpIDogTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgaWYgKGRlc2NyaXB0aW9uID09PSAnJylcbiAgIEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZVtyZXN1bHRdID0gdHJ1ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbiB9O1xuIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoU3ltYm9sV3JhcHBlciwgTmF0aXZlU3ltYm9sKTtcbiB2YXIgc3ltYm9sUHJvdG90eXBlID0gU3ltYm9sV3JhcHBlci5wcm90b3R5cGUgPSBOYXRpdmVTeW1ib2wucHJvdG90eXBlO1xuIHN5bWJvbFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFN5bWJvbFdyYXBwZXI7XG4gdmFyIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG90eXBlLnRvU3RyaW5nO1xuIHZhciBuYXRpdmUgPSBTdHJpbmcoTmF0aXZlU3ltYm9sKCd0ZXN0JykpID09ICdTeW1ib2wodGVzdCknO1xuIHZhciByZWdleHAgPSAvXlN5bWJvbFxcKCguKilcXClbXildKyQvO1xuIGRlZmluZVByb3BlcnR5KHN5bWJvbFByb3RvdHlwZSwgJ2Rlc2NyaXB0aW9uJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICB2YXIgc3ltYm9sID0gaXNPYmplY3QodGhpcykgPyB0aGlzLnZhbHVlT2YoKSA6IHRoaXM7XG4gICB2YXIgc3RyaW5nID0gc3ltYm9sVG9TdHJpbmcuY2FsbChzeW1ib2wpO1xuICAgaWYgKGhhcyhFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmUsIHN5bWJvbCkpXG4gICAgcmV0dXJuICcnO1xuICAgdmFyIGRlc2MgPSBuYXRpdmUgPyBzdHJpbmcuc2xpY2UoNywgLTEpIDogc3RyaW5nLnJlcGxhY2UocmVnZXhwLCAnJDEnKTtcbiAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gIH1cbiB9KTtcbiAkKHtcbiAgZ2xvYmFsOiB0cnVlLFxuICBmb3JjZWQ6IHRydWVcbiB9LCB7IFN5bWJvbDogU3ltYm9sV3JhcHBlciB9KTtcbn1cblxuLyoqKi8gfSksXG4vKiAxNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTczKTtcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaGFzSW5zdGFuY2UnKTtcblxuLyoqKi8gfSksXG4vKiAxNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTczKTtcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG5cbi8qKiovIH0pLFxuLyogMTc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Myk7XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbi8qKiovIH0pLFxuLyogMTc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Myk7XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG5cbi8qKiovIH0pLFxuLyogMTgwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Myk7XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ21hdGNoQWxsJyk7XG5cbi8qKiovIH0pLFxuLyogMTgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Myk7XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3JlcGxhY2UnKTtcblxuLyoqKi8gfSksXG4vKiAxODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTczKTtcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnc2VhcmNoJyk7XG5cbi8qKiovIH0pLFxuLyogMTgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Myk7XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuLyoqKi8gfSksXG4vKiAxODQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTczKTtcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnc3BsaXQnKTtcblxuLyoqKi8gfSksXG4vKiAxODUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTczKTtcbmRlZmluZVdlbGxLbm93blN5bWJvbCgndG9QcmltaXRpdmUnKTtcblxuLyoqKi8gfSksXG4vKiAxODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTczKTtcbmRlZmluZVdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxuLyoqKi8gfSksXG4vKiAxODcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIGRlZmluZVdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTczKTtcbmRlZmluZVdlbGxLbm93blN5bWJvbCgndW5zY29wYWJsZXMnKTtcblxuLyoqKi8gfSksXG4vKiAxODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIHNldFRvU3RyaW5nVGFnID0gX193X3BkZmpzX3JlcXVpcmVfXyg4NSk7XG5zZXRUb1N0cmluZ1RhZyhNYXRoLCAnTWF0aCcsIHRydWUpO1xuXG4vKioqLyB9KSxcbi8qIDE4OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg1KTtcbnNldFRvU3RyaW5nVGFnKGdsb2JhbC5KU09OLCAnSlNPTicsIHRydWUpO1xuXG4vKioqLyB9KSxcbi8qIDE5MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5fX3dfcGRmanNfcmVxdWlyZV9fKDE5MSk7XG52YXIgZW50cnlVbmJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYxKTtcbm1vZHVsZS5leHBvcnRzID0gZW50cnlVbmJpbmQoJ1N0cmluZycsICdwYWRTdGFydCcpO1xuXG4vKioqLyB9KSxcbi8qIDE5MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcbnZhciAkcGFkU3RhcnQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5Mikuc3RhcnQ7XG52YXIgV0VCS0lUX0JVRyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTk0KTtcbiQoe1xuIHRhcmdldDogJ1N0cmluZycsXG4gcHJvdG86IHRydWUsXG4gZm9yY2VkOiBXRUJLSVRfQlVHXG59LCB7XG4gcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCkge1xuICByZXR1cm4gJHBhZFN0YXJ0KHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE5MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgdG9MZW5ndGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciByZXBlYXQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5Myk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0VORCkge1xuIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIG1heExlbmd0aCwgZmlsbFN0cmluZykge1xuICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gIHZhciBzdHJpbmdMZW5ndGggPSBTLmxlbmd0aDtcbiAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gIHZhciBpbnRNYXhMZW5ndGggPSB0b0xlbmd0aChtYXhMZW5ndGgpO1xuICB2YXIgZmlsbExlbiwgc3RyaW5nRmlsbGVyO1xuICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKVxuICAgcmV0dXJuIFM7XG4gIGZpbGxMZW4gPSBpbnRNYXhMZW5ndGggLSBzdHJpbmdMZW5ndGg7XG4gIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIGNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gIGlmIChzdHJpbmdGaWxsZXIubGVuZ3RoID4gZmlsbExlbilcbiAgIHN0cmluZ0ZpbGxlciA9IHN0cmluZ0ZpbGxlci5zbGljZSgwLCBmaWxsTGVuKTtcbiAgcmV0dXJuIElTX0VORCA/IFMgKyBzdHJpbmdGaWxsZXIgOiBzdHJpbmdGaWxsZXIgKyBTO1xuIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gc3RhcnQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gZW5kOiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG5cbi8qKiovIH0pLFxuLyogMTkzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgdG9JbnRlZ2VyID0gX193X3BkZmpzX3JlcXVpcmVfXyg0OCk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xubW9kdWxlLmV4cG9ydHMgPSAnJy5yZXBlYXQgfHwgZnVuY3Rpb24gcmVwZWF0KGNvdW50KSB7XG4gdmFyIHN0ciA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKTtcbiB2YXIgcmVzdWx0ID0gJyc7XG4gdmFyIG4gPSB0b0ludGVnZXIoY291bnQpO1xuIGlmIChuIDwgMCB8fCBuID09IEluZmluaXR5KVxuICB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBudW1iZXIgb2YgcmVwZXRpdGlvbnMnKTtcbiBmb3IgKDsgbiA+IDA7IChuID4+Pj0gMSkgJiYgKHN0ciArPSBzdHIpKVxuICBpZiAobiAmIDEpXG4gICByZXN1bHQgKz0gc3RyO1xuIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE5NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgdXNlckFnZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjkpO1xubW9kdWxlLmV4cG9ydHMgPSAvVmVyc2lvblxcLzEwXFwuXFxkKyhcXC5cXGQrKT8oIE1vYmlsZVxcL1xcdyspPyBTYWZhcmlcXC8vLnRlc3QodXNlckFnZW50KTtcblxuLyoqKi8gfSksXG4vKiAxOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXygxOTYpO1xudmFyIGVudHJ5VW5iaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg2MSk7XG5tb2R1bGUuZXhwb3J0cyA9IGVudHJ5VW5iaW5kKCdTdHJpbmcnLCAncGFkRW5kJyk7XG5cbi8qKiovIH0pLFxuLyogMTk2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyICRwYWRFbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5MikuZW5kO1xudmFyIFdFQktJVF9CVUcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5NCk7XG4kKHtcbiB0YXJnZXQ6ICdTdHJpbmcnLFxuIHByb3RvOiB0cnVlLFxuIGZvcmNlZDogV0VCS0lUX0JVR1xufSwge1xuIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCkge1xuICByZXR1cm4gJHBhZEVuZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxOTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuX193X3BkZmpzX3JlcXVpcmVfXygxOTgpO1xudmFyIHBhdGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbm1vZHVsZS5leHBvcnRzID0gcGF0aC5PYmplY3QudmFsdWVzO1xuXG4vKioqLyB9KSxcbi8qIDE5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyICR2YWx1ZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5OSkudmFsdWVzO1xuJCh7XG4gdGFyZ2V0OiAnT2JqZWN0JyxcbiBzdGF0OiB0cnVlXG59LCB7XG4gdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoTykge1xuICByZXR1cm4gJHZhbHVlcyhPKTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXygxMyk7XG52YXIgb2JqZWN0S2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNzMpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcpO1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxNSkuZjtcbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVE9fRU5UUklFUykge1xuIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoaXQpO1xuICB2YXIga2V5cyA9IG9iamVjdEtleXMoTyk7XG4gIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIHdoaWxlIChsZW5ndGggPiBpKSB7XG4gICBrZXkgPSBrZXlzW2krK107XG4gICBpZiAoIURFU0NSSVBUT1JTIHx8IHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoTywga2V5KSkge1xuICAgIHJlc3VsdC5wdXNoKFRPX0VOVFJJRVMgPyBbXG4gICAgIGtleSxcbiAgICAgT1trZXldXG4gICAgXSA6IE9ba2V5XSk7XG4gICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbiB9O1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuIGVudHJpZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiB2YWx1ZXM6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG5cbi8qKiovIH0pLFxuLyogMjAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMjAxKTtcbnZhciBwYXRoID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Myk7XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGguT2JqZWN0LmVudHJpZXM7XG5cbi8qKiovIH0pLFxuLyogMjAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygxMCk7XG52YXIgJGVudHJpZXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5OSkuZW50cmllcztcbiQoe1xuIHRhcmdldDogJ09iamVjdCcsXG4gc3RhdDogdHJ1ZVxufSwge1xuIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoTykge1xuICByZXR1cm4gJGVudHJpZXMoTyk7XG4gfVxufSk7XG5cbi8qKiovIH0pLFxuLyogMjAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmdldERvY3VtZW50ID0gZ2V0RG9jdW1lbnQ7XG5leHBvcnRzLnNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5ID0gc2V0UERGTmV0d29ya1N0cmVhbUZhY3Rvcnk7XG5leHBvcnRzLmJ1aWxkID0gZXhwb3J0cy52ZXJzaW9uID0gZXhwb3J0cy5QREZQYWdlUHJveHkgPSBleHBvcnRzLlBERkRvY3VtZW50UHJveHkgPSBleHBvcnRzLlBERldvcmtlciA9IGV4cG9ydHMuUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gZXhwb3J0cy5Mb29wYmFja1BvcnQgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd19wZGZqc19yZXF1aXJlX18oMikpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX2ZvbnRfbG9hZGVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyMDMpO1xuXG52YXIgX25vZGVfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwNCk7XG5cbnZhciBfYW5ub3RhdGlvbl9zdG9yYWdlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMDUpO1xuXG52YXIgX2FwaV9jb21wYXRpYmlsaXR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMDYpO1xuXG52YXIgX2NhbnZhcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjA3KTtcblxudmFyIF93b3JrZXJfb3B0aW9ucyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjA5KTtcblxudmFyIF9pc19ub2RlID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcblxudmFyIF9tZXNzYWdlX2hhbmRsZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxMCk7XG5cbnZhciBfbWV0YWRhdGEgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxMSk7XG5cbnZhciBfb3B0aW9uYWxfY29udGVudF9jb25maWcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxMyk7XG5cbnZhciBfdHJhbnNwb3J0X3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjE0KTtcblxudmFyIF93ZWJnbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjE1KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7IGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoaXRlcikpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KGFycik7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyB0aHJvdyBfZTI7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UzKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMzsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbnZhciBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkUgPSA2NTUzNjtcbnZhciBSRU5ERVJJTkdfQ0FOQ0VMTEVEX1RJTUVPVVQgPSAxMDA7XG52YXIgRGVmYXVsdENhbnZhc0ZhY3RvcnkgPSBfaXNfbm9kZS5pc05vZGVKUyA/IF9ub2RlX3V0aWxzLk5vZGVDYW52YXNGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NQ2FudmFzRmFjdG9yeTtcbnZhciBEZWZhdWx0Q01hcFJlYWRlckZhY3RvcnkgPSBfaXNfbm9kZS5pc05vZGVKUyA/IF9ub2RlX3V0aWxzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA6IF9kaXNwbGF5X3V0aWxzLkRPTUNNYXBSZWFkZXJGYWN0b3J5O1xudmFyIGNyZWF0ZVBERk5ldHdvcmtTdHJlYW07XG5cbmZ1bmN0aW9uIHNldFBERk5ldHdvcmtTdHJlYW1GYWN0b3J5KHBkZk5ldHdvcmtTdHJlYW1GYWN0b3J5KSB7XG4gIGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0gPSBwZGZOZXR3b3JrU3RyZWFtRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQoc3JjKSB7XG4gIHZhciB0YXNrID0gbmV3IFBERkRvY3VtZW50TG9hZGluZ1Rhc2soKTtcbiAgdmFyIHNvdXJjZTtcblxuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIikge1xuICAgIHNvdXJjZSA9IHtcbiAgICAgIHVybDogc3JjXG4gICAgfTtcbiAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikoc3JjKSkge1xuICAgIHNvdXJjZSA9IHtcbiAgICAgIGRhdGE6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgUERGRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgc291cmNlID0ge1xuICAgICAgcmFuZ2U6IHNyY1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaWYgKF90eXBlb2Yoc3JjKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgaW4gZ2V0RG9jdW1lbnQsIFwiICsgXCJuZWVkIGVpdGhlciBVaW50OEFycmF5LCBzdHJpbmcgb3IgYSBwYXJhbWV0ZXIgb2JqZWN0XCIpO1xuICAgIH1cblxuICAgIGlmICghc3JjLnVybCAmJiAhc3JjLmRhdGEgJiYgIXNyYy5yYW5nZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgb2JqZWN0OiBuZWVkIGVpdGhlciAuZGF0YSwgLnJhbmdlIG9yIC51cmxcIik7XG4gICAgfVxuXG4gICAgc291cmNlID0gc3JjO1xuICB9XG5cbiAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHZhciByYW5nZVRyYW5zcG9ydCA9IG51bGwsXG4gICAgICB3b3JrZXIgPSBudWxsO1xuXG4gIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICBpZiAoa2V5ID09PSBcInVybFwiICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHBhcmFtc1trZXldID0gbmV3IFVSTChzb3VyY2Vba2V5XSwgd2luZG93LmxvY2F0aW9uKS5ocmVmO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChrZXkgPT09IFwicmFuZ2VcIikge1xuICAgICAgcmFuZ2VUcmFuc3BvcnQgPSBzb3VyY2Vba2V5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIndvcmtlclwiKSB7XG4gICAgICB3b3JrZXIgPSBzb3VyY2Vba2V5XTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcImRhdGFcIiAmJiAhKHNvdXJjZVtrZXldIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgIHZhciBwZGZCeXRlcyA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAodHlwZW9mIHBkZkJ5dGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHBhcmFtc1trZXldID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHBkZkJ5dGVzKTtcbiAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihwZGZCeXRlcykgPT09IFwib2JqZWN0XCIgJiYgcGRmQnl0ZXMgIT09IG51bGwgJiYgIWlzTmFOKHBkZkJ5dGVzLmxlbmd0aCkpIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBuZXcgVWludDhBcnJheShwZGZCeXRlcyk7XG4gICAgICB9IGVsc2UgaWYgKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKShwZGZCeXRlcykpIHtcbiAgICAgICAgcGFyYW1zW2tleV0gPSBuZXcgVWludDhBcnJheShwZGZCeXRlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiBiaW5hcnkgZGF0YTogZWl0aGVyIHR5cGVkIGFycmF5LCBcIiArIFwic3RyaW5nIG9yIGFycmF5LWxpa2Ugb2JqZWN0IGlzIGV4cGVjdGVkIGluIHRoZSBcIiArIFwiZGF0YSBwcm9wZXJ0eS5cIik7XG4gICAgICB9XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHBhcmFtc1trZXldID0gc291cmNlW2tleV07XG4gIH1cblxuICBwYXJhbXMucmFuZ2VDaHVua1NpemUgPSBwYXJhbXMucmFuZ2VDaHVua1NpemUgfHwgREVGQVVMVF9SQU5HRV9DSFVOS19TSVpFO1xuICBwYXJhbXMuQ01hcFJlYWRlckZhY3RvcnkgPSBwYXJhbXMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBwYXJhbXMuaWdub3JlRXJyb3JzID0gcGFyYW1zLnN0b3BBdEVycm9ycyAhPT0gdHJ1ZTtcbiAgcGFyYW1zLmZvbnRFeHRyYVByb3BlcnRpZXMgPSBwYXJhbXMuZm9udEV4dHJhUHJvcGVydGllcyA9PT0gdHJ1ZTtcbiAgcGFyYW1zLnBkZkJ1ZyA9IHBhcmFtcy5wZGZCdWcgPT09IHRydWU7XG5cbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhcmFtcy5tYXhJbWFnZVNpemUpKSB7XG4gICAgcGFyYW1zLm1heEltYWdlU2l6ZSA9IC0xO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMuaXNFdmFsU3VwcG9ydGVkICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5pc0V2YWxTdXBwb3J0ZWQgPSB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMuZGlzYWJsZUZvbnRGYWNlICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5kaXNhYmxlRm9udEZhY2UgPSBfYXBpX2NvbXBhdGliaWxpdHkuYXBpQ29tcGF0aWJpbGl0eVBhcmFtcy5kaXNhYmxlRm9udEZhY2UgfHwgZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIHBhcmFtcy5vd25lckRvY3VtZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcGFyYW1zLm93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXJhbXMuZGlzYWJsZVJhbmdlICE9PSBcImJvb2xlYW5cIikge1xuICAgIHBhcmFtcy5kaXNhYmxlUmFuZ2UgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVTdHJlYW0gIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcGFyYW1zLmRpc2FibGVTdHJlYW0gPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcGFyYW1zLmRpc2FibGVBdXRvRmV0Y2ggIT09IFwiYm9vbGVhblwiKSB7XG4gICAgcGFyYW1zLmRpc2FibGVBdXRvRmV0Y2ggPSBmYWxzZTtcbiAgfVxuXG4gICgwLCBfdXRpbC5zZXRWZXJib3NpdHlMZXZlbCkocGFyYW1zLnZlcmJvc2l0eSk7XG5cbiAgaWYgKCF3b3JrZXIpIHtcbiAgICB2YXIgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5OiBwYXJhbXMudmVyYm9zaXR5LFxuICAgICAgcG9ydDogX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydFxuICAgIH07XG4gICAgd29ya2VyID0gd29ya2VyUGFyYW1zLnBvcnQgPyBQREZXb3JrZXIuZnJvbVBvcnQod29ya2VyUGFyYW1zKSA6IG5ldyBQREZXb3JrZXIod29ya2VyUGFyYW1zKTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cblxuICB2YXIgZG9jSWQgPSB0YXNrLmRvY0lkO1xuICB3b3JrZXIucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGFzay5kZXN0cm95ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvYWRpbmcgYWJvcnRlZFwiKTtcbiAgICB9XG5cbiAgICB2YXIgd29ya2VySWRQcm9taXNlID0gX2ZldGNoRG9jdW1lbnQod29ya2VyLCBwYXJhbXMsIHJhbmdlVHJhbnNwb3J0LCBkb2NJZCk7XG5cbiAgICB2YXIgbmV0d29ya1N0cmVhbVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgdmFyIG5ldHdvcmtTdHJlYW07XG5cbiAgICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IF90cmFuc3BvcnRfc3RyZWFtLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0oe1xuICAgICAgICAgIGxlbmd0aDogcGFyYW1zLmxlbmd0aCxcbiAgICAgICAgICBpbml0aWFsRGF0YTogcGFyYW1zLmluaXRpYWxEYXRhLFxuICAgICAgICAgIHByb2dyZXNzaXZlRG9uZTogcGFyYW1zLnByb2dyZXNzaXZlRG9uZSxcbiAgICAgICAgICBkaXNhYmxlUmFuZ2U6IHBhcmFtcy5kaXNhYmxlUmFuZ2UsXG4gICAgICAgICAgZGlzYWJsZVN0cmVhbTogcGFyYW1zLmRpc2FibGVTdHJlYW1cbiAgICAgICAgfSwgcmFuZ2VUcmFuc3BvcnQpO1xuICAgICAgfSBlbHNlIGlmICghcGFyYW1zLmRhdGEpIHtcbiAgICAgICAgbmV0d29ya1N0cmVhbSA9IGNyZWF0ZVBERk5ldHdvcmtTdHJlYW0oe1xuICAgICAgICAgIHVybDogcGFyYW1zLnVybCxcbiAgICAgICAgICBsZW5ndGg6IHBhcmFtcy5sZW5ndGgsXG4gICAgICAgICAgaHR0cEhlYWRlcnM6IHBhcmFtcy5odHRwSGVhZGVycyxcbiAgICAgICAgICB3aXRoQ3JlZGVudGlhbHM6IHBhcmFtcy53aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgcmFuZ2VDaHVua1NpemU6IHBhcmFtcy5yYW5nZUNodW5rU2l6ZSxcbiAgICAgICAgICBkaXNhYmxlUmFuZ2U6IHBhcmFtcy5kaXNhYmxlUmFuZ2UsXG4gICAgICAgICAgZGlzYWJsZVN0cmVhbTogcGFyYW1zLmRpc2FibGVTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUobmV0d29ya1N0cmVhbSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKFt3b3JrZXJJZFByb21pc2UsIG5ldHdvcmtTdHJlYW1Qcm9taXNlXSkudGhlbihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgICAgd29ya2VySWQgPSBfcmVmMlswXSxcbiAgICAgICAgICBuZXR3b3JrU3RyZWFtID0gX3JlZjJbMV07XG5cbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGRvY0lkLCB3b3JrZXJJZCwgd29ya2VyLnBvcnQpO1xuICAgICAgbWVzc2FnZUhhbmRsZXIucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPSB3b3JrZXIucG9zdE1lc3NhZ2VUcmFuc2ZlcnM7XG4gICAgICB2YXIgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zKTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSlbXCJjYXRjaFwiXSh0YXNrLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIHJldHVybiB0YXNrO1xufVxuXG5mdW5jdGlvbiBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIHNvdXJjZSwgcGRmRGF0YVJhbmdlVHJhbnNwb3J0LCBkb2NJZCkge1xuICBpZiAod29ya2VyLmRlc3Ryb3llZCkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gIH1cblxuICBpZiAocGRmRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgc291cmNlLmxlbmd0aCA9IHBkZkRhdGFSYW5nZVRyYW5zcG9ydC5sZW5ndGg7XG4gICAgc291cmNlLmluaXRpYWxEYXRhID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmluaXRpYWxEYXRhO1xuICAgIHNvdXJjZS5wcm9ncmVzc2l2ZURvbmUgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQucHJvZ3Jlc3NpdmVEb25lO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtlci5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREb2NSZXF1ZXN0XCIsIHtcbiAgICBkb2NJZDogZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogJzIuNi4zNDcnLFxuICAgIHNvdXJjZToge1xuICAgICAgZGF0YTogc291cmNlLmRhdGEsXG4gICAgICB1cmw6IHNvdXJjZS51cmwsXG4gICAgICBwYXNzd29yZDogc291cmNlLnBhc3N3b3JkLFxuICAgICAgZGlzYWJsZUF1dG9GZXRjaDogc291cmNlLmRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICByYW5nZUNodW5rU2l6ZTogc291cmNlLnJhbmdlQ2h1bmtTaXplLFxuICAgICAgbGVuZ3RoOiBzb3VyY2UubGVuZ3RoXG4gICAgfSxcbiAgICBtYXhJbWFnZVNpemU6IHNvdXJjZS5tYXhJbWFnZVNpemUsXG4gICAgZGlzYWJsZUZvbnRGYWNlOiBzb3VyY2UuZGlzYWJsZUZvbnRGYWNlLFxuICAgIHBvc3RNZXNzYWdlVHJhbnNmZXJzOiB3b3JrZXIucG9zdE1lc3NhZ2VUcmFuc2ZlcnMsXG4gICAgZG9jQmFzZVVybDogc291cmNlLmRvY0Jhc2VVcmwsXG4gICAgaWdub3JlRXJyb3JzOiBzb3VyY2UuaWdub3JlRXJyb3JzLFxuICAgIGlzRXZhbFN1cHBvcnRlZDogc291cmNlLmlzRXZhbFN1cHBvcnRlZCxcbiAgICBmb250RXh0cmFQcm9wZXJ0aWVzOiBzb3VyY2UuZm9udEV4dHJhUHJvcGVydGllc1xuICB9KS50aGVuKGZ1bmN0aW9uICh3b3JrZXJJZCkge1xuICAgIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya2VySWQ7XG4gIH0pO1xufVxuXG52YXIgUERGRG9jdW1lbnRMb2FkaW5nVGFzayA9IGZ1bmN0aW9uIFBERkRvY3VtZW50TG9hZGluZ1Rhc2tDbG9zdXJlKCkge1xuICB2YXIgbmV4dERvY3VtZW50SWQgPSAwO1xuXG4gIHZhciBQREZEb2N1bWVudExvYWRpbmdUYXNrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQREZEb2N1bWVudExvYWRpbmdUYXNrKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkRvY3VtZW50TG9hZGluZ1Rhc2spO1xuXG4gICAgICB0aGlzLl9jYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgICB0aGlzLmRvY0lkID0gXCJkXCIgKyBuZXh0RG9jdW1lbnRJZCsrO1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMub25QYXNzd29yZCA9IG51bGw7XG4gICAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgdGhpcy5vblVuc3VwcG9ydGVkRmVhdHVyZSA9IG51bGw7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFBERkRvY3VtZW50TG9hZGluZ1Rhc2ssIFt7XG4gICAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB2YXIgdHJhbnNwb3J0RGVzdHJveWVkID0gIXRoaXMuX3RyYW5zcG9ydCA/IFByb21pc2UucmVzb2x2ZSgpIDogdGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydERlc3Ryb3llZC50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcblxuICAgICAgICAgIGlmIChfdGhpcy5fd29ya2VyKSB7XG4gICAgICAgICAgICBfdGhpcy5fd29ya2VyLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgX3RoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvbWlzZVwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBERkRvY3VtZW50TG9hZGluZ1Rhc2s7XG4gIH0oKTtcblxuICByZXR1cm4gUERGRG9jdW1lbnRMb2FkaW5nVGFzaztcbn0oKTtcblxudmFyIFBERkRhdGFSYW5nZVRyYW5zcG9ydCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERkRhdGFSYW5nZVRyYW5zcG9ydChsZW5ndGgsIGluaXRpYWxEYXRhKSB7XG4gICAgdmFyIHByb2dyZXNzaXZlRG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRGF0YVJhbmdlVHJhbnNwb3J0KTtcblxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuaW5pdGlhbERhdGEgPSBpbml0aWFsRGF0YTtcbiAgICB0aGlzLnByb2dyZXNzaXZlRG9uZSA9IHByb2dyZXNzaXZlRG9uZTtcbiAgICB0aGlzLl9yYW5nZUxpc3RlbmVycyA9IFtdO1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERkRhdGFSYW5nZVRyYW5zcG9ydCwgW3tcbiAgICBrZXk6IFwiYWRkUmFuZ2VMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9yYW5nZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUHJvZ3Jlc3NMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRQcm9ncmVzc0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9wcm9ncmVzc0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25EYXRhUmFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EYXRhUmFuZ2UoYmVnaW4sIGNodW5rKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fcmFuZ2VMaXN0ZW5lcnMpLFxuICAgICAgICAgIF9zdGVwO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25EYXRhUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EYXRhUHJvZ3Jlc3MobG9hZGVkLCB0b3RhbCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF90aGlzMi5fcHJvZ3Jlc3NMaXN0ZW5lcnMpLFxuICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKGxvYWRlZCwgdG90YWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkRhdGFQcm9ncmVzc2l2ZVJlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoX3RoaXMzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMpLFxuICAgICAgICAgICAgX3N0ZXAzO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgIGxpc3RlbmVyKGNodW5rKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25EYXRhUHJvZ3Jlc3NpdmVEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRGF0YVByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9pdGVyYXRvcjQgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihfdGhpczQuX3Byb2dyZXNzaXZlRG9uZUxpc3RlbmVycyksXG4gICAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIF9pdGVyYXRvcjQuZigpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidHJhbnNwb3J0UmVhZHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHJhbnNwb3J0UmVhZHkoKSB7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXF1ZXN0RGF0YVJhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBQREZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZVwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWJvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnQoKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbn0oKTtcblxuZXhwb3J0cy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBQREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG5cbnZhciBQREZEb2N1bWVudFByb3h5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGRG9jdW1lbnRQcm94eShwZGZJbmZvLCB0cmFuc3BvcnQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRG9jdW1lbnRQcm94eSk7XG5cbiAgICB0aGlzLl9wZGZJbmZvID0gcGRmSW5mbztcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRG9jdW1lbnRQcm94eSwgW3tcbiAgICBrZXk6IFwiZ2V0UGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZShwYWdlTnVtYmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFnZUluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUluZGV4KHJlZik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlc3RpbmF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREZXN0aW5hdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXN0aW5hdGlvbihpZCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbihpZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhZ2VMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFnZUxhYmVscygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxhYmVscygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTGF5b3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYXlvdXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFnZU1vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFnZU1vZGUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VNb2RlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdlclByZWZlcmVuY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdlclByZWZlcmVuY2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRWaWV3ZXJQcmVmZXJlbmNlcygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcGVuQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wZW5BY3Rpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXR0YWNobWVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXR0YWNobWVudHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEF0dGFjaG1lbnRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEphdmFTY3JpcHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SmF2YVNjcmlwdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0SmF2YVNjcmlwdCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPdXRsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE91dGxpbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE91dGxpbmUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbmFsQ29udGVudENvbmZpZygpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBlcm1pc3Npb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlcm1pc3Npb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQZXJtaXNzaW9ucygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRNZXRhZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXRhZGF0YSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWV0YWRhdGEoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREYXRhKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERvd25sb2FkSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREb3dubG9hZEluZm8oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3RhdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFN0YXRzKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhcnRDbGVhbnVwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmxvYWRpbmdUYXNrLmRlc3Ryb3koKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2F2ZURvY3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhdmVEb2N1bWVudChhbm5vdGF0aW9uU3RvcmFnZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5zYXZlRG9jdW1lbnQoYW5ub3RhdGlvblN0b3JhZ2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhbm5vdGF0aW9uU3RvcmFnZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiYW5ub3RhdGlvblN0b3JhZ2VcIiwgbmV3IF9hbm5vdGF0aW9uX3N0b3JhZ2UuQW5ub3RhdGlvblN0b3JhZ2UoKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm51bVBhZ2VzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5udW1QYWdlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmluZ2VycHJpbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wZGZJbmZvLmZpbmdlcnByaW50O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsb2FkaW5nUGFyYW1zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdQYXJhbXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxvYWRpbmdUYXNrXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdUYXNrO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZEb2N1bWVudFByb3h5O1xufSgpO1xuXG5leHBvcnRzLlBERkRvY3VtZW50UHJveHkgPSBQREZEb2N1bWVudFByb3h5O1xuXG52YXIgUERGUGFnZVByb3h5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCwgb3duZXJEb2N1bWVudCkge1xuICAgIHZhciBwZGZCdWcgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IGZhbHNlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERlBhZ2VQcm94eSk7XG5cbiAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5fcGFnZUluZm8gPSBwYWdlSW5mbztcbiAgICB0aGlzLl9vd25lckRvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgdGhpcy5fc3RhdHMgPSBwZGZCdWcgPyBuZXcgX2Rpc3BsYXlfdXRpbHMuU3RhdFRpbWVyKCkgOiBudWxsO1xuICAgIHRoaXMuX3BkZkJ1ZyA9IHBkZkJ1ZztcbiAgICB0aGlzLmNvbW1vbk9ianMgPSB0cmFuc3BvcnQuY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBuZXcgUERGT2JqZWN0cygpO1xuICAgIHRoaXMuY2xlYW51cEFmdGVyUmVuZGVyID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuX2ludGVudFN0YXRlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERlBhZ2VQcm94eSwgW3tcbiAgICBrZXk6IFwiZ2V0Vmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld3BvcnQoKSB7XG4gICAgICB2YXIgX3JlZjMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIHNjYWxlID0gX3JlZjMuc2NhbGUsXG4gICAgICAgICAgX3JlZjMkcm90YXRpb24gPSBfcmVmMy5yb3RhdGlvbixcbiAgICAgICAgICByb3RhdGlvbiA9IF9yZWYzJHJvdGF0aW9uID09PSB2b2lkIDAgPyB0aGlzLnJvdGF0ZSA6IF9yZWYzJHJvdGF0aW9uLFxuICAgICAgICAgIF9yZWYzJG9mZnNldFggPSBfcmVmMy5vZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFggPSBfcmVmMyRvZmZzZXRYID09PSB2b2lkIDAgPyAwIDogX3JlZjMkb2Zmc2V0WCxcbiAgICAgICAgICBfcmVmMyRvZmZzZXRZID0gX3JlZjMub2Zmc2V0WSxcbiAgICAgICAgICBvZmZzZXRZID0gX3JlZjMkb2Zmc2V0WSA9PT0gdm9pZCAwID8gMCA6IF9yZWYzJG9mZnNldFksXG4gICAgICAgICAgX3JlZjMkZG9udEZsaXAgPSBfcmVmMy5kb250RmxpcCxcbiAgICAgICAgICBkb250RmxpcCA9IF9yZWYzJGRvbnRGbGlwID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGRvbnRGbGlwO1xuXG4gICAgICByZXR1cm4gbmV3IF9kaXNwbGF5X3V0aWxzLlBhZ2VWaWV3cG9ydCh7XG4gICAgICAgIHZpZXdCb3g6IHRoaXMudmlldyxcbiAgICAgICAgc2NhbGU6IHNjYWxlLFxuICAgICAgICByb3RhdGlvbjogcm90YXRpb24sXG4gICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICAgIGRvbnRGbGlwOiBkb250RmxpcFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFubm90YXRpb25zKCkge1xuICAgICAgdmFyIF9yZWY0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgICBfcmVmNCRpbnRlbnQgPSBfcmVmNC5pbnRlbnQsXG4gICAgICAgICAgaW50ZW50ID0gX3JlZjQkaW50ZW50ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjQkaW50ZW50O1xuXG4gICAgICBpZiAoIXRoaXMuYW5ub3RhdGlvbnNQcm9taXNlIHx8IHRoaXMuYW5ub3RhdGlvbnNJbnRlbnQgIT09IGludGVudCkge1xuICAgICAgICB0aGlzLmFubm90YXRpb25zUHJvbWlzZSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRBbm5vdGF0aW9ucyh0aGlzLl9wYWdlSW5kZXgsIGludGVudCk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbnNJbnRlbnQgPSBpbnRlbnQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmFubm90YXRpb25zUHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihfcmVmNSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBjYW52YXNDb250ZXh0ID0gX3JlZjUuY2FudmFzQ29udGV4dCxcbiAgICAgICAgICB2aWV3cG9ydCA9IF9yZWY1LnZpZXdwb3J0LFxuICAgICAgICAgIF9yZWY1JGludGVudCA9IF9yZWY1LmludGVudCxcbiAgICAgICAgICBpbnRlbnQgPSBfcmVmNSRpbnRlbnQgPT09IHZvaWQgMCA/IFwiZGlzcGxheVwiIDogX3JlZjUkaW50ZW50LFxuICAgICAgICAgIF9yZWY1JGVuYWJsZVdlYkdMID0gX3JlZjUuZW5hYmxlV2ViR0wsXG4gICAgICAgICAgZW5hYmxlV2ViR0wgPSBfcmVmNSRlbmFibGVXZWJHTCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmNSRlbmFibGVXZWJHTCxcbiAgICAgICAgICBfcmVmNSRyZW5kZXJJbnRlcmFjdGkgPSBfcmVmNS5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zLFxuICAgICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXMgPSBfcmVmNSRyZW5kZXJJbnRlcmFjdGkgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjUkcmVuZGVySW50ZXJhY3RpLFxuICAgICAgICAgIF9yZWY1JHRyYW5zZm9ybSA9IF9yZWY1LnRyYW5zZm9ybSxcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBfcmVmNSR0cmFuc2Zvcm0gPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNSR0cmFuc2Zvcm0sXG4gICAgICAgICAgX3JlZjUkaW1hZ2VMYXllciA9IF9yZWY1LmltYWdlTGF5ZXIsXG4gICAgICAgICAgaW1hZ2VMYXllciA9IF9yZWY1JGltYWdlTGF5ZXIgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNSRpbWFnZUxheWVyLFxuICAgICAgICAgIF9yZWY1JGNhbnZhc0ZhY3RvcnkgPSBfcmVmNS5jYW52YXNGYWN0b3J5LFxuICAgICAgICAgIGNhbnZhc0ZhY3RvcnkgPSBfcmVmNSRjYW52YXNGYWN0b3J5ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjUkY2FudmFzRmFjdG9yeSxcbiAgICAgICAgICBfcmVmNSRiYWNrZ3JvdW5kID0gX3JlZjUuYmFja2dyb3VuZCxcbiAgICAgICAgICBiYWNrZ3JvdW5kID0gX3JlZjUkYmFja2dyb3VuZCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWY1JGJhY2tncm91bmQsXG4gICAgICAgICAgX3JlZjUkYW5ub3RhdGlvblN0b3JhID0gX3JlZjUuYW5ub3RhdGlvblN0b3JhZ2UsXG4gICAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2UgPSBfcmVmNSRhbm5vdGF0aW9uU3RvcmEgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmNSRhbm5vdGF0aW9uU3RvcmEsXG4gICAgICAgICAgX3JlZjUkb3B0aW9uYWxDb250ZW50ID0gX3JlZjUub3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSxcbiAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gX3JlZjUkb3B0aW9uYWxDb250ZW50ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjUkb3B0aW9uYWxDb250ZW50O1xuXG4gICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgdGhpcy5fc3RhdHMudGltZShcIk92ZXJhbGxcIik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZW5kZXJpbmdJbnRlbnQgPSBpbnRlbnQgPT09IFwicHJpbnRcIiA/IFwicHJpbnRcIiA6IFwiZGlzcGxheVwiO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuXG4gICAgICBpZiAoIW9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UpIHtcbiAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChyZW5kZXJpbmdJbnRlbnQpO1xuXG4gICAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KHJlbmRlcmluZ0ludGVudCwgaW50ZW50U3RhdGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzRmFjdG9yeUluc3RhbmNlID0gY2FudmFzRmFjdG9yeSB8fCBuZXcgRGVmYXVsdENhbnZhc0ZhY3Rvcnkoe1xuICAgICAgICBvd25lckRvY3VtZW50OiB0aGlzLl9vd25lckRvY3VtZW50XG4gICAgICB9KTtcbiAgICAgIHZhciB3ZWJHTENvbnRleHQgPSBuZXcgX3dlYmdsLldlYkdMQ29udGV4dCh7XG4gICAgICAgIGVuYWJsZTogZW5hYmxlV2ViR0xcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIWludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICAgIGFyZ3NBcnJheTogW10sXG4gICAgICAgICAgbGFzdENodW5rOiBmYWxzZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLl9zdGF0cykge1xuICAgICAgICAgIHRoaXMuX3N0YXRzLnRpbWUoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wdW1wT3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgICAgICBpbnRlbnQ6IHJlbmRlcmluZ0ludGVudCxcbiAgICAgICAgICByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zOiByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID09PSB0cnVlLFxuICAgICAgICAgIGFubm90YXRpb25TdG9yYWdlOiBhbm5vdGF0aW9uU3RvcmFnZSAmJiBhbm5vdGF0aW9uU3RvcmFnZS5nZXRBbGwoKSB8fCBudWxsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29tcGxldGUgPSBmdW5jdGlvbiBjb21wbGV0ZShlcnJvcikge1xuICAgICAgICB2YXIgaSA9IGludGVudFN0YXRlLnJlbmRlclRhc2tzLmluZGV4T2YoaW50ZXJuYWxSZW5kZXJUYXNrKTtcblxuICAgICAgICBpZiAoaSA+PSAwKSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3Muc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNS5jbGVhbnVwQWZ0ZXJSZW5kZXIgfHwgcmVuZGVyaW5nSW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICBfdGhpczUucGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM1Ll90cnlDbGVhbnVwKCk7XG5cbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhcGFiaWxpdHkucmVqZWN0KGVycm9yKTtcblxuICAgICAgICAgIF90aGlzNS5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgICAgaW50ZW50U3RhdGU6IGludGVudFN0YXRlLFxuICAgICAgICAgICAgcmVhc29uOiBlcnJvclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczUuX3N0YXRzKSB7XG4gICAgICAgICAgX3RoaXM1Ll9zdGF0cy50aW1lRW5kKFwiUmVuZGVyaW5nXCIpO1xuXG4gICAgICAgICAgX3RoaXM1Ll9zdGF0cy50aW1lRW5kKFwiT3ZlcmFsbFwiKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIGludGVybmFsUmVuZGVyVGFzayA9IG5ldyBJbnRlcm5hbFJlbmRlclRhc2soe1xuICAgICAgICBjYWxsYmFjazogY29tcGxldGUsXG4gICAgICAgIHBhcmFtczoge1xuICAgICAgICAgIGNhbnZhc0NvbnRleHQ6IGNhbnZhc0NvbnRleHQsXG4gICAgICAgICAgdmlld3BvcnQ6IHZpZXdwb3J0LFxuICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtLFxuICAgICAgICAgIGltYWdlTGF5ZXI6IGltYWdlTGF5ZXIsXG4gICAgICAgICAgYmFja2dyb3VuZDogYmFja2dyb3VuZFxuICAgICAgICB9LFxuICAgICAgICBvYmpzOiB0aGlzLm9ianMsXG4gICAgICAgIGNvbW1vbk9ianM6IHRoaXMuY29tbW9uT2JqcyxcbiAgICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgICBjYW52YXNGYWN0b3J5OiBjYW52YXNGYWN0b3J5SW5zdGFuY2UsXG4gICAgICAgIHdlYkdMQ29udGV4dDogd2ViR0xDb250ZXh0LFxuICAgICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6IHJlbmRlcmluZ0ludGVudCAhPT0gXCJwcmludFwiLFxuICAgICAgICBwZGZCdWc6IHRoaXMuX3BkZkJ1Z1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghaW50ZW50U3RhdGUucmVuZGVyVGFza3MpIHtcbiAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MgPSBbXTtcbiAgICAgIH1cblxuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MucHVzaChpbnRlcm5hbFJlbmRlclRhc2spO1xuICAgICAgdmFyIHJlbmRlclRhc2sgPSBpbnRlcm5hbFJlbmRlclRhc2sudGFzaztcbiAgICAgIFByb21pc2UuYWxsKFtpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5LnByb21pc2UsIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2VdKS50aGVuKGZ1bmN0aW9uIChfcmVmNikge1xuICAgICAgICB2YXIgX3JlZjcgPSBfc2xpY2VkVG9BcnJheShfcmVmNiwgMiksXG4gICAgICAgICAgICB0cmFuc3BhcmVuY3kgPSBfcmVmN1swXSxcbiAgICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZyA9IF9yZWY3WzFdO1xuXG4gICAgICAgIGlmIChfdGhpczUucGVuZGluZ0NsZWFudXApIHtcbiAgICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczUuX3N0YXRzKSB7XG4gICAgICAgICAgX3RoaXM1Ll9zdGF0cy50aW1lKFwiUmVuZGVyaW5nXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmluaXRpYWxpemVHcmFwaGljcyh7XG4gICAgICAgICAgdHJhbnNwYXJlbmN5OiB0cmFuc3BhcmVuY3ksXG4gICAgICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnOiBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICAgICAgfSk7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkKCk7XG4gICAgICB9KVtcImNhdGNoXCJdKGNvbXBsZXRlKTtcbiAgICAgIHJldHVybiByZW5kZXJUYXNrO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcGVyYXRvckxpc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3BlcmF0b3JMaXN0KCkge1xuICAgICAgZnVuY3Rpb24gb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgICAgdmFyIGkgPSBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5pbmRleE9mKG9wTGlzdFRhc2spO1xuXG4gICAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVuZGVyaW5nSW50ZW50ID0gXCJvcGxpc3RcIjtcblxuICAgICAgdmFyIGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChyZW5kZXJpbmdJbnRlbnQpO1xuXG4gICAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICAgIGludGVudFN0YXRlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KHJlbmRlcmluZ0ludGVudCwgaW50ZW50U3RhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgb3BMaXN0VGFzaztcblxuICAgICAgaWYgKCFpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICBvcExpc3RUYXNrID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgb3BMaXN0VGFzay5vcGVyYXRvckxpc3RDaGFuZ2VkID0gb3BlcmF0b3JMaXN0Q2hhbmdlZDtcbiAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzID0gW107XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLnB1c2gob3BMaXN0VGFzayk7XG4gICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCA9IHtcbiAgICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICAgIGxhc3RDaHVuazogZmFsc2VcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5fc3RhdHMpIHtcbiAgICAgICAgICB0aGlzLl9zdGF0cy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgcGFnZUluZGV4OiB0aGlzLl9wYWdlSW5kZXgsXG4gICAgICAgICAgaW50ZW50OiByZW5kZXJpbmdJbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdHJlYW1UZXh0Q29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzdHJlYW1UZXh0Q29udGVudCgpIHtcbiAgICAgIHZhciBfcmVmOCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge30sXG4gICAgICAgICAgX3JlZjgkbm9ybWFsaXplV2hpdGVzID0gX3JlZjgubm9ybWFsaXplV2hpdGVzcGFjZSxcbiAgICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlID0gX3JlZjgkbm9ybWFsaXplV2hpdGVzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWY4JG5vcm1hbGl6ZVdoaXRlcyxcbiAgICAgICAgICBfcmVmOCRkaXNhYmxlQ29tYmluZVQgPSBfcmVmOC5kaXNhYmxlQ29tYmluZVRleHRJdGVtcyxcbiAgICAgICAgICBkaXNhYmxlQ29tYmluZVRleHRJdGVtcyA9IF9yZWY4JGRpc2FibGVDb21iaW5lVCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmOCRkaXNhYmxlQ29tYmluZVQ7XG5cbiAgICAgIHZhciBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSA9IDEwMDtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRUZXh0Q29udGVudFwiLCB7XG4gICAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlOiBub3JtYWxpemVXaGl0ZXNwYWNlID09PSB0cnVlLFxuICAgICAgICBjb21iaW5lVGV4dEl0ZW1zOiBkaXNhYmxlQ29tYmluZVRleHRJdGVtcyAhPT0gdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBoaWdoV2F0ZXJNYXJrOiBURVhUX0NPTlRFTlRfQ0hVTktfU0laRSxcbiAgICAgICAgc2l6ZTogZnVuY3Rpb24gc2l6ZSh0ZXh0Q29udGVudCkge1xuICAgICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUZXh0Q29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0Q29udGVudCgpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIHJlYWRhYmxlU3RyZWFtID0gdGhpcy5zdHJlYW1UZXh0Q29udGVudChwYXJhbXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICAgICAgICB2YXIgX3RleHRDb250ZW50JGl0ZW1zO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBfcmVmOS52YWx1ZSxcbiAgICAgICAgICAgICAgICBkb25lID0gX3JlZjkuZG9uZTtcblxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbih0ZXh0Q29udGVudC5zdHlsZXMsIHZhbHVlLnN0eWxlcyk7XG5cbiAgICAgICAgICAgIChfdGV4dENvbnRlbnQkaXRlbXMgPSB0ZXh0Q29udGVudC5pdGVtcykucHVzaC5hcHBseShfdGV4dENvbnRlbnQkaXRlbXMsIF90b0NvbnN1bWFibGVBcnJheSh2YWx1ZS5pdGVtcykpO1xuXG4gICAgICAgICAgICBwdW1wKCk7XG4gICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgdmFyIHRleHRDb250ZW50ID0ge1xuICAgICAgICAgIGl0ZW1zOiBbXSxcbiAgICAgICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICAgICAgfTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZXN0cm95XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9kZXN0cm95KCkge1xuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0LnBhZ2VDYWNoZVt0aGlzLl9wYWdlSW5kZXhdID0gbnVsbDtcbiAgICAgIHZhciB3YWl0T24gPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcih0aGlzLl9pbnRlbnRTdGF0ZXMpLFxuICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgX3N0ZXA1JHZhbHVlID0gX3NsaWNlZFRvQXJyYXkoX3N0ZXA1LnZhbHVlLCAyKSxcbiAgICAgICAgICAgICAgaW50ZW50ID0gX3N0ZXA1JHZhbHVlWzBdLFxuICAgICAgICAgICAgICBpbnRlbnRTdGF0ZSA9IF9zdGVwNSR2YWx1ZVsxXTtcblxuICAgICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICAgIGludGVudFN0YXRlOiBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgIHJlYXNvbjogbmV3IEVycm9yKFwiUGFnZSB3YXMgZGVzdHJveWVkLlwiKSxcbiAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcIm9wbGlzdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGludGVudFN0YXRlLnJlbmRlclRhc2tzKSxcbiAgICAgICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBpbnRlcm5hbFJlbmRlclRhc2sgPSBfc3RlcDYudmFsdWU7XG4gICAgICAgICAgICAgIHdhaXRPbi5wdXNoKGludGVybmFsUmVuZGVyVGFzay5jb21wbGV0ZWQpO1xuICAgICAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNS5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vYmpzLmNsZWFyKCk7XG4gICAgICB0aGlzLmFubm90YXRpb25zUHJvbWlzZSA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW51cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgdmFyIHJlc2V0U3RhdHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcy5fdHJ5Q2xlYW51cChyZXNldFN0YXRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3RyeUNsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RyeUNsZWFudXAoKSB7XG4gICAgICB2YXIgcmVzZXRTdGF0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICghdGhpcy5wZW5kaW5nQ2xlYW51cCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5faW50ZW50U3RhdGVzLnZhbHVlcygpKSxcbiAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yNy5zKCk7ICEoX3N0ZXA3ID0gX2l0ZXJhdG9yNy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwNyR2YWx1ZSA9IF9zdGVwNy52YWx1ZSxcbiAgICAgICAgICAgICAgcmVuZGVyVGFza3MgPSBfc3RlcDckdmFsdWUucmVuZGVyVGFza3MsXG4gICAgICAgICAgICAgIG9wZXJhdG9yTGlzdCA9IF9zdGVwNyR2YWx1ZS5vcGVyYXRvckxpc3Q7XG5cbiAgICAgICAgICBpZiAocmVuZGVyVGFza3MubGVuZ3RoICE9PSAwIHx8ICFvcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I3LmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLmNsZWFyKCk7XG5cbiAgICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgICAgdGhpcy5hbm5vdGF0aW9uc1Byb21pc2UgPSBudWxsO1xuXG4gICAgICBpZiAocmVzZXRTdGF0cyAmJiB0aGlzLl9zdGF0cykge1xuICAgICAgICB0aGlzLl9zdGF0cyA9IG5ldyBfZGlzcGxheV91dGlscy5TdGF0VGltZXIoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zdGFydFJlbmRlclBhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3N0YXJ0UmVuZGVyUGFnZSh0cmFuc3BhcmVuY3ksIGludGVudCkge1xuICAgICAgdmFyIGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChpbnRlbnQpO1xuXG4gICAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRzKSB7XG4gICAgICAgIHRoaXMuX3N0YXRzLnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVuZGVyUGFnZUNodW5rXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBvcGVyYXRvckxpc3RDaHVuay5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5mbkFycmF5LnB1c2gob3BlcmF0b3JMaXN0Q2h1bmsuZm5BcnJheVtpXSk7XG4gICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgICAgfVxuXG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzW19pMl0ub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICAgIHRoaXMuX3RyeUNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3B1bXBPcGVyYXRvckxpc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1bXBPcGVyYXRvckxpc3QoYXJncykge1xuICAgICAgdmFyIF90aGlzNiA9IHRoaXM7XG5cbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKGFyZ3MuaW50ZW50LCAnUERGUGFnZVByb3h5Ll9wdW1wT3BlcmF0b3JMaXN0OiBFeHBlY3RlZCBcImludGVudFwiIGFyZ3VtZW50LicpO1xuXG4gICAgICB2YXIgcmVhZGFibGVTdHJlYW0gPSB0aGlzLl90cmFuc3BvcnQubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhTdHJlYW0oXCJHZXRPcGVyYXRvckxpc3RcIiwgYXJncyk7XG5cbiAgICAgIHZhciByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcblxuICAgICAgdmFyIGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChhcmdzLmludGVudCk7XG5cbiAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IHJlYWRlcjtcblxuICAgICAgdmFyIHB1bXAgPSBmdW5jdGlvbiBwdW1wKCkge1xuICAgICAgICByZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYxMCkge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYxMC52YWx1ZSxcbiAgICAgICAgICAgICAgZG9uZSA9IF9yZWYxMC5kb25lO1xuXG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IG51bGw7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF90aGlzNi5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIF90aGlzNi5fcmVuZGVyUGFnZUNodW5rKHZhbHVlLCBpbnRlbnRTdGF0ZSk7XG5cbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKF90aGlzNi5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QpIHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVudFN0YXRlLnJlbmRlclRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzW2ldLm9wZXJhdG9yTGlzdENoYW5nZWQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX3RoaXM2Ll90cnlDbGVhbnVwKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkpIHtcbiAgICAgICAgICAgIGludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgcHVtcCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfYWJvcnRPcGVyYXRvckxpc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Fib3J0T3BlcmF0b3JMaXN0KF9yZWYxMSkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG5cbiAgICAgIHZhciBpbnRlbnRTdGF0ZSA9IF9yZWYxMS5pbnRlbnRTdGF0ZSxcbiAgICAgICAgICByZWFzb24gPSBfcmVmMTEucmVhc29uLFxuICAgICAgICAgIF9yZWYxMSRmb3JjZSA9IF9yZWYxMS5mb3JjZSxcbiAgICAgICAgICBmb3JjZSA9IF9yZWYxMSRmb3JjZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMTEkZm9yY2U7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciB8fCBfdHlwZW9mKHJlYXNvbikgPT09IFwib2JqZWN0XCIgJiYgcmVhc29uICE9PSBudWxsLCAnUERGUGFnZVByb3h5Ll9hYm9ydE9wZXJhdG9yTGlzdDogRXhwZWN0ZWQgXCJyZWFzb25cIiBhcmd1bWVudC4nKTtcblxuICAgICAgaWYgKCFpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWZvcmNlKSB7XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXM3Ll9hYm9ydE9wZXJhdG9yTGlzdCh7XG4gICAgICAgICAgICAgIGludGVudFN0YXRlOiBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICAgICAgcmVhc29uOiByZWFzb24sXG4gICAgICAgICAgICAgIGZvcmNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgfSwgUkVOREVSSU5HX0NBTkNFTExFRF9USU1FT1VUKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24ocmVhc29uICYmIHJlYXNvbi5tZXNzYWdlKSk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5faW50ZW50U3RhdGVzKSxcbiAgICAgICAgICBfc3RlcDg7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwOCR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwOC52YWx1ZSwgMiksXG4gICAgICAgICAgICAgIGludGVudCA9IF9zdGVwOCR2YWx1ZVswXSxcbiAgICAgICAgICAgICAgY3VySW50ZW50U3RhdGUgPSBfc3RlcDgkdmFsdWVbMV07XG5cbiAgICAgICAgICBpZiAoY3VySW50ZW50U3RhdGUgPT09IGludGVudFN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXNbXCJkZWxldGVcIl0oaW50ZW50KTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yOC5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3I4LmYoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VOdW1iZXJcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlSW5kZXggKyAxO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyb3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlZlwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnJlZjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXNlclVuaXRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby51c2VyVW5pdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidmlld1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInN0YXRzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERlBhZ2VQcm94eTtcbn0oKTtcblxuZXhwb3J0cy5QREZQYWdlUHJveHkgPSBQREZQYWdlUHJveHk7XG5cbnZhciBMb29wYmFja1BvcnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMb29wYmFja1BvcnQoKSB7XG4gICAgdmFyIGRlZmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvb3BiYWNrUG9ydCk7XG5cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9kZWZlciA9IGRlZmVyO1xuICAgIHRoaXMuX2RlZmVycmVkID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTG9vcGJhY2tQb3J0LCBbe1xuICAgIGtleTogXCJwb3N0TWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwb3N0TWVzc2FnZShvYmosIHRyYW5zZmVycykge1xuICAgICAgdmFyIF90aGlzOCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKF90eXBlb2YodmFsdWUpICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNsb25lZC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGNsb25lZC5nZXQodmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGJ1ZmZlciwgcmVzdWx0O1xuXG4gICAgICAgIGlmICgoYnVmZmVyID0gdmFsdWUuYnVmZmVyKSAmJiAoMCwgX3V0aWwuaXNBcnJheUJ1ZmZlcikoYnVmZmVyKSkge1xuICAgICAgICAgIHZhciB0cmFuc2ZlcmFibGUgPSB0cmFuc2ZlcnMgJiYgdHJhbnNmZXJzLmluY2x1ZGVzKGJ1ZmZlcik7XG5cbiAgICAgICAgICBpZiAodHJhbnNmZXJhYmxlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgdmFsdWUuY29uc3RydWN0b3IoYnVmZmVyLCB2YWx1ZS5ieXRlT2Zmc2V0LCB2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IHZhbHVlLmNvbnN0cnVjdG9yKHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjbG9uZWQuc2V0KHZhbHVlLCByZXN1bHQpO1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXN1bHQgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IFtdIDoge307XG4gICAgICAgIGNsb25lZC5zZXQodmFsdWUsIHJlc3VsdCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiB2YWx1ZSkge1xuICAgICAgICAgIHZhciBkZXNjID0gdm9pZCAwLFxuICAgICAgICAgICAgICBwID0gdmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoIShkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCBpKSkpIHtcbiAgICAgICAgICAgIHAgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHR5cGVvZiBkZXNjLnZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGRlc2MudmFsdWUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmhhc093blByb3BlcnR5ICYmIHZhbHVlLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxvb3BiYWNrUG9ydC5wb3N0TWVzc2FnZSAtIGNhbm5vdCBjbG9uZTogXCIuY29uY2F0KHZhbHVlW2ldKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdFtpXSA9IGNsb25lVmFsdWUoZGVzYy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2RlZmVyKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwoX3RoaXM4LCB7XG4gICAgICAgICAgICBkYXRhOiBvYmpcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2xvbmVkID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgIHZhciBlID0ge1xuICAgICAgICBkYXRhOiBjbG9uZVZhbHVlKG9iailcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2RlZmVycmVkLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczguX2xpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICAgIGxpc3RlbmVyLmNhbGwoX3RoaXM4LCBlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRXZlbnRMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUV2ZW50TGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGkgPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XG5cbiAgICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRlcm1pbmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0ZXJtaW5hdGUoKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTG9vcGJhY2tQb3J0O1xufSgpO1xuXG5leHBvcnRzLkxvb3BiYWNrUG9ydCA9IExvb3BiYWNrUG9ydDtcblxudmFyIFBERldvcmtlciA9IGZ1bmN0aW9uIFBERldvcmtlckNsb3N1cmUoKSB7XG4gIHZhciBwZGZXb3JrZXJQb3J0cyA9IG5ldyBXZWFrTWFwKCk7XG4gIHZhciBpc1dvcmtlckRpc2FibGVkID0gZmFsc2U7XG4gIHZhciBmYWxsYmFja1dvcmtlclNyYztcbiAgdmFyIG5leHRGYWtlV29ya2VySWQgPSAwO1xuICB2YXIgZmFrZVdvcmtlckNhcGFiaWxpdHk7XG5cbiAgaWYgKF9pc19ub2RlLmlzTm9kZUpTICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpc1dvcmtlckRpc2FibGVkID0gdHJ1ZTtcbiAgICBmYWxsYmFja1dvcmtlclNyYyA9IFwiLi9wZGYud29ya2VyLmpzXCI7XG4gIH0gZWxzZSBpZiAoKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJ1bmRlZmluZWRcIiA/IFwidW5kZWZpbmVkXCIgOiBfdHlwZW9mKGRvY3VtZW50KSkgPT09IFwib2JqZWN0XCIgJiYgXCJjdXJyZW50U2NyaXB0XCIgaW4gZG9jdW1lbnQpIHtcbiAgICB2YXIgcGRmanNGaWxlUGF0aCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmM7XG5cbiAgICBpZiAocGRmanNGaWxlUGF0aCkge1xuICAgICAgZmFsbGJhY2tXb3JrZXJTcmMgPSBwZGZqc0ZpbGVQYXRoLnJlcGxhY2UoLyhcXC4oPzptaW5cXC4pP2pzKShcXD8uKik/JC9pLCBcIi53b3JrZXIkMSQyXCIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIF9nZXRXb3JrZXJTcmMoKSB7XG4gICAgaWYgKF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYykge1xuICAgICAgcmV0dXJuIF93b3JrZXJfb3B0aW9ucy5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGZhbGxiYWNrV29ya2VyU3JjICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBpZiAoIV9pc19ub2RlLmlzTm9kZUpTKSB7XG4gICAgICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKSgnTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbGxiYWNrV29ya2VyU3JjO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignTm8gXCJHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyY1wiIHNwZWNpZmllZC4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpIHtcbiAgICB2YXIgbWFpbldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuXG4gICAgdHJ5IHtcbiAgICAgIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlciA9IGdsb2JhbFRoaXMucGRmanNXb3JrZXIgJiYgZ2xvYmFsVGhpcy5wZGZqc1dvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICB9IGNhdGNoIChleCkge31cblxuICAgIHJldHVybiBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIgfHwgbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwRmFrZVdvcmtlckdsb2JhbCgpIHtcbiAgICBpZiAoZmFrZVdvcmtlckNhcGFiaWxpdHkpIHtcbiAgICAgIHJldHVybiBmYWtlV29ya2VyQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cblxuICAgIGZha2VXb3JrZXJDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuXG4gICAgdmFyIGxvYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZjEyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlciwgd29ya2VyO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlciA9IGdldE1haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoIShfaXNfbm9kZS5pc05vZGVKUyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3b3JrZXIgPSBldmFsKFwicmVxdWlyZVwiKShfZ2V0V29ya2VyU3JjKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgd29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCBfZGlzcGxheV91dGlscy5sb2FkU2NyaXB0KShfZ2V0V29ya2VyU3JjKCkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHdpbmRvdy5wZGZqc1dvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUpO1xuICAgICAgfSkpO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gbG9hZGVyKCkge1xuICAgICAgICByZXR1cm4gX3JlZjEyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9O1xuICAgIH0oKTtcblxuICAgIGxvYWRlcigpLnRoZW4oZmFrZVdvcmtlckNhcGFiaWxpdHkucmVzb2x2ZSwgZmFrZVdvcmtlckNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICByZXR1cm4gZmFrZVdvcmtlckNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNETldyYXBwZXIodXJsKSB7XG4gICAgdmFyIHdyYXBwZXIgPSBcImltcG9ydFNjcmlwdHMoJ1wiICsgdXJsICsgXCInKTtcIjtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0pKTtcbiAgfVxuXG4gIHZhciBQREZXb3JrZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBERldvcmtlcigpIHtcbiAgICAgIHZhciBfcmVmMTMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9LFxuICAgICAgICAgIF9yZWYxMyRuYW1lID0gX3JlZjEzLm5hbWUsXG4gICAgICAgICAgbmFtZSA9IF9yZWYxMyRuYW1lID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjEzJG5hbWUsXG4gICAgICAgICAgX3JlZjEzJHBvcnQgPSBfcmVmMTMucG9ydCxcbiAgICAgICAgICBwb3J0ID0gX3JlZjEzJHBvcnQgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmMTMkcG9ydCxcbiAgICAgICAgICBfcmVmMTMkdmVyYm9zaXR5ID0gX3JlZjEzLnZlcmJvc2l0eSxcbiAgICAgICAgICB2ZXJib3NpdHkgPSBfcmVmMTMkdmVyYm9zaXR5ID09PSB2b2lkIDAgPyAoMCwgX3V0aWwuZ2V0VmVyYm9zaXR5TGV2ZWwpKCkgOiBfcmVmMTMkdmVyYm9zaXR5O1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGV29ya2VyKTtcblxuICAgICAgaWYgKHBvcnQgJiYgcGRmV29ya2VyUG9ydHMuaGFzKHBvcnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSBQREZXb3JrZXIgcGVyIHBvcnRcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3N0TWVzc2FnZVRyYW5zZmVycyA9IHRydWU7XG4gICAgICB0aGlzLnZlcmJvc2l0eSA9IHZlcmJvc2l0eTtcbiAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbnVsbDtcblxuICAgICAgaWYgKHBvcnQpIHtcbiAgICAgICAgcGRmV29ya2VyUG9ydHMuc2V0KHBvcnQsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXRpYWxpemUoKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoUERGV29ya2VyLCBbe1xuICAgICAga2V5OiBcIl9pbml0aWFsaXplRnJvbVBvcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdGlhbGl6ZUZyb21Qb3J0KHBvcnQpIHtcbiAgICAgICAgdGhpcy5fcG9ydCA9IHBvcnQ7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHBvcnQpO1xuXG4gICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZnVuY3Rpb24gKCkge30pO1xuXG4gICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9pbml0aWFsaXplXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXRpYWxpemUoKSB7XG4gICAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuXG4gICAgICAgIGlmICh0eXBlb2YgV29ya2VyICE9PSBcInVuZGVmaW5lZFwiICYmICFpc1dvcmtlckRpc2FibGVkICYmICFnZXRNYWluVGhyZWFkV29ya2VyTWVzc2FnZUhhbmRsZXIoKSkge1xuICAgICAgICAgIHZhciB3b3JrZXJTcmMgPSBfZ2V0V29ya2VyU3JjKCk7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCEoMCwgX3V0aWwuaXNTYW1lT3JpZ2luKSh3aW5kb3cubG9jYXRpb24uaHJlZiwgd29ya2VyU3JjKSkge1xuICAgICAgICAgICAgICB3b3JrZXJTcmMgPSBjcmVhdGVDRE5XcmFwcGVyKG5ldyBVUkwod29ya2VyU3JjLCB3aW5kb3cubG9jYXRpb24pLmhyZWYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcih3b3JrZXJTcmMpO1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHdvcmtlcik7XG5cbiAgICAgICAgICAgIHZhciB0ZXJtaW5hdGVFYXJseSA9IGZ1bmN0aW9uIHRlcm1pbmF0ZUVhcmx5KCkge1xuICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcblxuICAgICAgICAgICAgICBpZiAoX3RoaXM5LmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIF90aGlzOS5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXM5Ll9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIG9uV29ya2VyRXJyb3IgPSBmdW5jdGlvbiBvbldvcmtlckVycm9yKCkge1xuICAgICAgICAgICAgICBpZiAoIV90aGlzOS5fd2ViV29ya2VyKSB7XG4gICAgICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuXG4gICAgICAgICAgICAgIGlmIChfdGhpczkuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIF90aGlzOS5fbWVzc2FnZUhhbmRsZXIgPSBtZXNzYWdlSGFuZGxlcjtcbiAgICAgICAgICAgICAgICBfdGhpczkuX3BvcnQgPSB3b3JrZXI7XG4gICAgICAgICAgICAgICAgX3RoaXM5Ll93ZWJXb3JrZXIgPSB3b3JrZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuc3VwcG9ydFRyYW5zZmVycykge1xuICAgICAgICAgICAgICAgICAgX3RoaXM5LnBvc3RNZXNzYWdlVHJhbnNmZXJzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3RoaXM5Ll9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuXG4gICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICAgICAgICAgICAgICB2ZXJib3NpdHk6IF90aGlzOS52ZXJib3NpdHlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpczkuX3NldHVwRmFrZVdvcmtlcigpO1xuXG4gICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5vbihcInJlYWR5XCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgIHdvcmtlci5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG5cbiAgICAgICAgICAgICAgaWYgKF90aGlzOS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB0ZXJtaW5hdGVFYXJseSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzOS5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgc2VuZFRlc3QgPSBmdW5jdGlvbiBzZW5kVGVzdCgpIHtcbiAgICAgICAgICAgICAgdmFyIHRlc3RPYmogPSBuZXcgVWludDhBcnJheShbX3RoaXM5LnBvc3RNZXNzYWdlVHJhbnNmZXJzID8gMjU1IDogMF0pO1xuXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcInRlc3RcIiwgdGVzdE9iaiwgW3Rlc3RPYmouYnVmZmVyXSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiQ2Fubm90IHVzZSBwb3N0TWVzc2FnZSB0cmFuc2ZlcnMuXCIpO1xuICAgICAgICAgICAgICAgIHRlc3RPYmpbMF0gPSAwO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJ0ZXN0XCIsIHRlc3RPYmopO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZW5kVGVzdCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC5pbmZvKShcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfc2V0dXBGYWtlV29ya2VyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldHVwRmFrZVdvcmtlcigpIHtcbiAgICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuXG4gICAgICAgIGlmICghaXNXb3JrZXJEaXNhYmxlZCkge1xuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlNldHRpbmcgdXAgZmFrZSB3b3JrZXIuXCIpO1xuICAgICAgICAgIGlzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dXBGYWtlV29ya2VyR2xvYmFsKCkudGhlbihmdW5jdGlvbiAoV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgICBpZiAoX3RoaXMxMC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIF90aGlzMTAuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBvcnQgPSBuZXcgTG9vcGJhY2tQb3J0KCk7XG4gICAgICAgICAgX3RoaXMxMC5fcG9ydCA9IHBvcnQ7XG4gICAgICAgICAgdmFyIGlkID0gXCJmYWtlXCIgKyBuZXh0RmFrZVdvcmtlcklkKys7XG4gICAgICAgICAgdmFyIHdvcmtlckhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihpZCArIFwiX3dvcmtlclwiLCBpZCwgcG9ydCk7XG4gICAgICAgICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgICAgICAgdmFyIG1lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoaWQsIGlkICsgXCJfd29ya2VyXCIsIHBvcnQpO1xuICAgICAgICAgIF90aGlzMTAuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG5cbiAgICAgICAgICBfdGhpczEwLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuXG4gICAgICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICAgICAgICB2ZXJib3NpdHk6IF90aGlzMTAudmVyYm9zaXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIF90aGlzMTAuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiU2V0dGluZyB1cCBmYWtlIHdvcmtlciBmYWlsZWQ6IFxcXCJcIi5jb25jYXQocmVhc29uLm1lc3NhZ2UsIFwiXFxcIi5cIikpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuX3dlYldvcmtlcikge1xuICAgICAgICAgIHRoaXMuX3dlYldvcmtlci50ZXJtaW5hdGUoKTtcblxuICAgICAgICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBwZGZXb3JrZXJQb3J0c1tcImRlbGV0ZVwiXSh0aGlzLl9wb3J0KTtcbiAgICAgICAgdGhpcy5fcG9ydCA9IG51bGw7XG5cbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuXG4gICAgICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb21pc2VcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBvcnRcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibWVzc2FnZUhhbmRsZXJcIixcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWVzc2FnZUhhbmRsZXI7XG4gICAgICB9XG4gICAgfV0sIFt7XG4gICAgICBrZXk6IFwiZnJvbVBvcnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tUG9ydChwYXJhbXMpIHtcbiAgICAgICAgaWYgKCFwYXJhbXMgfHwgIXBhcmFtcy5wb3J0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUERGV29ya2VyLmZyb21Qb3J0IC0gaW52YWxpZCBtZXRob2Qgc2lnbmF0dXJlLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwZGZXb3JrZXJQb3J0cy5oYXMocGFyYW1zLnBvcnQpKSB7XG4gICAgICAgICAgcmV0dXJuIHBkZldvcmtlclBvcnRzLmdldChwYXJhbXMucG9ydCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV3IFBERldvcmtlcihwYXJhbXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRXb3JrZXJTcmNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRXb3JrZXJTcmMoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0V29ya2VyU3JjKCk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFBERldvcmtlcjtcbiAgfSgpO1xuXG4gIHJldHVybiBQREZXb3JrZXI7XG59KCk7XG5cbmV4cG9ydHMuUERGV29ya2VyID0gUERGV29ya2VyO1xuXG52YXIgV29ya2VyVHJhbnNwb3J0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gV29ya2VyVHJhbnNwb3J0KG1lc3NhZ2VIYW5kbGVyLCBsb2FkaW5nVGFzaywgbmV0d29ya1N0cmVhbSwgcGFyYW1zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdvcmtlclRyYW5zcG9ydCk7XG5cbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgdGhpcy5sb2FkaW5nVGFzayA9IGxvYWRpbmdUYXNrO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5mb250TG9hZGVyID0gbmV3IF9mb250X2xvYWRlci5Gb250TG9hZGVyKHtcbiAgICAgIGRvY0lkOiBsb2FkaW5nVGFzay5kb2NJZCxcbiAgICAgIG9uVW5zdXBwb3J0ZWRGZWF0dXJlOiB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZS5iaW5kKHRoaXMpLFxuICAgICAgb3duZXJEb2N1bWVudDogcGFyYW1zLm93bmVyRG9jdW1lbnRcbiAgICB9KTtcbiAgICB0aGlzLl9wYXJhbXMgPSBwYXJhbXM7XG4gICAgdGhpcy5DTWFwUmVhZGVyRmFjdG9yeSA9IG5ldyBwYXJhbXMuQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogcGFyYW1zLmNNYXBVcmwsXG4gICAgICBpc0NvbXByZXNzZWQ6IHBhcmFtcy5jTWFwUGFja2VkXG4gICAgfSk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9wYXNzd29yZENhcGFiaWxpdHkgPSBudWxsO1xuICAgIHRoaXMuX25ldHdvcmtTdHJlYW0gPSBuZXR3b3JrU3RyZWFtO1xuICAgIHRoaXMuX2Z1bGxSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RQcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5wYWdlQ2FjaGUgPSBbXTtcbiAgICB0aGlzLnBhZ2VQcm9taXNlcyA9IFtdO1xuICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLnNldHVwTWVzc2FnZUhhbmRsZXIoKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXb3JrZXJUcmFuc3BvcnQsIFt7XG4gICAga2V5OiBcImRlc3Ryb3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHZhciBfdGhpczExID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuZGVzdHJveUNhcGFiaWxpdHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgICAgaWYgKHRoaXMuX3Bhc3N3b3JkQ2FwYWJpbGl0eSkge1xuICAgICAgICB0aGlzLl9wYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkIGR1cmluZyBvblBhc3N3b3JkIGNhbGxiYWNrXCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHdhaXRPbiA9IFtdO1xuICAgICAgdGhpcy5wYWdlQ2FjaGUuZm9yRWFjaChmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICBpZiAocGFnZSkge1xuICAgICAgICAgIHdhaXRPbi5wdXNoKHBhZ2UuX2Rlc3Ryb3koKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5wYWdlQ2FjaGUubGVuZ3RoID0gMDtcbiAgICAgIHRoaXMucGFnZVByb21pc2VzLmxlbmd0aCA9IDA7XG4gICAgICB2YXIgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgICAgd2FpdE9uLnB1c2godGVybWluYXRlZCk7XG4gICAgICBQcm9taXNlLmFsbCh3YWl0T24pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczExLmZvbnRMb2FkZXIuY2xlYXIoKTtcblxuICAgICAgICBpZiAoX3RoaXMxMS5fbmV0d29ya1N0cmVhbSkge1xuICAgICAgICAgIF90aGlzMTEuX25ldHdvcmtTdHJlYW0uY2FuY2VsQWxsUmVxdWVzdHMobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiV29ya2VyIHdhcyB0ZXJtaW5hdGVkLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXMxMS5tZXNzYWdlSGFuZGxlcikge1xuICAgICAgICAgIF90aGlzMTEubWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuXG4gICAgICAgICAgX3RoaXMxMS5tZXNzYWdlSGFuZGxlciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczExLmRlc3Ryb3lDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIHJldHVybiB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldHVwTWVzc2FnZUhhbmRsZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0dXBNZXNzYWdlSGFuZGxlcigpIHtcbiAgICAgIHZhciBfdGhpczEyID0gdGhpcztcblxuICAgICAgdmFyIG1lc3NhZ2VIYW5kbGVyID0gdGhpcy5tZXNzYWdlSGFuZGxlcixcbiAgICAgICAgICBsb2FkaW5nVGFzayA9IHRoaXMubG9hZGluZ1Rhc2s7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldFJlYWRlclwiLCBmdW5jdGlvbiAoZGF0YSwgc2luaykge1xuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShfdGhpczEyLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgICBfdGhpczEyLl9mdWxsUmVhZGVyID0gX3RoaXMxMi5fbmV0d29ya1N0cmVhbS5nZXRGdWxsUmVhZGVyKCk7XG5cbiAgICAgICAgX3RoaXMxMi5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgIF90aGlzMTIuX2xhc3RQcm9ncmVzcyA9IHtcbiAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICAgIHRvdGFsOiBldnQudG90YWxcbiAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHNpbmsub25QdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMTIuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYxNCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjE0LnZhbHVlLFxuICAgICAgICAgICAgICAgIGRvbmUgPSBfcmVmMTQuZG9uZTtcblxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWx1ZSksIFwiR2V0UmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgICAgc2luay5lbnF1ZXVlKG5ldyBVaW50OEFycmF5KHZhbHVlKSwgMSwgW3ZhbHVlXSk7XG4gICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgc2luay5vbkNhbmNlbCA9IGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICBfdGhpczEyLl9mdWxsUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuXG4gICAgICAgICAgc2luay5yZWFkeVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFkeVJlYXNvbikge1xuICAgICAgICAgICAgaWYgKF90aGlzMTIuZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiUmVhZGVySGVhZGVyc1JlYWR5XCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciBoZWFkZXJzQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgICAgdmFyIGZ1bGxSZWFkZXIgPSBfdGhpczEyLl9mdWxsUmVhZGVyO1xuICAgICAgICBmdWxsUmVhZGVyLmhlYWRlcnNSZWFkeS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoIWZ1bGxSZWFkZXIuaXNTdHJlYW1pbmdTdXBwb3J0ZWQgfHwgIWZ1bGxSZWFkZXIuaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgaWYgKF90aGlzMTIuX2xhc3RQcm9ncmVzcyAmJiBsb2FkaW5nVGFzay5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3MoX3RoaXMxMi5fbGFzdFByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVsbFJlYWRlci5vblByb2dyZXNzID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICAgICAgICBpZiAobG9hZGluZ1Rhc2sub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgICAgICAgdG90YWw6IGV2dC50b3RhbFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGhlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgaXNTdHJlYW1pbmdTdXBwb3J0ZWQ6IGZ1bGxSZWFkZXIuaXNTdHJlYW1pbmdTdXBwb3J0ZWQsXG4gICAgICAgICAgICBpc1JhbmdlU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzUmFuZ2VTdXBwb3J0ZWQsXG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoOiBmdWxsUmVhZGVyLmNvbnRlbnRMZW5ndGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgaGVhZGVyc0NhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmFuZ2VSZWFkZXJcIiwgZnVuY3Rpb24gKGRhdGEsIHNpbmspIHtcbiAgICAgICAgKDAsIF91dGlsLmFzc2VydCkoX3RoaXMxMi5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuXG4gICAgICAgIHZhciByYW5nZVJlYWRlciA9IF90aGlzMTIuX25ldHdvcmtTdHJlYW0uZ2V0UmFuZ2VSZWFkZXIoZGF0YS5iZWdpbiwgZGF0YS5lbmQpO1xuXG4gICAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc2luay5vblB1bGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWYxNSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gX3JlZjE1LnZhbHVlLFxuICAgICAgICAgICAgICAgIGRvbmUgPSBfcmVmMTUuZG9uZTtcblxuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWx1ZSksIFwiR2V0UmFuZ2VSZWFkZXIgLSBleHBlY3RlZCBhbiBBcnJheUJ1ZmZlci5cIik7XG4gICAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBzaW5rLm9uQ2FuY2VsID0gZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIHJhbmdlUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICAgIHNpbmsucmVhZHlbXCJjYXRjaFwiXShmdW5jdGlvbiAocmVhZHlSZWFzb24pIHtcbiAgICAgICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IHJlYWR5UmVhc29uO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldERvY1wiLCBmdW5jdGlvbiAoX3JlZjE2KSB7XG4gICAgICAgIHZhciBwZGZJbmZvID0gX3JlZjE2LnBkZkluZm87XG4gICAgICAgIF90aGlzMTIuX251bVBhZ2VzID0gcGRmSW5mby5udW1QYWdlcztcblxuICAgICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZXNvbHZlKG5ldyBQREZEb2N1bWVudFByb3h5KHBkZkluZm8sIF90aGlzMTIpKTtcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NFeGNlcHRpb25cIiwgZnVuY3Rpb24gKGV4KSB7XG4gICAgICAgIHZhciByZWFzb247XG5cbiAgICAgICAgc3dpdGNoIChleC5uYW1lKSB7XG4gICAgICAgICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguY29kZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCI6XG4gICAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGV4Lm1lc3NhZ2UpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uXCI6XG4gICAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKGV4Lm1lc3NhZ2UsIGV4LnN0YXR1cyk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguZGV0YWlscyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHZhciBtc2cgPSBcIkRvY0V4Y2VwdGlvbiAtIGV4cGVjdGVkIGEgdmFsaWQgRXJyb3IuXCI7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKG1zZyk7XG4gICAgICAgIH1cblxuICAgICAgICBsb2FkaW5nVGFzay5fY2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZnVuY3Rpb24gKGV4Y2VwdGlvbikge1xuICAgICAgICBfdGhpczEyLl9wYXNzd29yZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUGFzc3dvcmQgPSBmdW5jdGlvbiB1cGRhdGVQYXNzd29yZChwYXNzd29yZCkge1xuICAgICAgICAgICAgX3RoaXMxMi5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgICAgICBwYXNzd29yZDogcGFzc3dvcmRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXhjZXB0aW9uLmNvZGUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBfdGhpczEyLl9wYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3RoaXMxMi5fcGFzc3dvcmRDYXBhYmlsaXR5LnJlamVjdChuZXcgX3V0aWwuUGFzc3dvcmRFeGNlcHRpb24oZXhjZXB0aW9uLm1lc3NhZ2UsIGV4Y2VwdGlvbi5jb2RlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMxMi5fcGFzc3dvcmRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRGF0YUxvYWRlZFwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAobG9hZGluZ1Rhc2sub25Qcm9ncmVzcykge1xuICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgbG9hZGVkOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMxMi5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiU3RhcnRSZW5kZXJQYWdlXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWdlID0gX3RoaXMxMi5wYWdlQ2FjaGVbZGF0YS5wYWdlSW5kZXhdO1xuXG4gICAgICAgIHBhZ2UuX3N0YXJ0UmVuZGVyUGFnZShkYXRhLnRyYW5zcGFyZW5jeSwgZGF0YS5pbnRlbnQpO1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoX3RoaXMxMi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2RhdGEgPSBfc2xpY2VkVG9BcnJheShkYXRhLCAzKSxcbiAgICAgICAgICAgIGlkID0gX2RhdGFbMF0sXG4gICAgICAgICAgICB0eXBlID0gX2RhdGFbMV0sXG4gICAgICAgICAgICBleHBvcnRlZERhdGEgPSBfZGF0YVsyXTtcblxuICAgICAgICBpZiAoX3RoaXMxMi5jb21tb25PYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIFwiRm9udFwiOlxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IF90aGlzMTIuX3BhcmFtcztcblxuICAgICAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiBleHBvcnRlZERhdGEpIHtcbiAgICAgICAgICAgICAgdmFyIGV4cG9ydGVkRXJyb3IgPSBleHBvcnRlZERhdGEuZXJyb3I7XG4gICAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIkVycm9yIGR1cmluZyBmb250IGxvYWRpbmc6IFwiLmNvbmNhdChleHBvcnRlZEVycm9yKSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMxMi5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRXJyb3IpO1xuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZm9udFJlZ2lzdHJ5ID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5wZGZCdWcgJiYgZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yICYmIGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvci5lbmFibGVkKSB7XG4gICAgICAgICAgICAgIGZvbnRSZWdpc3RyeSA9IHtcbiAgICAgICAgICAgICAgICByZWdpc3RlckZvbnQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRm9udChmb250LCB1cmwpIHtcbiAgICAgICAgICAgICAgICAgIGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvci5mb250QWRkZWQoZm9udCwgdXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb250ID0gbmV3IF9mb250X2xvYWRlci5Gb250RmFjZU9iamVjdChleHBvcnRlZERhdGEsIHtcbiAgICAgICAgICAgICAgaXNFdmFsU3VwcG9ydGVkOiBwYXJhbXMuaXNFdmFsU3VwcG9ydGVkLFxuICAgICAgICAgICAgICBkaXNhYmxlRm9udEZhY2U6IHBhcmFtcy5kaXNhYmxlRm9udEZhY2UsXG4gICAgICAgICAgICAgIGlnbm9yZUVycm9yczogcGFyYW1zLmlnbm9yZUVycm9ycyxcbiAgICAgICAgICAgICAgb25VbnN1cHBvcnRlZEZlYXR1cmU6IF90aGlzMTIuX29uVW5zdXBwb3J0ZWRGZWF0dXJlLmJpbmQoX3RoaXMxMiksXG4gICAgICAgICAgICAgIGZvbnRSZWdpc3RyeTogZm9udFJlZ2lzdHJ5XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgX3RoaXMxMi5mb250TG9hZGVyLmJpbmQoZm9udClbXCJjYXRjaFwiXShmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJGb250RmFsbGJhY2tcIiwge1xuICAgICAgICAgICAgICAgIGlkOiBpZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGlmICghcGFyYW1zLmZvbnRFeHRyYVByb3BlcnRpZXMgJiYgZm9udC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZm9udC5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIF90aGlzMTIuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBmb250KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGb250UGF0aFwiOlxuICAgICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICAgICAgX3RoaXMxMi5jb21tb25PYmpzLnJlc29sdmUoaWQsIGV4cG9ydGVkRGF0YSk7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCB1bmtub3duIGNvbW1vbiBvYmplY3QgdHlwZSBcIi5jb25jYXQodHlwZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwib2JqXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2RhdGEyID0gX3NsaWNlZFRvQXJyYXkoZGF0YSwgNCksXG4gICAgICAgICAgICBpZCA9IF9kYXRhMlswXSxcbiAgICAgICAgICAgIHBhZ2VJbmRleCA9IF9kYXRhMlsxXSxcbiAgICAgICAgICAgIHR5cGUgPSBfZGF0YTJbMl0sXG4gICAgICAgICAgICBpbWFnZURhdGEgPSBfZGF0YTJbM107XG5cbiAgICAgICAgdmFyIHBhZ2VQcm94eSA9IF90aGlzMTIucGFnZUNhY2hlW3BhZ2VJbmRleF07XG5cbiAgICAgICAgaWYgKHBhZ2VQcm94eS5vYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcIkltYWdlXCI6XG4gICAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgICAgdmFyIE1BWF9JTUFHRV9TSVpFX1RPX1NUT1JFID0gODAwMDAwMDtcblxuICAgICAgICAgICAgaWYgKGltYWdlRGF0YSAmJiBcImRhdGFcIiBpbiBpbWFnZURhdGEgJiYgaW1hZ2VEYXRhLmRhdGEubGVuZ3RoID4gTUFYX0lNQUdFX1NJWkVfVE9fU1RPUkUpIHtcbiAgICAgICAgICAgICAgcGFnZVByb3h5LmNsZWFudXBBZnRlclJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdvdCB1bmtub3duIG9iamVjdCB0eXBlIFwiLmNvbmNhdCh0eXBlKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGlmIChfdGhpczEyLmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsb2FkaW5nVGFzay5vblByb2dyZXNzKSB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICBsb2FkZWQ6IGRhdGEubG9hZGVkLFxuICAgICAgICAgICAgdG90YWw6IGRhdGEudG90YWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBtZXNzYWdlSGFuZGxlci5vbihcIlVuc3VwcG9ydGVkRmVhdHVyZVwiLCB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZS5iaW5kKHRoaXMpKTtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiRmV0Y2hCdWlsdEluQ01hcFwiLCBmdW5jdGlvbiAoZGF0YSwgc2luaykge1xuICAgICAgICBpZiAoX3RoaXMxMi5kZXN0cm95ZWQpIHtcbiAgICAgICAgICBzaW5rLmVycm9yKG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmV0Y2hlZCA9IGZhbHNlO1xuXG4gICAgICAgIHNpbmsub25QdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmZXRjaGVkKSB7XG4gICAgICAgICAgICBzaW5rLmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZmV0Y2hlZCA9IHRydWU7XG5cbiAgICAgICAgICBfdGhpczEyLkNNYXBSZWFkZXJGYWN0b3J5LmZldGNoKGRhdGEpLnRoZW4oZnVuY3Rpb24gKGJ1aWx0SW5DTWFwKSB7XG4gICAgICAgICAgICBzaW5rLmVucXVldWUoYnVpbHRJbkNNYXAsIDEsIFtidWlsdEluQ01hcC5jTWFwRGF0YS5idWZmZXJdKTtcbiAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25VbnN1cHBvcnRlZEZlYXR1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uVW5zdXBwb3J0ZWRGZWF0dXJlKF9yZWYxNykge1xuICAgICAgdmFyIGZlYXR1cmVJZCA9IF9yZWYxNy5mZWF0dXJlSWQ7XG5cbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmxvYWRpbmdUYXNrLm9uVW5zdXBwb3J0ZWRGZWF0dXJlKSB7XG4gICAgICAgIHRoaXMubG9hZGluZ1Rhc2sub25VbnN1cHBvcnRlZEZlYXR1cmUoZmVhdHVyZUlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREYXRhKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGF0YVwiLCBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlKHBhZ2VOdW1iZXIpIHtcbiAgICAgIHZhciBfdGhpczEzID0gdGhpcztcblxuICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHBhZ2VOdW1iZXIpIHx8IHBhZ2VOdW1iZXIgPD0gMCB8fCBwYWdlTnVtYmVyID4gdGhpcy5fbnVtUGFnZXMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZSByZXF1ZXN0XCIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBhZ2VJbmRleCA9IHBhZ2VOdW1iZXIgLSAxO1xuXG4gICAgICBpZiAocGFnZUluZGV4IGluIHRoaXMucGFnZVByb21pc2VzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VQcm9taXNlc1twYWdlSW5kZXhdO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChwYWdlSW5mbykge1xuICAgICAgICBpZiAoX3RoaXMxMy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZ2UgPSBuZXcgUERGUGFnZVByb3h5KHBhZ2VJbmRleCwgcGFnZUluZm8sIF90aGlzMTMsIF90aGlzMTMuX3BhcmFtcy5vd25lckRvY3VtZW50LCBfdGhpczEzLl9wYXJhbXMucGRmQnVnKTtcbiAgICAgICAgX3RoaXMxMy5wYWdlQ2FjaGVbcGFnZUluZGV4XSA9IHBhZ2U7XG4gICAgICAgIHJldHVybiBwYWdlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnBhZ2VQcm9taXNlc1twYWdlSW5kZXhdID0gcHJvbWlzZTtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlSW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFnZUluZGV4KHJlZikge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgICAgcmVmOiByZWZcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKHJlYXNvbikpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFubm90YXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRBbm5vdGF0aW9uc1wiLCB7XG4gICAgICAgIHBhZ2VJbmRleDogcGFnZUluZGV4LFxuICAgICAgICBpbnRlbnQ6IGludGVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNhdmVEb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzYXZlRG9jdW1lbnQoYW5ub3RhdGlvblN0b3JhZ2UpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIlNhdmVEb2N1bWVudFwiLCB7XG4gICAgICAgIG51bVBhZ2VzOiB0aGlzLl9udW1QYWdlcyxcbiAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IGFubm90YXRpb25TdG9yYWdlICYmIGFubm90YXRpb25TdG9yYWdlLmdldEFsbCgpIHx8IG51bGwsXG4gICAgICAgIGZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyID8gdGhpcy5fZnVsbFJlYWRlci5maWxlbmFtZSA6IG51bGxcbiAgICAgIH0pW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uU3RvcmFnZSkge1xuICAgICAgICAgIGFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlc3RpbmF0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvbnNcIiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldERlc3RpbmF0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgICBpZiAodHlwZW9mIGlkICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJJbnZhbGlkIGRlc3RpbmF0aW9uIHJlcXVlc3QuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25cIiwge1xuICAgICAgICBpZDogaWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGFiZWxzXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTGF5b3V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhZ2VMYXlvdXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlTGF5b3V0XCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYWdlTW9kZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VNb2RlXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWV3ZXJQcmVmZXJlbmNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFZpZXdlclByZWZlcmVuY2VzXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcGVuQWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9wZW5BY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBdHRhY2htZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRBdHRhY2htZW50cygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRKYXZhU2NyaXB0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEphdmFTY3JpcHQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRKYXZhU2NyaXB0XCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPdXRsaW5lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE91dGxpbmUoKSB7XG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPdXRsaW5lXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRPcHRpb25hbENvbnRlbnRDb25maWdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0T3B0aW9uYWxDb250ZW50Q29uZmlnXCIsIG51bGwpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBfb3B0aW9uYWxfY29udGVudF9jb25maWcuT3B0aW9uYWxDb250ZW50Q29uZmlnKHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBlcm1pc3Npb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBlcm1pc3Npb25zKCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGVybWlzc2lvbnNcIiwgbnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE1ldGFkYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1ldGFkYXRhKCkge1xuICAgICAgdmFyIF90aGlzMTQgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNZXRhZGF0YVwiLCBudWxsKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaW5mbzogcmVzdWx0c1swXSxcbiAgICAgICAgICBtZXRhZGF0YTogcmVzdWx0c1sxXSA/IG5ldyBfbWV0YWRhdGEuTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lOiBfdGhpczE0Ll9mdWxsUmVhZGVyID8gX3RoaXMxNC5fZnVsbFJlYWRlci5maWxlbmFtZSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGF0c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFN0YXRzXCIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGFydENsZWFudXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc3RhcnRDbGVhbnVwKCkge1xuICAgICAgdmFyIF90aGlzMTUgPSB0aGlzO1xuXG4gICAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJDbGVhbnVwXCIsIG51bGwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBfdGhpczE1LnBhZ2VDYWNoZS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgdmFyIHBhZ2UgPSBfdGhpczE1LnBhZ2VDYWNoZVtpXTtcblxuICAgICAgICAgIGlmIChwYWdlKSB7XG4gICAgICAgICAgICB2YXIgY2xlYW51cFN1Y2Nlc3NmdWwgPSBwYWdlLmNsZWFudXAoKTtcblxuICAgICAgICAgICAgaWYgKCFjbGVhbnVwU3VjY2Vzc2Z1bCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzdGFydENsZWFudXA6IFBhZ2UgXCIuY29uY2F0KGkgKyAxLCBcIiBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLlwiKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMxNS5jb21tb25PYmpzLmNsZWFyKCk7XG5cbiAgICAgICAgX3RoaXMxNS5mb250TG9hZGVyLmNsZWFyKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwibG9hZGluZ1BhcmFtc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuX3BhcmFtcztcbiAgICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImxvYWRpbmdQYXJhbXNcIiwge1xuICAgICAgICBkaXNhYmxlQXV0b0ZldGNoOiBwYXJhbXMuZGlzYWJsZUF1dG9GZXRjaCxcbiAgICAgICAgZGlzYWJsZUZvbnRGYWNlOiBwYXJhbXMuZGlzYWJsZUZvbnRGYWNlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV29ya2VyVHJhbnNwb3J0O1xufSgpO1xuXG52YXIgUERGT2JqZWN0cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERk9iamVjdHMoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERk9iamVjdHMpO1xuXG4gICAgdGhpcy5fb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGT2JqZWN0cywgW3tcbiAgICBrZXk6IFwiX2Vuc3VyZU9ialwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5zdXJlT2JqKG9iaklkKSB7XG4gICAgICBpZiAodGhpcy5fb2Jqc1tvYmpJZF0pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ianNbb2JqSWRdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fb2Jqc1tvYmpJZF0gPSB7XG4gICAgICAgIGNhcGFiaWxpdHk6ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKSxcbiAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgcmVzb2x2ZWQ6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KG9iaklkKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9lbnN1cmVPYmoob2JqSWQpLmNhcGFiaWxpdHkucHJvbWlzZS50aGVuKGNhbGxiYWNrKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIG9iaiA9IHRoaXMuX29ianNbb2JqSWRdO1xuXG4gICAgICBpZiAoIW9iaiB8fCAhb2JqLnJlc29sdmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlcXVlc3Rpbmcgb2JqZWN0IHRoYXQgaXNuJ3QgcmVzb2x2ZWQgeWV0IFwiLmNvbmNhdChvYmpJZCwgXCIuXCIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG9iai5kYXRhO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKG9iaklkKSB7XG4gICAgICB2YXIgb2JqID0gdGhpcy5fb2Jqc1tvYmpJZF07XG4gICAgICByZXR1cm4gb2JqID8gb2JqLnJlc29sdmVkIDogZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzb2x2ZShvYmpJZCwgZGF0YSkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX2Vuc3VyZU9iaihvYmpJZCk7XG5cbiAgICAgIG9iai5yZXNvbHZlZCA9IHRydWU7XG4gICAgICBvYmouZGF0YSA9IGRhdGE7XG4gICAgICBvYmouY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuX29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZPYmplY3RzO1xufSgpO1xuXG52YXIgUmVuZGVyVGFzayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlbmRlclRhc2soaW50ZXJuYWxSZW5kZXJUYXNrKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlbmRlclRhc2spO1xuXG4gICAgdGhpcy5faW50ZXJuYWxSZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHRoaXMub25Db250aW51ZSA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUmVuZGVyVGFzaywgW3tcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgIHRoaXMuX2ludGVybmFsUmVuZGVyVGFzay5jYW5jZWwoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvbWlzZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJlbmRlclRhc2s7XG59KCk7XG5cbnZhciBJbnRlcm5hbFJlbmRlclRhc2sgPSBmdW5jdGlvbiBJbnRlcm5hbFJlbmRlclRhc2tDbG9zdXJlKCkge1xuICB2YXIgY2FudmFzSW5SZW5kZXJpbmcgPSBuZXcgV2Vha1NldCgpO1xuXG4gIHZhciBJbnRlcm5hbFJlbmRlclRhc2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEludGVybmFsUmVuZGVyVGFzayhfcmVmMTgpIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IF9yZWYxOC5jYWxsYmFjayxcbiAgICAgICAgICBwYXJhbXMgPSBfcmVmMTgucGFyYW1zLFxuICAgICAgICAgIG9ianMgPSBfcmVmMTgub2JqcyxcbiAgICAgICAgICBjb21tb25PYmpzID0gX3JlZjE4LmNvbW1vbk9ianMsXG4gICAgICAgICAgb3BlcmF0b3JMaXN0ID0gX3JlZjE4Lm9wZXJhdG9yTGlzdCxcbiAgICAgICAgICBwYWdlSW5kZXggPSBfcmVmMTgucGFnZUluZGV4LFxuICAgICAgICAgIGNhbnZhc0ZhY3RvcnkgPSBfcmVmMTguY2FudmFzRmFjdG9yeSxcbiAgICAgICAgICB3ZWJHTENvbnRleHQgPSBfcmVmMTgud2ViR0xDb250ZXh0LFxuICAgICAgICAgIF9yZWYxOCR1c2VSZXF1ZXN0QW5pbSA9IF9yZWYxOC51c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUsXG4gICAgICAgICAgdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gX3JlZjE4JHVzZVJlcXVlc3RBbmltID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYxOCR1c2VSZXF1ZXN0QW5pbSxcbiAgICAgICAgICBfcmVmMTgkcGRmQnVnID0gX3JlZjE4LnBkZkJ1ZyxcbiAgICAgICAgICBwZGZCdWcgPSBfcmVmMTgkcGRmQnVnID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYxOCRwZGZCdWc7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBJbnRlcm5hbFJlbmRlclRhc2spO1xuXG4gICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgIHRoaXMub2JqcyA9IG9ianM7XG4gICAgICB0aGlzLmNvbW1vbk9ianMgPSBjb21tb25PYmpzO1xuICAgICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSBudWxsO1xuICAgICAgdGhpcy5vcGVyYXRvckxpc3QgPSBvcGVyYXRvckxpc3Q7XG4gICAgICB0aGlzLl9wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkgPSBjYW52YXNGYWN0b3J5O1xuICAgICAgdGhpcy53ZWJHTENvbnRleHQgPSB3ZWJHTENvbnRleHQ7XG4gICAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrID0gbnVsbDtcbiAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB0cnVlICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgICB0aGlzLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgdGhpcy50YXNrID0gbmV3IFJlbmRlclRhc2sodGhpcyk7XG4gICAgICB0aGlzLl9jb250aW51ZUJvdW5kID0gdGhpcy5fY29udGludWUuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuX3NjaGVkdWxlTmV4dEJvdW5kID0gdGhpcy5fc2NoZWR1bGVOZXh0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9uZXh0Qm91bmQgPSB0aGlzLl9uZXh0LmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9jYW52YXMgPSBwYXJhbXMuY2FudmFzQ29udGV4dC5jYW52YXM7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKEludGVybmFsUmVuZGVyVGFzaywgW3tcbiAgICAgIGtleTogXCJpbml0aWFsaXplR3JhcGhpY3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplR3JhcGhpY3MoX3JlZjE5KSB7XG4gICAgICAgIHZhciBfcmVmMTkkdHJhbnNwYXJlbmN5ID0gX3JlZjE5LnRyYW5zcGFyZW5jeSxcbiAgICAgICAgICAgIHRyYW5zcGFyZW5jeSA9IF9yZWYxOSR0cmFuc3BhcmVuY3kgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjE5JHRyYW5zcGFyZW5jeSxcbiAgICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZyA9IF9yZWYxOS5vcHRpb25hbENvbnRlbnRDb25maWc7XG5cbiAgICAgICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgICAgIGlmIChjYW52YXNJblJlbmRlcmluZy5oYXModGhpcy5fY2FudmFzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjYW52YXNJblJlbmRlcmluZy5hZGQodGhpcy5fY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlciAmJiBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyLmVuYWJsZWQpIHtcbiAgICAgICAgICB0aGlzLnN0ZXBwZXIgPSBnbG9iYWxUaGlzLlN0ZXBwZXJNYW5hZ2VyLmNyZWF0ZSh0aGlzLl9wYWdlSW5kZXgpO1xuICAgICAgICAgIHRoaXMuc3RlcHBlci5pbml0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgICAgICB0aGlzLnN0ZXBwZXIubmV4dEJyZWFrUG9pbnQgPSB0aGlzLnN0ZXBwZXIuZ2V0TmV4dEJyZWFrUG9pbnQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGhpcyRwYXJhbXMgPSB0aGlzLnBhcmFtcyxcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQgPSBfdGhpcyRwYXJhbXMuY2FudmFzQ29udGV4dCxcbiAgICAgICAgICAgIHZpZXdwb3J0ID0gX3RoaXMkcGFyYW1zLnZpZXdwb3J0LFxuICAgICAgICAgICAgdHJhbnNmb3JtID0gX3RoaXMkcGFyYW1zLnRyYW5zZm9ybSxcbiAgICAgICAgICAgIGltYWdlTGF5ZXIgPSBfdGhpcyRwYXJhbXMuaW1hZ2VMYXllcixcbiAgICAgICAgICAgIGJhY2tncm91bmQgPSBfdGhpcyRwYXJhbXMuYmFja2dyb3VuZDtcbiAgICAgICAgdGhpcy5nZnggPSBuZXcgX2NhbnZhcy5DYW52YXNHcmFwaGljcyhjYW52YXNDb250ZXh0LCB0aGlzLmNvbW1vbk9ianMsIHRoaXMub2JqcywgdGhpcy5jYW52YXNGYWN0b3J5LCB0aGlzLndlYkdMQ29udGV4dCwgaW1hZ2VMYXllciwgb3B0aW9uYWxDb250ZW50Q29uZmlnKTtcbiAgICAgICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICAgICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICAgICAgdHJhbnNwYXJlbmN5OiB0cmFuc3BhcmVuY3ksXG4gICAgICAgICAgYmFja2dyb3VuZDogYmFja2dyb3VuZFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSAwO1xuICAgICAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgICB2YXIgZXJyb3IgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG4gICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNhbmNlbGxlZCA9IHRydWU7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2Z4KSB7XG4gICAgICAgICAgdGhpcy5nZnguZW5kRHJhd2luZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgICAgIGNhbnZhc0luUmVuZGVyaW5nW1wiZGVsZXRlXCJdKHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNhbGxiYWNrKGVycm9yIHx8IG5ldyBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24oXCJSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlIFwiLmNvbmNhdCh0aGlzLl9wYWdlSW5kZXggKyAxKSwgXCJjYW52YXNcIikpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJvcGVyYXRvckxpc3RDaGFuZ2VkXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmdyYXBoaWNzUmVhZHkpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayA9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RlcHBlcikge1xuICAgICAgICAgIHRoaXMuc3RlcHBlci51cGRhdGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMucnVubmluZykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvbnRpbnVlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9jb250aW51ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jb250aW51ZSgpIHtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcblxuICAgICAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy50YXNrLm9uQ29udGludWUpIHtcbiAgICAgICAgICB0aGlzLnRhc2sub25Db250aW51ZSh0aGlzLl9zY2hlZHVsZU5leHRCb3VuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2NoZWR1bGVOZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX3NjaGVkdWxlTmV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zY2hlZHVsZU5leHQoKSB7XG4gICAgICAgIHZhciBfdGhpczE2ID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczE2Ll9uZXh0Qm91bmQoKVtcImNhdGNoXCJdKF90aGlzMTYuY2FuY2VsLmJpbmQoX3RoaXMxNikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4odGhpcy5fbmV4dEJvdW5kKVtcImNhdGNoXCJdKHRoaXMuY2FuY2VsLmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9uZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX25leHQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgdGhpcy5vcGVyYXRvckxpc3RJZHggPSB0aGlzLmdmeC5leGVjdXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0LCB0aGlzLm9wZXJhdG9yTGlzdElkeCwgdGhpcy5fY29udGludWVCb3VuZCwgdGhpcy5zdGVwcGVyKTtcblxuICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3BlcmF0b3JMaXN0SWR4ID09PSB0aGlzLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmspIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdmeC5lbmREcmF3aW5nKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW52YXNJblJlbmRlcmluZ1tcImRlbGV0ZVwiXSh0aGlzLl9jYW52YXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgZnVuY3Rpb24gX25leHQoKSB7XG4gICAgICAgICAgcmV0dXJuIF9uZXh0Mi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9uZXh0O1xuICAgICAgfSgpXG4gICAgfSwge1xuICAgICAga2V5OiBcImNvbXBsZXRlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhcGFiaWxpdHkucHJvbWlzZVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gSW50ZXJuYWxSZW5kZXJUYXNrO1xuICB9KCk7XG5cbiAgcmV0dXJuIEludGVybmFsUmVuZGVyVGFzaztcbn0oKTtcblxudmFyIHZlcnNpb24gPSAnMi42LjM0Nyc7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xudmFyIGJ1aWxkID0gJzNiZTljNjVmJztcbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcblxuLyoqKi8gfSksXG4vKiAyMDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRm9udExvYWRlciA9IGV4cG9ydHMuRm9udEZhY2VPYmplY3QgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd19wZGZqc19yZXF1aXJlX18oMikpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgQmFzZUZvbnRMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlRm9udExvYWRlcihfcmVmKSB7XG4gICAgdmFyIGRvY0lkID0gX3JlZi5kb2NJZCxcbiAgICAgICAgb25VbnN1cHBvcnRlZEZlYXR1cmUgPSBfcmVmLm9uVW5zdXBwb3J0ZWRGZWF0dXJlLFxuICAgICAgICBfcmVmJG93bmVyRG9jdW1lbnQgPSBfcmVmLm93bmVyRG9jdW1lbnQsXG4gICAgICAgIG93bmVyRG9jdW1lbnQgPSBfcmVmJG93bmVyRG9jdW1lbnQgPT09IHZvaWQgMCA/IGdsb2JhbFRoaXMuZG9jdW1lbnQgOiBfcmVmJG93bmVyRG9jdW1lbnQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUZvbnRMb2FkZXIpO1xuXG4gICAgaWYgKHRoaXMuY29uc3RydWN0b3IgPT09IEJhc2VGb250TG9hZGVyKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUZvbnRMb2FkZXIuXCIpO1xuICAgIH1cblxuICAgIHRoaXMuZG9jSWQgPSBkb2NJZDtcbiAgICB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZSA9IG9uVW5zdXBwb3J0ZWRGZWF0dXJlO1xuICAgIHRoaXMuX2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcyA9IFtdO1xuICAgIHRoaXMuc3R5bGVFbGVtZW50ID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlRm9udExvYWRlciwgW3tcbiAgICBrZXk6IFwiYWRkTmF0aXZlRm9udEZhY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLnB1c2gobmF0aXZlRm9udEZhY2UpO1xuXG4gICAgICB0aGlzLl9kb2N1bWVudC5mb250cy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbnNlcnRSdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluc2VydFJ1bGUocnVsZSkge1xuICAgICAgdmFyIHN0eWxlRWxlbWVudCA9IHRoaXMuc3R5bGVFbGVtZW50O1xuXG4gICAgICBpZiAoIXN0eWxlRWxlbWVudCkge1xuICAgICAgICBzdHlsZUVsZW1lbnQgPSB0aGlzLnN0eWxlRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgc3R5bGVFbGVtZW50LmlkID0gXCJQREZKU19GT05UX1NUWUxFX1RBR19cIi5jb25jYXQodGhpcy5kb2NJZCk7XG5cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiaGVhZFwiKVswXS5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3R5bGVTaGVldCA9IHN0eWxlRWxlbWVudC5zaGVldDtcbiAgICAgIHN0eWxlU2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzdHlsZVNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5uYXRpdmVGb250RmFjZXMuZm9yRWFjaChmdW5jdGlvbiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgX3RoaXMuX2RvY3VtZW50LmZvbnRzW1wiZGVsZXRlXCJdKG5hdGl2ZUZvbnRGYWNlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5uYXRpdmVGb250RmFjZXMubGVuZ3RoID0gMDtcblxuICAgICAgaWYgKHRoaXMuc3R5bGVFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnN0eWxlRWxlbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9iaW5kID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShmb250KSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICAgIHZhciBuYXRpdmVGb250RmFjZSwgcnVsZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAoIShmb250LmF0dGFjaGVkIHx8IGZvbnQubWlzc2luZ0ZpbGUpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIik7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGZvbnQuYXR0YWNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRm9udExvYWRpbmdBUElTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIG5hdGl2ZUZvbnRGYWNlID0gZm9udC5jcmVhdGVOYXRpdmVGb250RmFjZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCFuYXRpdmVGb250RmFjZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDc7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVGb250RmFjZS5sb2FkZWQ7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDcpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUoe1xuICAgICAgICAgICAgICAgICAgZmVhdHVyZUlkOiBfdXRpbC5VTlNVUFBPUlRFRF9GRUFUVVJFUy5lcnJvckZvbnRMb2FkTmF0aXZlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJGYWlsZWQgdG8gbG9hZCBmb250ICdcIi5jb25jYXQobmF0aXZlRm9udEZhY2UuZmFtaWx5LCBcIic6ICdcIikuY29uY2F0KF9jb250ZXh0LnQwLCBcIicuXCIpKTtcbiAgICAgICAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQudDA7XG5cbiAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMTk6XG4gICAgICAgICAgICAgICAgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gX3RoaXMyLl9xdWV1ZUxvYWRpbmdDYWxsYmFjayhyZXNvbHZlKTtcblxuICAgICAgICAgICAgICAgICAgX3RoaXMyLl9wcmVwYXJlRm9udExvYWRFdmVudChbcnVsZV0sIFtmb250XSwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzcsIDEyXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBiaW5kKF94KSB7XG4gICAgICAgIHJldHVybiBfYmluZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmluZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcXVldWVMb2FkaW5nQ2FsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfcXVldWVMb2FkaW5nQ2FsbGJhY2tgLlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ByZXBhcmVGb250TG9hZEV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlRm9udExvYWRFdmVudChydWxlcywgZm9udHNUb0xvYWQsIHJlcXVlc3QpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYF9wcmVwYXJlRm9udExvYWRFdmVudGAuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgc3VwcG9ydGVkID0gdHlwZW9mIHRoaXMuX2RvY3VtZW50ICE9PSBcInVuZGVmaW5lZFwiICYmICEhdGhpcy5fZG9jdW1lbnQuZm9udHM7XG4gICAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkXCIsIHN1cHBvcnRlZCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZGAuXCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfbG9hZFRlc3RGb250XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfbG9hZFRlc3RGb250YC5cIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VGb250TG9hZGVyO1xufSgpO1xuXG52YXIgRm9udExvYWRlcjtcbmV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XG57XG4gIGV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9CYXNlRm9udExvYWRlcikge1xuICAgIF9pbmhlcml0cyhHZW5lcmljRm9udExvYWRlciwgX0Jhc2VGb250TG9hZGVyKTtcblxuICAgIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoR2VuZXJpY0ZvbnRMb2FkZXIpO1xuXG4gICAgZnVuY3Rpb24gR2VuZXJpY0ZvbnRMb2FkZXIocGFyYW1zKSB7XG4gICAgICB2YXIgX3RoaXMzO1xuXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2VuZXJpY0ZvbnRMb2FkZXIpO1xuXG4gICAgICBfdGhpczMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwYXJhbXMpO1xuICAgICAgX3RoaXMzLmxvYWRpbmdDb250ZXh0ID0ge1xuICAgICAgICByZXF1ZXN0czogW10sXG4gICAgICAgIG5leHRSZXF1ZXN0SWQ6IDBcbiAgICAgIH07XG4gICAgICBfdGhpczMubG9hZFRlc3RGb250SWQgPSAwO1xuICAgICAgcmV0dXJuIF90aGlzMztcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoR2VuZXJpY0ZvbnRMb2FkZXIsIFt7XG4gICAgICBrZXk6IFwiX3F1ZXVlTG9hZGluZ0NhbGxiYWNrXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3F1ZXVlTG9hZGluZ0NhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlUmVxdWVzdCgpIHtcbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgICAgIHJlcXVlc3QuZG9uZSA9IHRydWU7XG5cbiAgICAgICAgICB3aGlsZSAoY29udGV4dC5yZXF1ZXN0cy5sZW5ndGggPiAwICYmIGNvbnRleHQucmVxdWVzdHNbMF0uZG9uZSkge1xuICAgICAgICAgICAgdmFyIG90aGVyUmVxdWVzdCA9IGNvbnRleHQucmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQob3RoZXJSZXF1ZXN0LmNhbGxiYWNrLCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29udGV4dCA9IHRoaXMubG9hZGluZ0NvbnRleHQ7XG4gICAgICAgIHZhciByZXF1ZXN0ID0ge1xuICAgICAgICAgIGlkOiBcInBkZmpzLWZvbnQtbG9hZGluZy1cIi5jb25jYXQoY29udGV4dC5uZXh0UmVxdWVzdElkKyspLFxuICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgIGNvbXBsZXRlOiBjb21wbGV0ZVJlcXVlc3QsXG4gICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrXG4gICAgICAgIH07XG4gICAgICAgIGNvbnRleHQucmVxdWVzdHMucHVzaChyZXF1ZXN0KTtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9wcmVwYXJlRm9udExvYWRFdmVudFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlRm9udExvYWRFdmVudChydWxlcywgZm9udHMsIHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGEuY2hhckNvZGVBdChvZmZzZXQpIDw8IDI0IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDEpIDw8IDE2IHwgZGF0YS5jaGFyQ29kZUF0KG9mZnNldCArIDIpIDw8IDggfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMykgJiAweGZmO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gc3BsaWNlU3RyaW5nKHMsIG9mZnNldCwgcmVtb3ZlLCBpbnNlcnQpIHtcbiAgICAgICAgICB2YXIgY2h1bmsxID0gcy5zdWJzdHJpbmcoMCwgb2Zmc2V0KTtcbiAgICAgICAgICB2YXIgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgICAgICByZXR1cm4gY2h1bmsxICsgaW5zZXJ0ICsgY2h1bmsyO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGksIGlpO1xuXG4gICAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgICAgdmFyIGNhbGxlZCA9IDA7XG5cbiAgICAgICAgZnVuY3Rpb24gaXNGb250UmVhZHkobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsZWQrKztcblxuICAgICAgICAgIGlmIChjYWxsZWQgPiAzMCkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgICAgIGN0eC5maWxsVGV4dChcIi5cIiwgMCwgMjApO1xuICAgICAgICAgIHZhciBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuXG4gICAgICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2FkVGVzdEZvbnRJZCA9IFwibHRcIi5jb25jYXQoRGF0ZS5ub3coKSkuY29uY2F0KHRoaXMubG9hZFRlc3RGb250SWQrKyk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5fbG9hZFRlc3RGb250O1xuICAgICAgICB2YXIgQ09NTUVOVF9PRkZTRVQgPSA5NzY7XG4gICAgICAgIGRhdGEgPSBzcGxpY2VTdHJpbmcoZGF0YSwgQ09NTUVOVF9PRkZTRVQsIGxvYWRUZXN0Rm9udElkLmxlbmd0aCwgbG9hZFRlc3RGb250SWQpO1xuICAgICAgICB2YXIgQ0ZGX0NIRUNLU1VNX09GRlNFVCA9IDE2O1xuICAgICAgICB2YXIgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IGludDMyKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gbG9hZFRlc3RGb250SWQubGVuZ3RoIC0gMzsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgICBjaGVja3N1bSA9IGNoZWNrc3VtIC0gWFhYWF9WQUxVRSArIGludDMyKGxvYWRUZXN0Rm9udElkLCBpKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgICAgIGNoZWNrc3VtID0gY2hlY2tzdW0gLSBYWFhYX1ZBTFVFICsgaW50MzIobG9hZFRlc3RGb250SWQgKyBcIlhYWFwiLCBpKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENGRl9DSEVDS1NVTV9PRkZTRVQsIDQsICgwLCBfdXRpbC5zdHJpbmczMikoY2hlY2tzdW0pKTtcbiAgICAgICAgdmFyIHVybCA9IFwidXJsKGRhdGE6Zm9udC9vcGVudHlwZTtiYXNlNjQsXCIuY29uY2F0KGJ0b2EoZGF0YSksIFwiKTtcIik7XG4gICAgICAgIHZhciBydWxlID0gXCJAZm9udC1mYWNlIHtmb250LWZhbWlseTpcXFwiXCIuY29uY2F0KGxvYWRUZXN0Rm9udElkLCBcIlxcXCI7c3JjOlwiKS5jb25jYXQodXJsLCBcIn1cIik7XG4gICAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgICAgdmFyIG5hbWVzID0gW107XG5cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBmb250cy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgbmFtZXMucHVzaChmb250c1tpXS5sb2FkZWROYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWVzLnB1c2gobG9hZFRlc3RGb250SWQpO1xuXG4gICAgICAgIHZhciBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgICAgIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLmhlaWdodCA9IFwiMTBweFwiO1xuICAgICAgICBkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIGRpdi5zdHlsZS50b3AgPSBkaXYuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG5cbiAgICAgICAgZm9yIChpID0gMCwgaWkgPSBuYW1lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcblxuICAgICAgICAgIHNwYW4udGV4dENvbnRlbnQgPSBcIkhpXCI7XG4gICAgICAgICAgc3Bhbi5zdHlsZS5mb250RmFtaWx5ID0gbmFtZXNbaV07XG4gICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0Ll9kb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGRpdik7XG5cbiAgICAgICAgICByZXF1ZXN0LmNvbXBsZXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJpc1N5bmNGb250TG9hZGluZ1N1cHBvcnRlZFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBzdXBwb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG0gPSAvTW96aWxsYVxcLzUuMC4qP3J2OihcXGQrKS4qPyBHZWNrby8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAgICAgICAgIGlmIChtICYmIG1bMV0gPj0gMTQpIHtcbiAgICAgICAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgc3VwcG9ydGVkKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2xvYWRUZXN0Rm9udFwiLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHZhciBnZXRMb2FkVGVzdEZvbnQgPSBmdW5jdGlvbiBnZXRMb2FkVGVzdEZvbnQoKSB7XG4gICAgICAgICAgcmV0dXJuIGF0b2IoXCJUMVJVVHdBTEFJQUFBd0F3UTBaR0lESHRaZzRBQUFPWUFBQUFnVVpHVkUxbGt6WndBQUFFSEFBQUFCeEhSRVZHQUJRQVwiICsgXCJGUUFBQkRnQUFBQWVUMU12TWxZTll3a0FBQUVnQUFBQVlHTnRZWEFCRFFMVUFBQUNOQUFBQVVKb1pXRmsveFZGRFFBQVwiICsgXCJBTHdBQUFBMmFHaGxZUWRrQStvQUFBRDBBQUFBSkdodGRIZ0Q2QUFBQUFBRVdBQUFBQVp0WVhod0FBSlFBQUFBQVJnQVwiICsgXCJBQUFHYm1GdFpWam1kSDRBQUFHQUFBQUFzWEJ2YzNUL2hnQXpBQUFEZUFBQUFDQUFBUUFBQUFFQUFMWlJGc1JmRHp6MVwiICsgXCJBQXNENkFBQUFBRE9CT1RMQUFBQUFNNEtIRHdBQUFBQUErZ0RJUUFBQUFnQUFnQUFBQUFBQUFBQkFBQURJUUFBQUZvRFwiICsgXCI2QUFBQUFBRDZBQUJBQUFBQUFBQUFBQUFBQUFBQUFBQUFRQUFVQUFBQWdBQUFBUUQ2QUgwQUFVQUFBS0tBcndBQUFDTVwiICsgXCJBb29DdkFBQUFlQUFNUUVDQUFBQ0FBWUpBQUFBQUFBQUFBQUFBUUFBQUFBQUFBQUFBQUFBQUZCbVJXUUF3QUF1QUM0RFwiICsgXCJJUDg0QUZvRElRQUFBQUFBQVFBQUFBQUFBQUFBQUNBQUlBQUJBQUFBRGdDdUFBRUFBQUFBQUFBQUFRQUFBQUVBQUFBQVwiICsgXCJBQUVBQVFBQUFBRUFBQUFBQUFJQUFRQUFBQUVBQUFBQUFBTUFBUUFBQUFFQUFBQUFBQVFBQVFBQUFBRUFBQUFBQUFVQVwiICsgXCJBUUFBQUFFQUFBQUFBQVlBQVFBQUFBTUFBUVFKQUFBQUFnQUJBQU1BQVFRSkFBRUFBZ0FCQUFNQUFRUUpBQUlBQWdBQlwiICsgXCJBQU1BQVFRSkFBTUFBZ0FCQUFNQUFRUUpBQVFBQWdBQkFBTUFBUVFKQUFVQUFnQUJBQU1BQVFRSkFBWUFBZ0FCV0FCWVwiICsgXCJBQUFBQUFBQUF3QUFBQU1BQUFBY0FBRUFBQUFBQUR3QUF3QUJBQUFBSEFBRUFDQUFBQUFFQUFRQUFRQUFBQzcvL3dBQVwiICsgXCJBQzcvLy8vVEFBRUFBQUFBQUFBQkJnQUFBUUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFFQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFNQUFBQUFBQUQvZ3dBeUFBQUFBUUFBQUFBQUFBQUFBQUFBQUFBQVwiICsgXCJBQUFCQUFRRUFBRUJBUUpZQUFFQkFTSDREd0Q0R3dIRUF2Z2NBL2dYQkl3TUFZdUwrbno1dFFYa0Q1ajNDQkxuRVFBQ1wiICsgXCJBUUVCSVZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlBQUFCQVFBQUR3QUNBUUVFRS90M1wiICsgXCJEb3Y2ZkFINmZBVCtmUHA4K253SERvc01Ddm0xQ3ZtMURBejZmQlFBQUFBQUFBQUJBQUFBQU1tSmJ6RUFBQUFBemdUalwiICsgXCJGUUFBQUFET0JPUXBBQUVBQUFBQUFBQUFEQUFVQUFRQUFBQUJBQUFBQWdBQkFBQUFBQUFBQUFBRDZBQUFBQUFBQUE9PVwiKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfbG9hZFRlc3RGb250XCIsIGdldExvYWRUZXN0Rm9udCgpKTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gR2VuZXJpY0ZvbnRMb2FkZXI7XG4gIH0oQmFzZUZvbnRMb2FkZXIpO1xufVxuXG52YXIgRm9udEZhY2VPYmplY3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb250RmFjZU9iamVjdCh0cmFuc2xhdGVkRGF0YSwgX3JlZjIpIHtcbiAgICB2YXIgX3JlZjIkaXNFdmFsU3VwcG9ydGVkID0gX3JlZjIuaXNFdmFsU3VwcG9ydGVkLFxuICAgICAgICBpc0V2YWxTdXBwb3J0ZWQgPSBfcmVmMiRpc0V2YWxTdXBwb3J0ZWQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmMiRpc0V2YWxTdXBwb3J0ZWQsXG4gICAgICAgIF9yZWYyJGRpc2FibGVGb250RmFjZSA9IF9yZWYyLmRpc2FibGVGb250RmFjZSxcbiAgICAgICAgZGlzYWJsZUZvbnRGYWNlID0gX3JlZjIkZGlzYWJsZUZvbnRGYWNlID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGRpc2FibGVGb250RmFjZSxcbiAgICAgICAgX3JlZjIkaWdub3JlRXJyb3JzID0gX3JlZjIuaWdub3JlRXJyb3JzLFxuICAgICAgICBpZ25vcmVFcnJvcnMgPSBfcmVmMiRpZ25vcmVFcnJvcnMgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkaWdub3JlRXJyb3JzLFxuICAgICAgICBfcmVmMiRvblVuc3VwcG9ydGVkRmUgPSBfcmVmMi5vblVuc3VwcG9ydGVkRmVhdHVyZSxcbiAgICAgICAgb25VbnN1cHBvcnRlZEZlYXR1cmUgPSBfcmVmMiRvblVuc3VwcG9ydGVkRmUgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmMiRvblVuc3VwcG9ydGVkRmUsXG4gICAgICAgIF9yZWYyJGZvbnRSZWdpc3RyeSA9IF9yZWYyLmZvbnRSZWdpc3RyeSxcbiAgICAgICAgZm9udFJlZ2lzdHJ5ID0gX3JlZjIkZm9udFJlZ2lzdHJ5ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjIkZm9udFJlZ2lzdHJ5O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZvbnRGYWNlT2JqZWN0KTtcblxuICAgIHRoaXMuY29tcGlsZWRHbHlwaHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgZm9yICh2YXIgaSBpbiB0cmFuc2xhdGVkRGF0YSkge1xuICAgICAgdGhpc1tpXSA9IHRyYW5zbGF0ZWREYXRhW2ldO1xuICAgIH1cblxuICAgIHRoaXMuaXNFdmFsU3VwcG9ydGVkID0gaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgICB0aGlzLmRpc2FibGVGb250RmFjZSA9IGRpc2FibGVGb250RmFjZSA9PT0gdHJ1ZTtcbiAgICB0aGlzLmlnbm9yZUVycm9ycyA9IGlnbm9yZUVycm9ycyA9PT0gdHJ1ZTtcbiAgICB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZSA9IG9uVW5zdXBwb3J0ZWRGZWF0dXJlO1xuICAgIHRoaXMuZm9udFJlZ2lzdHJ5ID0gZm9udFJlZ2lzdHJ5O1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZvbnRGYWNlT2JqZWN0LCBbe1xuICAgIGtleTogXCJjcmVhdGVOYXRpdmVGb250RmFjZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVOYXRpdmVGb250RmFjZSgpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmF0aXZlRm9udEZhY2UgPSBuZXcgRm9udEZhY2UodGhpcy5sb2FkZWROYW1lLCB0aGlzLmRhdGEsIHt9KTtcblxuICAgICAgaWYgKHRoaXMuZm9udFJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuZm9udFJlZ2lzdHJ5LnJlZ2lzdGVyRm9udCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZUZvbnRGYWNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVGb250RmFjZVJ1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gKDAsIF91dGlsLmJ5dGVzVG9TdHJpbmcpKG5ldyBVaW50OEFycmF5KHRoaXMuZGF0YSkpO1xuICAgICAgdmFyIHVybCA9IFwidXJsKGRhdGE6XCIuY29uY2F0KHRoaXMubWltZXR5cGUsIFwiO2Jhc2U2NCxcIikuY29uY2F0KGJ0b2EoZGF0YSksIFwiKTtcIik7XG4gICAgICB2YXIgcnVsZSA9IFwiQGZvbnQtZmFjZSB7Zm9udC1mYW1pbHk6XFxcIlwiLmNvbmNhdCh0aGlzLmxvYWRlZE5hbWUsIFwiXFxcIjtzcmM6XCIpLmNvbmNhdCh1cmwsIFwifVwiKTtcblxuICAgICAgaWYgKHRoaXMuZm9udFJlZ2lzdHJ5KSB7XG4gICAgICAgIHRoaXMuZm9udFJlZ2lzdHJ5LnJlZ2lzdGVyRm9udCh0aGlzLCB1cmwpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGF0aEdlbmVyYXRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQYXRoR2VuZXJhdG9yKG9ianMsIGNoYXJhY3Rlcikge1xuICAgICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl07XG4gICAgICB9XG5cbiAgICAgIHZhciBjbWRzLCBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBjbWRzID0gb2Jqcy5nZXQodGhpcy5sb2FkZWROYW1lICsgXCJfcGF0aF9cIiArIGNoYXJhY3Rlcik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBpZiAoIXRoaXMuaWdub3JlRXJyb3JzKSB7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fb25VbnN1cHBvcnRlZEZlYXR1cmUpIHtcbiAgICAgICAgICB0aGlzLl9vblVuc3VwcG9ydGVkRmVhdHVyZSh7XG4gICAgICAgICAgICBmZWF0dXJlSWQ6IF91dGlsLlVOU1VQUE9SVEVEX0ZFQVRVUkVTLmVycm9yRm9udEdldFBhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcImdldFBhdGhHZW5lcmF0b3IgLSBpZ25vcmluZyBjaGFyYWN0ZXI6IFxcXCJcIi5jb25jYXQoZXgsIFwiXFxcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHt9O1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0V2YWxTdXBwb3J0ZWQgJiYgX3V0aWwuSXNFdmFsU3VwcG9ydGVkQ2FjaGVkLnZhbHVlKSB7XG4gICAgICAgIHZhciBhcmdzLFxuICAgICAgICAgICAganMgPSBcIlwiO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGNtZHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICAgIGN1cnJlbnQgPSBjbWRzW2ldO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQuYXJncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcmdzID0gY3VycmVudC5hcmdzLmpvaW4oXCIsXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcmdzID0gXCJcIjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBqcyArPSBcImMuXCIgKyBjdXJyZW50LmNtZCArIFwiKFwiICsgYXJncyArIFwiKTtcXG5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBuZXcgRnVuY3Rpb24oXCJjXCIsIFwic2l6ZVwiLCBqcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBmdW5jdGlvbiAoYywgc2l6ZSkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9paSA9IGNtZHMubGVuZ3RoOyBfaSA8IF9paTsgX2krKykge1xuICAgICAgICAgIGN1cnJlbnQgPSBjbWRzW19pXTtcblxuICAgICAgICAgIGlmIChjdXJyZW50LmNtZCA9PT0gXCJzY2FsZVwiKSB7XG4gICAgICAgICAgICBjdXJyZW50LmFyZ3MgPSBbc2l6ZSwgLXNpemVdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNbY3VycmVudC5jbWRdLmFwcGx5KGMsIGN1cnJlbnQuYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEZvbnRGYWNlT2JqZWN0O1xufSgpO1xuXG5leHBvcnRzLkZvbnRGYWNlT2JqZWN0ID0gRm9udEZhY2VPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMjA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IGV4cG9ydHMuTm9kZUNhbnZhc0ZhY3RvcnkgPSB2b2lkIDA7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiKSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfTsgfSBlbHNlIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyB9IHJldHVybiBfdHlwZW9mKG9iaik7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIE5vZGVDYW52YXNGYWN0b3J5ID0gZnVuY3Rpb24gTm9kZUNhbnZhc0ZhY3RvcnkoKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQ2FudmFzRmFjdG9yeSk7XG5cbiAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZDogTm9kZUNhbnZhc0ZhY3RvcnlcIik7XG59O1xuXG5leHBvcnRzLk5vZGVDYW52YXNGYWN0b3J5ID0gTm9kZUNhbnZhc0ZhY3Rvcnk7XG5cbnZhciBOb2RlQ01hcFJlYWRlckZhY3RvcnkgPSBmdW5jdGlvbiBOb2RlQ01hcFJlYWRlckZhY3RvcnkoKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQ01hcFJlYWRlckZhY3RvcnkpO1xuXG4gICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJOb3QgaW1wbGVtZW50ZWQ6IE5vZGVDTWFwUmVhZGVyRmFjdG9yeVwiKTtcbn07XG5cbmV4cG9ydHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5ID0gTm9kZUNNYXBSZWFkZXJGYWN0b3J5O1xuXG5pZiAoX2lzX25vZGUuaXNOb2RlSlMpIHtcbiAgZXhwb3J0cy5Ob2RlQ2FudmFzRmFjdG9yeSA9IE5vZGVDYW52YXNGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUNhbnZhc0ZhY3RvcnkpIHtcbiAgICBfaW5oZXJpdHMoTm9kZUNhbnZhc0ZhY3RvcnksIF9CYXNlQ2FudmFzRmFjdG9yeSk7XG5cbiAgICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKE5vZGVDYW52YXNGYWN0b3J5KTtcblxuICAgIGZ1bmN0aW9uIE5vZGVDYW52YXNGYWN0b3J5KCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVDYW52YXNGYWN0b3J5KTtcblxuICAgICAgcmV0dXJuIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhOb2RlQ2FudmFzRmFjdG9yeSwgW3tcbiAgICAgIGtleTogXCJjcmVhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgY2FudmFzIHNpemVcIik7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgQ2FudmFzID0gcmVxdWlyZShcImNhbnZhc1wiKTtcblxuICAgICAgICB2YXIgY2FudmFzID0gQ2FudmFzLmNyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIE5vZGVDYW52YXNGYWN0b3J5O1xuICB9KF9kaXNwbGF5X3V0aWxzLkJhc2VDYW52YXNGYWN0b3J5KTtcblxuICBleHBvcnRzLk5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IE5vZGVDTWFwUmVhZGVyRmFjdG9yeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VDTWFwUmVhZGVyRmFjdG9yKSB7XG4gICAgX2luaGVyaXRzKE5vZGVDTWFwUmVhZGVyRmFjdG9yeSwgX0Jhc2VDTWFwUmVhZGVyRmFjdG9yKTtcblxuICAgIHZhciBfc3VwZXIyID0gX2NyZWF0ZVN1cGVyKE5vZGVDTWFwUmVhZGVyRmFjdG9yeSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlQ01hcFJlYWRlckZhY3RvcnkoKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUNNYXBSZWFkZXJGYWN0b3J5KTtcblxuICAgICAgcmV0dXJuIF9zdXBlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBfY3JlYXRlQ2xhc3MoTm9kZUNNYXBSZWFkZXJGYWN0b3J5LCBbe1xuICAgICAga2V5OiBcIl9mZXRjaERhdGFcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xuXG4gICAgICAgICAgZnMucmVhZEZpbGUodXJsLCBmdW5jdGlvbiAoZXJyb3IsIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciB8fCAhZGF0YSkge1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVycm9yKSk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIGNNYXBEYXRhOiBuZXcgVWludDhBcnJheShkYXRhKSxcbiAgICAgICAgICAgICAgY29tcHJlc3Npb25UeXBlOiBjb21wcmVzc2lvblR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG5cbiAgICByZXR1cm4gTm9kZUNNYXBSZWFkZXJGYWN0b3J5O1xuICB9KF9kaXNwbGF5X3V0aWxzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSk7XG59XG5cbi8qKiovIH0pLFxuLyogMjA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkFubm90YXRpb25TdG9yYWdlID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBBbm5vdGF0aW9uU3RvcmFnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uU3RvcmFnZSk7XG5cbiAgICB0aGlzLl9zdG9yYWdlID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX21vZGlmaWVkID0gZmFsc2U7XG4gICAgdGhpcy5vblNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQW5ub3RhdGlvblN0b3JhZ2UsIFt7XG4gICAga2V5OiBcImdldE9yQ3JlYXRlVmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0T3JDcmVhdGVWYWx1ZShrZXksIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3N0b3JhZ2UuaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0b3JhZ2Uuc2V0KGtleSwgZGVmYXVsdFZhbHVlKTtcblxuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VmFsdWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3N0b3JhZ2UuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldE1vZGlmaWVkKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0b3JhZ2Uuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRBbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWxsKCkge1xuICAgICAgaWYgKHRoaXMuX3N0b3JhZ2Uuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyh0aGlzLl9zdG9yYWdlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldE1vZGlmaWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRNb2RpZmllZCgpIHtcbiAgICAgIGlmICghdGhpcy5fbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5fbW9kaWZpZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLm9uU2V0TW9kaWZpZWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZXNldE1vZGlmaWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0TW9kaWZpZWQoKSB7XG4gICAgICBpZiAodGhpcy5fbW9kaWZpZWQpIHtcbiAgICAgICAgdGhpcy5fbW9kaWZpZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub25SZXNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0aGlzLm9uUmVzZXRNb2RpZmllZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpemVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdG9yYWdlLnNpemU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFubm90YXRpb25TdG9yYWdlO1xufSgpO1xuXG5leHBvcnRzLkFubm90YXRpb25TdG9yYWdlID0gQW5ub3RhdGlvblN0b3JhZ2U7XG5cbi8qKiovIH0pLFxuLyogMjA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmFwaUNvbXBhdGliaWxpdHlQYXJhbXMgPSB2b2lkIDA7XG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG5cbnZhciBjb21wYXRpYmlsaXR5UGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbntcbiAgKGZ1bmN0aW9uIGNoZWNrRm9udEZhY2UoKSB7XG4gICAgaWYgKF9pc19ub2RlLmlzTm9kZUpTKSB7XG4gICAgICBjb21wYXRpYmlsaXR5UGFyYW1zLmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgfVxuICB9KSgpO1xufVxudmFyIGFwaUNvbXBhdGliaWxpdHlQYXJhbXMgPSBPYmplY3QuZnJlZXplKGNvbXBhdGliaWxpdHlQYXJhbXMpO1xuZXhwb3J0cy5hcGlDb21wYXRpYmlsaXR5UGFyYW1zID0gYXBpQ29tcGF0aWJpbGl0eVBhcmFtcztcblxuLyoqKi8gfSksXG4vKiAyMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQ2FudmFzR3JhcGhpY3MgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5cbnZhciBfcGF0dGVybl9oZWxwZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwOCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbnZhciBNSU5fRk9OVF9TSVpFID0gMTY7XG52YXIgTUFYX0ZPTlRfU0laRSA9IDEwMDtcbnZhciBNQVhfR1JPVVBfU0laRSA9IDQwOTY7XG52YXIgTUlOX1dJRFRIX0ZBQ1RPUiA9IDAuNjU7XG52YXIgQ09NUElMRV9UWVBFM19HTFlQSFMgPSB0cnVlO1xudmFyIE1BWF9TSVpFX1RPX0NPTVBJTEUgPSAxMDAwO1xudmFyIEZVTExfQ0hVTktfSEVJR0hUID0gMTY7XG5cbmZ1bmN0aW9uIGFkZENvbnRleHRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBpZiAoIWN0eC5tb3pDdXJyZW50VHJhbnNmb3JtKSB7XG4gICAgY3R4Ll9vcmlnaW5hbFNhdmUgPSBjdHguc2F2ZTtcbiAgICBjdHguX29yaWdpbmFsUmVzdG9yZSA9IGN0eC5yZXN0b3JlO1xuICAgIGN0eC5fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICAgIGN0eC5fb3JpZ2luYWxTY2FsZSA9IGN0eC5zY2FsZTtcbiAgICBjdHguX29yaWdpbmFsVHJhbnNsYXRlID0gY3R4LnRyYW5zbGF0ZTtcbiAgICBjdHguX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgICBjdHguX29yaWdpbmFsU2V0VHJhbnNmb3JtID0gY3R4LnNldFRyYW5zZm9ybTtcbiAgICBjdHguX3RyYW5zZm9ybU1hdHJpeCA9IGN0eC5fdHJhbnNmb3JtTWF0cml4IHx8IFsxLCAwLCAwLCAxLCAwLCAwXTtcbiAgICBjdHguX3RyYW5zZm9ybVN0YWNrID0gW107XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGN0eCwgXCJtb3pDdXJyZW50VHJhbnNmb3JtXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3R4LCBcIm1vekN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlXCIsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcy5fdHJhbnNmb3JtTWF0cml4O1xuICAgICAgICB2YXIgYSA9IG1bMF0sXG4gICAgICAgICAgICBiID0gbVsxXSxcbiAgICAgICAgICAgIGMgPSBtWzJdLFxuICAgICAgICAgICAgZCA9IG1bM10sXG4gICAgICAgICAgICBlID0gbVs0XSxcbiAgICAgICAgICAgIGYgPSBtWzVdO1xuICAgICAgICB2YXIgYWRfYmMgPSBhICogZCAtIGIgKiBjO1xuICAgICAgICB2YXIgYmNfYWQgPSBiICogYyAtIGEgKiBkO1xuICAgICAgICByZXR1cm4gW2QgLyBhZF9iYywgYiAvIGJjX2FkLCBjIC8gYmNfYWQsIGEgLyBhZF9iYywgKGQgKiBlIC0gYyAqIGYpIC8gYmNfYWQsIChiICogZSAtIGEgKiBmKSAvIGFkX2JjXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGN0eC5zYXZlID0gZnVuY3Rpb24gY3R4U2F2ZSgpIHtcbiAgICAgIHZhciBvbGQgPSB0aGlzLl90cmFuc2Zvcm1NYXRyaXg7XG5cbiAgICAgIHRoaXMuX3RyYW5zZm9ybVN0YWNrLnB1c2gob2xkKTtcblxuICAgICAgdGhpcy5fdHJhbnNmb3JtTWF0cml4ID0gb2xkLnNsaWNlKDAsIDYpO1xuXG4gICAgICB0aGlzLl9vcmlnaW5hbFNhdmUoKTtcbiAgICB9O1xuXG4gICAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiBjdHhSZXN0b3JlKCkge1xuICAgICAgdmFyIHByZXYgPSB0aGlzLl90cmFuc2Zvcm1TdGFjay5wb3AoKTtcblxuICAgICAgaWYgKHByZXYpIHtcbiAgICAgICAgdGhpcy5fdHJhbnNmb3JtTWF0cml4ID0gcHJldjtcblxuICAgICAgICB0aGlzLl9vcmlnaW5hbFJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY3R4LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIGN0eFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgICB2YXIgbSA9IHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgIG1bNF0gPSBtWzBdICogeCArIG1bMl0gKiB5ICsgbVs0XTtcbiAgICAgIG1bNV0gPSBtWzFdICogeCArIG1bM10gKiB5ICsgbVs1XTtcblxuICAgICAgdGhpcy5fb3JpZ2luYWxUcmFuc2xhdGUoeCwgeSk7XG4gICAgfTtcblxuICAgIGN0eC5zY2FsZSA9IGZ1bmN0aW9uIGN0eFNjYWxlKHgsIHkpIHtcbiAgICAgIHZhciBtID0gdGhpcy5fdHJhbnNmb3JtTWF0cml4O1xuICAgICAgbVswXSA9IG1bMF0gKiB4O1xuICAgICAgbVsxXSA9IG1bMV0gKiB4O1xuICAgICAgbVsyXSA9IG1bMl0gKiB5O1xuICAgICAgbVszXSA9IG1bM10gKiB5O1xuXG4gICAgICB0aGlzLl9vcmlnaW5hbFNjYWxlKHgsIHkpO1xuICAgIH07XG5cbiAgICBjdHgudHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIHZhciBtID0gdGhpcy5fdHJhbnNmb3JtTWF0cml4O1xuICAgICAgdGhpcy5fdHJhbnNmb3JtTWF0cml4ID0gW21bMF0gKiBhICsgbVsyXSAqIGIsIG1bMV0gKiBhICsgbVszXSAqIGIsIG1bMF0gKiBjICsgbVsyXSAqIGQsIG1bMV0gKiBjICsgbVszXSAqIGQsIG1bMF0gKiBlICsgbVsyXSAqIGYgKyBtWzRdLCBtWzFdICogZSArIG1bM10gKiBmICsgbVs1XV07XG5cbiAgICAgIGN0eC5fb3JpZ2luYWxUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgfTtcblxuICAgIGN0eC5zZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbiBjdHhTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgdGhpcy5fdHJhbnNmb3JtTWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuXG4gICAgICBjdHguX29yaWdpbmFsU2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIH07XG5cbiAgICBjdHgucm90YXRlID0gZnVuY3Rpb24gY3R4Um90YXRlKGFuZ2xlKSB7XG4gICAgICB2YXIgY29zVmFsdWUgPSBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICB2YXIgc2luVmFsdWUgPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB2YXIgbSA9IHRoaXMuX3RyYW5zZm9ybU1hdHJpeDtcbiAgICAgIHRoaXMuX3RyYW5zZm9ybU1hdHJpeCA9IFttWzBdICogY29zVmFsdWUgKyBtWzJdICogc2luVmFsdWUsIG1bMV0gKiBjb3NWYWx1ZSArIG1bM10gKiBzaW5WYWx1ZSwgbVswXSAqIC1zaW5WYWx1ZSArIG1bMl0gKiBjb3NWYWx1ZSwgbVsxXSAqIC1zaW5WYWx1ZSArIG1bM10gKiBjb3NWYWx1ZSwgbVs0XSwgbVs1XV07XG5cbiAgICAgIHRoaXMuX29yaWdpbmFsUm90YXRlKGFuZ2xlKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBDYWNoZWRDYW52YXNlcyA9IGZ1bmN0aW9uIENhY2hlZENhbnZhc2VzQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQ2FjaGVkQ2FudmFzZXMoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBDYWNoZWRDYW52YXNlcy5wcm90b3R5cGUgPSB7XG4gICAgZ2V0Q2FudmFzOiBmdW5jdGlvbiBDYWNoZWRDYW52YXNlc19nZXRDYW52YXMoaWQsIHdpZHRoLCBoZWlnaHQsIHRyYWNrVHJhbnNmb3JtKSB7XG4gICAgICB2YXIgY2FudmFzRW50cnk7XG5cbiAgICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5yZXNldChjYW52YXNFbnRyeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNhbnZhc0VudHJ5LmNvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmNhY2hlW2lkXSA9IGNhbnZhc0VudHJ5O1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhY2tUcmFuc2Zvcm0pIHtcbiAgICAgICAgYWRkQ29udGV4dEN1cnJlbnRUcmFuc2Zvcm0oY2FudmFzRW50cnkuY29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjYW52YXNFbnRyeTtcbiAgICB9LFxuICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgICAgdmFyIGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICAgIHRoaXMuY2FudmFzRmFjdG9yeS5kZXN0cm95KGNhbnZhc0VudHJ5KTtcbiAgICAgICAgZGVsZXRlIHRoaXMuY2FjaGVbaWRdO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIENhY2hlZENhbnZhc2VzO1xufSgpO1xuXG5mdW5jdGlvbiBjb21waWxlVHlwZTNHbHlwaChpbWdEYXRhKSB7XG4gIHZhciBQT0lOVF9UT19QUk9DRVNTX0xJTUlUID0gMTAwMDtcbiAgdmFyIHdpZHRoID0gaW1nRGF0YS53aWR0aCxcbiAgICAgIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICB2YXIgaSxcbiAgICAgIGosXG4gICAgICBqMCxcbiAgICAgIHdpZHRoMSA9IHdpZHRoICsgMTtcbiAgdmFyIHBvaW50cyA9IG5ldyBVaW50OEFycmF5KHdpZHRoMSAqIChoZWlnaHQgKyAxKSk7XG4gIHZhciBQT0lOVF9UWVBFUyA9IG5ldyBVaW50OEFycmF5KFswLCAyLCA0LCAwLCAxLCAwLCA1LCA0LCA4LCAxMCwgMCwgOCwgMCwgMiwgMSwgMF0pO1xuICB2YXIgbGluZVNpemUgPSB3aWR0aCArIDcgJiB+NyxcbiAgICAgIGRhdGEwID0gaW1nRGF0YS5kYXRhO1xuICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxpbmVTaXplICogaGVpZ2h0KSxcbiAgICAgIHBvcyA9IDAsXG4gICAgICBpaTtcblxuICBmb3IgKGkgPSAwLCBpaSA9IGRhdGEwLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICB2YXIgbWFzayA9IDEyOCxcbiAgICAgICAgZWxlbSA9IGRhdGEwW2ldO1xuXG4gICAgd2hpbGUgKG1hc2sgPiAwKSB7XG4gICAgICBkYXRhW3BvcysrXSA9IGVsZW0gJiBtYXNrID8gMCA6IDI1NTtcbiAgICAgIG1hc2sgPj49IDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvdW50ID0gMDtcbiAgcG9zID0gMDtcblxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzWzBdID0gMTtcbiAgICArK2NvdW50O1xuICB9XG5cbiAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICBpZiAoZGF0YVtwb3NdICE9PSBkYXRhW3BvcyArIDFdKSB7XG4gICAgICBwb2ludHNbal0gPSBkYXRhW3Bvc10gPyAyIDogMTtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuXG4gICAgcG9zKys7XG4gIH1cblxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2pdID0gMjtcbiAgICArK2NvdW50O1xuICB9XG5cbiAgZm9yIChpID0gMTsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgcG9zID0gaSAqIGxpbmVTaXplO1xuICAgIGowID0gaSAqIHdpZHRoMTtcblxuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajBdID0gZGF0YVtwb3NdID8gMSA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cblxuICAgIHZhciBzdW0gPSAoZGF0YVtwb3NdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemVdID8gOCA6IDApO1xuXG4gICAgZm9yIChqID0gMTsgaiA8IHdpZHRoOyBqKyspIHtcbiAgICAgIHN1bSA9IChzdW0gPj4gMikgKyAoZGF0YVtwb3MgKyAxXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplICsgMV0gPyA4IDogMCk7XG5cbiAgICAgIGlmIChQT0lOVF9UWVBFU1tzdW1dKSB7XG4gICAgICAgIHBvaW50c1tqMCArIGpdID0gUE9JTlRfVFlQRVNbc3VtXTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cblxuICAgICAgcG9zKys7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFbcG9zIC0gbGluZVNpemVdICE9PSBkYXRhW3Bvc10pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gMiA6IDQ7XG4gICAgICArK2NvdW50O1xuICAgIH1cblxuICAgIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHBvcyA9IGxpbmVTaXplICogKGhlaWdodCAtIDEpO1xuICBqMCA9IGkgKiB3aWR0aDE7XG5cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqMF0gPSA4O1xuICAgICsrY291bnQ7XG4gIH1cblxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gNCA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cblxuICAgIHBvcysrO1xuICB9XG5cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqMCArIGpdID0gNDtcbiAgICArK2NvdW50O1xuICB9XG5cbiAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHN0ZXBzID0gbmV3IEludDMyQXJyYXkoWzAsIHdpZHRoMSwgLTEsIDAsIC13aWR0aDEsIDAsIDAsIDAsIDFdKTtcbiAgdmFyIG91dGxpbmVzID0gW107XG5cbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIHZhciBwID0gaSAqIHdpZHRoMTtcbiAgICB2YXIgZW5kID0gcCArIHdpZHRoO1xuXG4gICAgd2hpbGUgKHAgPCBlbmQgJiYgIXBvaW50c1twXSkge1xuICAgICAgcCsrO1xuICAgIH1cblxuICAgIGlmIChwID09PSBlbmQpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBjb29yZHMgPSBbcCAlIHdpZHRoMSwgaV07XG4gICAgdmFyIHR5cGUgPSBwb2ludHNbcF0sXG4gICAgICAgIHAwID0gcCxcbiAgICAgICAgcHA7XG5cbiAgICBkbyB7XG4gICAgICB2YXIgc3RlcCA9IHN0ZXBzW3R5cGVdO1xuXG4gICAgICBkbyB7XG4gICAgICAgIHAgKz0gc3RlcDtcbiAgICAgIH0gd2hpbGUgKCFwb2ludHNbcF0pO1xuXG4gICAgICBwcCA9IHBvaW50c1twXTtcblxuICAgICAgaWYgKHBwICE9PSA1ICYmIHBwICE9PSAxMCkge1xuICAgICAgICB0eXBlID0gcHA7XG4gICAgICAgIHBvaW50c1twXSA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlID0gcHAgJiAweDMzICogdHlwZSA+PiA0O1xuICAgICAgICBwb2ludHNbcF0gJj0gdHlwZSA+PiAyIHwgdHlwZSA8PCAyO1xuICAgICAgfVxuXG4gICAgICBjb29yZHMucHVzaChwICUgd2lkdGgxKTtcbiAgICAgIGNvb3Jkcy5wdXNoKHAgLyB3aWR0aDEgfCAwKTtcblxuICAgICAgaWYgKCFwb2ludHNbcF0pIHtcbiAgICAgICAgLS1jb3VudDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwMCAhPT0gcCk7XG5cbiAgICBvdXRsaW5lcy5wdXNoKGNvb3Jkcyk7XG4gICAgLS1pO1xuICB9XG5cbiAgdmFyIGRyYXdPdXRsaW5lID0gZnVuY3Rpb24gZHJhd091dGxpbmUoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5iZWdpblBhdGgoKTtcblxuICAgIGZvciAodmFyIGsgPSAwLCBrayA9IG91dGxpbmVzLmxlbmd0aDsgayA8IGtrOyBrKyspIHtcbiAgICAgIHZhciBvID0gb3V0bGluZXNba107XG4gICAgICBjLm1vdmVUbyhvWzBdLCBvWzFdKTtcblxuICAgICAgZm9yICh2YXIgbCA9IDIsIGxsID0gby5sZW5ndGg7IGwgPCBsbDsgbCArPSAyKSB7XG4gICAgICAgIGMubGluZVRvKG9bbF0sIG9bbCArIDFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjLmZpbGwoKTtcbiAgICBjLmJlZ2luUGF0aCgpO1xuICAgIGMucmVzdG9yZSgpO1xuICB9O1xuXG4gIHJldHVybiBkcmF3T3V0bGluZTtcbn1cblxudmFyIENhbnZhc0V4dHJhU3RhdGUgPSBmdW5jdGlvbiBDYW52YXNFeHRyYVN0YXRlQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gQ2FudmFzRXh0cmFTdGF0ZSgpIHtcbiAgICB0aGlzLmFscGhhSXNTaGFwZSA9IGZhbHNlO1xuICAgIHRoaXMuZm9udFNpemUgPSAwO1xuICAgIHRoaXMuZm9udFNpemVTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIHRoaXMudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICB0aGlzLmZvbnRNYXRyaXggPSBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLmxlYWRpbmcgPSAwO1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmxpbmVYID0gMDtcbiAgICB0aGlzLmxpbmVZID0gMDtcbiAgICB0aGlzLmNoYXJTcGFjaW5nID0gMDtcbiAgICB0aGlzLndvcmRTcGFjaW5nID0gMDtcbiAgICB0aGlzLnRleHRIU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dFJlbmRlcmluZ01vZGUgPSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMO1xuICAgIHRoaXMudGV4dFJpc2UgPSAwO1xuICAgIHRoaXMuZmlsbENvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgdGhpcy5zdHJva2VDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG4gICAgdGhpcy5zdHJva2VBbHBoYSA9IDE7XG4gICAgdGhpcy5saW5lV2lkdGggPSAxO1xuICAgIHRoaXMuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIHRoaXMucmVzdW1lU01hc2tDdHggPSBudWxsO1xuICAgIHRoaXMudHJhbnNmZXJNYXBzID0gbnVsbDtcbiAgfVxuXG4gIENhbnZhc0V4dHJhU3RhdGUucHJvdG90eXBlID0ge1xuICAgIGNsb25lOiBmdW5jdGlvbiBDYW52YXNFeHRyYVN0YXRlX2Nsb25lKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgfSxcbiAgICBzZXRDdXJyZW50UG9pbnQ6IGZ1bmN0aW9uIENhbnZhc0V4dHJhU3RhdGVfc2V0Q3VycmVudFBvaW50KHgsIHkpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIENhbnZhc0V4dHJhU3RhdGU7XG59KCk7XG5cbnZhciBDYW52YXNHcmFwaGljcyA9IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzQ2xvc3VyZSgpIHtcbiAgdmFyIEVYRUNVVElPTl9USU1FID0gMTU7XG4gIHZhciBFWEVDVVRJT05fU1RFUFMgPSAxMDtcblxuICBmdW5jdGlvbiBDYW52YXNHcmFwaGljcyhjYW52YXNDdHgsIGNvbW1vbk9ianMsIG9ianMsIGNhbnZhc0ZhY3RvcnksIHdlYkdMQ29udGV4dCwgaW1hZ2VMYXllciwgb3B0aW9uYWxDb250ZW50Q29uZmlnKSB7XG4gICAgdGhpcy5jdHggPSBjYW52YXNDdHg7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUoKTtcbiAgICB0aGlzLnN0YXRlU3RhY2sgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgdGhpcy54b2JqcyA9IG51bGw7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy53ZWJHTENvbnRleHQgPSB3ZWJHTENvbnRleHQ7XG4gICAgdGhpcy5pbWFnZUxheWVyID0gaW1hZ2VMYXllcjtcbiAgICB0aGlzLmdyb3VwU3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdHJ1ZTtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjayA9IFtdO1xuICAgIHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnID0gb3B0aW9uYWxDb250ZW50Q29uZmlnO1xuICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMgPSBuZXcgQ2FjaGVkQ2FudmFzZXModGhpcy5jYW52YXNGYWN0b3J5KTtcblxuICAgIGlmIChjYW52YXNDdHgpIHtcbiAgICAgIGFkZENvbnRleHRDdXJyZW50VHJhbnNmb3JtKGNhbnZhc0N0eCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwdXRCaW5hcnlJbWFnZURhdGEoY3R4LCBpbWdEYXRhKSB7XG4gICAgdmFyIHRyYW5zZmVyTWFwcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgICAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgdmFyIHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIHZhciBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB2YXIgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gICAgdmFyIGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB2YXIgc3JjUG9zID0gMCxcbiAgICAgICAgZGVzdFBvcztcbiAgICB2YXIgc3JjID0gaW1nRGF0YS5kYXRhO1xuICAgIHZhciBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gICAgdmFyIGksIGosIHRoaXNDaHVua0hlaWdodCwgZWxlbXNJblRoaXNDaHVuaztcbiAgICB2YXIgdHJhbnNmZXJNYXBSZWQsIHRyYW5zZmVyTWFwR3JlZW4sIHRyYW5zZmVyTWFwQmx1ZSwgdHJhbnNmZXJNYXBHcmF5O1xuXG4gICAgaWYgKHRyYW5zZmVyTWFwcykge1xuICAgICAgc3dpdGNoICh0cmFuc2Zlck1hcHMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB0cmFuc2Zlck1hcFJlZCA9IHRyYW5zZmVyTWFwc1swXTtcbiAgICAgICAgICB0cmFuc2Zlck1hcEdyZWVuID0gdHJhbnNmZXJNYXBzWzBdO1xuICAgICAgICAgIHRyYW5zZmVyTWFwQmx1ZSA9IHRyYW5zZmVyTWFwc1swXTtcbiAgICAgICAgICB0cmFuc2Zlck1hcEdyYXkgPSB0cmFuc2Zlck1hcHNbMF07XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHRyYW5zZmVyTWFwUmVkID0gdHJhbnNmZXJNYXBzWzBdO1xuICAgICAgICAgIHRyYW5zZmVyTWFwR3JlZW4gPSB0cmFuc2Zlck1hcHNbMV07XG4gICAgICAgICAgdHJhbnNmZXJNYXBCbHVlID0gdHJhbnNmZXJNYXBzWzJdO1xuICAgICAgICAgIHRyYW5zZmVyTWFwR3JheSA9IHRyYW5zZmVyTWFwc1szXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFApIHtcbiAgICAgIHZhciBzcmNMZW5ndGggPSBzcmMuYnl0ZUxlbmd0aDtcbiAgICAgIHZhciBkZXN0MzIgPSBuZXcgVWludDMyQXJyYXkoZGVzdC5idWZmZXIsIDAsIGRlc3QuYnl0ZUxlbmd0aCA+PiAyKTtcbiAgICAgIHZhciBkZXN0MzJEYXRhTGVuZ3RoID0gZGVzdDMyLmxlbmd0aDtcbiAgICAgIHZhciBmdWxsU3JjRGlmZiA9IHdpZHRoICsgNyA+PiAzO1xuICAgICAgdmFyIHdoaXRlID0gMHhmZmZmZmZmZjtcbiAgICAgIHZhciBibGFjayA9IF91dGlsLklzTGl0dGxlRW5kaWFuQ2FjaGVkLnZhbHVlID8gMHhmZjAwMDAwMCA6IDB4MDAwMDAwZmY7XG5cbiAgICAgIGlmICh0cmFuc2Zlck1hcEdyYXkpIHtcbiAgICAgICAgaWYgKHRyYW5zZmVyTWFwR3JheVswXSA9PT0gMHhmZiAmJiB0cmFuc2Zlck1hcEdyYXlbMHhmZl0gPT09IDApIHtcbiAgICAgICAgICB2YXIgX3JlZiA9IFtibGFjaywgd2hpdGVdO1xuICAgICAgICAgIHdoaXRlID0gX3JlZlswXTtcbiAgICAgICAgICBibGFjayA9IF9yZWZbMV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHRvdGFsQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgICAgZGVzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgICAgdmFyIHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgICAgdmFyIGsgPSAwO1xuICAgICAgICAgIHZhciBrRW5kID0gc3JjRGlmZiA+IGZ1bGxTcmNEaWZmID8gd2lkdGggOiBzcmNEaWZmICogOCAtIDc7XG4gICAgICAgICAgdmFyIGtFbmRVbnJvbGxlZCA9IGtFbmQgJiB+NztcbiAgICAgICAgICB2YXIgbWFzayA9IDA7XG4gICAgICAgICAgdmFyIHNyY0J5dGUgPSAwO1xuXG4gICAgICAgICAgZm9yICg7IGsgPCBrRW5kVW5yb2xsZWQ7IGsgKz0gOCkge1xuICAgICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxMjggPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgNjQgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTYgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgOCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMSA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yICg7IGsgPCBrRW5kOyBrKyspIHtcbiAgICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICAgIHNyY0J5dGUgPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgICAgICBtYXNrID0gMTI4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiBtYXNrID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKGRlc3RQb3MgPCBkZXN0MzJEYXRhTGVuZ3RoKSB7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbWdEYXRhLmtpbmQgPT09IF91dGlsLkltYWdlS2luZC5SR0JBXzMyQlBQKSB7XG4gICAgICB2YXIgaGFzVHJhbnNmZXJNYXBzID0gISEodHJhbnNmZXJNYXBSZWQgfHwgdHJhbnNmZXJNYXBHcmVlbiB8fCB0cmFuc2Zlck1hcEJsdWUpO1xuICAgICAgaiA9IDA7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiBGVUxMX0NIVU5LX0hFSUdIVCAqIDQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBmdWxsQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgZGVzdC5zZXQoc3JjLnN1YmFycmF5KHNyY1Bvcywgc3JjUG9zICsgZWxlbXNJblRoaXNDaHVuaykpO1xuICAgICAgICBzcmNQb3MgKz0gZWxlbXNJblRoaXNDaHVuaztcblxuICAgICAgICBpZiAoaGFzVHJhbnNmZXJNYXBzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IGVsZW1zSW5UaGlzQ2h1bms7IF9rICs9IDQpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcFJlZCkge1xuICAgICAgICAgICAgICBkZXN0W19rICsgMF0gPSB0cmFuc2Zlck1hcFJlZFtkZXN0W19rICsgMF1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBHcmVlbikge1xuICAgICAgICAgICAgICBkZXN0W19rICsgMV0gPSB0cmFuc2Zlck1hcEdyZWVuW2Rlc3RbX2sgKyAxXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEJsdWUpIHtcbiAgICAgICAgICAgICAgZGVzdFtfayArIDJdID0gdHJhbnNmZXJNYXBCbHVlW2Rlc3RbX2sgKyAyXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgICBqICs9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA8IHRvdGFsQ2h1bmtzKSB7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHBhcnRpYWxDaHVua0hlaWdodCAqIDQ7XG4gICAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNQb3MsIHNyY1BvcyArIGVsZW1zSW5UaGlzQ2h1bmspKTtcblxuICAgICAgICBpZiAoaGFzVHJhbnNmZXJNYXBzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2syID0gMDsgX2syIDwgZWxlbXNJblRoaXNDaHVuazsgX2syICs9IDQpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcFJlZCkge1xuICAgICAgICAgICAgICBkZXN0W19rMiArIDBdID0gdHJhbnNmZXJNYXBSZWRbZGVzdFtfazIgKyAwXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEdyZWVuKSB7XG4gICAgICAgICAgICAgIGRlc3RbX2syICsgMV0gPSB0cmFuc2Zlck1hcEdyZWVuW2Rlc3RbX2syICsgMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBCbHVlKSB7XG4gICAgICAgICAgICAgIGRlc3RbX2syICsgMl0gPSB0cmFuc2Zlck1hcEJsdWVbZGVzdFtfazIgKyAyXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuUkdCXzI0QlBQKSB7XG4gICAgICB2YXIgX2hhc1RyYW5zZmVyTWFwcyA9ICEhKHRyYW5zZmVyTWFwUmVkIHx8IHRyYW5zZmVyTWFwR3JlZW4gfHwgdHJhbnNmZXJNYXBCbHVlKTtcblxuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgICBlbGVtc0luVGhpc0NodW5rID0gd2lkdGggKiB0aGlzQ2h1bmtIZWlnaHQ7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICAgIGlmIChpID49IGZ1bGxDaHVua3MpIHtcbiAgICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgICAgZWxlbXNJblRoaXNDaHVuayA9IHdpZHRoICogdGhpc0NodW5rSGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgZGVzdFBvcyA9IDA7XG5cbiAgICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOykge1xuICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICAgIGRlc3RbZGVzdFBvcysrXSA9IDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfaGFzVHJhbnNmZXJNYXBzKSB7XG4gICAgICAgICAgZm9yICh2YXIgX2szID0gMDsgX2szIDwgZGVzdFBvczsgX2szICs9IDQpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcFJlZCkge1xuICAgICAgICAgICAgICBkZXN0W19rMyArIDBdID0gdHJhbnNmZXJNYXBSZWRbZGVzdFtfazMgKyAwXV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2Zlck1hcEdyZWVuKSB7XG4gICAgICAgICAgICAgIGRlc3RbX2szICsgMV0gPSB0cmFuc2Zlck1hcEdyZWVuW2Rlc3RbX2szICsgMV1dO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHJhbnNmZXJNYXBCbHVlKSB7XG4gICAgICAgICAgICAgIGRlc3RbX2szICsgMl0gPSB0cmFuc2Zlck1hcEJsdWVbZGVzdFtfazMgKyAyXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBpbWFnZSBraW5kOiBcIi5jb25jYXQoaW1nRGF0YS5raW5kKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcHV0QmluYXJ5SW1hZ2VNYXNrKGN0eCwgaW1nRGF0YSkge1xuICAgIHZhciBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICAgICAgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIHZhciBwYXJ0aWFsQ2h1bmtIZWlnaHQgPSBoZWlnaHQgJSBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgICB2YXIgZnVsbENodW5rcyA9IChoZWlnaHQgLSBwYXJ0aWFsQ2h1bmtIZWlnaHQpIC8gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgdmFyIHRvdGFsQ2h1bmtzID0gcGFydGlhbENodW5rSGVpZ2h0ID09PSAwID8gZnVsbENodW5rcyA6IGZ1bGxDaHVua3MgKyAxO1xuICAgIHZhciBjaHVua0ltZ0RhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgdmFyIHNyY1BvcyA9IDA7XG4gICAgdmFyIHNyYyA9IGltZ0RhdGEuZGF0YTtcbiAgICB2YXIgZGVzdCA9IGNodW5rSW1nRGF0YS5kYXRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b3RhbENodW5rczsgaSsrKSB7XG4gICAgICB2YXIgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIHZhciBkZXN0UG9zID0gMztcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzQ2h1bmtIZWlnaHQ7IGorKykge1xuICAgICAgICB2YXIgbWFzayA9IDA7XG5cbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB3aWR0aDsgaysrKSB7XG4gICAgICAgICAgaWYgKCFtYXNrKSB7XG4gICAgICAgICAgICB2YXIgZWxlbSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgICBtYXNrID0gMTI4O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRlc3RbZGVzdFBvc10gPSBlbGVtICYgbWFzayA/IDAgOiAyNTU7XG4gICAgICAgICAgZGVzdFBvcyArPSA0O1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29weUN0eFN0YXRlKHNvdXJjZUN0eCwgZGVzdEN0eCkge1xuICAgIHZhciBwcm9wZXJ0aWVzID0gW1wic3Ryb2tlU3R5bGVcIiwgXCJmaWxsU3R5bGVcIiwgXCJmaWxsUnVsZVwiLCBcImdsb2JhbEFscGhhXCIsIFwibGluZVdpZHRoXCIsIFwibGluZUNhcFwiLCBcImxpbmVKb2luXCIsIFwibWl0ZXJMaW1pdFwiLCBcImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvblwiLCBcImZvbnRcIl07XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNbaV07XG5cbiAgICAgIGlmIChzb3VyY2VDdHhbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGVzdEN0eFtwcm9wZXJ0eV0gPSBzb3VyY2VDdHhbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzb3VyY2VDdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVzdEN0eC5zZXRMaW5lRGFzaChzb3VyY2VDdHguZ2V0TGluZURhc2goKSk7XG4gICAgICBkZXN0Q3R4LmxpbmVEYXNoT2Zmc2V0ID0gc291cmNlQ3R4LmxpbmVEYXNoT2Zmc2V0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0Q3R4VG9EZWZhdWx0KGN0eCkge1xuICAgIGN0eC5zdHJva2VTdHlsZSA9IFwiIzAwMDAwMFwiO1xuICAgIGN0eC5maWxsU3R5bGUgPSBcIiMwMDAwMDBcIjtcbiAgICBjdHguZmlsbFJ1bGUgPSBcIm5vbnplcm9cIjtcbiAgICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICAgIGN0eC5saW5lV2lkdGggPSAxO1xuICAgIGN0eC5saW5lQ2FwID0gXCJidXR0XCI7XG4gICAgY3R4LmxpbmVKb2luID0gXCJtaXRlclwiO1xuICAgIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gICAgY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICBjdHguZm9udCA9IFwiMTBweCBzYW5zLXNlcmlmXCI7XG5cbiAgICBpZiAoY3R4LnNldExpbmVEYXNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgICBjdHgubGluZURhc2hPZmZzZXQgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBvc2VTTWFza0JhY2tkcm9wKGJ5dGVzLCByMCwgZzAsIGIwKSB7XG4gICAgdmFyIGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgIHZhciBhbHBoYSA9IGJ5dGVzW2ldO1xuXG4gICAgICBpZiAoYWxwaGEgPT09IDApIHtcbiAgICAgICAgYnl0ZXNbaSAtIDNdID0gcjA7XG4gICAgICAgIGJ5dGVzW2kgLSAyXSA9IGcwO1xuICAgICAgICBieXRlc1tpIC0gMV0gPSBiMDtcbiAgICAgIH0gZWxzZSBpZiAoYWxwaGEgPCAyNTUpIHtcbiAgICAgICAgdmFyIGFscGhhXyA9IDI1NSAtIGFscGhhO1xuICAgICAgICBieXRlc1tpIC0gM10gPSBieXRlc1tpIC0gM10gKiBhbHBoYSArIHIwICogYWxwaGFfID4+IDg7XG4gICAgICAgIGJ5dGVzW2kgLSAyXSA9IGJ5dGVzW2kgLSAyXSAqIGFscGhhICsgZzAgKiBhbHBoYV8gPj4gODtcbiAgICAgICAgYnl0ZXNbaSAtIDFdID0gYnl0ZXNbaSAtIDFdICogYWxwaGEgKyBiMCAqIGFscGhhXyA+PiA4O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBvc2VTTWFza0FscGhhKG1hc2tEYXRhLCBsYXllckRhdGEsIHRyYW5zZmVyTWFwKSB7XG4gICAgdmFyIGxlbmd0aCA9IG1hc2tEYXRhLmxlbmd0aDtcbiAgICB2YXIgc2NhbGUgPSAxIC8gMjU1O1xuXG4gICAgZm9yICh2YXIgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIGFscGhhID0gdHJhbnNmZXJNYXAgPyB0cmFuc2Zlck1hcFttYXNrRGF0YVtpXV0gOiBtYXNrRGF0YVtpXTtcbiAgICAgIGxheWVyRGF0YVtpXSA9IGxheWVyRGF0YVtpXSAqIGFscGhhICogc2NhbGUgfCAwO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBvc2VTTWFza0x1bWlub3NpdHkobWFza0RhdGEsIGxheWVyRGF0YSwgdHJhbnNmZXJNYXApIHtcbiAgICB2YXIgbGVuZ3RoID0gbWFza0RhdGEubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgICAgdmFyIHkgPSBtYXNrRGF0YVtpIC0gM10gKiA3NyArIG1hc2tEYXRhW2kgLSAyXSAqIDE1MiArIG1hc2tEYXRhW2kgLSAxXSAqIDI4O1xuICAgICAgbGF5ZXJEYXRhW2ldID0gdHJhbnNmZXJNYXAgPyBsYXllckRhdGFbaV0gKiB0cmFuc2Zlck1hcFt5ID4+IDhdID4+IDggOiBsYXllckRhdGFbaV0gKiB5ID4+IDE2O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCkge1xuICAgIHZhciBoYXNCYWNrZHJvcCA9ICEhYmFja2Ryb3A7XG4gICAgdmFyIHIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFswXSA6IDA7XG4gICAgdmFyIGcwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsxXSA6IDA7XG4gICAgdmFyIGIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsyXSA6IDA7XG4gICAgdmFyIGNvbXBvc2VGbjtcblxuICAgIGlmIChzdWJ0eXBlID09PSBcIkx1bWlub3NpdHlcIikge1xuICAgICAgY29tcG9zZUZuID0gY29tcG9zZVNNYXNrTHVtaW5vc2l0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9zZUZuID0gY29tcG9zZVNNYXNrQWxwaGE7XG4gICAgfVxuXG4gICAgdmFyIFBJWEVMU19UT19QUk9DRVNTID0gMTA0ODU3NjtcbiAgICB2YXIgY2h1bmtTaXplID0gTWF0aC5taW4oaGVpZ2h0LCBNYXRoLmNlaWwoUElYRUxTX1RPX1BST0NFU1MgLyB3aWR0aCkpO1xuXG4gICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3cgKz0gY2h1bmtTaXplKSB7XG4gICAgICB2YXIgY2h1bmtIZWlnaHQgPSBNYXRoLm1pbihjaHVua1NpemUsIGhlaWdodCAtIHJvdyk7XG4gICAgICB2YXIgbWFza0RhdGEgPSBtYXNrQ3R4LmdldEltYWdlRGF0YSgwLCByb3csIHdpZHRoLCBjaHVua0hlaWdodCk7XG4gICAgICB2YXIgbGF5ZXJEYXRhID0gbGF5ZXJDdHguZ2V0SW1hZ2VEYXRhKDAsIHJvdywgd2lkdGgsIGNodW5rSGVpZ2h0KTtcblxuICAgICAgaWYgKGhhc0JhY2tkcm9wKSB7XG4gICAgICAgIGNvbXBvc2VTTWFza0JhY2tkcm9wKG1hc2tEYXRhLmRhdGEsIHIwLCBnMCwgYjApO1xuICAgICAgfVxuXG4gICAgICBjb21wb3NlRm4obWFza0RhdGEuZGF0YSwgbGF5ZXJEYXRhLmRhdGEsIHRyYW5zZmVyTWFwKTtcbiAgICAgIG1hc2tDdHgucHV0SW1hZ2VEYXRhKGxheWVyRGF0YSwgMCwgcm93KTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wb3NlU01hc2soY3R4LCBzbWFzaywgbGF5ZXJDdHgsIHdlYkdMQ29udGV4dCkge1xuICAgIHZhciBtYXNrID0gc21hc2suY2FudmFzO1xuICAgIHZhciBtYXNrQ3R4ID0gc21hc2suY29udGV4dDtcbiAgICBjdHguc2V0VHJhbnNmb3JtKHNtYXNrLnNjYWxlWCwgMCwgMCwgc21hc2suc2NhbGVZLCBzbWFzay5vZmZzZXRYLCBzbWFzay5vZmZzZXRZKTtcbiAgICB2YXIgYmFja2Ryb3AgPSBzbWFzay5iYWNrZHJvcCB8fCBudWxsO1xuXG4gICAgaWYgKCFzbWFzay50cmFuc2Zlck1hcCAmJiB3ZWJHTENvbnRleHQuaXNFbmFibGVkKSB7XG4gICAgICB2YXIgY29tcG9zZWQgPSB3ZWJHTENvbnRleHQuY29tcG9zZVNNYXNrKHtcbiAgICAgICAgbGF5ZXI6IGxheWVyQ3R4LmNhbnZhcyxcbiAgICAgICAgbWFzazogbWFzayxcbiAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgIHN1YnR5cGU6IHNtYXNrLnN1YnR5cGUsXG4gICAgICAgICAgYmFja2Ryb3A6IGJhY2tkcm9wXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UoY29tcG9zZWQsIHNtYXNrLm9mZnNldFgsIHNtYXNrLm9mZnNldFkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIG1hc2sud2lkdGgsIG1hc2suaGVpZ2h0LCBzbWFzay5zdWJ0eXBlLCBiYWNrZHJvcCwgc21hc2sudHJhbnNmZXJNYXApO1xuICAgIGN0eC5kcmF3SW1hZ2UobWFzaywgMCwgMCk7XG4gIH1cblxuICB2YXIgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuICB2YXIgTElORV9KT0lOX1NUWUxFUyA9IFtcIm1pdGVyXCIsIFwicm91bmRcIiwgXCJiZXZlbFwiXTtcbiAgdmFyIE5PUk1BTF9DTElQID0ge307XG4gIHZhciBFT19DTElQID0ge307XG4gIENhbnZhc0dyYXBoaWNzLnByb3RvdHlwZSA9IHtcbiAgICBiZWdpbkRyYXdpbmc6IGZ1bmN0aW9uIGJlZ2luRHJhd2luZyhfcmVmMikge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IF9yZWYyLnRyYW5zZm9ybSxcbiAgICAgICAgICB2aWV3cG9ydCA9IF9yZWYyLnZpZXdwb3J0LFxuICAgICAgICAgIF9yZWYyJHRyYW5zcGFyZW5jeSA9IF9yZWYyLnRyYW5zcGFyZW5jeSxcbiAgICAgICAgICB0cmFuc3BhcmVuY3kgPSBfcmVmMiR0cmFuc3BhcmVuY3kgPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZjIkdHJhbnNwYXJlbmN5LFxuICAgICAgICAgIF9yZWYyJGJhY2tncm91bmQgPSBfcmVmMi5iYWNrZ3JvdW5kLFxuICAgICAgICAgIGJhY2tncm91bmQgPSBfcmVmMiRiYWNrZ3JvdW5kID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjIkYmFja2dyb3VuZDtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0O1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcInJnYigyNTUsIDI1NSwgMjU1KVwiO1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIGlmICh0cmFuc3BhcmVuY3kpIHtcbiAgICAgICAgdmFyIHRyYW5zcGFyZW50Q2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJ0cmFuc3BhcmVudFwiLCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb21wb3NpdGVDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgICAgdGhpcy5jdHggPSB0cmFuc3BhcmVudENhbnZhcy5jb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseSh0aGlzLmN0eCwgdGhpcy5jb21wb3NpdGVDdHgubW96Q3VycmVudFRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0aGlzLmN0eC50cmFuc2Zvcm0uYXBwbHkodGhpcy5jdHgsIHRyYW5zZm9ybSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseSh0aGlzLmN0eCwgdmlld3BvcnQudHJhbnNmb3JtKTtcbiAgICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm0uc2xpY2UoKTtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICB0aGlzLmltYWdlTGF5ZXIuYmVnaW5MYXlvdXQoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGV4ZWN1dGVPcGVyYXRvckxpc3Q6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2V4ZWN1dGVPcGVyYXRvckxpc3Qob3BlcmF0b3JMaXN0LCBleGVjdXRpb25TdGFydElkeCwgY29udGludWVDYWxsYmFjaywgc3RlcHBlcikge1xuICAgICAgdmFyIGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgICB2YXIgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgICAgdmFyIGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgICAgdmFyIGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChhcmdzQXJyYXlMZW4gPT09IGkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjaHVua09wZXJhdGlvbnMgPSBhcmdzQXJyYXlMZW4gLSBpID4gRVhFQ1VUSU9OX1NURVBTICYmIHR5cGVvZiBjb250aW51ZUNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCI7XG4gICAgICB2YXIgZW5kVGltZSA9IGNodW5rT3BlcmF0aW9ucyA/IERhdGUubm93KCkgKyBFWEVDVVRJT05fVElNRSA6IDA7XG4gICAgICB2YXIgc3RlcHMgPSAwO1xuICAgICAgdmFyIGNvbW1vbk9ianMgPSB0aGlzLmNvbW1vbk9ianM7XG4gICAgICB2YXIgb2JqcyA9IHRoaXMub2JqcztcbiAgICAgIHZhciBmbklkO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoc3RlcHBlciAhPT0gdW5kZWZpbmVkICYmIGkgPT09IHN0ZXBwZXIubmV4dEJyZWFrUG9pbnQpIHtcbiAgICAgICAgICBzdGVwcGVyLmJyZWFrSXQoaSwgY29udGludWVDYWxsYmFjayk7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICBmbklkID0gZm5BcnJheVtpXTtcblxuICAgICAgICBpZiAoZm5JZCAhPT0gX3V0aWwuT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgICB0aGlzW2ZuSWRdLmFwcGx5KHRoaXMsIGFyZ3NBcnJheVtpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGFyZ3NBcnJheVtpXSksXG4gICAgICAgICAgICAgIF9zdGVwO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBkZXBPYmpJZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgb2Jqc1Bvb2wgPSBkZXBPYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyBjb21tb25PYmpzIDogb2JqcztcblxuICAgICAgICAgICAgICBpZiAoIW9ianNQb29sLmhhcyhkZXBPYmpJZCkpIHtcbiAgICAgICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGkrKztcblxuICAgICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2h1bmtPcGVyYXRpb25zICYmICsrc3RlcHMgPiBFWEVDVVRJT05fU1RFUFMpIHtcbiAgICAgICAgICBpZiAoRGF0ZS5ub3coKSA+IGVuZFRpbWUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHN0ZXBzID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZW5kRHJhd2luZzogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZW5kRHJhd2luZygpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5lbmRTTWFza0dyb3VwKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYgKHRoaXMudHJhbnNwYXJlbnRDYW52YXMpIHtcbiAgICAgICAgdGhpcy5jdHggPSB0aGlzLmNvbXBvc2l0ZUN0eDtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZSh0aGlzLnRyYW5zcGFyZW50Q2FudmFzLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZWRDYW52YXNlcy5jbGVhcigpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHQuY2xlYXIoKTtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICB0aGlzLmltYWdlTGF5ZXIuZW5kTGF5b3V0KCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRMaW5lV2lkdGg6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldExpbmVXaWR0aCh3aWR0aCkge1xuICAgICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5jdHgubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfSxcbiAgICBzZXRMaW5lQ2FwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRMaW5lQ2FwKHN0eWxlKSB7XG4gICAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgICB9LFxuICAgIHNldExpbmVKb2luOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRMaW5lSm9pbihzdHlsZSkge1xuICAgICAgdGhpcy5jdHgubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgICB9LFxuICAgIHNldE1pdGVyTGltaXQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldE1pdGVyTGltaXQobGltaXQpIHtcbiAgICAgIHRoaXMuY3R4Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgICB9LFxuICAgIHNldERhc2g6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldERhc2goZGFzaEFycmF5LCBkYXNoUGhhc2UpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lRGFzaChkYXNoQXJyYXkpO1xuICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBkYXNoUGhhc2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBzZXRSZW5kZXJpbmdJbnRlbnQ6IGZ1bmN0aW9uIHNldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHt9LFxuICAgIHNldEZsYXRuZXNzOiBmdW5jdGlvbiBzZXRGbGF0bmVzcyhmbGF0bmVzcykge30sXG4gICAgc2V0R1N0YXRlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRHU3RhdGUoc3RhdGVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBzdGF0ZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgc3RhdGUgPSBzdGF0ZXNbaV07XG4gICAgICAgIHZhciBrZXkgPSBzdGF0ZVswXTtcbiAgICAgICAgdmFyIHZhbHVlID0gc3RhdGVbMV07XG5cbiAgICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4odmFsdWUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudCh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcIkNBXCI6XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQWxwaGEgPSBzdGF0ZVsxXTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gc3RhdGVbMV07XG4gICAgICAgICAgICB0aGlzLmN0eC5nbG9iYWxBbHBoYSA9IHN0YXRlWzFdO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiQk1cIjpcbiAgICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IHZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIFwiU01hc2tcIjpcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2spIHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPiAwICYmIHRoaXMuc3RhdGVTdGFja1t0aGlzLnN0YXRlU3RhY2subGVuZ3RoIC0gMV0uYWN0aXZlU01hc2sgPT09IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc3VzcGVuZFNNYXNrR3JvdXAoKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFNNYXNrR3JvdXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSB2YWx1ZSA/IHRoaXMudGVtcFNNYXNrIDogbnVsbDtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaykge1xuICAgICAgICAgICAgICB0aGlzLmJlZ2luU01hc2tHcm91cCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRlbXBTTWFzayA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJUUlwiOlxuICAgICAgICAgICAgdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBiZWdpblNNYXNrR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luU01hc2tHcm91cCgpIHtcbiAgICAgIHZhciBhY3RpdmVTTWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICAgIHZhciBkcmF3bldpZHRoID0gYWN0aXZlU01hc2suY2FudmFzLndpZHRoO1xuICAgICAgdmFyIGRyYXduSGVpZ2h0ID0gYWN0aXZlU01hc2suY2FudmFzLmhlaWdodDtcbiAgICAgIHZhciBjYWNoZUlkID0gXCJzbWFza0dyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcbiAgICAgIHZhciBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQsIHRydWUpO1xuICAgICAgdmFyIGN1cnJlbnRDdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gY3VycmVudEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgICAgZ3JvdXBDdHguc2NhbGUoMSAvIGFjdGl2ZVNNYXNrLnNjYWxlWCwgMSAvIGFjdGl2ZVNNYXNrLnNjYWxlWSk7XG4gICAgICBncm91cEN0eC50cmFuc2xhdGUoLWFjdGl2ZVNNYXNrLm9mZnNldFgsIC1hY3RpdmVTTWFzay5vZmZzZXRZKTtcbiAgICAgIGdyb3VwQ3R4LnRyYW5zZm9ybS5hcHBseShncm91cEN0eCwgY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICBhY3RpdmVTTWFzay5zdGFydFRyYW5zZm9ybUludmVyc2UgPSBncm91cEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtSW52ZXJzZTtcbiAgICAgIGNvcHlDdHhTdGF0ZShjdXJyZW50Q3R4LCBncm91cEN0eCk7XG4gICAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgICAgdGhpcy5zZXRHU3RhdGUoW1tcIkJNXCIsIFwic291cmNlLW92ZXJcIl0sIFtcImNhXCIsIDFdLCBbXCJDQVwiLCAxXV0pO1xuICAgICAgdGhpcy5ncm91cFN0YWNrLnB1c2goY3VycmVudEN0eCk7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwrKztcbiAgICB9LFxuICAgIHN1c3BlbmRTTWFza0dyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRTTWFza0dyb3VwKCkge1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgICAgY29tcG9zZVNNYXNrKHRoaXMuY3R4LCB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2ssIGdyb3VwQ3R4LCB0aGlzLndlYkdMQ29udGV4dCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICBjb3B5Q3R4U3RhdGUoZ3JvdXBDdHgsIHRoaXMuY3R4KTtcbiAgICAgIHRoaXMuY3VycmVudC5yZXN1bWVTTWFza0N0eCA9IGdyb3VwQ3R4O1xuXG4gICAgICB2YXIgZGVsdGFUcmFuc2Zvcm0gPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2suc3RhcnRUcmFuc2Zvcm1JbnZlcnNlLCBncm91cEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtKTtcblxuICAgICAgdGhpcy5jdHgudHJhbnNmb3JtLmFwcGx5KHRoaXMuY3R4LCBkZWx0YVRyYW5zZm9ybSk7XG4gICAgICBncm91cEN0eC5zYXZlKCk7XG4gICAgICBncm91cEN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICBncm91cEN0eC5jbGVhclJlY3QoMCwgMCwgZ3JvdXBDdHguY2FudmFzLndpZHRoLCBncm91cEN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICAgIGdyb3VwQ3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHJlc3VtZVNNYXNrR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZFNNYXNrR3JvdXAoKSB7XG4gICAgICB2YXIgZ3JvdXBDdHggPSB0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHg7XG4gICAgICB2YXIgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgICAgdGhpcy5ncm91cExldmVsKys7XG4gICAgfSxcbiAgICBlbmRTTWFza0dyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRTTWFza0dyb3VwKCkge1xuICAgICAgdmFyIGdyb3VwQ3R4ID0gdGhpcy5jdHg7XG4gICAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5ncm91cFN0YWNrLnBvcCgpO1xuICAgICAgY29tcG9zZVNNYXNrKHRoaXMuY3R4LCB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2ssIGdyb3VwQ3R4LCB0aGlzLndlYkdMQ29udGV4dCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICBjb3B5Q3R4U3RhdGUoZ3JvdXBDdHgsIHRoaXMuY3R4KTtcblxuICAgICAgdmFyIGRlbHRhVHJhbnNmb3JtID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrLnN0YXJ0VHJhbnNmb3JtSW52ZXJzZSwgZ3JvdXBDdHgubW96Q3VycmVudFRyYW5zZm9ybSk7XG5cbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybS5hcHBseSh0aGlzLmN0eCwgZGVsdGFUcmFuc2Zvcm0pO1xuICAgIH0sXG4gICAgc2F2ZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2F2ZSgpIHtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHZhciBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICB0aGlzLnN0YXRlU3RhY2sucHVzaChvbGQpO1xuICAgICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gICAgICB0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHggPSBudWxsO1xuICAgIH0sXG4gICAgcmVzdG9yZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcmVzdG9yZSgpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnQucmVzdW1lU01hc2tDdHgpIHtcbiAgICAgICAgdGhpcy5yZXN1bWVTTWFza0dyb3VwKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgIT09IG51bGwgJiYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggPT09IDAgfHwgdGhpcy5zdGF0ZVN0YWNrW3RoaXMuc3RhdGVTdGFjay5sZW5ndGggLSAxXS5hY3RpdmVTTWFzayAhPT0gdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSkge1xuICAgICAgICB0aGlzLmVuZFNNYXNrR3JvdXAoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc3RhdGVTdGFjay5sZW5ndGggIT09IDApIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5zdGF0ZVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zZm9ybTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfdHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIH0sXG4gICAgY29uc3RydWN0UGF0aDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfY29uc3RydWN0UGF0aChvcHMsIGFyZ3MpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgdmFyIHggPSBjdXJyZW50LngsXG4gICAgICAgICAgeSA9IGN1cnJlbnQueTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwLCBpaSA9IG9wcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHN3aXRjaCAob3BzW2ldIHwgMCkge1xuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnJlY3RhbmdsZTpcbiAgICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGFyZ3NbaisrXTtcblxuICAgICAgICAgICAgaWYgKHdpZHRoID09PSAwICYmIGN0eC5saW5lV2lkdGggPCB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKSkge1xuICAgICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaGVpZ2h0ID09PSAwICYmIGN0eC5saW5lV2lkdGggPCB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKSkge1xuICAgICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgdmFyIHloID0geSArIGhlaWdodDtcbiAgICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeWgpO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRvOlxuICAgICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG86XG4gICAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgICB5ID0gYXJnc1tqICsgNV07XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5KTtcbiAgICAgICAgICAgIGogKz0gNjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzI6XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzM6XG4gICAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSk7XG4gICAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQuc2V0Q3VycmVudFBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19jbG9zZVBhdGgoKSB7XG4gICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuICAgIHN0cm9rZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc3Ryb2tlKGNvbnN1bWVQYXRoKSB7XG4gICAgICBjb25zdW1lUGF0aCA9IHR5cGVvZiBjb25zdW1lUGF0aCAhPT0gXCJ1bmRlZmluZWRcIiA/IGNvbnN1bWVQYXRoIDogdHJ1ZTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBzdHJva2VDb2xvciA9IHRoaXMuY3VycmVudC5zdHJva2VDb2xvcjtcbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5zdHJva2VBbHBoYTtcblxuICAgICAgaWYgKHRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgaWYgKHN0cm9rZUNvbG9yICYmIHN0cm9rZUNvbG9yLmhhc093blByb3BlcnR5KFwidHlwZVwiKSAmJiBzdHJva2VDb2xvci50eXBlID09PSBcIlBhdHRlcm5cIikge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybSA9IGN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICAgICAgdmFyIHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pWzBdO1xuXG4gICAgICAgICAgY3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMpO1xuICAgICAgICAgIGN0eC5saW5lV2lkdGggPSBNYXRoLm1heCh0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKSAqIE1JTl9XSURUSF9GQUNUT1IsIHRoaXMuY3VycmVudC5saW5lV2lkdGggKiBzY2FsZSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmxpbmVXaWR0aCA9IE1hdGgubWF4KHRoaXMuZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpICogTUlOX1dJRFRIX0ZBQ1RPUiwgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25zdW1lUGF0aCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5maWxsQWxwaGE7XG4gICAgfSxcbiAgICBjbG9zZVN0cm9rZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfY2xvc2VTdHJva2UoKSB7XG4gICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICB9LFxuICAgIGZpbGw6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2ZpbGwoY29uc3VtZVBhdGgpIHtcbiAgICAgIGNvbnN1bWVQYXRoID0gdHlwZW9mIGNvbnN1bWVQYXRoICE9PSBcInVuZGVmaW5lZFwiID8gY29uc3VtZVBhdGggOiB0cnVlO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdmFyIGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgICB2YXIgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICAgIHZhciBuZWVkUmVzdG9yZSA9IGZhbHNlO1xuXG4gICAgICBpZiAoaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgICBjdHguc2V0VHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMpO1xuICAgICAgICBuZWVkUmVzdG9yZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdFT0ZpbGwpIHtcbiAgICAgICAgICBjdHguZmlsbChcImV2ZW5vZGRcIik7XG4gICAgICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobmVlZFJlc3RvcmUpIHtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbnN1bWVQYXRoKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZVBhdGgoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVvRmlsbDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZW9GaWxsKCkge1xuICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICAgIHRoaXMuZmlsbCgpO1xuICAgIH0sXG4gICAgZmlsbFN0cm9rZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMuZmlsbChmYWxzZSk7XG4gICAgICB0aGlzLnN0cm9rZShmYWxzZSk7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gICAgfSxcbiAgICBlb0ZpbGxTdHJva2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VvRmlsbFN0cm9rZSgpIHtcbiAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICB9LFxuICAgIGNsb3NlRmlsbFN0cm9rZTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfY2xvc2VGaWxsU3Ryb2tlKCkge1xuICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICAgIH0sXG4gICAgY2xvc2VFT0ZpbGxTdHJva2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2Nsb3NlRU9GaWxsU3Ryb2tlKCkge1xuICAgICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICB9LFxuICAgIGVuZFBhdGg6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZFBhdGgoKSB7XG4gICAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gICAgfSxcbiAgICBjbGlwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19jbGlwKCkge1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IE5PUk1BTF9DTElQO1xuICAgIH0sXG4gICAgZW9DbGlwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lb0NsaXAoKSB7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gRU9fQ0xJUDtcbiAgICB9LFxuICAgIGJlZ2luVGV4dDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfYmVnaW5UZXh0KCkge1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgICB9LFxuICAgIGVuZFRleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZFRleHQoKSB7XG4gICAgICB2YXIgcGF0aHMgPSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICAgIGlmIChwYXRocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aHNbaV07XG4gICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0uYXBwbHkoY3R4LCBwYXRoLnRyYW5zZm9ybSk7XG4gICAgICAgIGN0eC50cmFuc2xhdGUocGF0aC54LCBwYXRoLnkpO1xuICAgICAgICBwYXRoLmFkZFRvUGF0aChjdHgsIHBhdGguZm9udFNpemUpO1xuICAgICAgfVxuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgY3R4LmNsaXAoKTtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUZXh0UGF0aHM7XG4gICAgfSxcbiAgICBzZXRDaGFyU3BhY2luZzogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0Q2hhclNwYWNpbmcoc3BhY2luZykge1xuICAgICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgICB9LFxuICAgIHNldFdvcmRTcGFjaW5nOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRXb3JkU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgICB0aGlzLmN1cnJlbnQud29yZFNwYWNpbmcgPSBzcGFjaW5nO1xuICAgIH0sXG4gICAgc2V0SFNjYWxlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRIU2NhbGUoc2NhbGUpIHtcbiAgICAgIHRoaXMuY3VycmVudC50ZXh0SFNjYWxlID0gc2NhbGUgLyAxMDA7XG4gICAgfSxcbiAgICBzZXRMZWFkaW5nOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRMZWFkaW5nKGxlYWRpbmcpIHtcbiAgICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gICAgfSxcbiAgICBzZXRGb250OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRGb250KGZvbnRSZWZOYW1lLCBzaXplKSB7XG4gICAgICB2YXIgZm9udE9iaiA9IHRoaXMuY29tbW9uT2Jqcy5nZXQoZm9udFJlZk5hbWUpO1xuICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG5cbiAgICAgIGlmICghZm9udE9iaikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBmaW5kIGZvbnQgZm9yIFwiLmNvbmNhdChmb250UmVmTmFtZSkpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggPyBmb250T2JqLmZvbnRNYXRyaXggOiBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcblxuICAgICAgaWYgKGN1cnJlbnQuZm9udE1hdHJpeFswXSA9PT0gMCB8fCBjdXJyZW50LmZvbnRNYXRyaXhbM10gPT09IDApIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiSW52YWxpZCBmb250IG1hdHJpeCBmb3IgZm9udCBcIiArIGZvbnRSZWZOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgICB0aGlzLmN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuXG4gICAgICBpZiAoZm9udE9iai5pc1R5cGUzRm9udCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuYW1lID0gZm9udE9iai5sb2FkZWROYW1lIHx8IFwic2Fucy1zZXJpZlwiO1xuICAgICAgdmFyIGJvbGQgPSBcIm5vcm1hbFwiO1xuXG4gICAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgICBib2xkID0gXCI5MDBcIjtcbiAgICAgIH0gZWxzZSBpZiAoZm9udE9iai5ib2xkKSB7XG4gICAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICAgIH1cblxuICAgICAgdmFyIGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG4gICAgICB2YXIgdHlwZWZhY2UgPSBcIlxcXCJcIi5jb25jYXQobmFtZSwgXCJcXFwiLCBcIikuY29uY2F0KGZvbnRPYmouZmFsbGJhY2tOYW1lKTtcbiAgICAgIHZhciBicm93c2VyRm9udFNpemUgPSBzaXplO1xuXG4gICAgICBpZiAoc2l6ZSA8IE1JTl9GT05UX1NJWkUpIHtcbiAgICAgICAgYnJvd3NlckZvbnRTaXplID0gTUlOX0ZPTlRfU0laRTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA+IE1BWF9GT05UX1NJWkUpIHtcbiAgICAgICAgYnJvd3NlckZvbnRTaXplID0gTUFYX0ZPTlRfU0laRTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jdXJyZW50LmZvbnRTaXplU2NhbGUgPSBzaXplIC8gYnJvd3NlckZvbnRTaXplO1xuICAgICAgdGhpcy5jdHguZm9udCA9IFwiXCIuY29uY2F0KGl0YWxpYywgXCIgXCIpLmNvbmNhdChib2xkLCBcIiBcIikuY29uY2F0KGJyb3dzZXJGb250U2l6ZSwgXCJweCBcIikuY29uY2F0KHR5cGVmYWNlKTtcbiAgICB9LFxuICAgIHNldFRleHRSZW5kZXJpbmdNb2RlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRUZXh0UmVuZGVyaW5nTW9kZShtb2RlKSB7XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPSBtb2RlO1xuICAgIH0sXG4gICAgc2V0VGV4dFJpc2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldFRleHRSaXNlKHJpc2UpIHtcbiAgICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHJpc2U7XG4gICAgfSxcbiAgICBtb3ZlVGV4dDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfbW92ZVRleHQoeCwgeSkge1xuICAgICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZICs9IHk7XG4gICAgfSxcbiAgICBzZXRMZWFkaW5nTW92ZVRleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgICB0aGlzLnNldExlYWRpbmcoLXkpO1xuICAgICAgdGhpcy5tb3ZlVGV4dCh4LCB5KTtcbiAgICB9LFxuICAgIHNldFRleHRNYXRyaXg6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldFRleHRNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB0aGlzLmN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICAgICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgICAgdGhpcy5jdXJyZW50LnkgPSB0aGlzLmN1cnJlbnQubGluZVkgPSAwO1xuICAgIH0sXG4gICAgbmV4dExpbmU6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX25leHRMaW5lKCkge1xuICAgICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gICAgfSxcbiAgICBwYWludENoYXI6IGZ1bmN0aW9uIHBhaW50Q2hhcihjaGFyYWN0ZXIsIHgsIHksIHBhdHRlcm5UcmFuc2Zvcm0pIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgdmFyIGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgICB2YXIgdGV4dFJlbmRlcmluZ01vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlO1xuICAgICAgdmFyIGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZSAvIGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICAgIHZhciBmaWxsU3Ryb2tlTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICAgIHZhciBpc0FkZFRvUGF0aFNldCA9ICEhKHRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyk7XG4gICAgICB2YXIgcGF0dGVybkZpbGwgPSBjdXJyZW50LnBhdHRlcm5GaWxsICYmICFmb250Lm1pc3NpbmdGaWxlO1xuICAgICAgdmFyIGFkZFRvUGF0aDtcblxuICAgICAgaWYgKGZvbnQuZGlzYWJsZUZvbnRGYWNlIHx8IGlzQWRkVG9QYXRoU2V0IHx8IHBhdHRlcm5GaWxsKSB7XG4gICAgICAgIGFkZFRvUGF0aCA9IGZvbnQuZ2V0UGF0aEdlbmVyYXRvcih0aGlzLmNvbW1vbk9ianMsIGNoYXJhY3Rlcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBwYXR0ZXJuRmlsbCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgIGFkZFRvUGF0aChjdHgsIGZvbnRTaXplKTtcblxuICAgICAgICBpZiAocGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICAgIGN0eC5zZXRUcmFuc2Zvcm0uYXBwbHkoY3R4LCBwYXR0ZXJuVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICAgIGN0eC5zdHJva2VUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICAgIHZhciBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fCAodGhpcy5wZW5kaW5nVGV4dFBhdGhzID0gW10pO1xuICAgICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgICB0cmFuc2Zvcm06IGN0eC5tb3pDdXJyZW50VHJhbnNmb3JtLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeSxcbiAgICAgICAgICBmb250U2l6ZTogZm9udFNpemUsXG4gICAgICAgICAgYWRkVG9QYXRoOiBhZGRUb1BhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICAgIHZhciBfdGhpcyRjYWNoZWRDYW52YXNlcyQgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlzRm9udFN1YnBpeGVsQUFFbmFibGVkXCIsIDEwLCAxMCksXG4gICAgICAgICAgY3R4ID0gX3RoaXMkY2FjaGVkQ2FudmFzZXMkLmNvbnRleHQ7XG5cbiAgICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiSVwiLCAwLCAxMCk7XG4gICAgICB2YXIgZGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMTAsIDEwKS5kYXRhO1xuICAgICAgdmFyIGVuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDM7IGkgPCBkYXRhLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIGlmIChkYXRhW2ldID4gMCAmJiBkYXRhW2ldIDwgMjU1KSB7XG4gICAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNGb250U3VicGl4ZWxBQUVuYWJsZWRcIiwgZW5hYmxlZCk7XG4gICAgfSxcblxuICAgIHNob3dUZXh0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zaG93VGV4dChnbHlwaHMpIHtcbiAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgdmFyIGZvbnQgPSBjdXJyZW50LmZvbnQ7XG5cbiAgICAgIGlmIChmb250LmlzVHlwZTNGb250KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dUeXBlM1RleHQoZ2x5cGhzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcblxuICAgICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHZhciBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgICAgdmFyIGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICAgIHZhciB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgICB2YXIgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICAgIHZhciB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICAgIHZhciBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgICAgdmFyIHZlcnRpY2FsID0gZm9udC52ZXJ0aWNhbDtcbiAgICAgIHZhciBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgICB2YXIgZGVmYXVsdFZNZXRyaWNzID0gZm9udC5kZWZhdWx0Vk1ldHJpY3M7XG4gICAgICB2YXIgd2lkdGhBZHZhbmNlU2NhbGUgPSBmb250U2l6ZSAqIGN1cnJlbnQuZm9udE1hdHJpeFswXTtcbiAgICAgIHZhciBzaW1wbGVGaWxsVGV4dCA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgJiYgIWZvbnQuZGlzYWJsZUZvbnRGYWNlICYmICFjdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHZhciBwYXR0ZXJuVHJhbnNmb3JtO1xuXG4gICAgICBpZiAoY3VycmVudC5wYXR0ZXJuRmlsbCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICB2YXIgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzKTtcbiAgICAgICAgcGF0dGVyblRyYW5zZm9ybSA9IGN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICAgIH1cblxuICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGN1cnJlbnQudGV4dE1hdHJpeCk7XG4gICAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG5cbiAgICAgIGlmIChmb250RGlyZWN0aW9uID4gMCkge1xuICAgICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIDEpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGluZVdpZHRoID0gY3VycmVudC5saW5lV2lkdGg7XG4gICAgICB2YXIgc2NhbGUgPSBjdXJyZW50LnRleHRNYXRyaXhTY2FsZTtcblxuICAgICAgaWYgKHNjYWxlID09PSAwIHx8IGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICB2YXIgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcblxuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgICAgICBsaW5lV2lkdGggPSB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKSAqIE1JTl9XSURUSF9GQUNUT1I7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVXaWR0aCAvPSBzY2FsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvbnRTaXplU2NhbGUgIT09IDEuMCkge1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemVTY2FsZSwgZm9udFNpemVTY2FsZSk7XG4gICAgICAgIGxpbmVXaWR0aCAvPSBmb250U2l6ZVNjYWxlO1xuICAgICAgfVxuXG4gICAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoO1xuICAgICAgdmFyIHggPSAwLFxuICAgICAgICAgIGk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZ2x5cGggPSBnbHlwaHNbaV07XG5cbiAgICAgICAgaWYgKCgwLCBfdXRpbC5pc051bSkoZ2x5cGgpKSB7XG4gICAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVzdG9yZU5lZWRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgICB2YXIgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICAgIHZhciBhY2NlbnQgPSBnbHlwaC5hY2NlbnQ7XG4gICAgICAgIHZhciBzY2FsZWRYLCBzY2FsZWRZLCBzY2FsZWRBY2NlbnRYLCBzY2FsZWRBY2NlbnRZO1xuICAgICAgICB2YXIgd2lkdGggPSBnbHlwaC53aWR0aDtcblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICB2YXIgdm1ldHJpYywgdngsIHZ5O1xuICAgICAgICAgIHZtZXRyaWMgPSBnbHlwaC52bWV0cmljIHx8IGRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgICB2eCA9IGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjU7XG4gICAgICAgICAgdnggPSAtdnggKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgICB2eSA9IHZtZXRyaWNbMl0gKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgc2NhbGVkWSA9ICh4ICsgdnkpIC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgc2NhbGVkWSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZm9udC5yZW1lYXN1cmUgJiYgd2lkdGggPiAwKSB7XG4gICAgICAgICAgdmFyIG1lYXN1cmVkV2lkdGggPSBjdHgubWVhc3VyZVRleHQoY2hhcmFjdGVyKS53aWR0aCAqIDEwMDAgLyBmb250U2l6ZSAqIGZvbnRTaXplU2NhbGU7XG5cbiAgICAgICAgICBpZiAod2lkdGggPCBtZWFzdXJlZFdpZHRoICYmIHRoaXMuaXNGb250U3VicGl4ZWxBQUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHZhciBjaGFyYWN0ZXJTY2FsZVggPSB3aWR0aCAvIG1lYXN1cmVkV2lkdGg7XG4gICAgICAgICAgICByZXN0b3JlTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgICBjdHguc2NhbGUoY2hhcmFjdGVyU2NhbGVYLCAxKTtcbiAgICAgICAgICAgIHNjYWxlZFggLz0gY2hhcmFjdGVyU2NhbGVYO1xuICAgICAgICAgIH0gZWxzZSBpZiAod2lkdGggIT09IG1lYXN1cmVkV2lkdGgpIHtcbiAgICAgICAgICAgIHNjYWxlZFggKz0gKHdpZHRoIC0gbWVhc3VyZWRXaWR0aCkgLyAyMDAwICogZm9udFNpemUgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSkge1xuICAgICAgICAgIGlmIChzaW1wbGVGaWxsVGV4dCAmJiAhYWNjZW50KSB7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWludENoYXIoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZLCBwYXR0ZXJuVHJhbnNmb3JtKTtcblxuICAgICAgICAgICAgaWYgKGFjY2VudCkge1xuICAgICAgICAgICAgICBzY2FsZWRBY2NlbnRYID0gc2NhbGVkWCArIGZvbnRTaXplICogYWNjZW50Lm9mZnNldC54IC8gZm9udFNpemVTY2FsZTtcbiAgICAgICAgICAgICAgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICAgIHRoaXMucGFpbnRDaGFyKGFjY2VudC5mb250Q2hhciwgc2NhbGVkQWNjZW50WCwgc2NhbGVkQWNjZW50WSwgcGF0dGVyblRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNoYXJXaWR0aDtcblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICBjaGFyV2lkdGggPSB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhcldpZHRoID0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgeCArPSBjaGFyV2lkdGg7XG5cbiAgICAgICAgaWYgKHJlc3RvcmVOZWVkZWQpIHtcbiAgICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICBjdXJyZW50LnkgLT0geDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIHNob3dUeXBlM1RleHQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3Nob3dUeXBlM1RleHQoZ2x5cGhzKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgIHZhciBmb250ID0gY3VycmVudC5mb250O1xuICAgICAgdmFyIGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICAgIHZhciBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgICAgdmFyIHNwYWNpbmdEaXIgPSBmb250LnZlcnRpY2FsID8gMSA6IC0xO1xuICAgICAgdmFyIGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICAgIHZhciB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgICB2YXIgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgICB2YXIgZm9udE1hdHJpeCA9IGN1cnJlbnQuZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICAgIHZhciBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgICAgdmFyIGlzVGV4dEludmlzaWJsZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICAgIHZhciBpLCBnbHlwaCwgd2lkdGgsIHNwYWNpbmdMZW5ndGg7XG5cbiAgICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtLmFwcGx5KGN0eCwgY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkpO1xuICAgICAgY3R4LnNjYWxlKHRleHRIU2NhbGUsIGZvbnREaXJlY3Rpb24pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ2x5cGggPSBnbHlwaHNbaV07XG5cbiAgICAgICAgaWYgKCgwLCBfdXRpbC5pc051bSkoZ2x5cGgpKSB7XG4gICAgICAgICAgc3BhY2luZ0xlbmd0aCA9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgICAgY3VycmVudC54ICs9IHNwYWNpbmdMZW5ndGggKiB0ZXh0SFNjYWxlO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNwYWNpbmcgPSAoZ2x5cGguaXNTcGFjZSA/IHdvcmRTcGFjaW5nIDogMCkgKyBjaGFyU3BhY2luZztcbiAgICAgICAgdmFyIG9wZXJhdG9yTGlzdCA9IGZvbnQuY2hhclByb2NPcGVyYXRvckxpc3RbZ2x5cGgub3BlcmF0b3JMaXN0SWRdO1xuXG4gICAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVHlwZTMgY2hhcmFjdGVyIFxcXCJcIi5jb25jYXQoZ2x5cGgub3BlcmF0b3JMaXN0SWQsIFwiXFxcIiBpcyBub3QgYXZhaWxhYmxlLlwiKSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gZ2x5cGg7XG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgICAgY3R4LnNjYWxlKGZvbnRTaXplLCBmb250U2l6ZSk7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGZvbnRNYXRyaXgpO1xuICAgICAgICAgIHRoaXMuZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QpO1xuICAgICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zZm9ybWVkID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbZ2x5cGgud2lkdGgsIDBdLCBmb250TWF0cml4KTtcblxuICAgICAgICB3aWR0aCA9IHRyYW5zZm9ybWVkWzBdICogZm9udFNpemUgKyBzcGFjaW5nO1xuICAgICAgICBjdHgudHJhbnNsYXRlKHdpZHRoLCAwKTtcbiAgICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gbnVsbDtcbiAgICB9LFxuICAgIHNldENoYXJXaWR0aDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0Q2hhcldpZHRoKHhXaWR0aCwgeVdpZHRoKSB7fSxcbiAgICBzZXRDaGFyV2lkdGhBbmRCb3VuZHM6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldENoYXJXaWR0aEFuZEJvdW5kcyh4V2lkdGgsIHlXaWR0aCwgbGx4LCBsbHksIHVyeCwgdXJ5KSB7XG4gICAgICB0aGlzLmN0eC5yZWN0KGxseCwgbGx5LCB1cnggLSBsbHgsIHVyeSAtIGxseSk7XG4gICAgICB0aGlzLmNsaXAoKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH0sXG4gICAgZ2V0Q29sb3JOX1BhdHRlcm46IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2dldENvbG9yTl9QYXR0ZXJuKElSKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcGF0dGVybjtcblxuICAgICAgaWYgKElSWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgICB2YXIgY29sb3IgPSBJUlsxXTtcbiAgICAgICAgdmFyIGJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm0gfHwgdGhpcy5jdHgubW96Q3VycmVudFRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB2YXIgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICAgIGNyZWF0ZUNhbnZhc0dyYXBoaWNzOiBmdW5jdGlvbiBjcmVhdGVDYW52YXNHcmFwaGljcyhjdHgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2FudmFzR3JhcGhpY3MoY3R4LCBfdGhpcy5jb21tb25PYmpzLCBfdGhpcy5vYmpzLCBfdGhpcy5jYW52YXNGYWN0b3J5LCBfdGhpcy53ZWJHTENvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcGF0dGVybiA9IG5ldyBfcGF0dGVybl9oZWxwZXIuVGlsaW5nUGF0dGVybihJUiwgY29sb3IsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0dGVybiA9ICgwLCBfcGF0dGVybl9oZWxwZXIuZ2V0U2hhZGluZ1BhdHRlcm5Gcm9tSVIpKElSKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgfSxcbiAgICBzZXRTdHJva2VDb2xvck46IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldFN0cm9rZUNvbG9yTigpIHtcbiAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB9LFxuICAgIHNldEZpbGxDb2xvck46IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3NldEZpbGxDb2xvck4oKSB7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICAgICAgdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsID0gdHJ1ZTtcbiAgICB9LFxuICAgIHNldFN0cm9rZVJHQkNvbG9yOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zZXRTdHJva2VSR0JDb2xvcihyLCBnLCBiKSB7XG4gICAgICB2YXIgY29sb3IgPSBfdXRpbC5VdGlsLm1ha2VDc3NSZ2IociwgZywgYik7XG5cbiAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjb2xvcjtcbiAgICB9LFxuICAgIHNldEZpbGxSR0JDb2xvcjogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3Nfc2V0RmlsbFJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICAgIHZhciBjb2xvciA9IF91dGlsLlV0aWwubWFrZUNzc1JnYihyLCBnLCBiKTtcblxuICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gY29sb3I7XG4gICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gY29sb3I7XG4gICAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgICB9LFxuICAgIHNoYWRpbmdGaWxsOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19zaGFkaW5nRmlsbChwYXR0ZXJuSVIpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgdmFyIHBhdHRlcm4gPSAoMCwgX3BhdHRlcm5faGVscGVyLmdldFNoYWRpbmdQYXR0ZXJuRnJvbUlSKShwYXR0ZXJuSVIpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm4uZ2V0UGF0dGVybihjdHgsIHRoaXMsIHRydWUpO1xuICAgICAgdmFyIGludiA9IGN0eC5tb3pDdXJyZW50VHJhbnNmb3JtSW52ZXJzZTtcblxuICAgICAgaWYgKGludikge1xuICAgICAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICAgICAgdmFyIHdpZHRoID0gY2FudmFzLndpZHRoO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuICAgICAgICB2YXIgYmwgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFswLCAwXSwgaW52KTtcblxuICAgICAgICB2YXIgYnIgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFswLCBoZWlnaHRdLCBpbnYpO1xuXG4gICAgICAgIHZhciB1bCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3dpZHRoLCAwXSwgaW52KTtcblxuICAgICAgICB2YXIgdXIgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt3aWR0aCwgaGVpZ2h0XSwgaW52KTtcblxuICAgICAgICB2YXIgeDAgPSBNYXRoLm1pbihibFswXSwgYnJbMF0sIHVsWzBdLCB1clswXSk7XG4gICAgICAgIHZhciB5MCA9IE1hdGgubWluKGJsWzFdLCBiclsxXSwgdWxbMV0sIHVyWzFdKTtcbiAgICAgICAgdmFyIHgxID0gTWF0aC5tYXgoYmxbMF0sIGJyWzBdLCB1bFswXSwgdXJbMF0pO1xuICAgICAgICB2YXIgeTEgPSBNYXRoLm1heChibFsxXSwgYnJbMV0sIHVsWzFdLCB1clsxXSk7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHgwLCB5MCwgeDEgLSB4MCwgeTEgLSB5MCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCgtMWUxMCwgLTFlMTAsIDJlMTAsIDJlMTApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9LFxuICAgIGJlZ2luSW5saW5lSW1hZ2U6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luSW5saW5lSW1hZ2UoKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW5saW5lSW1hZ2VcIik7XG4gICAgfSxcbiAgICBiZWdpbkltYWdlRGF0YTogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfYmVnaW5JbWFnZURhdGEoKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIGJlZ2luSW1hZ2VEYXRhXCIpO1xuICAgIH0sXG4gICAgcGFpbnRGb3JtWE9iamVjdEJlZ2luOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEZvcm1YT2JqZWN0QmVnaW4obWF0cml4LCBiYm94KSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnB1c2godGhpcy5iYXNlVHJhbnNmb3JtKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSAmJiBtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtLmFwcGx5KHRoaXMsIG1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICAgIGlmIChiYm94KSB7XG4gICAgICAgIHZhciB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICAgIHRoaXMuY3R4LnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuY2xpcCgpO1xuICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBhaW50Rm9ybVhPYmplY3RFbmQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3BhaW50Rm9ybVhPYmplY3RFbmQoKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybVN0YWNrLnBvcCgpO1xuICAgIH0sXG4gICAgYmVnaW5Hcm91cDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfYmVnaW5Hcm91cChncm91cCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICB2YXIgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuXG4gICAgICBpZiAoIWdyb3VwLmlzb2xhdGVkKSB7XG4gICAgICAgICgwLCBfdXRpbC5pbmZvKShcIlRPRE86IFN1cHBvcnQgbm9uLWlzb2xhdGVkIGdyb3Vwcy5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChncm91cC5rbm9ja291dCkge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJLbm9ja291dCBncm91cHMgbm90IHN1cHBvcnRlZC5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gY3VycmVudEN0eC5tb3pDdXJyZW50VHJhbnNmb3JtO1xuXG4gICAgICBpZiAoZ3JvdXAubWF0cml4KSB7XG4gICAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtLmFwcGx5KGN1cnJlbnRDdHgsIGdyb3VwLm1hdHJpeCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb3VuZGluZyBib3ggaXMgcmVxdWlyZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRzID0gX3V0aWwuVXRpbC5nZXRBeGlhbEFsaWduZWRCb3VuZGluZ0JveChncm91cC5iYm94LCBjdXJyZW50Q3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm0pO1xuXG4gICAgICB2YXIgY2FudmFzQm91bmRzID0gWzAsIDAsIGN1cnJlbnRDdHguY2FudmFzLndpZHRoLCBjdXJyZW50Q3R4LmNhbnZhcy5oZWlnaHRdO1xuICAgICAgYm91bmRzID0gX3V0aWwuVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICAgIHZhciBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgICAgdmFyIG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgICB2YXIgZHJhd25XaWR0aCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbMl0pIC0gb2Zmc2V0WCwgMSk7XG4gICAgICB2YXIgZHJhd25IZWlnaHQgPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFksIDEpO1xuICAgICAgdmFyIHNjYWxlWCA9IDEsXG4gICAgICAgICAgc2NhbGVZID0gMTtcblxuICAgICAgaWYgKGRyYXduV2lkdGggPiBNQVhfR1JPVVBfU0laRSkge1xuICAgICAgICBzY2FsZVggPSBkcmF3bldpZHRoIC8gTUFYX0dST1VQX1NJWkU7XG4gICAgICAgIGRyYXduV2lkdGggPSBNQVhfR1JPVVBfU0laRTtcbiAgICAgIH1cblxuICAgICAgaWYgKGRyYXduSGVpZ2h0ID4gTUFYX0dST1VQX1NJWkUpIHtcbiAgICAgICAgc2NhbGVZID0gZHJhd25IZWlnaHQgLyBNQVhfR1JPVVBfU0laRTtcbiAgICAgICAgZHJhd25IZWlnaHQgPSBNQVhfR1JPVVBfU0laRTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhY2hlSWQgPSBcImdyb3VwQXRcIiArIHRoaXMuZ3JvdXBMZXZlbDtcblxuICAgICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICAgIGNhY2hlSWQgKz0gXCJfc21hc2tfXCIgKyB0aGlzLnNtYXNrQ291bnRlcisrICUgMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNjcmF0Y2hDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhjYWNoZUlkLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCwgdHJ1ZSk7XG4gICAgICB2YXIgZ3JvdXBDdHggPSBzY3JhdGNoQ2FudmFzLmNvbnRleHQ7XG4gICAgICBncm91cEN0eC5zY2FsZSgxIC8gc2NhbGVYLCAxIC8gc2NhbGVZKTtcbiAgICAgIGdyb3VwQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgICAgZ3JvdXBDdHgudHJhbnNmb3JtLmFwcGx5KGdyb3VwQ3R4LCBjdXJyZW50VHJhbnNmb3JtKTtcblxuICAgICAgaWYgKGdyb3VwLnNtYXNrKSB7XG4gICAgICAgIHRoaXMuc21hc2tTdGFjay5wdXNoKHtcbiAgICAgICAgICBjYW52YXM6IHNjcmF0Y2hDYW52YXMuY2FudmFzLFxuICAgICAgICAgIGNvbnRleHQ6IGdyb3VwQ3R4LFxuICAgICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgICAgb2Zmc2V0WTogb2Zmc2V0WSxcbiAgICAgICAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICAgICAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICAgIGJhY2tkcm9wOiBncm91cC5zbWFzay5iYWNrZHJvcCxcbiAgICAgICAgICB0cmFuc2Zlck1hcDogZ3JvdXAuc21hc2sudHJhbnNmZXJNYXAgfHwgbnVsbCxcbiAgICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY3VycmVudEN0eC50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgIGN1cnJlbnRDdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgfVxuXG4gICAgICBjb3B5Q3R4U3RhdGUoY3VycmVudEN0eCwgZ3JvdXBDdHgpO1xuICAgICAgdGhpcy5jdHggPSBncm91cEN0eDtcbiAgICAgIHRoaXMuc2V0R1N0YXRlKFtbXCJCTVwiLCBcInNvdXJjZS1vdmVyXCJdLCBbXCJjYVwiLCAxXSwgW1wiQ0FcIiwgMV1dKTtcbiAgICAgIHRoaXMuZ3JvdXBTdGFjay5wdXNoKGN1cnJlbnRDdHgpO1xuICAgICAgdGhpcy5ncm91cExldmVsKys7XG4gICAgICB0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgPSBudWxsO1xuICAgIH0sXG4gICAgZW5kR3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZEdyb3VwKGdyb3VwKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICAgIHZhciBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy5jdHggPSB0aGlzLmdyb3VwU3RhY2sucG9wKCk7XG5cbiAgICAgIGlmICh0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY3R4Lm1vekltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgICAgdGhpcy50ZW1wU01hc2sgPSB0aGlzLnNtYXNrU3RhY2sucG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UoZ3JvdXBDdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBiZWdpbkFubm90YXRpb25zOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19iZWdpbkFubm90YXRpb25zKCkge1xuICAgICAgdGhpcy5zYXZlKCk7XG5cbiAgICAgIGlmICh0aGlzLmJhc2VUcmFuc2Zvcm0pIHtcbiAgICAgICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtLmFwcGx5KHRoaXMuY3R4LCB0aGlzLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZW5kQW5ub3RhdGlvbnM6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZEFubm90YXRpb25zKCkge1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBiZWdpbkFubm90YXRpb246IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luQW5ub3RhdGlvbihyZWN0LCB0cmFuc2Zvcm0sIG1hdHJpeCkge1xuICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICByZXNldEN0eFRvRGVmYXVsdCh0aGlzLmN0eCk7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgQ2FudmFzRXh0cmFTdGF0ZSgpO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZWN0KSAmJiByZWN0Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB2YXIgd2lkdGggPSByZWN0WzJdIC0gcmVjdFswXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJlY3RbM10gLSByZWN0WzFdO1xuICAgICAgICB0aGlzLmN0eC5yZWN0KHJlY3RbMF0sIHJlY3RbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB0aGlzLmNsaXAoKTtcbiAgICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHJhbnNmb3JtLmFwcGx5KHRoaXMsIHRyYW5zZm9ybSk7XG4gICAgICB0aGlzLnRyYW5zZm9ybS5hcHBseSh0aGlzLCBtYXRyaXgpO1xuICAgIH0sXG4gICAgZW5kQW5ub3RhdGlvbjogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZW5kQW5ub3RhdGlvbigpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH0sXG4gICAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG4gICAgICB2YXIgd2lkdGggPSBpbWcud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgICAgdmFyIGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgICB2YXIgZ2x5cGggPSB0aGlzLnByb2Nlc3NpbmdUeXBlMztcblxuICAgICAgaWYgKENPTVBJTEVfVFlQRTNfR0xZUEhTICYmIGdseXBoICYmIGdseXBoLmNvbXBpbGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHdpZHRoIDw9IE1BWF9TSVpFX1RPX0NPTVBJTEUgJiYgaGVpZ2h0IDw9IE1BWF9TSVpFX1RPX0NPTVBJTEUpIHtcbiAgICAgICAgICBnbHlwaC5jb21waWxlZCA9IGNvbXBpbGVUeXBlM0dseXBoKHtcbiAgICAgICAgICAgIGRhdGE6IGltZy5kYXRhLFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbHlwaC5jb21waWxlZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdseXBoICYmIGdseXBoLmNvbXBpbGVkKSB7XG4gICAgICAgIGdseXBoLmNvbXBpbGVkKGN0eCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZyk7XG4gICAgICBtYXNrQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLWluXCI7XG4gICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzKSA6IGZpbGxDb2xvcjtcbiAgICAgIG1hc2tDdHguZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBtYXNrQ3R4LnJlc3RvcmUoKTtcbiAgICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QobWFza0NhbnZhcy5jYW52YXMpO1xuICAgIH0sXG4gICAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0UmVwZWF0OiBmdW5jdGlvbiBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQoaW1nRGF0YSwgc2NhbGVYKSB7XG4gICAgICB2YXIgc2tld1ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgICB2YXIgc2tld1kgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IDA7XG4gICAgICB2YXIgc2NhbGVZID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgcG9zaXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICB2YXIgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICAgIHZhciBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgICAgdmFyIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgbWFza0N0eCA9IG1hc2tDYW52YXMuY29udGV4dDtcbiAgICAgIG1hc2tDdHguc2F2ZSgpO1xuICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltZ0RhdGEpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcykgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jdHg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0oc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgcG9zaXRpb25zW2ldLCBwb3NpdGlvbnNbaSArIDFdKTtcbiAgICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLmNhbnZhcywgMCwgMCwgd2lkdGgsIGhlaWdodCwgMCwgLTEsIDEsIDEpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcGFpbnRJbWFnZU1hc2tYT2JqZWN0R3JvdXA6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3BhaW50SW1hZ2VNYXNrWE9iamVjdEdyb3VwKGltYWdlcykge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdmFyIGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgICB2YXIgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gaW1hZ2VzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIGltYWdlID0gaW1hZ2VzW2ldO1xuICAgICAgICB2YXIgd2lkdGggPSBpbWFnZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICAgICAgdmFyIG1hc2tDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1hc2tDYW52YXNcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIHZhciBtYXNrQ3R4ID0gbWFza0NhbnZhcy5jb250ZXh0O1xuICAgICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgICAgcHV0QmluYXJ5SW1hZ2VNYXNrKG1hc2tDdHgsIGltYWdlKTtcbiAgICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgICBtYXNrQ3R4LmZpbGxTdHlsZSA9IGlzUGF0dGVybkZpbGwgPyBmaWxsQ29sb3IuZ2V0UGF0dGVybihtYXNrQ3R4LCB0aGlzKSA6IGZpbGxDb2xvcjtcbiAgICAgICAgbWFza0N0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCBpbWFnZS50cmFuc2Zvcm0pO1xuICAgICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgICBjdHguZHJhd0ltYWdlKG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWludEltYWdlWE9iamVjdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRJbWFnZVhPYmplY3Qob2JqSWQpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpbWdEYXRhID0gb2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChvYmpJZCkgOiB0aGlzLm9ianMuZ2V0KG9iaklkKTtcblxuICAgICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIkRlcGVuZGVudCBpbWFnZSBpc24ndCByZWFkeSB5ZXRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgICB9LFxuICAgIHBhaW50SW1hZ2VYT2JqZWN0UmVwZWF0OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludEltYWdlWE9iamVjdFJlcGVhdChvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGltZ0RhdGEgPSBvYmpJZC5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KG9iaklkKSA6IHRoaXMub2Jqcy5nZXQob2JqSWQpO1xuXG4gICAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgICAgdmFyIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICBtYXAucHVzaCh7XG4gICAgICAgICAgdHJhbnNmb3JtOiBbc2NhbGVYLCAwLCAwLCBzY2FsZVksIHBvc2l0aW9uc1tpXSwgcG9zaXRpb25zW2kgKyAxXV0sXG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHc6IHdpZHRoLFxuICAgICAgICAgIGg6IGhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCk7XG4gICAgfSxcbiAgICBwYWludElubGluZUltYWdlWE9iamVjdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgY3R4LnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgICAgdmFyIGN1cnJlbnRUcmFuc2Zvcm0gPSBjdHgubW96Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG4gICAgICB2YXIgYSA9IGN1cnJlbnRUcmFuc2Zvcm1bMF0sXG4gICAgICAgICAgYiA9IGN1cnJlbnRUcmFuc2Zvcm1bMV07XG4gICAgICB2YXIgd2lkdGhTY2FsZSA9IE1hdGgubWF4KE1hdGguc3FydChhICogYSArIGIgKiBiKSwgMSk7XG4gICAgICB2YXIgYyA9IGN1cnJlbnRUcmFuc2Zvcm1bMl0sXG4gICAgICAgICAgZCA9IGN1cnJlbnRUcmFuc2Zvcm1bM107XG4gICAgICB2YXIgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLnNxcnQoYyAqIGMgKyBkICogZCksIDEpO1xuICAgICAgdmFyIGltZ1RvUGFpbnQsIHRtcENhbnZhcztcblxuICAgICAgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhLCB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzKTtcbiAgICAgICAgaW1nVG9QYWludCA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWludFdpZHRoID0gd2lkdGgsXG4gICAgICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB2YXIgdG1wQ2FudmFzSWQgPSBcInByZXNjYWxlMVwiO1xuXG4gICAgICB3aGlsZSAod2lkdGhTY2FsZSA+IDIgJiYgcGFpbnRXaWR0aCA+IDEgfHwgaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICB2YXIgbmV3V2lkdGggPSBwYWludFdpZHRoLFxuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gcGFpbnRIZWlnaHQ7XG5cbiAgICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgICAgbmV3V2lkdGggPSBNYXRoLmNlaWwocGFpbnRXaWR0aCAvIDIpO1xuICAgICAgICAgIHdpZHRoU2NhbGUgLz0gcGFpbnRXaWR0aCAvIG5ld1dpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgICAgICBuZXdIZWlnaHQgPSBNYXRoLmNlaWwocGFpbnRIZWlnaHQgLyAyKTtcbiAgICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKHRtcENhbnZhc0lkLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgICAgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICAgIHRtcEN0eC5jbGVhclJlY3QoMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1nVG9QYWludCwgMCwgMCwgcGFpbnRXaWR0aCwgcGFpbnRIZWlnaHQsIDAsIDAsIG5ld1dpZHRoLCBuZXdIZWlnaHQpO1xuICAgICAgICBpbWdUb1BhaW50ID0gdG1wQ2FudmFzLmNhbnZhcztcbiAgICAgICAgcGFpbnRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICBwYWludEhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgdG1wQ2FudmFzSWQgPSB0bXBDYW52YXNJZCA9PT0gXCJwcmVzY2FsZTFcIiA/IFwicHJlc2NhbGUyXCIgOiBcInByZXNjYWxlMVwiO1xuICAgICAgfVxuXG4gICAgICBjdHguZHJhd0ltYWdlKGltZ1RvUGFpbnQsIDAsIDAsIHBhaW50V2lkdGgsIHBhaW50SGVpZ2h0LCAwLCAtaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgaWYgKHRoaXMuaW1hZ2VMYXllcikge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldENhbnZhc1Bvc2l0aW9uKDAsIC1oZWlnaHQpO1xuICAgICAgICB0aGlzLmltYWdlTGF5ZXIuYXBwZW5kSW1hZ2Uoe1xuICAgICAgICAgIGltZ0RhdGE6IGltZ0RhdGEsXG4gICAgICAgICAgbGVmdDogcG9zaXRpb25bMF0sXG4gICAgICAgICAgdG9wOiBwb3NpdGlvblsxXSxcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyBjdXJyZW50VHJhbnNmb3JtWzBdLFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0IC8gY3VycmVudFRyYW5zZm9ybVszXVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSxcbiAgICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY3R4O1xuICAgICAgdmFyIHcgPSBpbWdEYXRhLndpZHRoO1xuICAgICAgdmFyIGggPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIHZhciB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHcsIGgpO1xuICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSwgdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IG1hcC5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IG1hcFtpXTtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIGVudHJ5LnRyYW5zZm9ybSk7XG4gICAgICAgIGN0eC5zY2FsZSgxLCAtMSk7XG4gICAgICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLmNhbnZhcywgZW50cnkueCwgZW50cnkueSwgZW50cnkudywgZW50cnkuaCwgMCwgLTEsIDEsIDEpO1xuXG4gICAgICAgIGlmICh0aGlzLmltYWdlTGF5ZXIpIHtcbiAgICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldENhbnZhc1Bvc2l0aW9uKGVudHJ5LngsIGVudHJ5LnkpO1xuICAgICAgICAgIHRoaXMuaW1hZ2VMYXllci5hcHBlbmRJbWFnZSh7XG4gICAgICAgICAgICBpbWdEYXRhOiBpbWdEYXRhLFxuICAgICAgICAgICAgbGVmdDogcG9zaXRpb25bMF0sXG4gICAgICAgICAgICB0b3A6IHBvc2l0aW9uWzFdLFxuICAgICAgICAgICAgd2lkdGg6IHcsXG4gICAgICAgICAgICBoZWlnaHQ6IGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX3BhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuICAgIH0sXG4gICAgbWFya1BvaW50OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19tYXJrUG9pbnQodGFnKSB7fSxcbiAgICBtYXJrUG9pbnRQcm9wczogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfbWFya1BvaW50UHJvcHModGFnLCBwcm9wZXJ0aWVzKSB7fSxcbiAgICBiZWdpbk1hcmtlZENvbnRlbnQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2JlZ2luTWFya2VkQ29udGVudCh0YWcpIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19iZWdpbk1hcmtlZENvbnRlbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh0YWcgPT09IFwiT0NcIikge1xuICAgICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgICB2aXNpYmxlOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZy5pc1Zpc2libGUocHJvcGVydGllcylcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgICB2aXNpYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gICAgfSxcbiAgICBlbmRNYXJrZWRDb250ZW50OiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19lbmRNYXJrZWRDb250ZW50KCkge1xuICAgICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sucG9wKCk7XG4gICAgICB0aGlzLmNvbnRlbnRWaXNpYmxlID0gdGhpcy5pc0NvbnRlbnRWaXNpYmxlKCk7XG4gICAgfSxcbiAgICBiZWdpbkNvbXBhdDogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfYmVnaW5Db21wYXQoKSB7fSxcbiAgICBlbmRDb21wYXQ6IGZ1bmN0aW9uIENhbnZhc0dyYXBoaWNzX2VuZENvbXBhdCgpIHt9LFxuICAgIGNvbnN1bWVQYXRoOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19jb25zdW1lUGF0aCgpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcblxuICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IEVPX0NMSVApIHtcbiAgICAgICAgICBjdHguY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgfSxcbiAgICBnZXRTaW5nbGVQaXhlbFdpZHRoOiBmdW5jdGlvbiBnZXRTaW5nbGVQaXhlbFdpZHRoKHNjYWxlKSB7XG4gICAgICBpZiAodGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9PT0gbnVsbCkge1xuICAgICAgICB2YXIgaW52ZXJzZSA9IHRoaXMuY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlO1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gTWF0aC5zcXJ0KE1hdGgubWF4KGludmVyc2VbMF0gKiBpbnZlcnNlWzBdICsgaW52ZXJzZVsxXSAqIGludmVyc2VbMV0sIGludmVyc2VbMl0gKiBpbnZlcnNlWzJdICsgaW52ZXJzZVszXSAqIGludmVyc2VbM10pKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGg7XG4gICAgfSxcbiAgICBnZXRDYW52YXNQb3NpdGlvbjogZnVuY3Rpb24gQ2FudmFzR3JhcGhpY3NfZ2V0Q2FudmFzUG9zaXRpb24oeCwgeSkge1xuICAgICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICByZXR1cm4gW3RyYW5zZm9ybVswXSAqIHggKyB0cmFuc2Zvcm1bMl0gKiB5ICsgdHJhbnNmb3JtWzRdLCB0cmFuc2Zvcm1bMV0gKiB4ICsgdHJhbnNmb3JtWzNdICogeSArIHRyYW5zZm9ybVs1XV07XG4gICAgfSxcbiAgICBpc0NvbnRlbnRWaXNpYmxlOiBmdW5jdGlvbiBDYW52YXNHcmFwaGljc19pc0NvbnRlbnRWaXNpYmxlKCkge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMubWFya2VkQ29udGVudFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXJrZWRDb250ZW50U3RhY2tbaV0udmlzaWJsZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZm9yICh2YXIgb3AgaW4gX3V0aWwuT1BTKSB7XG4gICAgQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW191dGlsLk9QU1tvcF1dID0gQ2FudmFzR3JhcGhpY3MucHJvdG90eXBlW29wXTtcbiAgfVxuXG4gIHJldHVybiBDYW52YXNHcmFwaGljcztcbn0oKTtcblxuZXhwb3J0cy5DYW52YXNHcmFwaGljcyA9IENhbnZhc0dyYXBoaWNzO1xuXG4vKioqLyB9KSxcbi8qIDIwOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5nZXRTaGFkaW5nUGF0dGVybkZyb21JUiA9IGdldFNoYWRpbmdQYXR0ZXJuRnJvbUlSO1xuZXhwb3J0cy5UaWxpbmdQYXR0ZXJuID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG52YXIgU2hhZGluZ0lScyA9IHt9O1xuXG5mdW5jdGlvbiBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCkge1xuICBpZiAoIWJib3ggfHwgdHlwZW9mIFBhdGgyRCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICB2YXIgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIHZhciByZWdpb24gPSBuZXcgUGF0aDJEKCk7XG4gIHJlZ2lvbi5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICBjdHguY2xpcChyZWdpb24pO1xufVxuXG5TaGFkaW5nSVJzLlJhZGlhbEF4aWFsID0ge1xuICBmcm9tSVI6IGZ1bmN0aW9uIFJhZGlhbEF4aWFsX2Zyb21JUihyYXcpIHtcbiAgICB2YXIgdHlwZSA9IHJhd1sxXTtcbiAgICB2YXIgYmJveCA9IHJhd1syXTtcbiAgICB2YXIgY29sb3JTdG9wcyA9IHJhd1szXTtcbiAgICB2YXIgcDAgPSByYXdbNF07XG4gICAgdmFyIHAxID0gcmF3WzVdO1xuICAgIHZhciByMCA9IHJhd1s2XTtcbiAgICB2YXIgcjEgPSByYXdbN107XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiUGF0dGVyblwiLFxuICAgICAgZ2V0UGF0dGVybjogZnVuY3Rpb24gUmFkaWFsQXhpYWxfZ2V0UGF0dGVybihjdHgpIHtcbiAgICAgICAgYXBwbHlCb3VuZGluZ0JveChjdHgsIGJib3gpO1xuICAgICAgICB2YXIgZ3JhZDtcblxuICAgICAgICBpZiAodHlwZSA9PT0gXCJheGlhbFwiKSB7XG4gICAgICAgICAgZ3JhZCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChwMFswXSwgcDBbMV0sIHAxWzBdLCBwMVsxXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJyYWRpYWxcIikge1xuICAgICAgICAgIGdyYWQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQocDBbMF0sIHAwWzFdLCByMCwgcDFbMF0sIHAxWzFdLCByMSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjb2xvclN0b3BzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgICB2YXIgYyA9IGNvbG9yU3RvcHNbaV07XG4gICAgICAgICAgZ3JhZC5hZGRDb2xvclN0b3AoY1swXSwgY1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ3JhZDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG52YXIgY3JlYXRlTWVzaENhbnZhcyA9IGZ1bmN0aW9uIGNyZWF0ZU1lc2hDYW52YXNDbG9zdXJlKCkge1xuICBmdW5jdGlvbiBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcDEsIHAyLCBwMywgYzEsIGMyLCBjMykge1xuICAgIHZhciBjb29yZHMgPSBjb250ZXh0LmNvb3JkcyxcbiAgICAgICAgY29sb3JzID0gY29udGV4dC5jb2xvcnM7XG4gICAgdmFyIGJ5dGVzID0gZGF0YS5kYXRhLFxuICAgICAgICByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gICAgdmFyIHRtcDtcblxuICAgIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgICB0bXAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHRtcDtcbiAgICAgIHRtcCA9IGMxO1xuICAgICAgYzEgPSBjMjtcbiAgICAgIGMyID0gdG1wO1xuICAgIH1cblxuICAgIGlmIChjb29yZHNbcDIgKyAxXSA+IGNvb3Jkc1twMyArIDFdKSB7XG4gICAgICB0bXAgPSBwMjtcbiAgICAgIHAyID0gcDM7XG4gICAgICBwMyA9IHRtcDtcbiAgICAgIHRtcCA9IGMyO1xuICAgICAgYzIgPSBjMztcbiAgICAgIGMzID0gdG1wO1xuICAgIH1cblxuICAgIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgICB0bXAgPSBwMTtcbiAgICAgIHAxID0gcDI7XG4gICAgICBwMiA9IHRtcDtcbiAgICAgIHRtcCA9IGMxO1xuICAgICAgYzEgPSBjMjtcbiAgICAgIGMyID0gdG1wO1xuICAgIH1cblxuICAgIHZhciB4MSA9IChjb29yZHNbcDFdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICAgIHZhciB5MSA9IChjb29yZHNbcDEgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgICB2YXIgeDIgPSAoY29vcmRzW3AyXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgICB2YXIgeTIgPSAoY29vcmRzW3AyICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gICAgdmFyIHgzID0gKGNvb3Jkc1twM10gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gICAgdmFyIHkzID0gKGNvb3Jkc1twMyArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuXG4gICAgaWYgKHkxID49IHkzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGMxciA9IGNvbG9yc1tjMV0sXG4gICAgICAgIGMxZyA9IGNvbG9yc1tjMSArIDFdLFxuICAgICAgICBjMWIgPSBjb2xvcnNbYzEgKyAyXTtcbiAgICB2YXIgYzJyID0gY29sb3JzW2MyXSxcbiAgICAgICAgYzJnID0gY29sb3JzW2MyICsgMV0sXG4gICAgICAgIGMyYiA9IGNvbG9yc1tjMiArIDJdO1xuICAgIHZhciBjM3IgPSBjb2xvcnNbYzNdLFxuICAgICAgICBjM2cgPSBjb2xvcnNbYzMgKyAxXSxcbiAgICAgICAgYzNiID0gY29sb3JzW2MzICsgMl07XG4gICAgdmFyIG1pblkgPSBNYXRoLnJvdW5kKHkxKSxcbiAgICAgICAgbWF4WSA9IE1hdGgucm91bmQoeTMpO1xuICAgIHZhciB4YSwgY2FyLCBjYWcsIGNhYjtcbiAgICB2YXIgeGIsIGNiciwgY2JnLCBjYmI7XG5cbiAgICBmb3IgKHZhciB5ID0gbWluWTsgeSA8PSBtYXhZOyB5KyspIHtcbiAgICAgIGlmICh5IDwgeTIpIHtcbiAgICAgICAgdmFyIF9rID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh5IDwgeTEpIHtcbiAgICAgICAgICBfayA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoeTEgPT09IHkyKSB7XG4gICAgICAgICAgX2sgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9rID0gKHkxIC0geSkgLyAoeTEgLSB5Mik7XG4gICAgICAgIH1cblxuICAgICAgICB4YSA9IHgxIC0gKHgxIC0geDIpICogX2s7XG4gICAgICAgIGNhciA9IGMxciAtIChjMXIgLSBjMnIpICogX2s7XG4gICAgICAgIGNhZyA9IGMxZyAtIChjMWcgLSBjMmcpICogX2s7XG4gICAgICAgIGNhYiA9IGMxYiAtIChjMWIgLSBjMmIpICogX2s7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX2syID0gdm9pZCAwO1xuXG4gICAgICAgIGlmICh5ID4geTMpIHtcbiAgICAgICAgICBfazIgPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHkyID09PSB5Mykge1xuICAgICAgICAgIF9rMiA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2syID0gKHkyIC0geSkgLyAoeTIgLSB5Myk7XG4gICAgICAgIH1cblxuICAgICAgICB4YSA9IHgyIC0gKHgyIC0geDMpICogX2syO1xuICAgICAgICBjYXIgPSBjMnIgLSAoYzJyIC0gYzNyKSAqIF9rMjtcbiAgICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBfazI7XG4gICAgICAgIGNhYiA9IGMyYiAtIChjMmIgLSBjM2IpICogX2syO1xuICAgICAgfVxuXG4gICAgICB2YXIgayA9IHZvaWQgMDtcblxuICAgICAgaWYgKHkgPCB5MSkge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoeSA+IHkzKSB7XG4gICAgICAgIGsgPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgayA9ICh5MSAtIHkpIC8gKHkxIC0geTMpO1xuICAgICAgfVxuXG4gICAgICB4YiA9IHgxIC0gKHgxIC0geDMpICogaztcbiAgICAgIGNiciA9IGMxciAtIChjMXIgLSBjM3IpICogaztcbiAgICAgIGNiZyA9IGMxZyAtIChjMWcgLSBjM2cpICogaztcbiAgICAgIGNiYiA9IGMxYiAtIChjMWIgLSBjM2IpICogaztcbiAgICAgIHZhciB4MV8gPSBNYXRoLnJvdW5kKE1hdGgubWluKHhhLCB4YikpO1xuICAgICAgdmFyIHgyXyA9IE1hdGgucm91bmQoTWF0aC5tYXgoeGEsIHhiKSk7XG4gICAgICB2YXIgaiA9IHJvd1NpemUgKiB5ICsgeDFfICogNDtcblxuICAgICAgZm9yICh2YXIgeCA9IHgxXzsgeCA8PSB4Ml87IHgrKykge1xuICAgICAgICBrID0gKHhhIC0geCkgLyAoeGEgLSB4Yik7XG5cbiAgICAgICAgaWYgKGsgPCAwKSB7XG4gICAgICAgICAgayA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoayA+IDEpIHtcbiAgICAgICAgICBrID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJ5dGVzW2orK10gPSBjYXIgLSAoY2FyIC0gY2JyKSAqIGsgfCAwO1xuICAgICAgICBieXRlc1tqKytdID0gY2FnIC0gKGNhZyAtIGNiZykgKiBrIHwgMDtcbiAgICAgICAgYnl0ZXNbaisrXSA9IGNhYiAtIChjYWIgLSBjYmIpICogayB8IDA7XG4gICAgICAgIGJ5dGVzW2orK10gPSAyNTU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpIHtcbiAgICB2YXIgcHMgPSBmaWd1cmUuY29vcmRzO1xuICAgIHZhciBjcyA9IGZpZ3VyZS5jb2xvcnM7XG4gICAgdmFyIGksIGlpO1xuXG4gICAgc3dpdGNoIChmaWd1cmUudHlwZSkge1xuICAgICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgICAgdmFyIHZlcnRpY2VzUGVyUm93ID0gZmlndXJlLnZlcnRpY2VzUGVyUm93O1xuICAgICAgICB2YXIgcm93cyA9IE1hdGguZmxvb3IocHMubGVuZ3RoIC8gdmVydGljZXNQZXJSb3cpIC0gMTtcbiAgICAgICAgdmFyIGNvbHMgPSB2ZXJ0aWNlc1BlclJvdyAtIDE7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgIHZhciBxID0gaSAqIHZlcnRpY2VzUGVyUm93O1xuXG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb2xzOyBqKyssIHErKykge1xuICAgICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3FdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3FdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgICAgZHJhd1RyaWFuZ2xlKGRhdGEsIGNvbnRleHQsIHBzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBwc1txICsgMV0sIHBzW3EgKyB2ZXJ0aWNlc1BlclJvd10sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvdyArIDFdLCBjc1txICsgMV0sIGNzW3EgKyB2ZXJ0aWNlc1BlclJvd10pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFwidHJpYW5nbGVzXCI6XG4gICAgICAgIGZvciAoaSA9IDAsIGlpID0gcHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1tpXSwgcHNbaSArIDFdLCBwc1tpICsgMl0sIGNzW2ldLCBjc1tpICsgMV0sIGNzW2kgKyAyXSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBmaWd1cmVcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTWVzaENhbnZhcyhib3VuZHMsIGNvbWJpbmVzU2NhbGUsIGNvb3JkcywgY29sb3JzLCBmaWd1cmVzLCBiYWNrZ3JvdW5kQ29sb3IsIGNhY2hlZENhbnZhc2VzLCB3ZWJHTENvbnRleHQpIHtcbiAgICB2YXIgRVhQRUNURURfU0NBTEUgPSAxLjE7XG4gICAgdmFyIE1BWF9QQVRURVJOX1NJWkUgPSAzMDAwO1xuICAgIHZhciBCT1JERVJfU0laRSA9IDI7XG4gICAgdmFyIG9mZnNldFggPSBNYXRoLmZsb29yKGJvdW5kc1swXSk7XG4gICAgdmFyIG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgdmFyIGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKGJvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIHZhciBib3VuZHNIZWlnaHQgPSBNYXRoLmNlaWwoYm91bmRzWzNdKSAtIG9mZnNldFk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5taW4oTWF0aC5jZWlsKE1hdGguYWJzKGJvdW5kc1dpZHRoICogY29tYmluZXNTY2FsZVswXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZXNTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIHZhciBzY2FsZVggPSBib3VuZHNXaWR0aCAvIHdpZHRoO1xuICAgIHZhciBzY2FsZVkgPSBib3VuZHNIZWlnaHQgLyBoZWlnaHQ7XG4gICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IGNvb3JkcyxcbiAgICAgIGNvbG9yczogY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgdmFyIHBhZGRlZFdpZHRoID0gd2lkdGggKyBCT1JERVJfU0laRSAqIDI7XG4gICAgdmFyIHBhZGRlZEhlaWdodCA9IGhlaWdodCArIEJPUkRFUl9TSVpFICogMjtcbiAgICB2YXIgY2FudmFzLCB0bXBDYW52YXMsIGksIGlpO1xuXG4gICAgaWYgKHdlYkdMQ29udGV4dC5pc0VuYWJsZWQpIHtcbiAgICAgIGNhbnZhcyA9IHdlYkdMQ29udGV4dC5kcmF3RmlndXJlcyh7XG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yLFxuICAgICAgICBmaWd1cmVzOiBmaWd1cmVzLFxuICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICB9KTtcbiAgICAgIHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCwgZmFsc2UpO1xuICAgICAgdG1wQ2FudmFzLmNvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICAgIGNhbnZhcyA9IHRtcENhbnZhcy5jYW52YXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRtcENhbnZhcyA9IGNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcIm1lc2hcIiwgcGFkZGVkV2lkdGgsIHBhZGRlZEhlaWdodCwgZmFsc2UpO1xuICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdmFyIGRhdGEgPSB0bXBDdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgICBpZiAoYmFja2dyb3VuZENvbG9yKSB7XG4gICAgICAgIHZhciBieXRlcyA9IGRhdGEuZGF0YTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBpaSA9IGJ5dGVzLmxlbmd0aDsgaSA8IGlpOyBpICs9IDQpIHtcbiAgICAgICAgICBieXRlc1tpXSA9IGJhY2tncm91bmRDb2xvclswXTtcbiAgICAgICAgICBieXRlc1tpICsgMV0gPSBiYWNrZ3JvdW5kQ29sb3JbMV07XG4gICAgICAgICAgYnl0ZXNbaSArIDJdID0gYmFja2dyb3VuZENvbG9yWzJdO1xuICAgICAgICAgIGJ5dGVzW2kgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgZmlndXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZXNbaV0sIGNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB0bXBDdHgucHV0SW1hZ2VEYXRhKGRhdGEsIEJPUkRFUl9TSVpFLCBCT1JERVJfU0laRSk7XG4gICAgICBjYW52YXMgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IGNhbnZhcyxcbiAgICAgIG9mZnNldFg6IG9mZnNldFggLSBCT1JERVJfU0laRSAqIHNjYWxlWCxcbiAgICAgIG9mZnNldFk6IG9mZnNldFkgLSBCT1JERVJfU0laRSAqIHNjYWxlWSxcbiAgICAgIHNjYWxlWDogc2NhbGVYLFxuICAgICAgc2NhbGVZOiBzY2FsZVlcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZU1lc2hDYW52YXM7XG59KCk7XG5cblNoYWRpbmdJUnMuTWVzaCA9IHtcbiAgZnJvbUlSOiBmdW5jdGlvbiBNZXNoX2Zyb21JUihyYXcpIHtcbiAgICB2YXIgY29vcmRzID0gcmF3WzJdO1xuICAgIHZhciBjb2xvcnMgPSByYXdbM107XG4gICAgdmFyIGZpZ3VyZXMgPSByYXdbNF07XG4gICAgdmFyIGJvdW5kcyA9IHJhd1s1XTtcbiAgICB2YXIgbWF0cml4ID0gcmF3WzZdO1xuICAgIHZhciBiYm94ID0gcmF3WzddO1xuICAgIHZhciBiYWNrZ3JvdW5kID0gcmF3WzhdO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcIlBhdHRlcm5cIixcbiAgICAgIGdldFBhdHRlcm46IGZ1bmN0aW9uIE1lc2hfZ2V0UGF0dGVybihjdHgsIG93bmVyLCBzaGFkaW5nRmlsbCkge1xuICAgICAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCk7XG4gICAgICAgIHZhciBzY2FsZTtcblxuICAgICAgICBpZiAoc2hhZGluZ0ZpbGwpIHtcbiAgICAgICAgICBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUoY3R4Lm1vekN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZShvd25lci5iYXNlVHJhbnNmb3JtKTtcblxuICAgICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHZhciBtYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobWF0cml4KTtcblxuICAgICAgICAgICAgc2NhbGUgPSBbc2NhbGVbMF0gKiBtYXRyaXhTY2FsZVswXSwgc2NhbGVbMV0gKiBtYXRyaXhTY2FsZVsxXV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMgPSBjcmVhdGVNZXNoQ2FudmFzKGJvdW5kcywgc2NhbGUsIGNvb3JkcywgY29sb3JzLCBmaWd1cmVzLCBzaGFkaW5nRmlsbCA/IG51bGwgOiBiYWNrZ3JvdW5kLCBvd25lci5jYWNoZWRDYW52YXNlcywgb3duZXIud2ViR0xDb250ZXh0KTtcblxuICAgICAgICBpZiAoIXNoYWRpbmdGaWxsKSB7XG4gICAgICAgICAgY3R4LnNldFRyYW5zZm9ybS5hcHBseShjdHgsIG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuXG4gICAgICAgICAgaWYgKG1hdHJpeCkge1xuICAgICAgICAgICAgY3R4LnRyYW5zZm9ybS5hcHBseShjdHgsIG1hdHJpeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgICAgIGN0eC5zY2FsZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgICAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5jYW52YXMsIFwibm8tcmVwZWF0XCIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5TaGFkaW5nSVJzLkR1bW15ID0ge1xuICBmcm9tSVI6IGZ1bmN0aW9uIER1bW15X2Zyb21JUigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJQYXR0ZXJuXCIsXG4gICAgICBnZXRQYXR0ZXJuOiBmdW5jdGlvbiBEdW1teV9mcm9tSVJfZ2V0UGF0dGVybigpIHtcbiAgICAgICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldFNoYWRpbmdQYXR0ZXJuRnJvbUlSKHJhdykge1xuICB2YXIgc2hhZGluZ0lSID0gU2hhZGluZ0lSc1tyYXdbMF1dO1xuXG4gIGlmICghc2hhZGluZ0lSKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBJUiB0eXBlOiBcIi5jb25jYXQocmF3WzBdKSk7XG4gIH1cblxuICByZXR1cm4gc2hhZGluZ0lSLmZyb21JUihyYXcpO1xufVxuXG52YXIgVGlsaW5nUGF0dGVybiA9IGZ1bmN0aW9uIFRpbGluZ1BhdHRlcm5DbG9zdXJlKCkge1xuICB2YXIgUGFpbnRUeXBlID0ge1xuICAgIENPTE9SRUQ6IDEsXG4gICAgVU5DT0xPUkVEOiAyXG4gIH07XG4gIHZhciBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcblxuICBmdW5jdGlvbiBUaWxpbmdQYXR0ZXJuKElSLCBjb2xvciwgY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pIHtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdCA9IElSWzJdO1xuICAgIHRoaXMubWF0cml4ID0gSVJbM10gfHwgWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIHRoaXMuYmJveCA9IElSWzRdO1xuICAgIHRoaXMueHN0ZXAgPSBJUls1XTtcbiAgICB0aGlzLnlzdGVwID0gSVJbNl07XG4gICAgdGhpcy5wYWludFR5cGUgPSBJUls3XTtcbiAgICB0aGlzLnRpbGluZ1R5cGUgPSBJUls4XTtcbiAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgdGhpcy5jYW52YXNHcmFwaGljc0ZhY3RvcnkgPSBjYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gYmFzZVRyYW5zZm9ybTtcbiAgICB0aGlzLnR5cGUgPSBcIlBhdHRlcm5cIjtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgfVxuXG4gIFRpbGluZ1BhdHRlcm4ucHJvdG90eXBlID0ge1xuICAgIGNyZWF0ZVBhdHRlcm5DYW52YXM6IGZ1bmN0aW9uIFRpbGluUGF0dGVybl9jcmVhdGVQYXR0ZXJuQ2FudmFzKG93bmVyKSB7XG4gICAgICB2YXIgb3BlcmF0b3JMaXN0ID0gdGhpcy5vcGVyYXRvckxpc3Q7XG4gICAgICB2YXIgYmJveCA9IHRoaXMuYmJveDtcbiAgICAgIHZhciB4c3RlcCA9IHRoaXMueHN0ZXA7XG4gICAgICB2YXIgeXN0ZXAgPSB0aGlzLnlzdGVwO1xuICAgICAgdmFyIHBhaW50VHlwZSA9IHRoaXMucGFpbnRUeXBlO1xuICAgICAgdmFyIHRpbGluZ1R5cGUgPSB0aGlzLnRpbGluZ1R5cGU7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmNvbG9yO1xuICAgICAgdmFyIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IHRoaXMuY2FudmFzR3JhcGhpY3NGYWN0b3J5O1xuICAgICAgKDAsIF91dGlsLmluZm8pKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICAgIHZhciB4MCA9IGJib3hbMF0sXG4gICAgICAgICAgeTAgPSBiYm94WzFdLFxuICAgICAgICAgIHgxID0gYmJveFsyXSxcbiAgICAgICAgICB5MSA9IGJib3hbM107XG5cbiAgICAgIHZhciBtYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5tYXRyaXgpO1xuXG4gICAgICB2YXIgY3VyTWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG5cbiAgICAgIHZhciBjb21iaW5lZFNjYWxlID0gW21hdHJpeFNjYWxlWzBdICogY3VyTWF0cml4U2NhbGVbMF0sIG1hdHJpeFNjYWxlWzFdICogY3VyTWF0cml4U2NhbGVbMV1dO1xuICAgICAgdmFyIGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZSh4c3RlcCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWzBdKTtcbiAgICAgIHZhciBkaW15ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoeXN0ZXAsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVbMV0pO1xuICAgICAgdmFyIHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUsIHRydWUpO1xuICAgICAgdmFyIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdmFyIGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCk7XG4gICAgICBncmFwaGljcy5ncm91cExldmVsID0gb3duZXIuZ3JvdXBMZXZlbDtcbiAgICAgIHRoaXMuc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0KGdyYXBoaWNzLCBwYWludFR5cGUsIGNvbG9yKTtcbiAgICAgIGdyYXBoaWNzLnRyYW5zZm9ybShkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICAgIGdyYXBoaWNzLnRyYW5zZm9ybSgxLCAwLCAwLCAxLCAteDAsIC15MCk7XG4gICAgICB0aGlzLmNsaXBCYm94KGdyYXBoaWNzLCBiYm94LCB4MCwgeTAsIHgxLCB5MSk7XG4gICAgICBncmFwaGljcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oMSwgMCwgMCwgMSwgeDAsIHkwKTtcbiAgICAgIHRoaXMuY3R4LnNjYWxlKDEgLyBkaW14LnNjYWxlLCAxIC8gZGlteS5zY2FsZSk7XG4gICAgICByZXR1cm4gdG1wQ2FudmFzLmNhbnZhcztcbiAgICB9LFxuICAgIGdldFNpemVBbmRTY2FsZTogZnVuY3Rpb24gVGlsaW5nUGF0dGVybl9nZXRTaXplQW5kU2NhbGUoc3RlcCwgcmVhbE91dHB1dFNpemUsIHNjYWxlKSB7XG4gICAgICBzdGVwID0gTWF0aC5hYnMoc3RlcCk7XG4gICAgICB2YXIgbWF4U2l6ZSA9IE1hdGgubWF4KE1BWF9QQVRURVJOX1NJWkUsIHJlYWxPdXRwdXRTaXplKTtcbiAgICAgIHZhciBzaXplID0gTWF0aC5jZWlsKHN0ZXAgKiBzY2FsZSk7XG5cbiAgICAgIGlmIChzaXplID49IG1heFNpemUpIHtcbiAgICAgICAgc2l6ZSA9IG1heFNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZSA9IHNpemUgLyBzdGVwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBzY2FsZTogc2NhbGUsXG4gICAgICAgIHNpemU6IHNpemVcbiAgICAgIH07XG4gICAgfSxcbiAgICBjbGlwQmJveDogZnVuY3Rpb24gY2xpcEJib3goZ3JhcGhpY3MsIGJib3gsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShiYm94KSAmJiBiYm94Lmxlbmd0aCA9PT0gNCkge1xuICAgICAgICB2YXIgYmJveFdpZHRoID0geDEgLSB4MDtcbiAgICAgICAgdmFyIGJib3hIZWlnaHQgPSB5MSAtIHkwO1xuICAgICAgICBncmFwaGljcy5jdHgucmVjdCh4MCwgeTAsIGJib3hXaWR0aCwgYmJveEhlaWdodCk7XG4gICAgICAgIGdyYXBoaWNzLmNsaXAoKTtcbiAgICAgICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0RmlsbEFuZFN0cm9rZVN0eWxlVG9Db250ZXh0OiBmdW5jdGlvbiBzZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gZ3JhcGhpY3MuY3R4LFxuICAgICAgICAgIGN1cnJlbnQgPSBncmFwaGljcy5jdXJyZW50O1xuXG4gICAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgICBjYXNlIFBhaW50VHlwZS5DT0xPUkVEOlxuICAgICAgICAgIHZhciBjdHggPSB0aGlzLmN0eDtcbiAgICAgICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGN0eC5maWxsU3R5bGU7XG4gICAgICAgICAgY3VycmVudC5zdHJva2VDb2xvciA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhaW50VHlwZS5VTkNPTE9SRUQ6XG4gICAgICAgICAgdmFyIGNzc0NvbG9yID0gX3V0aWwuVXRpbC5tYWtlQ3NzUmdiKGNvbG9yWzBdLCBjb2xvclsxXSwgY29sb3JbMl0pO1xuXG4gICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgICBjb250ZXh0LnN0cm9rZVN0eWxlID0gY3NzQ29sb3I7XG4gICAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgX3V0aWwuRm9ybWF0RXJyb3IoXCJVbnN1cHBvcnRlZCBwYWludCB0eXBlOiBcIi5jb25jYXQocGFpbnRUeXBlKSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXRQYXR0ZXJuOiBmdW5jdGlvbiBUaWxpbmdQYXR0ZXJuX2dldFBhdHRlcm4oY3R4LCBvd25lcikge1xuICAgICAgY3R4ID0gdGhpcy5jdHg7XG4gICAgICBjdHguc2V0VHJhbnNmb3JtLmFwcGx5KGN0eCwgdGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGN0eC50cmFuc2Zvcm0uYXBwbHkoY3R4LCB0aGlzLm1hdHJpeCk7XG4gICAgICB2YXIgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcik7XG4gICAgICByZXR1cm4gY3R4LmNyZWF0ZVBhdHRlcm4odGVtcG9yYXJ5UGF0dGVybkNhbnZhcywgXCJyZXBlYXRcIik7XG4gICAgfVxuICB9O1xuICByZXR1cm4gVGlsaW5nUGF0dGVybjtcbn0oKTtcblxuZXhwb3J0cy5UaWxpbmdQYXR0ZXJuID0gVGlsaW5nUGF0dGVybjtcblxuLyoqKi8gfSksXG4vKiAyMDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuR2xvYmFsV29ya2VyT3B0aW9ucyA9IHZvaWQgMDtcbnZhciBHbG9iYWxXb3JrZXJPcHRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydHMuR2xvYmFsV29ya2VyT3B0aW9ucyA9IEdsb2JhbFdvcmtlck9wdGlvbnM7XG5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnQgPSBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnQgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBHbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclBvcnQ7XG5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9IEdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjID09PSB1bmRlZmluZWQgPyBcIlwiIDogR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmM7XG5cbi8qKiovIH0pLFxuLyogMjEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dfcGRmanNfcmVxdWlyZV9fKDIpKTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgQ2FsbGJhY2tLaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBEQVRBOiAxLFxuICBFUlJPUjogMlxufTtcbnZhciBTdHJlYW1LaW5kID0ge1xuICBVTktOT1dOOiAwLFxuICBDQU5DRUw6IDEsXG4gIENBTkNFTF9DT01QTEVURTogMixcbiAgQ0xPU0U6IDMsXG4gIEVOUVVFVUU6IDQsXG4gIEVSUk9SOiA1LFxuICBQVUxMOiA2LFxuICBQVUxMX0NPTVBMRVRFOiA3LFxuICBTVEFSVF9DT01QTEVURTogOFxufTtcblxuZnVuY3Rpb24gd3JhcFJlYXNvbihyZWFzb24pIHtcbiAgaWYgKF90eXBlb2YocmVhc29uKSAhPT0gXCJvYmplY3RcIiB8fCByZWFzb24gPT09IG51bGwpIHtcbiAgICByZXR1cm4gcmVhc29uO1xuICB9XG5cbiAgc3dpdGNoIChyZWFzb24ubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG5cbiAgICBjYXNlIFwiTWlzc2luZ1BERkV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlKTtcblxuICAgIGNhc2UgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uc3RhdHVzKTtcblxuICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uZGV0YWlscyk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi50b1N0cmluZygpKTtcbiAgfVxufVxuXG52YXIgTWVzc2FnZUhhbmRsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZXNzYWdlSGFuZGxlcihzb3VyY2VOYW1lLCB0YXJnZXROYW1lLCBjb21PYmopIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1lc3NhZ2VIYW5kbGVyKTtcblxuICAgIHRoaXMuc291cmNlTmFtZSA9IHNvdXJjZU5hbWU7XG4gICAgdGhpcy50YXJnZXROYW1lID0gdGFyZ2V0TmFtZTtcbiAgICB0aGlzLmNvbU9iaiA9IGNvbU9iajtcbiAgICB0aGlzLmNhbGxiYWNrSWQgPSAxO1xuICAgIHRoaXMuc3RyZWFtSWQgPSAxO1xuICAgIHRoaXMucG9zdE1lc3NhZ2VUcmFuc2ZlcnMgPSB0cnVlO1xuICAgIHRoaXMuc3RyZWFtU2lua3MgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuYWN0aW9uSGFuZGxlciA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgICBpZiAoZGF0YS50YXJnZXROYW1lICE9PSBfdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc3RyZWFtKSB7XG4gICAgICAgIF90aGlzLl9wcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFja0lkID0gZGF0YS5jYWxsYmFja0lkO1xuICAgICAgICB2YXIgY2FwYWJpbGl0eSA9IF90aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuXG4gICAgICAgIGlmICghY2FwYWJpbGl0eSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCByZXNvbHZlIGNhbGxiYWNrIFwiLmNvbmNhdChjYWxsYmFja0lkKSk7XG4gICAgICAgIH1cblxuICAgICAgICBkZWxldGUgX3RoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG5cbiAgICAgICAgaWYgKGRhdGEuY2FsbGJhY2sgPT09IENhbGxiYWNrS2luZC5EQVRBKSB7XG4gICAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKGRhdGEuZGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkVSUk9SKSB7XG4gICAgICAgICAgY2FwYWJpbGl0eS5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgY2FsbGJhY2sgY2FzZVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGFjdGlvbiA9IF90aGlzLmFjdGlvbkhhbmRsZXJbZGF0YS5hY3Rpb25dO1xuXG4gICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGFjdGlvbiBmcm9tIHdvcmtlcjogXCIuY29uY2F0KGRhdGEuYWN0aW9uKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkYXRhLmNhbGxiYWNrSWQpIHtcbiAgICAgICAgdmFyIGNiU291cmNlTmFtZSA9IF90aGlzLnNvdXJjZU5hbWU7XG4gICAgICAgIHZhciBjYlRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWU7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkRBVEEsXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICBkYXRhOiByZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBjYlNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiBjYlRhcmdldE5hbWUsXG4gICAgICAgICAgICBjYWxsYmFjazogQ2FsbGJhY2tLaW5kLkVSUk9SLFxuICAgICAgICAgICAgY2FsbGJhY2tJZDogZGF0YS5jYWxsYmFja0lkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgICAgX3RoaXMuX2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBhY3Rpb24oZGF0YS5kYXRhKTtcbiAgICB9O1xuXG4gICAgY29tT2JqLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIHRoaXMuX29uQ29tT2JqT25NZXNzYWdlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZXNzYWdlSGFuZGxlciwgW3tcbiAgICBrZXk6IFwib25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24oYWN0aW9uTmFtZSwgaGFuZGxlcikge1xuICAgICAgdmFyIGFoID0gdGhpcy5hY3Rpb25IYW5kbGVyO1xuXG4gICAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcXFwiXCIuY29uY2F0KGFjdGlvbk5hbWUsIFwiXFxcIlwiKSk7XG4gICAgICB9XG5cbiAgICAgIGFoW2FjdGlvbk5hbWVdID0gaGFuZGxlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgICAgdGhpcy5fcG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZW5kV2l0aFByb21pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFdpdGhQcm9taXNlKGFjdGlvbk5hbWUsIGRhdGEsIHRyYW5zZmVycykge1xuICAgICAgdmFyIGNhbGxiYWNrSWQgPSB0aGlzLmNhbGxiYWNrSWQrKztcbiAgICAgIHZhciBjYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllc1tjYWxsYmFja0lkXSA9IGNhcGFiaWxpdHk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX3Bvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZTogdGhpcy50YXJnZXROYW1lLFxuICAgICAgICAgIGFjdGlvbjogYWN0aW9uTmFtZSxcbiAgICAgICAgICBjYWxsYmFja0lkOiBjYWxsYmFja0lkLFxuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSwgdHJhbnNmZXJzKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGNhcGFiaWxpdHkucmVqZWN0KGV4KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFdpdGhTdHJlYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHN0cmVhbUlkID0gdGhpcy5zdHJlYW1JZCsrO1xuICAgICAgdmFyIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWU7XG4gICAgICB2YXIgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZTtcbiAgICAgIHZhciBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIHZhciBzdGFydENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgICAgX3RoaXMyLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSA9IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXI6IGNvbnRyb2xsZXIsXG4gICAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICAgIHB1bGxDYWxsOiBudWxsLFxuICAgICAgICAgICAgY2FuY2VsQ2FsbDogbnVsbCxcbiAgICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBfdGhpczIuX3Bvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWU6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgICAgfSwgdHJhbnNmZXJzKTtcblxuICAgICAgICAgIHJldHVybiBzdGFydENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVsbDogZnVuY3Rpb24gcHVsbChjb250cm9sbGVyKSB7XG4gICAgICAgICAgdmFyIHB1bGxDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgICAgIF90aGlzMi5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwgPSBwdWxsQ2FwYWJpbGl0eTtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTCxcbiAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHB1bGxDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24gY2FuY2VsKHJlYXNvbikge1xuICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgICAgdmFyIGNhbmNlbENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgICAgX3RoaXMyLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsID0gY2FuY2VsQ2FwYWJpbGl0eTtcbiAgICAgICAgICBfdGhpczIuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4gY2FuY2VsQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9LCBxdWV1ZWluZ1N0cmF0ZWd5KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NyZWF0ZVN0cmVhbVNpbmtcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVN0cmVhbVNpbmsoZGF0YSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgICB2YXIgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkO1xuICAgICAgdmFyIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWU7XG4gICAgICB2YXIgdGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZTtcbiAgICAgIHZhciBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICAgIHZhciBzdHJlYW1TaW5rID0ge1xuICAgICAgICBlbnF1ZXVlOiBmdW5jdGlvbiBlbnF1ZXVlKGNodW5rKSB7XG4gICAgICAgICAgdmFyIHNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgICAgdmFyIHRyYW5zZmVycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbGFzdERlc2lyZWRTaXplID0gdGhpcy5kZXNpcmVkU2l6ZTtcbiAgICAgICAgICB0aGlzLmRlc2lyZWRTaXplIC09IHNpemU7XG5cbiAgICAgICAgICBpZiAobGFzdERlc2lyZWRTaXplID4gMCAmJiB0aGlzLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICAgIHRoaXMuc2lua0NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgICAgICB0aGlzLnJlYWR5ID0gdGhpcy5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNlbGYuX3Bvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWU6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkVOUVVFVUUsXG4gICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBjaHVuazogY2h1bmtcbiAgICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0xPU0UsXG4gICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkZWxldGUgc2VsZi5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiBlcnJvcihyZWFzb24pIHtcbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciwgXCJlcnJvciBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNpbmtDYXBhYmlsaXR5OiAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCksXG4gICAgICAgIG9uUHVsbDogbnVsbCxcbiAgICAgICAgb25DYW5jZWw6IG51bGwsXG4gICAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgICAgZGVzaXJlZFNpemU6IGRhdGEuZGVzaXJlZFNpemUsXG4gICAgICAgIHJlYWR5OiBudWxsXG4gICAgICB9O1xuICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICBzdHJlYW1TaW5rLnJlYWR5ID0gc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgcmVzb2x2ZShhY3Rpb24oZGF0YS5kYXRhLCBzdHJlYW1TaW5rKSk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFLFxuICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWU6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuU1RBUlRfQ09NUExFVEUsXG4gICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9jZXNzU3RyZWFtTWVzc2FnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSkge1xuICAgICAgdmFyIHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZDtcbiAgICAgIHZhciBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lO1xuICAgICAgdmFyIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWU7XG4gICAgICB2YXIgY29tT2JqID0gdGhpcy5jb21PYmo7XG5cbiAgICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgICAgY2FzZSBTdHJlYW1LaW5kLlNUQVJUX0NPTVBMRVRFOlxuICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnN0YXJ0Q2FsbC5yZXNvbHZlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyZWFtS2luZC5QVUxMX0NPTVBMRVRFOlxuICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0ucHVsbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdKSB7XG4gICAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBzb3VyY2VOYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgICAgc3RyZWFtSWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXS5kZXNpcmVkU2l6ZSA8PSAwICYmIGRhdGEuZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXS5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0uZGVzaXJlZFNpemUgPSBkYXRhLmRlc2lyZWRTaXplO1xuICAgICAgICAgIHZhciBvblB1bGwgPSB0aGlzLnN0cmVhbVNpbmtzW2RhdGEuc3RyZWFtSWRdLm9uUHVsbDtcbiAgICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgcmVzb2x2ZShvblB1bGwgJiYgb25QdWxsKCkpO1xuICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgc291cmNlTmFtZTogc291cmNlTmFtZSxcbiAgICAgICAgICAgICAgdGFyZ2V0TmFtZTogdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyZWFtS2luZC5FTlFVRVVFOlxuICAgICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLCBcImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmNvbnRyb2xsZXIuZW5xdWV1ZShkYXRhLmNodW5rKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN0cmVhbUtpbmQuQ0xPU0U6XG4gICAgICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0sIFwiY2xvc2Ugc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG5cbiAgICAgICAgICBpZiAodGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jb250cm9sbGVyLmNsb3NlKCk7XG5cbiAgICAgICAgICB0aGlzLl9kZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUlkKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyZWFtS2luZC5FUlJPUjpcbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXSwgXCJlcnJvciBzaG91bGQgaGF2ZSBzdHJlYW0gY29udHJvbGxlclwiKTtcbiAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jb250cm9sbGVyLmVycm9yKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcblxuICAgICAgICAgIHRoaXMuX2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtSWQpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTF9DT01QTEVURTpcbiAgICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtSWQpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBTdHJlYW1LaW5kLkNBTkNFTDpcbiAgICAgICAgICBpZiAoIXRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgb25DYW5jZWwgPSB0aGlzLnN0cmVhbVNpbmtzW2RhdGEuc3RyZWFtSWRdLm9uQ2FuY2VsO1xuICAgICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlKG9uQ2FuY2VsICYmIG9uQ2FuY2VsKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICBzb3VyY2VOYW1lOiBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgICB0YXJnZXROYW1lOiB0YXJnZXROYW1lLFxuICAgICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFLFxuICAgICAgICAgICAgICBzdHJlYW1JZDogc3RyZWFtSWQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIHNvdXJjZU5hbWU6IHNvdXJjZU5hbWUsXG4gICAgICAgICAgICAgIHRhcmdldE5hbWU6IHRhcmdldE5hbWUsXG4gICAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICAgIHN0cmVhbUlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgcmVhc29uOiB3cmFwUmVhc29uKHJlYXNvbilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdLnNpbmtDYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0uaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnN0cmVhbVNpbmtzW3N0cmVhbUlkXTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgc3RyZWFtIGNhc2VcIik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9kZWxldGVTdHJlYW1Db250cm9sbGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZGVsZXRlU3RyZWFtQ29udHJvbGxlcjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKHN0cmVhbUlkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsU2V0dGxlZChbdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uc3RhcnRDYWxsLCB0aGlzLnN0cmVhbUNvbnRyb2xsZXJzW3N0cmVhbUlkXS5wdWxsQ2FsbCwgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbF0ubWFwKGZ1bmN0aW9uIChjYXBhYmlsaXR5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY2FwYWJpbGl0eSAmJiBjYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF07XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfZGVsZXRlU3RyZWFtQ29udHJvbGxlcihfeCkge1xuICAgICAgICByZXR1cm4gX2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZGVsZXRlU3RyZWFtQ29udHJvbGxlcjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJfcG9zdE1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Bvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycykge1xuICAgICAgaWYgKHRyYW5zZmVycyAmJiB0aGlzLnBvc3RNZXNzYWdlVHJhbnNmZXJzKSB7XG4gICAgICAgIHRoaXMuY29tT2JqLnBvc3RNZXNzYWdlKG1lc3NhZ2UsIHRyYW5zZmVycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5jb21PYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBNZXNzYWdlSGFuZGxlcjtcbn0oKTtcblxuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IE1lc3NhZ2VIYW5kbGVyO1xuXG4vKioqLyB9KSxcbi8qIDIxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5NZXRhZGF0YSA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcblxudmFyIF94bWxfcGFyc2VyID0gX193X3BkZmpzX3JlcXVpcmVfXygyMTIpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBNZXRhZGF0YSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1ldGFkYXRhKGRhdGEpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWV0YWRhdGEpO1xuXG4gICAgKDAsIF91dGlsLmFzc2VydCkodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIsIFwiTWV0YWRhdGE6IGlucHV0IGlzIG5vdCBhIHN0cmluZ1wiKTtcbiAgICBkYXRhID0gdGhpcy5fcmVwYWlyKGRhdGEpO1xuICAgIHZhciBwYXJzZXIgPSBuZXcgX3htbF9wYXJzZXIuU2ltcGxlWE1MUGFyc2VyKCk7XG4gICAgdmFyIHhtbERvY3VtZW50ID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhkYXRhKTtcbiAgICB0aGlzLl9tZXRhZGF0YU1hcCA9IG5ldyBNYXAoKTtcblxuICAgIGlmICh4bWxEb2N1bWVudCkge1xuICAgICAgdGhpcy5fcGFyc2UoeG1sRG9jdW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhNZXRhZGF0YSwgW3tcbiAgICBrZXk6IFwiX3JlcGFpclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVwYWlyKGRhdGEpIHtcbiAgICAgIHJldHVybiBkYXRhLnJlcGxhY2UoL15bXjxdKy8sIFwiXCIpLnJlcGxhY2UoLz5cXFxcMzc2XFxcXDM3NyhbXjxdKykvZywgZnVuY3Rpb24gKGFsbCwgY29kZXMpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gY29kZXMucmVwbGFjZSgvXFxcXChbMC0zXSkoWzAtN10pKFswLTddKS9nLCBmdW5jdGlvbiAoY29kZSwgZDEsIGQyLCBkMykge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGQxICogNjQgKyBkMiAqIDggKyBkMyAqIDEpO1xuICAgICAgICB9KS5yZXBsYWNlKC8mKGFtcHxhcG9zfGd0fGx0fHF1b3QpOy9nLCBmdW5jdGlvbiAoc3RyLCBuYW1lKSB7XG4gICAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiYW1wXCI6XG4gICAgICAgICAgICAgIHJldHVybiBcIiZcIjtcblxuICAgICAgICAgICAgY2FzZSBcImFwb3NcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiJ1wiO1xuXG4gICAgICAgICAgICBjYXNlIFwiZ3RcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiPlwiO1xuXG4gICAgICAgICAgICBjYXNlIFwibHRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIFwiPFwiO1xuXG4gICAgICAgICAgICBjYXNlIFwicXVvdFwiOlxuICAgICAgICAgICAgICByZXR1cm4gJ1wiJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfcmVwYWlyOiBcIi5jb25jYXQobmFtZSwgXCIgaXNuJ3QgZGVmaW5lZC5cIikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNoYXJzID0gXCJcIjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBieXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgdmFyIGNvZGUgPSBieXRlcy5jaGFyQ29kZUF0KGkpICogMjU2ICsgYnl0ZXMuY2hhckNvZGVBdChpICsgMSk7XG5cbiAgICAgICAgICBpZiAoY29kZSA+PSAzMiAmJiBjb2RlIDwgMTI3ICYmIGNvZGUgIT09IDYwICYmIGNvZGUgIT09IDYyICYmIGNvZGUgIT09IDM4KSB7XG4gICAgICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjaGFycyArPSBcIiYjeFwiICsgKDB4MTAwMDAgKyBjb2RlKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpICsgXCI7XCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFwiPlwiICsgY2hhcnM7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJzZSh4bWxEb2N1bWVudCkge1xuICAgICAgdmFyIHJkZiA9IHhtbERvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgaWYgKHJkZi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInJkZjpyZGZcIikge1xuICAgICAgICByZGYgPSByZGYuZmlyc3RDaGlsZDtcblxuICAgICAgICB3aGlsZSAocmRmICYmIHJkZi5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSBcInJkZjpyZGZcIikge1xuICAgICAgICAgIHJkZiA9IHJkZi5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9kZU5hbWUgPSByZGYgPyByZGYubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG5cbiAgICAgIGlmICghcmRmIHx8IG5vZGVOYW1lICE9PSBcInJkZjpyZGZcIiB8fCAhcmRmLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGlsZHJlbiA9IHJkZi5jaGlsZE5vZGVzO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBkZXNjID0gY2hpbGRyZW5baV07XG5cbiAgICAgICAgaWYgKGRlc2Mubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJyZGY6ZGVzY3JpcHRpb25cIikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gZGVzYy5jaGlsZE5vZGVzLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICBpZiAoZGVzYy5jaGlsZE5vZGVzW2pdLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwiI3RleHRcIikge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZGVzYy5jaGlsZE5vZGVzW2pdO1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBlbnRyeS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICB0aGlzLl9tZXRhZGF0YU1hcC5zZXQobmFtZSwgZW50cnkudGV4dENvbnRlbnQudHJpbSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWV0YWRhdGFNYXAuaGFzKG5hbWUpID8gdGhpcy5fbWV0YWRhdGFNYXAuZ2V0KG5hbWUpIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFsbCgpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5fbWV0YWRhdGFNYXApO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXRhZGF0YU1hcC5oYXMobmFtZSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIE1ldGFkYXRhO1xufSgpO1xuXG5leHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XG5cbi8qKiovIH0pLFxuLyogMjEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlNpbXBsZVhNTFBhcnNlciA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkgeyBfZ2V0ID0gUmVmbGVjdC5nZXQ7IH0gZWxzZSB7IF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7IHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7IGlmICghYmFzZSkgcmV0dXJuOyB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpOyBpZiAoZGVzYy5nZXQpIHsgcmV0dXJuIGRlc2MuZ2V0LmNhbGwocmVjZWl2ZXIpOyB9IHJldHVybiBkZXNjLnZhbHVlOyB9OyB9IHJldHVybiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyIHx8IHRhcmdldCk7IH1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkgeyB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkgeyBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTsgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7IH0gcmV0dXJuIG9iamVjdDsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgWE1MUGFyc2VyRXJyb3JDb2RlID0ge1xuICBOb0Vycm9yOiAwLFxuICBFbmRPZkRvY3VtZW50OiAtMSxcbiAgVW50ZXJtaW5hdGVkQ2RhdDogLTIsXG4gIFVudGVybWluYXRlZFhtbERlY2xhcmF0aW9uOiAtMyxcbiAgVW50ZXJtaW5hdGVkRG9jdHlwZURlY2xhcmF0aW9uOiAtNCxcbiAgVW50ZXJtaW5hdGVkQ29tbWVudDogLTUsXG4gIE1hbGZvcm1lZEVsZW1lbnQ6IC02LFxuICBPdXRPZk1lbW9yeTogLTcsXG4gIFVudGVybWluYXRlZEF0dHJpYnV0ZVZhbHVlOiAtOCxcbiAgVW50ZXJtaW5hdGVkRWxlbWVudDogLTksXG4gIEVsZW1lbnROZXZlckJlZ3VuOiAtMTBcbn07XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZShzLCBpbmRleCkge1xuICB2YXIgY2ggPSBzW2luZGV4XTtcbiAgcmV0dXJuIGNoID09PSBcIiBcIiB8fCBjaCA9PT0gXCJcXG5cIiB8fCBjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHRcIjtcbn1cblxuZnVuY3Rpb24gaXNXaGl0ZXNwYWNlU3RyaW5nKHMpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgaWYgKCFpc1doaXRlc3BhY2UocywgaSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIFhNTFBhcnNlckJhc2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBYTUxQYXJzZXJCYXNlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBYTUxQYXJzZXJCYXNlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhYTUxQYXJzZXJCYXNlLCBbe1xuICAgIGtleTogXCJfcmVzb2x2ZUVudGl0aWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNvbHZlRW50aXRpZXMocykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgcmV0dXJuIHMucmVwbGFjZSgvJihbXjtdKyk7L2csIGZ1bmN0aW9uIChhbGwsIGVudGl0eSkge1xuICAgICAgICBpZiAoZW50aXR5LnN1YnN0cmluZygwLCAyKSA9PT0gXCIjeFwiKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZW50aXR5LnN1YnN0cmluZygyKSwgMTYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChlbnRpdHkuc3Vic3RyaW5nKDAsIDEpID09PSBcIiNcIikge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGVudGl0eS5zdWJzdHJpbmcoMSksIDEwKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGVudGl0eSkge1xuICAgICAgICAgIGNhc2UgXCJsdFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiPFwiO1xuXG4gICAgICAgICAgY2FzZSBcImd0XCI6XG4gICAgICAgICAgICByZXR1cm4gXCI+XCI7XG5cbiAgICAgICAgICBjYXNlIFwiYW1wXCI6XG4gICAgICAgICAgICByZXR1cm4gXCImXCI7XG5cbiAgICAgICAgICBjYXNlIFwicXVvdFwiOlxuICAgICAgICAgICAgcmV0dXJuICdcIic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3RoaXMub25SZXNvbHZlRW50aXR5KGVudGl0eSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlQ29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VDb250ZW50KHMsIHN0YXJ0KSB7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgdmFyIHBvcyA9IHN0YXJ0O1xuXG4gICAgICBmdW5jdGlvbiBza2lwV3MoKSB7XG4gICAgICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiBpc1doaXRlc3BhY2UocywgcG9zKSkge1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiAhaXNXaGl0ZXNwYWNlKHMsIHBvcykgJiYgc1twb3NdICE9PSBcIj5cIiAmJiBzW3Bvc10gIT09IFwiL1wiKSB7XG4gICAgICAgICsrcG9zO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmFtZSA9IHMuc3Vic3RyaW5nKHN0YXJ0LCBwb3MpO1xuICAgICAgc2tpcFdzKCk7XG5cbiAgICAgIHdoaWxlIChwb3MgPCBzLmxlbmd0aCAmJiBzW3Bvc10gIT09IFwiPlwiICYmIHNbcG9zXSAhPT0gXCIvXCIgJiYgc1twb3NdICE9PSBcIj9cIikge1xuICAgICAgICBza2lwV3MoKTtcbiAgICAgICAgdmFyIGF0dHJOYW1lID0gXCJcIixcbiAgICAgICAgICAgIGF0dHJWYWx1ZSA9IFwiXCI7XG5cbiAgICAgICAgd2hpbGUgKHBvcyA8IHMubGVuZ3RoICYmICFpc1doaXRlc3BhY2UocywgcG9zKSAmJiBzW3Bvc10gIT09IFwiPVwiKSB7XG4gICAgICAgICAgYXR0ck5hbWUgKz0gc1twb3NdO1xuICAgICAgICAgICsrcG9zO1xuICAgICAgICB9XG5cbiAgICAgICAgc2tpcFdzKCk7XG5cbiAgICAgICAgaWYgKHNbcG9zXSAhPT0gXCI9XCIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgICsrcG9zO1xuICAgICAgICBza2lwV3MoKTtcbiAgICAgICAgdmFyIGF0dHJFbmRDaGFyID0gc1twb3NdO1xuXG4gICAgICAgIGlmIChhdHRyRW5kQ2hhciAhPT0gJ1wiJyAmJiBhdHRyRW5kQ2hhciAhPT0gXCInXCIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhdHRyRW5kSW5kZXggPSBzLmluZGV4T2YoYXR0ckVuZENoYXIsICsrcG9zKTtcblxuICAgICAgICBpZiAoYXR0ckVuZEluZGV4IDwgMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYXR0clZhbHVlID0gcy5zdWJzdHJpbmcocG9zLCBhdHRyRW5kSW5kZXgpO1xuICAgICAgICBhdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IGF0dHJOYW1lLFxuICAgICAgICAgIHZhbHVlOiB0aGlzLl9yZXNvbHZlRW50aXRpZXMoYXR0clZhbHVlKVxuICAgICAgICB9KTtcbiAgICAgICAgcG9zID0gYXR0ckVuZEluZGV4ICsgMTtcbiAgICAgICAgc2tpcFdzKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IGF0dHJpYnV0ZXMsXG4gICAgICAgIHBhcnNlZDogcG9zIC0gc3RhcnRcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wYXJzZVByb2Nlc3NpbmdJbnN0cnVjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcGFyc2VQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24ocywgc3RhcnQpIHtcbiAgICAgIHZhciBwb3MgPSBzdGFydDtcblxuICAgICAgZnVuY3Rpb24gc2tpcFdzKCkge1xuICAgICAgICB3aGlsZSAocG9zIDwgcy5sZW5ndGggJiYgaXNXaGl0ZXNwYWNlKHMsIHBvcykpIHtcbiAgICAgICAgICArK3BvcztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3aGlsZSAocG9zIDwgcy5sZW5ndGggJiYgIWlzV2hpdGVzcGFjZShzLCBwb3MpICYmIHNbcG9zXSAhPT0gXCI+XCIgJiYgc1twb3NdICE9PSBcIi9cIikge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgdmFyIG5hbWUgPSBzLnN1YnN0cmluZyhzdGFydCwgcG9zKTtcbiAgICAgIHNraXBXcygpO1xuICAgICAgdmFyIGF0dHJTdGFydCA9IHBvcztcblxuICAgICAgd2hpbGUgKHBvcyA8IHMubGVuZ3RoICYmIChzW3Bvc10gIT09IFwiP1wiIHx8IHNbcG9zICsgMV0gIT09IFwiPlwiKSkge1xuICAgICAgICArK3BvcztcbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlID0gcy5zdWJzdHJpbmcoYXR0clN0YXJ0LCBwb3MpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBwYXJzZWQ6IHBvcyAtIHN0YXJ0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYXJzZVhtbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVhtbChzKSB7XG4gICAgICB2YXIgaSA9IDA7XG5cbiAgICAgIHdoaWxlIChpIDwgcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGNoID0gc1tpXTtcbiAgICAgICAgdmFyIGogPSBpO1xuXG4gICAgICAgIGlmIChjaCA9PT0gXCI8XCIpIHtcbiAgICAgICAgICArK2o7XG4gICAgICAgICAgdmFyIGNoMiA9IHNbal07XG4gICAgICAgICAgdmFyIHEgPSB2b2lkIDA7XG5cbiAgICAgICAgICBzd2l0Y2ggKGNoMikge1xuICAgICAgICAgICAgY2FzZSBcIi9cIjpcbiAgICAgICAgICAgICAgKytqO1xuICAgICAgICAgICAgICBxID0gcy5pbmRleE9mKFwiPlwiLCBqKTtcblxuICAgICAgICAgICAgICBpZiAocSA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoWE1MUGFyc2VyRXJyb3JDb2RlLlVudGVybWluYXRlZEVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMub25FbmRFbGVtZW50KHMuc3Vic3RyaW5nKGosIHEpKTtcbiAgICAgICAgICAgICAgaiA9IHEgKyAxO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgICAgKytqO1xuXG4gICAgICAgICAgICAgIHZhciBwaSA9IHRoaXMuX3BhcnNlUHJvY2Vzc2luZ0luc3RydWN0aW9uKHMsIGopO1xuXG4gICAgICAgICAgICAgIGlmIChzLnN1YnN0cmluZyhqICsgcGkucGFyc2VkLCBqICsgcGkucGFyc2VkICsgMikgIT09IFwiPz5cIikge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihYTUxQYXJzZXJFcnJvckNvZGUuVW50ZXJtaW5hdGVkWG1sRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHRoaXMub25QaShwaS5uYW1lLCBwaS52YWx1ZSk7XG4gICAgICAgICAgICAgIGogKz0gcGkucGFyc2VkICsgMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICAgIGlmIChzLnN1YnN0cmluZyhqICsgMSwgaiArIDMpID09PSBcIi0tXCIpIHtcbiAgICAgICAgICAgICAgICBxID0gcy5pbmRleE9mKFwiLS0+XCIsIGogKyAzKTtcblxuICAgICAgICAgICAgICAgIGlmIChxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWRDb21tZW50KTtcbiAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29tbWVudChzLnN1YnN0cmluZyhqICsgMywgcSkpO1xuICAgICAgICAgICAgICAgIGogPSBxICsgMztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzLnN1YnN0cmluZyhqICsgMSwgaiArIDgpID09PSBcIltDREFUQVtcIikge1xuICAgICAgICAgICAgICAgIHEgPSBzLmluZGV4T2YoXCJdXT5cIiwgaiArIDgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHEgPCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoWE1MUGFyc2VyRXJyb3JDb2RlLlVudGVybWluYXRlZENkYXQpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMub25DZGF0YShzLnN1YnN0cmluZyhqICsgOCwgcSkpO1xuICAgICAgICAgICAgICAgIGogPSBxICsgMztcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzLnN1YnN0cmluZyhqICsgMSwgaiArIDgpID09PSBcIkRPQ1RZUEVcIikge1xuICAgICAgICAgICAgICAgIHZhciBxMiA9IHMuaW5kZXhPZihcIltcIiwgaiArIDgpO1xuICAgICAgICAgICAgICAgIHZhciBjb21wbGV4RG9jdHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHEgPSBzLmluZGV4T2YoXCI+XCIsIGogKyA4KTtcblxuICAgICAgICAgICAgICAgIGlmIChxIDwgMCkge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWREb2N0eXBlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChxMiA+IDAgJiYgcSA+IHEyKSB7XG4gICAgICAgICAgICAgICAgICBxID0gcy5pbmRleE9mKFwiXT5cIiwgaiArIDgpO1xuXG4gICAgICAgICAgICAgICAgICBpZiAocSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWREb2N0eXBlRGVjbGFyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGNvbXBsZXhEb2N0eXBlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgZG9jdHlwZUNvbnRlbnQgPSBzLnN1YnN0cmluZyhqICsgOCwgcSArIChjb21wbGV4RG9jdHlwZSA/IDEgOiAwKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkRvY3R5cGUoZG9jdHlwZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGogPSBxICsgKGNvbXBsZXhEb2N0eXBlID8gMiA6IDEpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihYTUxQYXJzZXJFcnJvckNvZGUuTWFsZm9ybWVkRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHZhciBjb250ZW50ID0gdGhpcy5fcGFyc2VDb250ZW50KHMsIGopO1xuXG4gICAgICAgICAgICAgIGlmIChjb250ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5NYWxmb3JtZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgaXNDbG9zZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgICBpZiAocy5zdWJzdHJpbmcoaiArIGNvbnRlbnQucGFyc2VkLCBqICsgY29udGVudC5wYXJzZWQgKyAyKSA9PT0gXCIvPlwiKSB7XG4gICAgICAgICAgICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHMuc3Vic3RyaW5nKGogKyBjb250ZW50LnBhcnNlZCwgaiArIGNvbnRlbnQucGFyc2VkICsgMSkgIT09IFwiPlwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFhNTFBhcnNlckVycm9yQ29kZS5VbnRlcm1pbmF0ZWRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB0aGlzLm9uQmVnaW5FbGVtZW50KGNvbnRlbnQubmFtZSwgY29udGVudC5hdHRyaWJ1dGVzLCBpc0Nsb3NlZCk7XG4gICAgICAgICAgICAgIGogKz0gY29udGVudC5wYXJzZWQgKyAoaXNDbG9zZWQgPyAyIDogMSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aGlsZSAoaiA8IHMubGVuZ3RoICYmIHNbal0gIT09IFwiPFwiKSB7XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHRleHQgPSBzLnN1YnN0cmluZyhpLCBqKTtcbiAgICAgICAgICB0aGlzLm9uVGV4dCh0aGlzLl9yZXNvbHZlRW50aXRpZXModGV4dCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaSA9IGo7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uUmVzb2x2ZUVudGl0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblJlc29sdmVFbnRpdHkobmFtZSkge1xuICAgICAgcmV0dXJuIFwiJlwiLmNvbmNhdChuYW1lLCBcIjtcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uUGlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25QaShuYW1lLCB2YWx1ZSkge31cbiAgfSwge1xuICAgIGtleTogXCJvbkNvbW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Db21tZW50KHRleHQpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNkYXRhKHRleHQpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25Eb2N0eXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRG9jdHlwZShkb2N0eXBlQ29udGVudCkge31cbiAgfSwge1xuICAgIGtleTogXCJvblRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25UZXh0KHRleHQpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25CZWdpbkVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25CZWdpbkVsZW1lbnQobmFtZSwgYXR0cmlidXRlcywgaXNFbXB0eSkge31cbiAgfSwge1xuICAgIGtleTogXCJvbkVuZEVsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25FbmRFbGVtZW50KG5hbWUpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwib25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVycm9yKGNvZGUpIHt9XG4gIH1dKTtcblxuICByZXR1cm4gWE1MUGFyc2VyQmFzZTtcbn0oKTtcblxudmFyIFNpbXBsZURPTU5vZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW1wbGVET01Ob2RlKG5vZGVOYW1lLCBub2RlVmFsdWUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlRE9NTm9kZSk7XG5cbiAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG4gICAgdGhpcy5ub2RlVmFsdWUgPSBub2RlVmFsdWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwicGFyZW50Tm9kZVwiLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2ltcGxlRE9NTm9kZSwgW3tcbiAgICBrZXk6IFwiaGFzQ2hpbGROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNDaGlsZE5vZGVzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlcyAmJiB0aGlzLmNoaWxkTm9kZXMubGVuZ3RoID4gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RDaGlsZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2RlcyAmJiB0aGlzLmNoaWxkTm9kZXNbMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5leHRTaWJsaW5nXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB2YXIgY2hpbGROb2RlcyA9IHRoaXMucGFyZW50Tm9kZS5jaGlsZE5vZGVzO1xuXG4gICAgICBpZiAoIWNoaWxkTm9kZXMpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gY2hpbGROb2Rlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGlsZE5vZGVzW2luZGV4ICsgMV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInRleHRDb250ZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuY2hpbGROb2Rlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlVmFsdWUgfHwgXCJcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY2hpbGROb2Rlcy5tYXAoZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBjaGlsZC50ZXh0Q29udGVudDtcbiAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpbXBsZURPTU5vZGU7XG59KCk7XG5cbnZhciBTaW1wbGVYTUxQYXJzZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9YTUxQYXJzZXJCYXNlKSB7XG4gIF9pbmhlcml0cyhTaW1wbGVYTUxQYXJzZXIsIF9YTUxQYXJzZXJCYXNlKTtcblxuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyKFNpbXBsZVhNTFBhcnNlcik7XG5cbiAgZnVuY3Rpb24gU2ltcGxlWE1MUGFyc2VyKCkge1xuICAgIHZhciBfdGhpczI7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlWE1MUGFyc2VyKTtcblxuICAgIF90aGlzMiA9IF9zdXBlci5jYWxsKHRoaXMpO1xuICAgIF90aGlzMi5fY3VycmVudEZyYWdtZW50ID0gbnVsbDtcbiAgICBfdGhpczIuX3N0YWNrID0gbnVsbDtcbiAgICBfdGhpczIuX2Vycm9yQ29kZSA9IFhNTFBhcnNlckVycm9yQ29kZS5Ob0Vycm9yO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU2ltcGxlWE1MUGFyc2VyLCBbe1xuICAgIGtleTogXCJwYXJzZUZyb21TdHJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFyc2VGcm9tU3RyaW5nKGRhdGEpIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRGcmFnbWVudCA9IFtdO1xuICAgICAgdGhpcy5fc3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuX2Vycm9yQ29kZSA9IFhNTFBhcnNlckVycm9yQ29kZS5Ob0Vycm9yO1xuICAgICAgdGhpcy5wYXJzZVhtbChkYXRhKTtcblxuICAgICAgaWYgKHRoaXMuX2Vycm9yQ29kZSAhPT0gWE1MUGFyc2VyRXJyb3JDb2RlLk5vRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgdmFyIF90aGlzJF9jdXJyZW50RnJhZ21lbiA9IF9zbGljZWRUb0FycmF5KHRoaXMuX2N1cnJlbnRGcmFnbWVudCwgMSksXG4gICAgICAgICAgZG9jdW1lbnRFbGVtZW50ID0gX3RoaXMkX2N1cnJlbnRGcmFnbWVuWzBdO1xuXG4gICAgICBpZiAoIWRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb2N1bWVudEVsZW1lbnQ6IGRvY3VtZW50RWxlbWVudFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25SZXNvbHZlRW50aXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uUmVzb2x2ZUVudGl0eShuYW1lKSB7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgY2FzZSBcImFwb3NcIjpcbiAgICAgICAgICByZXR1cm4gXCInXCI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfZ2V0KF9nZXRQcm90b3R5cGVPZihTaW1wbGVYTUxQYXJzZXIucHJvdG90eXBlKSwgXCJvblJlc29sdmVFbnRpdHlcIiwgdGhpcykuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25UZXh0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uVGV4dCh0ZXh0KSB7XG4gICAgICBpZiAoaXNXaGl0ZXNwYWNlU3RyaW5nKHRleHQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vZGUgPSBuZXcgU2ltcGxlRE9NTm9kZShcIiN0ZXh0XCIsIHRleHQpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50RnJhZ21lbnQucHVzaChub2RlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25DZGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkNkYXRhKHRleHQpIHtcbiAgICAgIHZhciBub2RlID0gbmV3IFNpbXBsZURPTU5vZGUoXCIjdGV4dFwiLCB0ZXh0KTtcblxuICAgICAgdGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2gobm9kZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uQmVnaW5FbGVtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQmVnaW5FbGVtZW50KG5hbWUsIGF0dHJpYnV0ZXMsIGlzRW1wdHkpIHtcbiAgICAgIHZhciBub2RlID0gbmV3IFNpbXBsZURPTU5vZGUobmFtZSk7XG4gICAgICBub2RlLmNoaWxkTm9kZXMgPSBbXTtcblxuICAgICAgdGhpcy5fY3VycmVudEZyYWdtZW50LnB1c2gobm9kZSk7XG5cbiAgICAgIGlmIChpc0VtcHR5KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc3RhY2sucHVzaCh0aGlzLl9jdXJyZW50RnJhZ21lbnQpO1xuXG4gICAgICB0aGlzLl9jdXJyZW50RnJhZ21lbnQgPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uRW5kRWxlbWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvbkVuZEVsZW1lbnQobmFtZSkge1xuICAgICAgdGhpcy5fY3VycmVudEZyYWdtZW50ID0gdGhpcy5fc3RhY2sucG9wKCkgfHwgW107XG4gICAgICB2YXIgbGFzdEVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RnJhZ21lbnRbdGhpcy5fY3VycmVudEZyYWdtZW50Lmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIWxhc3RFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gbGFzdEVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGxhc3RFbGVtZW50LmNoaWxkTm9kZXNbaV0ucGFyZW50Tm9kZSA9IGxhc3RFbGVtZW50O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvbkVycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uRXJyb3IoY29kZSkge1xuICAgICAgdGhpcy5fZXJyb3JDb2RlID0gY29kZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU2ltcGxlWE1MUGFyc2VyO1xufShYTUxQYXJzZXJCYXNlKTtcblxuZXhwb3J0cy5TaW1wbGVYTUxQYXJzZXIgPSBTaW1wbGVYTUxQYXJzZXI7XG5cbi8qKiovIH0pLFxuLyogMjEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLk9wdGlvbmFsQ29udGVudENvbmZpZyA9IHZvaWQgMDtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgT3B0aW9uYWxDb250ZW50R3JvdXAgPSBmdW5jdGlvbiBPcHRpb25hbENvbnRlbnRHcm91cChuYW1lLCBpbnRlbnQpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9wdGlvbmFsQ29udGVudEdyb3VwKTtcblxuICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICB0aGlzLm5hbWUgPSBuYW1lO1xuICB0aGlzLmludGVudCA9IGludGVudDtcbn07XG5cbnZhciBPcHRpb25hbENvbnRlbnRDb25maWcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBPcHRpb25hbENvbnRlbnRDb25maWcoZGF0YSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPcHRpb25hbENvbnRlbnRDb25maWcpO1xuXG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICB0aGlzLmNyZWF0b3IgPSBudWxsO1xuICAgIHRoaXMuX29yZGVyID0gbnVsbDtcbiAgICB0aGlzLl9ncm91cHMgPSBuZXcgTWFwKCk7XG5cbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubmFtZSA9IGRhdGEubmFtZTtcbiAgICB0aGlzLmNyZWF0b3IgPSBkYXRhLmNyZWF0b3I7XG4gICAgdGhpcy5fb3JkZXIgPSBkYXRhLm9yZGVyO1xuXG4gICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGRhdGEuZ3JvdXBzKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIF9ncm91cCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIHRoaXMuX2dyb3Vwcy5zZXQoX2dyb3VwLmlkLCBuZXcgT3B0aW9uYWxDb250ZW50R3JvdXAoX2dyb3VwLm5hbWUsIF9ncm91cC5pbnRlbnQpKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuYmFzZVN0YXRlID09PSBcIk9GRlwiKSB7XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX2dyb3VwcyksXG4gICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBncm91cCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBncm91cC52aXNpYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YS5vbiksXG4gICAgICAgIF9zdGVwMztcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvcjMucygpOyAhKF9zdGVwMyA9IF9pdGVyYXRvcjMubigpKS5kb25lOykge1xuICAgICAgICB2YXIgb24gPSBfc3RlcDMudmFsdWU7XG4gICAgICAgIHRoaXMuX2dyb3Vwcy5nZXQob24pLnZpc2libGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgIH1cblxuICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YS5vZmYpLFxuICAgICAgICBfc3RlcDQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3I0LnMoKTsgIShfc3RlcDQgPSBfaXRlcmF0b3I0Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIG9mZiA9IF9zdGVwNC52YWx1ZTtcbiAgICAgICAgdGhpcy5fZ3JvdXBzLmdldChvZmYpLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoT3B0aW9uYWxDb250ZW50Q29uZmlnLCBbe1xuICAgIGtleTogXCJpc1Zpc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNWaXNpYmxlKGdyb3VwKSB7XG4gICAgICBpZiAoZ3JvdXAudHlwZSA9PT0gXCJPQ0dcIikge1xuICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5oYXMoZ3JvdXAuaWQpKSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6IFwiLmNvbmNhdChncm91cC5pZCkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dyb3Vwcy5nZXQoZ3JvdXAuaWQpLnZpc2libGU7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnR5cGUgPT09IFwiT0NNRFwiKSB7XG4gICAgICAgIGlmIChncm91cC5leHByZXNzaW9uKSB7XG4gICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVmlzaWJpbGl0eSBleHByZXNzaW9uIG5vdCBzdXBwb3J0ZWQgeWV0LlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZ3JvdXAucG9saWN5IHx8IGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPblwiKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihncm91cC5pZHMpLFxuICAgICAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I1LnMoKTsgIShfc3RlcDUgPSBfaXRlcmF0b3I1Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGlkID0gX3N0ZXA1LnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogXCIuY29uY2F0KGlkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAodGhpcy5fZ3JvdXBzLmdldChpZCkudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjYgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihncm91cC5pZHMpLFxuICAgICAgICAgICAgICBfc3RlcDY7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9pZCA9IF9zdGVwNi52YWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5oYXMoX2lkKSkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiBcIi5jb25jYXQoX2lkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5nZXQoX2lkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoZ3JvdXAucG9saWN5ID09PSBcIkFueU9mZlwiKSB7XG4gICAgICAgICAgdmFyIF9pdGVyYXRvcjcgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihncm91cC5pZHMpLFxuICAgICAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIF9pZDIgPSBfc3RlcDcudmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ncm91cHMuaGFzKF9pZDIpKSB7XG4gICAgICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6IFwiLmNvbmNhdChfaWQyKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXRoaXMuX2dyb3Vwcy5nZXQoX2lkMikudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I3LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPZmZcIikge1xuICAgICAgICAgIHZhciBfaXRlcmF0b3I4ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZ3JvdXAuaWRzKSxcbiAgICAgICAgICAgICAgX3N0ZXA4O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yOC5zKCk7ICEoX3N0ZXA4ID0gX2l0ZXJhdG9yOC5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIHZhciBfaWQzID0gX3N0ZXA4LnZhbHVlO1xuXG4gICAgICAgICAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhfaWQzKSkge1xuICAgICAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiBcIi5jb25jYXQoX2lkMykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKHRoaXMuX2dyb3Vwcy5nZXQoX2lkMykudmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgX2l0ZXJhdG9yOC5lKGVycik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjguZigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5rbm93biBvcHRpb25hbCBjb250ZW50IHBvbGljeSBcIi5jb25jYXQoZ3JvdXAucG9saWN5LCBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5rbm93biBncm91cCB0eXBlIFwiLmNvbmNhdChncm91cC50eXBlLCBcIi5cIikpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFZpc2liaWxpdHlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VmlzaWJpbGl0eShpZCkge1xuICAgICAgdmFyIHZpc2libGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5fZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6IFwiLmNvbmNhdChpZCkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2dyb3Vwcy5nZXQoaWQpLnZpc2libGUgPSAhIXZpc2libGU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldE9yZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE9yZGVyKCkge1xuICAgICAgaWYgKCF0aGlzLl9ncm91cHMuc2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX29yZGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRlci5zbGljZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9ncm91cHMua2V5cygpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R3JvdXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdyb3VwcygpIHtcbiAgICAgIGlmICghdGhpcy5fZ3JvdXBzLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5fZ3JvdXBzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R3JvdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JvdXAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9ncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBPcHRpb25hbENvbnRlbnRDb25maWc7XG59KCk7XG5cbmV4cG9ydHMuT3B0aW9uYWxDb250ZW50Q29uZmlnID0gT3B0aW9uYWxDb250ZW50Q29uZmlnO1xuXG4vKioqLyB9KSxcbi8qIDIxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QREZEYXRhVHJhbnNwb3J0U3RyZWFtID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dfcGRmanNfcmVxdWlyZV9fKDIpKTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdDsgaWYgKHR5cGVvZiBTeW1ib2wgPT09IFwidW5kZWZpbmVkXCIgfHwgb1tTeW1ib2wuaXRlcmF0b3JdID09IG51bGwpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIFBERkRhdGFUcmFuc3BvcnRTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZEYXRhVHJhbnNwb3J0U3RyZWFtKHBhcmFtcywgcGRmRGF0YVJhbmdlVHJhbnNwb3J0KSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZEYXRhVHJhbnNwb3J0U3RyZWFtKTtcblxuICAgICgwLCBfdXRpbC5hc3NlcnQpKHBkZkRhdGFSYW5nZVRyYW5zcG9ydCwgJ1BERkRhdGFUcmFuc3BvcnRTdHJlYW0gLSBtaXNzaW5nIHJlcXVpcmVkIFwicGRmRGF0YVJhbmdlVHJhbnNwb3J0XCIgYXJndW1lbnQuJyk7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gcGFyYW1zLnByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB2YXIgaW5pdGlhbERhdGEgPSBwYXJhbXMuaW5pdGlhbERhdGE7XG5cbiAgICBpZiAoaW5pdGlhbERhdGEgJiYgaW5pdGlhbERhdGEubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG5cbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgfVxuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0ID0gcGRmRGF0YVJhbmdlVHJhbnNwb3J0O1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXBhcmFtcy5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSAhcGFyYW1zLmRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gcGFyYW1zLmxlbmd0aDtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzID0gW107XG5cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcihmdW5jdGlvbiAoYmVnaW4sIGNodW5rKSB7XG4gICAgICBfdGhpcy5fb25SZWNlaXZlRGF0YSh7XG4gICAgICAgIGJlZ2luOiBiZWdpbixcbiAgICAgICAgY2h1bms6IGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc0xpc3RlbmVyKGZ1bmN0aW9uIChsb2FkZWQsIHRvdGFsKSB7XG4gICAgICBfdGhpcy5fb25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZDogbG9hZGVkLFxuICAgICAgICB0b3RhbDogdG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgX3RoaXMuX29uUmVjZWl2ZURhdGEoe1xuICAgICAgICBjaHVuazogY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnRyYW5zcG9ydFJlYWR5KCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRGF0YVRyYW5zcG9ydFN0cmVhbSwgW3tcbiAgICBrZXk6IFwiX29uUmVjZWl2ZURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmVjZWl2ZURhdGEoYXJncykge1xuICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGFyZ3MuY2h1bmspLmJ1ZmZlcjtcblxuICAgICAgaWYgKGFyZ3MuYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3F1ZXVlZENodW5rcy5wdXNoKGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICAgIGlmIChyYW5nZVJlYWRlci5fYmVnaW4gIT09IGFyZ3MuYmVnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuXG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKGZvdW5kLCBcIl9vblJlY2VpdmVEYXRhIC0gbm8gYFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcmAgaW5zdGFuY2UgZm91bmQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25Qcm9ncmVzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25Qcm9ncmVzcyhldnQpIHtcbiAgICAgIGlmIChldnQudG90YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZmlyc3RSZWFkZXIgPSB0aGlzLl9yYW5nZVJlYWRlcnNbMF07XG5cbiAgICAgICAgaWYgKGZpcnN0UmVhZGVyICYmIGZpcnN0UmVhZGVyLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgICBmaXJzdFJlYWRlci5vblByb2dyZXNzKHtcbiAgICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZnVsbFJlYWRlciA9IHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuXG4gICAgICAgIGlmIChmdWxsUmVhZGVyICYmIGZ1bGxSZWFkZXIub25Qcm9ncmVzcykge1xuICAgICAgICAgIGZ1bGxSZWFkZXIub25Qcm9ncmVzcyh7XG4gICAgICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWQsXG4gICAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uUHJvZ3Jlc3NpdmVEb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICAgIGlmICh0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcikge1xuICAgICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5wcm9ncmVzc2l2ZURvbmUoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbW92ZVJhbmdlUmVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVSYW5nZVJlYWRlcihyZWFkZXIpIHtcbiAgICAgIHZhciBpID0gdGhpcy5fcmFuZ2VSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcblxuICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICB0aGlzLl9yYW5nZVJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRGdWxsUmVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRGF0YVRyYW5zcG9ydFN0cmVhbS5nZXRGdWxsUmVhZGVyIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLlwiKTtcbiAgICAgIHZhciBxdWV1ZWRDaHVua3MgPSB0aGlzLl9xdWV1ZWRDaHVua3M7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBudWxsO1xuICAgICAgcmV0dXJuIG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHRoaXMsIHF1ZXVlZENodW5rcywgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VSZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWFkZXIgPSBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuXG4gICAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQucmVxdWVzdERhdGFSYW5nZShiZWdpbiwgZW5kKTtcblxuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnB1c2gocmVhZGVyKTtcblxuICAgICAgcmV0dXJuIHJlYWRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsQWxsUmVxdWVzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWFkZXJzID0gdGhpcy5fcmFuZ2VSZWFkZXJzLnNsaWNlKDApO1xuXG4gICAgICByZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKHJhbmdlUmVhZGVyKSB7XG4gICAgICAgIHJhbmdlUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hYm9ydCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPyB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fbG9hZGVkIDogMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGRGF0YVRyYW5zcG9ydFN0cmVhbTtcbn0oKTtcblxuZXhwb3J0cy5QREZEYXRhVHJhbnNwb3J0U3RyZWFtID0gUERGRGF0YVRyYW5zcG9ydFN0cmVhbTtcblxudmFyIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyKHN0cmVhbSwgcXVldWVkQ2h1bmtzKSB7XG4gICAgdmFyIHByb2dyZXNzaXZlRG9uZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcik7XG5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fZG9uZSA9IHByb2dyZXNzaXZlRG9uZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG5cbiAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5fcXVldWVkQ2h1bmtzKSxcbiAgICAgICAgX3N0ZXA7XG5cbiAgICB0cnkge1xuICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgdmFyIGNodW5rID0gX3N0ZXAudmFsdWU7XG4gICAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlciwgW3tcbiAgICBrZXk6IFwiX2VucXVldWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VucXVldWUoY2h1bmspIHtcbiAgICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcblxuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVhZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBjaHVuaywgcmVxdWVzdENhcGFiaWxpdHk7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fcXVldWVkQ2h1bmtzLmxlbmd0aCA+IDApKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlKTtcblxuICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBfcmVhZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVhZDtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKHJlYXNvbikge1xuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9ncmVzc2l2ZURvbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVhZGVyc1JlYWR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGVhZGVyc1JlYWR5O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWxlbmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1JhbmdlU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3RyZWFtLl9pc1JhbmdlU3VwcG9ydGVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1N0cmVhbWluZ1N1cHBvcnRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N0cmVhbS5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2NvbnRlbnRMZW5ndGg7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SZWFkZXI7XG59KCk7XG5cbnZhciBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIoc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcik7XG5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fYmVnaW4gPSBiZWdpbjtcbiAgICB0aGlzLl9lbmQgPSBlbmQ7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyLCBbe1xuICAgIGtleTogXCJfZW5xdWV1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZW5xdWV1ZShjaHVuaykge1xuICAgICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gY2h1bms7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVxdWVzdHNDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcblxuICAgICAgICByZXF1ZXN0c0NhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBjaHVuaywgcmVxdWVzdENhcGFiaWxpdHk7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcXVldWVkQ2h1bmspIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bms7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2UpO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICByZXR1cm4gX3JlYWQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwocmVhc29uKSB7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdENhcGFiaWxpdHkpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG5cbiAgICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RyZWFtaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkRhdGFUcmFuc3BvcnRTdHJlYW1SYW5nZVJlYWRlcjtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiAyMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuV2ViR0xDb250ZXh0ID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBXZWJHTENvbnRleHQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBXZWJHTENvbnRleHQoX3JlZikge1xuICAgIHZhciBfcmVmJGVuYWJsZSA9IF9yZWYuZW5hYmxlLFxuICAgICAgICBlbmFibGUgPSBfcmVmJGVuYWJsZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGVuYWJsZTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBXZWJHTENvbnRleHQpO1xuXG4gICAgdGhpcy5fZW5hYmxlZCA9IGVuYWJsZSA9PT0gdHJ1ZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXZWJHTENvbnRleHQsIFt7XG4gICAga2V5OiBcImNvbXBvc2VTTWFza1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wb3NlU01hc2soX3JlZjIpIHtcbiAgICAgIHZhciBsYXllciA9IF9yZWYyLmxheWVyLFxuICAgICAgICAgIG1hc2sgPSBfcmVmMi5tYXNrLFxuICAgICAgICAgIHByb3BlcnRpZXMgPSBfcmVmMi5wcm9wZXJ0aWVzO1xuICAgICAgcmV0dXJuIFdlYkdMVXRpbHMuY29tcG9zZVNNYXNrKGxheWVyLCBtYXNrLCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd0ZpZ3VyZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd0ZpZ3VyZXMoX3JlZjMpIHtcbiAgICAgIHZhciB3aWR0aCA9IF9yZWYzLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF9yZWYzLmhlaWdodCxcbiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSBfcmVmMy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgZmlndXJlcyA9IF9yZWYzLmZpZ3VyZXMsXG4gICAgICAgICAgY29udGV4dCA9IF9yZWYzLmNvbnRleHQ7XG4gICAgICByZXR1cm4gV2ViR0xVdGlscy5kcmF3RmlndXJlcyh3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kQ29sb3IsIGZpZ3VyZXMsIGNvbnRleHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIFdlYkdMVXRpbHMuY2xlYW51cCgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0VuYWJsZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBlbmFibGVkID0gdGhpcy5fZW5hYmxlZDtcblxuICAgICAgaWYgKGVuYWJsZWQpIHtcbiAgICAgICAgZW5hYmxlZCA9IFdlYkdMVXRpbHMudHJ5SW5pdEdMKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2ViR0xDb250ZXh0O1xufSgpO1xuXG5leHBvcnRzLldlYkdMQ29udGV4dCA9IFdlYkdMQ29udGV4dDtcblxudmFyIFdlYkdMVXRpbHMgPSBmdW5jdGlvbiBXZWJHTFV0aWxzQ2xvc3VyZSgpIHtcbiAgZnVuY3Rpb24gbG9hZFNoYWRlcihnbCwgY29kZSwgc2hhZGVyVHlwZSkge1xuICAgIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoc2hhZGVyVHlwZSk7XG4gICAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgY29kZSk7XG4gICAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuICAgIHZhciBjb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcblxuICAgIGlmICghY29tcGlsZWQpIHtcbiAgICAgIHZhciBlcnJvck1zZyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGR1cmluZyBzaGFkZXIgY29tcGlsYXRpb246IFwiICsgZXJyb3JNc2cpO1xuICAgIH1cblxuICAgIHJldHVybiBzaGFkZXI7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIGNvZGUpIHtcbiAgICByZXR1cm4gbG9hZFNoYWRlcihnbCwgY29kZSwgZ2wuVkVSVEVYX1NIQURFUik7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgY29kZSkge1xuICAgIHJldHVybiBsb2FkU2hhZGVyKGdsLCBjb2RlLCBnbC5GUkFHTUVOVF9TSEFERVIpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbShnbCwgc2hhZGVycykge1xuICAgIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlpID0gc2hhZGVycy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyc1tpXSk7XG4gICAgfVxuXG4gICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgdmFyIGxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xuXG4gICAgaWYgKCFsaW5rZWQpIHtcbiAgICAgIHZhciBlcnJvck1zZyA9IGdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZHVyaW5nIHByb2dyYW0gbGlua2luZzogXCIgKyBlcnJvck1zZyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2dyYW07XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsLCBpbWFnZSwgdGV4dHVyZUlkKSB7XG4gICAgZ2wuYWN0aXZlVGV4dHVyZSh0ZXh0dXJlSWQpO1xuICAgIHZhciB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleHR1cmUpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBpbWFnZSk7XG4gICAgcmV0dXJuIHRleHR1cmU7XG4gIH1cblxuICB2YXIgY3VycmVudEdMLCBjdXJyZW50Q2FudmFzO1xuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlR0woKSB7XG4gICAgaWYgKGN1cnJlbnRHTCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGN1cnJlbnRHTCA9IGN1cnJlbnRDYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIHtcbiAgICAgIHByZW11bHRpcGxpZWRhbHBoYTogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBzbWFza1ZlcnRleFNoYWRlckNvZGUgPSBcIlxcXG4gIGF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgYXR0cmlidXRlIHZlYzIgYV90ZXhDb29yZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHVuaWZvcm0gdmVjMiB1X3Jlc29sdXRpb247ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdm9pZCBtYWluKCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIHZlYzIgY2xpcFNwYWNlID0gKGFfcG9zaXRpb24gLyB1X3Jlc29sdXRpb24pICogMi4wIC0gMS4wOyAgIFxcXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZSAqIHZlYzIoMSwgLTEpLCAwLCAxKTsgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIHZfdGV4Q29vcmQgPSBhX3RleENvb3JkOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI7XG4gIHZhciBzbWFza0ZyYWdtZW50U2hhZGVyQ29kZSA9IFwiXFxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHVuaWZvcm0gdmVjNCB1X2JhY2tkcm9wOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdW5pZm9ybSBpbnQgdV9zdWJ0eXBlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHNhbXBsZXIyRCB1X2ltYWdlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVfbWFzazsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB2YXJ5aW5nIHZlYzIgdl90ZXhDb29yZDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdm9pZCBtYWluKCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIHZlYzQgaW1hZ2VDb2xvciA9IHRleHR1cmUyRCh1X2ltYWdlLCB2X3RleENvb3JkKTsgICAgICAgICAgIFxcXG4gICAgdmVjNCBtYXNrQ29sb3IgPSB0ZXh0dXJlMkQodV9tYXNrLCB2X3RleENvb3JkKTsgICAgICAgICAgICAgXFxcbiAgICBpZiAodV9iYWNrZHJvcC5hID4gMC4wKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgbWFza0NvbG9yLnJnYiA9IG1hc2tDb2xvci5yZ2IgKiBtYXNrQ29sb3IuYSArICAgICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgdV9iYWNrZHJvcC5yZ2IgKiAoMS4wIC0gbWFza0NvbG9yLmEpOyAgICAgXFxcbiAgICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIGZsb2F0IGx1bTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgaWYgKHVfc3VidHlwZSA9PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgIGx1bSA9IG1hc2tDb2xvci5hOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgICBsdW0gPSBtYXNrQ29sb3IuciAqIDAuMyArIG1hc2tDb2xvci5nICogMC41OSArICAgICAgICAgICAgXFxcbiAgICAgICAgICAgIG1hc2tDb2xvci5iICogMC4xMTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgaW1hZ2VDb2xvci5hICo9IGx1bTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICBpbWFnZUNvbG9yLnJnYiAqPSBpbWFnZUNvbG9yLmE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgIGdsX0ZyYWdDb2xvciA9IGltYWdlQ29sb3I7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCI7XG4gIHZhciBzbWFza0NhY2hlID0gbnVsbDtcblxuICBmdW5jdGlvbiBpbml0U21hc2tHTCgpIHtcbiAgICB2YXIgY2FudmFzLCBnbDtcbiAgICBnZW5lcmF0ZUdMKCk7XG4gICAgY2FudmFzID0gY3VycmVudENhbnZhcztcbiAgICBjdXJyZW50Q2FudmFzID0gbnVsbDtcbiAgICBnbCA9IGN1cnJlbnRHTDtcbiAgICBjdXJyZW50R0wgPSBudWxsO1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIHNtYXNrVmVydGV4U2hhZGVyQ29kZSk7XG4gICAgdmFyIGZyYWdtZW50U2hhZGVyID0gY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIHNtYXNrRnJhZ21lbnRTaGFkZXJDb2RlKTtcbiAgICB2YXIgcHJvZ3JhbSA9IGNyZWF0ZVByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG4gICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICBjYWNoZS5nbCA9IGdsO1xuICAgIGNhY2hlLmNhbnZhcyA9IGNhbnZhcztcbiAgICBjYWNoZS5yZXNvbHV0aW9uTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3Jlc29sdXRpb25cIik7XG4gICAgY2FjaGUucG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICBjYWNoZS5iYWNrZHJvcExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9iYWNrZHJvcFwiKTtcbiAgICBjYWNoZS5zdWJ0eXBlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3N1YnR5cGVcIik7XG4gICAgdmFyIHRleENvb3JkTG9jYXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfdGV4Q29vcmRcIik7XG4gICAgdmFyIHRleExheWVyTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X2ltYWdlXCIpO1xuICAgIHZhciB0ZXhNYXNrTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X21hc2tcIik7XG4gICAgdmFyIHRleENvb3JkQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHRleENvb3JkQnVmZmVyKTtcbiAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShbMC4wLCAwLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCwgMC4wLCAxLjAsIDEuMCwgMC4wLCAxLjAsIDEuMF0pLCBnbC5TVEFUSUNfRFJBVyk7XG4gICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGV4Q29vcmRMb2NhdGlvbik7XG4gICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcih0ZXhDb29yZExvY2F0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm0xaSh0ZXhMYXllckxvY2F0aW9uLCAwKTtcbiAgICBnbC51bmlmb3JtMWkodGV4TWFza0xvY2F0aW9uLCAxKTtcbiAgICBzbWFza0NhY2hlID0gY2FjaGU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wb3NlU01hc2sobGF5ZXIsIG1hc2ssIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgd2lkdGggPSBsYXllci53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gbGF5ZXIuaGVpZ2h0O1xuXG4gICAgaWYgKCFzbWFza0NhY2hlKSB7XG4gICAgICBpbml0U21hc2tHTCgpO1xuICAgIH1cblxuICAgIHZhciBjYWNoZSA9IHNtYXNrQ2FjaGUsXG4gICAgICAgIGNhbnZhcyA9IGNhY2hlLmNhbnZhcyxcbiAgICAgICAgZ2wgPSBjYWNoZS5nbDtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgZ2wudW5pZm9ybTJmKGNhY2hlLnJlc29sdXRpb25Mb2NhdGlvbiwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAocHJvcGVydGllcy5iYWNrZHJvcCkge1xuICAgICAgZ2wudW5pZm9ybTRmKGNhY2hlLnJlc29sdXRpb25Mb2NhdGlvbiwgcHJvcGVydGllcy5iYWNrZHJvcFswXSwgcHJvcGVydGllcy5iYWNrZHJvcFsxXSwgcHJvcGVydGllcy5iYWNrZHJvcFsyXSwgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnVuaWZvcm00ZihjYWNoZS5yZXNvbHV0aW9uTG9jYXRpb24sIDAsIDAsIDAsIDApO1xuICAgIH1cblxuICAgIGdsLnVuaWZvcm0xaShjYWNoZS5zdWJ0eXBlTG9jYXRpb24sIHByb3BlcnRpZXMuc3VidHlwZSA9PT0gXCJMdW1pbm9zaXR5XCIgPyAxIDogMCk7XG4gICAgdmFyIHRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKGdsLCBsYXllciwgZ2wuVEVYVFVSRTApO1xuICAgIHZhciBtYXNrVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoZ2wsIG1hc2ssIGdsLlRFWFRVUkUxKTtcbiAgICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIG5ldyBGbG9hdDMyQXJyYXkoWzAsIDAsIHdpZHRoLCAwLCAwLCBoZWlnaHQsIDAsIGhlaWdodCwgd2lkdGgsIDAsIHdpZHRoLCBoZWlnaHRdKSwgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNhY2hlLnBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY2FjaGUucG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICBnbC5jbGVhckNvbG9yKDAsIDAsIDAsIDApO1xuICAgIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG4gICAgZ2wuY2xlYXIoZ2wuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuICAgIGdsLmZsdXNoKCk7XG4gICAgZ2wuZGVsZXRlVGV4dHVyZSh0ZXh0dXJlKTtcbiAgICBnbC5kZWxldGVUZXh0dXJlKG1hc2tUZXh0dXJlKTtcbiAgICBnbC5kZWxldGVCdWZmZXIoYnVmZmVyKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgdmFyIGZpZ3VyZXNWZXJ0ZXhTaGFkZXJDb2RlID0gXCJcXFxuICBhdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIGF0dHJpYnV0ZSB2ZWMzIGFfY29sb3I7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB1bmlmb3JtIHZlYzIgdV9yZXNvbHV0aW9uOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHVuaWZvcm0gdmVjMiB1X3NjYWxlOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgdW5pZm9ybSB2ZWMyIHVfb2Zmc2V0OyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHZhcnlpbmcgdmVjNCB2X2NvbG9yOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB2b2lkIG1haW4oKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgdmVjMiBwb3NpdGlvbiA9IChhX3Bvc2l0aW9uICsgdV9vZmZzZXQpICogdV9zY2FsZTsgICAgICAgICAgXFxcbiAgICB2ZWMyIGNsaXBTcGFjZSA9IChwb3NpdGlvbiAvIHVfcmVzb2x1dGlvbikgKiAyLjAgLSAxLjA7ICAgICBcXFxuICAgIGdsX1Bvc2l0aW9uID0gdmVjNChjbGlwU3BhY2UgKiB2ZWMyKDEsIC0xKSwgMCwgMSk7ICAgICAgICAgIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICB2X2NvbG9yID0gdmVjNChhX2NvbG9yIC8gMjU1LjAsIDEuMCk7ICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiO1xuICB2YXIgZmlndXJlc0ZyYWdtZW50U2hhZGVyQ29kZSA9IFwiXFxcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gIHZhcnlpbmcgdmVjNCB2X2NvbG9yOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcXFxuICB2b2lkIG1haW4oKSB7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXFxcbiAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIjtcbiAgdmFyIGZpZ3VyZXNDYWNoZSA9IG51bGw7XG5cbiAgZnVuY3Rpb24gaW5pdEZpZ3VyZXNHTCgpIHtcbiAgICB2YXIgY2FudmFzLCBnbDtcbiAgICBnZW5lcmF0ZUdMKCk7XG4gICAgY2FudmFzID0gY3VycmVudENhbnZhcztcbiAgICBjdXJyZW50Q2FudmFzID0gbnVsbDtcbiAgICBnbCA9IGN1cnJlbnRHTDtcbiAgICBjdXJyZW50R0wgPSBudWxsO1xuICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBjcmVhdGVWZXJ0ZXhTaGFkZXIoZ2wsIGZpZ3VyZXNWZXJ0ZXhTaGFkZXJDb2RlKTtcbiAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBjcmVhdGVGcmFnbWVudFNoYWRlcihnbCwgZmlndXJlc0ZyYWdtZW50U2hhZGVyQ29kZSk7XG4gICAgdmFyIHByb2dyYW0gPSBjcmVhdGVQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgdmFyIGNhY2hlID0ge307XG4gICAgY2FjaGUuZ2wgPSBnbDtcbiAgICBjYWNoZS5jYW52YXMgPSBjYW52YXM7XG4gICAgY2FjaGUucmVzb2x1dGlvbkxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9yZXNvbHV0aW9uXCIpO1xuICAgIGNhY2hlLnNjYWxlTG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgXCJ1X3NjYWxlXCIpO1xuICAgIGNhY2hlLm9mZnNldExvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidV9vZmZzZXRcIik7XG4gICAgY2FjaGUucG9zaXRpb25Mb2NhdGlvbiA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIFwiYV9wb3NpdGlvblwiKTtcbiAgICBjYWNoZS5jb2xvckxvY2F0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhX2NvbG9yXCIpO1xuICAgIGZpZ3VyZXNDYWNoZSA9IGNhY2hlO1xuICB9XG5cbiAgZnVuY3Rpb24gZHJhd0ZpZ3VyZXMod2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZENvbG9yLCBmaWd1cmVzLCBjb250ZXh0KSB7XG4gICAgaWYgKCFmaWd1cmVzQ2FjaGUpIHtcbiAgICAgIGluaXRGaWd1cmVzR0woKTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGUgPSBmaWd1cmVzQ2FjaGUsXG4gICAgICAgIGNhbnZhcyA9IGNhY2hlLmNhbnZhcyxcbiAgICAgICAgZ2wgPSBjYWNoZS5nbDtcbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCk7XG4gICAgZ2wudW5pZm9ybTJmKGNhY2hlLnJlc29sdXRpb25Mb2NhdGlvbiwgd2lkdGgsIGhlaWdodCk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgaSwgaWksIHJvd3M7XG5cbiAgICBmb3IgKGkgPSAwLCBpaSA9IGZpZ3VyZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgc3dpdGNoIChmaWd1cmVzW2ldLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgICAgICByb3dzID0gZmlndXJlc1tpXS5jb29yZHMubGVuZ3RoIC8gZmlndXJlc1tpXS52ZXJ0aWNlc1BlclJvdyB8IDA7XG4gICAgICAgICAgY291bnQgKz0gKHJvd3MgLSAxKSAqIChmaWd1cmVzW2ldLnZlcnRpY2VzUGVyUm93IC0gMSkgKiA2O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgICAgICBjb3VudCArPSBmaWd1cmVzW2ldLmNvb3Jkcy5sZW5ndGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkcyA9IG5ldyBGbG9hdDMyQXJyYXkoY291bnQgKiAyKTtcbiAgICB2YXIgY29sb3JzID0gbmV3IFVpbnQ4QXJyYXkoY291bnQgKiAzKTtcbiAgICB2YXIgY29vcmRzTWFwID0gY29udGV4dC5jb29yZHMsXG4gICAgICAgIGNvbG9yc01hcCA9IGNvbnRleHQuY29sb3JzO1xuICAgIHZhciBwSW5kZXggPSAwLFxuICAgICAgICBjSW5kZXggPSAwO1xuXG4gICAgZm9yIChpID0gMCwgaWkgPSBmaWd1cmVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIHZhciBmaWd1cmUgPSBmaWd1cmVzW2ldLFxuICAgICAgICAgIHBzID0gZmlndXJlLmNvb3JkcyxcbiAgICAgICAgICBjcyA9IGZpZ3VyZS5jb2xvcnM7XG5cbiAgICAgIHN3aXRjaCAoZmlndXJlLnR5cGUpIHtcbiAgICAgICAgY2FzZSBcImxhdHRpY2VcIjpcbiAgICAgICAgICB2YXIgY29scyA9IGZpZ3VyZS52ZXJ0aWNlc1BlclJvdztcbiAgICAgICAgICByb3dzID0gcHMubGVuZ3RoIC8gY29scyB8IDA7XG5cbiAgICAgICAgICBmb3IgKHZhciByb3cgPSAxOyByb3cgPCByb3dzOyByb3crKykge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHJvdyAqIGNvbHMgKyAxO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAxOyBjb2wgPCBjb2xzOyBjb2wrKywgb2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleF0gPSBjb29yZHNNYXBbcHNbb2Zmc2V0IC0gY29scyAtIDFdXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDFdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIGNvbHMgLSAxXSArIDFdO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgMl0gPSBjb29yZHNNYXBbcHNbb2Zmc2V0IC0gY29sc11dO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgM10gPSBjb29yZHNNYXBbcHNbb2Zmc2V0IC0gY29sc10gKyAxXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDRdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIDFdXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDVdID0gY29vcmRzTWFwW3BzW29mZnNldCAtIDFdICsgMV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXhdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIGNvbHMgLSAxXV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyAxXSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSBjb2xzIC0gMV0gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDJdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIGNvbHMgLSAxXSArIDJdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgM10gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gY29sc11dO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgNF0gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gY29sc10gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDVdID0gY29sb3JzTWFwW2NzW29mZnNldCAtIGNvbHNdICsgMl07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyA2XSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSAxXV07XG4gICAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyA3XSA9IGNvbG9yc01hcFtjc1tvZmZzZXQgLSAxXSArIDFdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgOF0gPSBjb2xvcnNNYXBbY3Nbb2Zmc2V0IC0gMV0gKyAyXTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDZdID0gY29vcmRzW3BJbmRleCArIDJdO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgN10gPSBjb29yZHNbcEluZGV4ICsgM107XG4gICAgICAgICAgICAgIGNvb3Jkc1twSW5kZXggKyA4XSA9IGNvb3Jkc1twSW5kZXggKyA0XTtcbiAgICAgICAgICAgICAgY29vcmRzW3BJbmRleCArIDldID0gY29vcmRzW3BJbmRleCArIDVdO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgMTBdID0gY29vcmRzTWFwW3BzW29mZnNldF1dO1xuICAgICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgMTFdID0gY29vcmRzTWFwW3BzW29mZnNldF0gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDldID0gY29sb3JzW2NJbmRleCArIDNdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTBdID0gY29sb3JzW2NJbmRleCArIDRdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTFdID0gY29sb3JzW2NJbmRleCArIDVdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTJdID0gY29sb3JzW2NJbmRleCArIDZdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTNdID0gY29sb3JzW2NJbmRleCArIDddO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTRdID0gY29sb3JzW2NJbmRleCArIDhdO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTVdID0gY29sb3JzTWFwW2NzW29mZnNldF1dO1xuICAgICAgICAgICAgICBjb2xvcnNbY0luZGV4ICsgMTZdID0gY29sb3JzTWFwW2NzW29mZnNldF0gKyAxXTtcbiAgICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDE3XSA9IGNvbG9yc01hcFtjc1tvZmZzZXRdICsgMl07XG4gICAgICAgICAgICAgIHBJbmRleCArPSAxMjtcbiAgICAgICAgICAgICAgY0luZGV4ICs9IDE4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgamogPSBwcy5sZW5ndGg7IGogPCBqajsgaisrKSB7XG4gICAgICAgICAgICBjb29yZHNbcEluZGV4XSA9IGNvb3Jkc01hcFtwc1tqXV07XG4gICAgICAgICAgICBjb29yZHNbcEluZGV4ICsgMV0gPSBjb29yZHNNYXBbcHNbal0gKyAxXTtcbiAgICAgICAgICAgIGNvbG9yc1tjSW5kZXhdID0gY29sb3JzTWFwW2NzW2pdXTtcbiAgICAgICAgICAgIGNvbG9yc1tjSW5kZXggKyAxXSA9IGNvbG9yc01hcFtjc1tqXSArIDFdO1xuICAgICAgICAgICAgY29sb3JzW2NJbmRleCArIDJdID0gY29sb3JzTWFwW2NzW2pdICsgMl07XG4gICAgICAgICAgICBwSW5kZXggKz0gMjtcbiAgICAgICAgICAgIGNJbmRleCArPSAzO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChiYWNrZ3JvdW5kQ29sb3IpIHtcbiAgICAgIGdsLmNsZWFyQ29sb3IoYmFja2dyb3VuZENvbG9yWzBdIC8gMjU1LCBiYWNrZ3JvdW5kQ29sb3JbMV0gLyAyNTUsIGJhY2tncm91bmRDb2xvclsyXSAvIDI1NSwgMS4wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wuY2xlYXJDb2xvcigwLCAwLCAwLCAwKTtcbiAgICB9XG5cbiAgICBnbC5jbGVhcihnbC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICB2YXIgY29vcmRzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvb3Jkc0J1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGNvb3JkcywgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNhY2hlLnBvc2l0aW9uTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY2FjaGUucG9zaXRpb25Mb2NhdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICB2YXIgY29sb3JzQnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGNvbG9yc0J1ZmZlcik7XG4gICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGNvbG9ycywgZ2wuU1RBVElDX0RSQVcpO1xuICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGNhY2hlLmNvbG9yTG9jYXRpb24pO1xuICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIoY2FjaGUuY29sb3JMb2NhdGlvbiwgMywgZ2wuVU5TSUdORURfQllURSwgZmFsc2UsIDAsIDApO1xuICAgIGdsLnVuaWZvcm0yZihjYWNoZS5zY2FsZUxvY2F0aW9uLCBjb250ZXh0LnNjYWxlWCwgY29udGV4dC5zY2FsZVkpO1xuICAgIGdsLnVuaWZvcm0yZihjYWNoZS5vZmZzZXRMb2NhdGlvbiwgY29udGV4dC5vZmZzZXRYLCBjb250ZXh0Lm9mZnNldFkpO1xuICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCBjb3VudCk7XG4gICAgZ2wuZmx1c2goKTtcbiAgICBnbC5kZWxldGVCdWZmZXIoY29vcmRzQnVmZmVyKTtcbiAgICBnbC5kZWxldGVCdWZmZXIoY29sb3JzQnVmZmVyKTtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0cnlJbml0R0w6IGZ1bmN0aW9uIHRyeUluaXRHTCgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGdlbmVyYXRlR0woKTtcbiAgICAgICAgcmV0dXJuICEhY3VycmVudEdMO1xuICAgICAgfSBjYXRjaCAoZXgpIHt9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGNvbXBvc2VTTWFzazogY29tcG9zZVNNYXNrLFxuICAgIGRyYXdGaWd1cmVzOiBkcmF3RmlndXJlcyxcbiAgICBjbGVhbnVwOiBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgICAgaWYgKHNtYXNrQ2FjaGUgJiYgc21hc2tDYWNoZS5jYW52YXMpIHtcbiAgICAgICAgc21hc2tDYWNoZS5jYW52YXMud2lkdGggPSAwO1xuICAgICAgICBzbWFza0NhY2hlLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmlndXJlc0NhY2hlICYmIGZpZ3VyZXNDYWNoZS5jYW52YXMpIHtcbiAgICAgICAgZmlndXJlc0NhY2hlLmNhbnZhcy53aWR0aCA9IDA7XG4gICAgICAgIGZpZ3VyZXNDYWNoZS5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgIH1cblxuICAgICAgc21hc2tDYWNoZSA9IG51bGw7XG4gICAgICBmaWd1cmVzQ2FjaGUgPSBudWxsO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuLyoqKi8gfSksXG4vKiAyMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuQW5ub3RhdGlvbkxheWVyID0gdm9pZCAwO1xuXG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2Fubm90YXRpb25fc3RvcmFnZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjA1KTtcblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTsgfVxuXG5mdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgby5fX3Byb3RvX18gPSBwOyByZXR1cm4gbzsgfTsgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmIChjYWxsICYmIChfdHlwZW9mKGNhbGwpID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7IHJldHVybiBjYWxsOyB9IHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpOyB9XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikgeyBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gc2VsZjsgfVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IERhdGUucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoRGF0ZSwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZiA6IGZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7IHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7IH07IHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFubm90YXRpb25FbGVtZW50RmFjdG9yeSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY3JlYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgc3VidHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5hbm5vdGF0aW9uVHlwZTtcblxuICAgICAgc3dpdGNoIChzdWJ0eXBlKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgICByZXR1cm4gbmV3IExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlRFWFQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5XSURHRVQ6XG4gICAgICAgICAgdmFyIGZpZWxkVHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5maWVsZFR5cGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpZWxkVHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgICAgICBjYXNlIFwiQnRuXCI6XG4gICAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmRhdGEucmFkaW9CdXR0b24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5kYXRhLmNoZWNrQm94KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgICAgIGNhc2UgXCJDaFwiOlxuICAgICAgICAgICAgICByZXR1cm4gbmV3IENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT1BVUDpcbiAgICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5GUkVFVEVYVDpcbiAgICAgICAgICByZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5MSU5FOlxuICAgICAgICAgIHJldHVybiBuZXcgTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1FVQVJFOlxuICAgICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5DSVJDTEU6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPTFlMSU5FOlxuICAgICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkNBUkVUOlxuICAgICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLklOSzpcbiAgICAgICAgICByZXR1cm4gbmV3IElua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9MWUdPTjpcbiAgICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkhJR0hMSUdIVDpcbiAgICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuVU5ERVJMSU5FOlxuICAgICAgICAgIHJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TUVVJR0dMWTpcbiAgICAgICAgICByZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TVFJJS0VPVVQ6XG4gICAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNUQU1QOlxuICAgICAgICAgIHJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkZJTEVBVFRBQ0hNRU5UOlxuICAgICAgICAgIHJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFubm90YXRpb25FbGVtZW50RmFjdG9yeTtcbn0oKTtcblxudmFyIEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIHZhciBpc1JlbmRlcmFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBpZ25vcmVCb3JkZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHRoaXMuaXNSZW5kZXJhYmxlID0gaXNSZW5kZXJhYmxlO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtZXRlcnMuZGF0YTtcbiAgICB0aGlzLmxheWVyID0gcGFyYW1ldGVycy5sYXllcjtcbiAgICB0aGlzLnBhZ2UgPSBwYXJhbWV0ZXJzLnBhZ2U7XG4gICAgdGhpcy52aWV3cG9ydCA9IHBhcmFtZXRlcnMudmlld3BvcnQ7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IHBhcmFtZXRlcnMubGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcjtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoO1xuICAgIHRoaXMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyA9IHBhcmFtZXRlcnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcztcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBwYXJhbWV0ZXJzLnN2Z0ZhY3Rvcnk7XG4gICAgdGhpcy5hbm5vdGF0aW9uU3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG5cbiAgICBpZiAoaXNSZW5kZXJhYmxlKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUNvbnRhaW5lcihpZ25vcmVCb3JkZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwiX2NyZWF0ZUNvbnRhaW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY3JlYXRlQ29udGFpbmVyKCkge1xuICAgICAgdmFyIGlnbm9yZUJvcmRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICBwYWdlID0gdGhpcy5wYWdlLFxuICAgICAgICAgIHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydDtcbiAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICAgIHZhciB3aWR0aCA9IGRhdGEucmVjdFsyXSAtIGRhdGEucmVjdFswXTtcbiAgICAgIHZhciBoZWlnaHQgPSBkYXRhLnJlY3RbM10gLSBkYXRhLnJlY3RbMV07XG4gICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuXG4gICAgICB2YXIgcmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG5cbiAgICAgIGNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSBcIm1hdHJpeChcIi5jb25jYXQodmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpLCBcIilcIik7XG4gICAgICBjb250YWluZXIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCItXCIuY29uY2F0KHJlY3RbMF0sIFwicHggLVwiKS5jb25jYXQocmVjdFsxXSwgXCJweFwiKTtcblxuICAgICAgaWYgKCFpZ25vcmVCb3JkZXIgJiYgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCA+IDApIHtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlcldpZHRoID0gXCJcIi5jb25jYXQoZGF0YS5ib3JkZXJTdHlsZS53aWR0aCwgXCJweFwiKTtcblxuICAgICAgICBpZiAoZGF0YS5ib3JkZXJTdHlsZS5zdHlsZSAhPT0gX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VTkRFUkxJTkUpIHtcbiAgICAgICAgICB3aWR0aCA9IHdpZHRoIC0gMiAqIGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgICAgICAgaGVpZ2h0ID0gaGVpZ2h0IC0gMiAqIGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaG9yaXpvbnRhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUuaG9yaXpvbnRhbENvcm5lclJhZGl1cztcbiAgICAgICAgdmFyIHZlcnRpY2FsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS52ZXJ0aWNhbENvcm5lclJhZGl1cztcblxuICAgICAgICBpZiAoaG9yaXpvbnRhbFJhZGl1cyA+IDAgfHwgdmVydGljYWxSYWRpdXMgPiAwKSB7XG4gICAgICAgICAgdmFyIHJhZGl1cyA9IFwiXCIuY29uY2F0KGhvcml6b250YWxSYWRpdXMsIFwicHggLyBcIikuY29uY2F0KHZlcnRpY2FsUmFkaXVzLCBcInB4XCIpO1xuICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKGRhdGEuYm9yZGVyU3R5bGUuc3R5bGUpIHtcbiAgICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuU09MSUQ6XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5EQVNIRUQ6XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBiZXZlbGVkXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuSU5TRVQ6XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogaW5zZXRcIik7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyQm90dG9tU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmNvbG9yKSB7XG4gICAgICAgICAgY29udGFpbmVyLnN0eWxlLmJvcmRlckNvbG9yID0gX3V0aWwuVXRpbC5tYWtlQ3NzUmdiKGRhdGEuY29sb3JbMF0gfCAwLCBkYXRhLmNvbG9yWzFdIHwgMCwgZGF0YS5jb2xvclsyXSB8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29udGFpbmVyLnN0eWxlLmxlZnQgPSBcIlwiLmNvbmNhdChyZWN0WzBdLCBcInB4XCIpO1xuICAgICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IFwiXCIuY29uY2F0KHJlY3RbMV0sIFwicHhcIik7XG4gICAgICBjb250YWluZXIuc3R5bGUud2lkdGggPSBcIlwiLmNvbmNhdCh3aWR0aCwgXCJweFwiKTtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIik7XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY3JlYXRlUG9wdXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NyZWF0ZVBvcHVwKGNvbnRhaW5lciwgdHJpZ2dlciwgZGF0YSkge1xuICAgICAgaWYgKCF0cmlnZ2VyKSB7XG4gICAgICAgIHRyaWdnZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICB0cmlnZ2VyLnN0eWxlLmhlaWdodCA9IGNvbnRhaW5lci5zdHlsZS5oZWlnaHQ7XG4gICAgICAgIHRyaWdnZXIuc3R5bGUud2lkdGggPSBjb250YWluZXIuc3R5bGUud2lkdGg7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0cmlnZ2VyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvcHVwRWxlbWVudCA9IG5ldyBQb3B1cEVsZW1lbnQoe1xuICAgICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICAgICAgY29sb3I6IGRhdGEuY29sb3IsXG4gICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICBtb2RpZmljYXRpb25EYXRlOiBkYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzOiBkYXRhLmNvbnRlbnRzLFxuICAgICAgICBoaWRlV3JhcHBlcjogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB2YXIgcG9wdXAgPSBwb3B1cEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBwb3B1cC5zdHlsZS5sZWZ0ID0gY29udGFpbmVyLnN0eWxlLndpZHRoO1xuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHBvcHVwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgYEFubm90YXRpb25FbGVtZW50LnJlbmRlcmAgY2FsbGVkXCIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBBbm5vdGF0aW9uRWxlbWVudDtcbn0oKTtcblxudmFyIExpbmtBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fubm90YXRpb25FbGVtZW50KSB7XG4gIF9pbmhlcml0cyhMaW5rQW5ub3RhdGlvbkVsZW1lbnQsIF9Bbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihMaW5rQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIExpbmtBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExpbmtBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLnVybCB8fCBwYXJhbWV0ZXJzLmRhdGEuZGVzdCB8fCBwYXJhbWV0ZXJzLmRhdGEuYWN0aW9uKTtcbiAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgcGFyYW1ldGVycywgaXNSZW5kZXJhYmxlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5rQW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImxpbmtBbm5vdGF0aW9uXCI7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICBsaW5rU2VydmljZSA9IHRoaXMubGlua1NlcnZpY2U7XG4gICAgICB2YXIgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuXG4gICAgICBpZiAoZGF0YS51cmwpIHtcbiAgICAgICAgKDAsIF9kaXNwbGF5X3V0aWxzLmFkZExpbmtBdHRyaWJ1dGVzKShsaW5rLCB7XG4gICAgICAgICAgdXJsOiBkYXRhLnVybCxcbiAgICAgICAgICB0YXJnZXQ6IGRhdGEubmV3V2luZG93ID8gX2Rpc3BsYXlfdXRpbHMuTGlua1RhcmdldC5CTEFOSyA6IGxpbmtTZXJ2aWNlLmV4dGVybmFsTGlua1RhcmdldCxcbiAgICAgICAgICByZWw6IGxpbmtTZXJ2aWNlLmV4dGVybmFsTGlua1JlbCxcbiAgICAgICAgICBlbmFibGVkOiBsaW5rU2VydmljZS5leHRlcm5hbExpbmtFbmFibGVkXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbikge1xuICAgICAgICB0aGlzLl9iaW5kTmFtZWRBY3Rpb24obGluaywgZGF0YS5hY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYmluZExpbmsobGluaywgZGF0YS5kZXN0KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQobGluayk7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9iaW5kTGlua1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0RGVzdGluYXRpb25IYXNoKGRlc3RpbmF0aW9uKTtcblxuICAgICAgbGluay5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZGVzdGluYXRpb24pIHtcbiAgICAgICAgICBfdGhpcy5saW5rU2VydmljZS5uYXZpZ2F0ZVRvKGRlc3RpbmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIGlmIChkZXN0aW5hdGlvbikge1xuICAgICAgICBsaW5rLmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxMaW5rXCI7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9iaW5kTmFtZWRBY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmROYW1lZEFjdGlvbihsaW5rLCBhY3Rpb24pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldEFuY2hvclVybChcIlwiKTtcblxuICAgICAgbGluay5vbmNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIubGlua1NlcnZpY2UuZXhlY3V0ZU5hbWVkQWN0aW9uKGFjdGlvbik7XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfTtcblxuICAgICAgbGluay5jbGFzc05hbWUgPSBcImludGVybmFsTGlua1wiO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBMaW5rQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFRleHRBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fubm90YXRpb25FbGVtZW50Mikge1xuICBfaW5oZXJpdHMoVGV4dEFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihUZXh0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXIyLmNhbGwodGhpcywgcGFyYW1ldGVycywgaXNSZW5kZXJhYmxlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhUZXh0QW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcInRleHRBbm5vdGF0aW9uXCI7XG4gICAgICB2YXIgaW1hZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgaW1hZ2Uuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIuc3R5bGUuaGVpZ2h0O1xuICAgICAgaW1hZ2Uuc3R5bGUud2lkdGggPSB0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aDtcbiAgICAgIGltYWdlLnNyYyA9IHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoICsgXCJhbm5vdGF0aW9uLVwiICsgdGhpcy5kYXRhLm5hbWUudG9Mb3dlckNhc2UoKSArIFwiLnN2Z1wiO1xuICAgICAgaW1hZ2UuYWx0ID0gXCJbe3t0eXBlfX0gQW5ub3RhdGlvbl1cIjtcbiAgICAgIGltYWdlLmRhdGFzZXQubDEwbklkID0gXCJ0ZXh0X2Fubm90YXRpb25fdHlwZVwiO1xuICAgICAgaW1hZ2UuZGF0YXNldC5sMTBuQXJncyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgdHlwZTogdGhpcy5kYXRhLm5hbWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cCh0aGlzLmNvbnRhaW5lciwgaW1hZ2UsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dEFubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fubm90YXRpb25FbGVtZW50Mykge1xuICBfaW5oZXJpdHMoV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIF9Bbm5vdGF0aW9uRWxlbWVudDMpO1xuXG4gIHZhciBfc3VwZXIzID0gX2NyZWF0ZVN1cGVyKFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgcmV0dXJuIF9zdXBlcjMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1dpZGdldEFubm90YXRpb25FbGVtKSB7XG4gIF9pbmhlcml0cyhUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIF9XaWRnZXRBbm5vdGF0aW9uRWxlbSk7XG5cbiAgdmFyIF9zdXBlcjQgPSBfY3JlYXRlU3VwZXIoVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUZXh0V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9IHBhcmFtZXRlcnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyB8fCAhcGFyYW1ldGVycy5kYXRhLmhhc0FwcGVhcmFuY2UgJiYgISFwYXJhbWV0ZXJzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICByZXR1cm4gX3N1cGVyNC5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIFRFWFRfQUxJR05NRU5UID0gW1wibGVmdFwiLCBcImNlbnRlclwiLCBcInJpZ2h0XCJdO1xuICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgdmFyIGlkID0gdGhpcy5kYXRhLmlkO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJ0ZXh0V2lkZ2V0QW5ub3RhdGlvblwiO1xuICAgICAgdmFyIGVsZW1lbnQgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zKSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IHN0b3JhZ2UuZ2V0T3JDcmVhdGVWYWx1ZShpZCwgdGhpcy5kYXRhLmZpZWxkVmFsdWUpO1xuXG4gICAgICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZXh0YXJlYVwiKTtcbiAgICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICBlbGVtZW50LnR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHRleHRDb250ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmRpc2FibGVkID0gdGhpcy5kYXRhLnJlYWRPbmx5O1xuICAgICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuXG4gICAgICAgIGlmICh0aGlzLmRhdGEubWF4TGVuICE9PSBudWxsKSB7XG4gICAgICAgICAgZWxlbWVudC5tYXhMZW5ndGggPSB0aGlzLmRhdGEubWF4TGVuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5jb21iKSB7XG4gICAgICAgICAgdmFyIGZpZWxkV2lkdGggPSB0aGlzLmRhdGEucmVjdFsyXSAtIHRoaXMuZGF0YS5yZWN0WzBdO1xuICAgICAgICAgIHZhciBjb21iV2lkdGggPSBmaWVsZFdpZHRoIC8gdGhpcy5kYXRhLm1heExlbjtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJjb21iXCIpO1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUubGV0dGVyU3BhY2luZyA9IFwiY2FsYyhcIi5jb25jYXQoY29tYldpZHRoLCBcInB4IC0gMWNoKVwiKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS52ZXJ0aWNhbEFsaWduID0gXCJtaWRkbGVcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gXCJ0YWJsZS1jZWxsXCI7XG4gICAgICAgIHZhciBmb250ID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5kYXRhLmZvbnRSZWZOYW1lICYmIHRoaXMucGFnZS5jb21tb25PYmpzLmhhcyh0aGlzLmRhdGEuZm9udFJlZk5hbWUpKSB7XG4gICAgICAgICAgZm9udCA9IHRoaXMucGFnZS5jb21tb25PYmpzLmdldCh0aGlzLmRhdGEuZm9udFJlZk5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0VGV4dFN0eWxlKGVsZW1lbnQsIGZvbnQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhLnRleHRBbGlnbm1lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS50ZXh0QWxpZ24gPSBURVhUX0FMSUdOTUVOVFt0aGlzLmRhdGEudGV4dEFsaWdubWVudF07XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0VGV4dFN0eWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRUZXh0U3R5bGUoZWxlbWVudCwgZm9udCkge1xuICAgICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICAgIHN0eWxlLmZvbnRTaXplID0gXCJcIi5jb25jYXQodGhpcy5kYXRhLmZvbnRTaXplLCBcInB4XCIpO1xuICAgICAgc3R5bGUuZGlyZWN0aW9uID0gdGhpcy5kYXRhLmZvbnREaXJlY3Rpb24gPCAwID8gXCJydGxcIiA6IFwibHRyXCI7XG5cbiAgICAgIGlmICghZm9udCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBib2xkID0gXCJub3JtYWxcIjtcblxuICAgICAgaWYgKGZvbnQuYmxhY2spIHtcbiAgICAgICAgYm9sZCA9IFwiOTAwXCI7XG4gICAgICB9IGVsc2UgaWYgKGZvbnQuYm9sZCkge1xuICAgICAgICBib2xkID0gXCJib2xkXCI7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlLmZvbnRXZWlnaHQgPSBib2xkO1xuICAgICAgc3R5bGUuZm9udFN0eWxlID0gZm9udC5pdGFsaWMgPyBcIml0YWxpY1wiIDogXCJub3JtYWxcIjtcbiAgICAgIHZhciBmb250RmFtaWx5ID0gZm9udC5sb2FkZWROYW1lID8gXCJcXFwiXCIuY29uY2F0KGZvbnQubG9hZGVkTmFtZSwgXCJcXFwiLCBcIikgOiBcIlwiO1xuICAgICAgdmFyIGZhbGxiYWNrTmFtZSA9IGZvbnQuZmFsbGJhY2tOYW1lIHx8IFwiSGVsdmV0aWNhLCBzYW5zLXNlcmlmXCI7XG4gICAgICBzdHlsZS5mb250RmFtaWx5ID0gZm9udEZhbWlseSArIGZhbGxiYWNrTmFtZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gVGV4dFdpZGdldEFubm90YXRpb25FbGVtZW50O1xufShXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfV2lkZ2V0QW5ub3RhdGlvbkVsZW0yKSB7XG4gIF9pbmhlcml0cyhDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50LCBfV2lkZ2V0QW5ub3RhdGlvbkVsZW0yKTtcblxuICB2YXIgX3N1cGVyNSA9IF9jcmVhdGVTdXBlcihDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBDaGVja2JveFdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICByZXR1cm4gX3N1cGVyNS5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHBhcmFtZXRlcnMucmVuZGVySW50ZXJhY3RpdmVGb3Jtcyk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBzdG9yYWdlID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgdmFyIGlkID0gZGF0YS5pZDtcbiAgICAgIHZhciB2YWx1ZSA9IHN0b3JhZ2UuZ2V0T3JDcmVhdGVWYWx1ZShpZCwgZGF0YS5maWVsZFZhbHVlICYmIGRhdGEuZmllbGRWYWx1ZSAhPT0gXCJPZmZcIik7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImJ1dHRvbldpZGdldEFubm90YXRpb24gY2hlY2tCb3hcIjtcbiAgICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgICBlbGVtZW50LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICBlbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQ7XG59KFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9XaWRnZXRBbm5vdGF0aW9uRWxlbTMpIHtcbiAgX2luaGVyaXRzKFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIF9XaWRnZXRBbm5vdGF0aW9uRWxlbTMpO1xuXG4gIHZhciBfc3VwZXI2ID0gX2NyZWF0ZVN1cGVyKFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHJldHVybiBfc3VwZXI2LmNhbGwodGhpcywgcGFyYW1ldGVycywgcGFyYW1ldGVycy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uIHJhZGlvQnV0dG9uXCI7XG4gICAgICB2YXIgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciBpZCA9IGRhdGEuaWQ7XG4gICAgICB2YXIgdmFsdWUgPSBzdG9yYWdlLmdldE9yQ3JlYXRlVmFsdWUoaWQsIGRhdGEuZmllbGRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZSk7XG4gICAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgICAgZWxlbWVudC50eXBlID0gXCJyYWRpb1wiO1xuICAgICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG5cbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBldmVudC50YXJnZXQubmFtZTtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkpLFxuICAgICAgICAgICAgX3N0ZXA7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIHJhZGlvID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChyYWRpbyAhPT0gZXZlbnQudGFyZ2V0KSB7XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8ucGFyZW50Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWFubm90YXRpb24taWRcIiksIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFJhZGlvQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQ7XG59KFdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0xpbmtBbm5vdGF0aW9uRWxlbWVuKSB7XG4gIF9pbmhlcml0cyhQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIF9MaW5rQW5ub3RhdGlvbkVsZW1lbik7XG5cbiAgdmFyIF9zdXBlcjcgPSBfY3JlYXRlU3VwZXIoUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICByZXR1cm4gX3N1cGVyNy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFB1c2hCdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBjb250YWluZXIgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZihQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQucHJvdG90eXBlKSwgXCJyZW5kZXJcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiYnV0dG9uV2lkZ2V0QW5ub3RhdGlvbiBwdXNoQnV0dG9uXCI7XG4gICAgICByZXR1cm4gY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQ7XG59KExpbmtBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1dpZGdldEFubm90YXRpb25FbGVtNCkge1xuICBfaW5oZXJpdHMoQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQsIF9XaWRnZXRBbm5vdGF0aW9uRWxlbTQpO1xuXG4gIHZhciBfc3VwZXI4ID0gX2NyZWF0ZVN1cGVyKENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHJldHVybiBfc3VwZXI4LmNhbGwodGhpcywgcGFyYW1ldGVycywgcGFyYW1ldGVycy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2hvaWNlV2lkZ2V0QW5ub3RhdGlvblwiO1xuICAgICAgdmFyIHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgICAgdmFyIGlkID0gdGhpcy5kYXRhLmlkO1xuICAgICAgc3RvcmFnZS5nZXRPckNyZWF0ZVZhbHVlKGlkLCB0aGlzLmRhdGEuZmllbGRWYWx1ZS5sZW5ndGggPiAwID8gdGhpcy5kYXRhLmZpZWxkVmFsdWVbMF0gOiBudWxsKTtcbiAgICAgIHZhciBzZWxlY3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNlbGVjdFwiKTtcbiAgICAgIHNlbGVjdEVsZW1lbnQuZGlzYWJsZWQgPSB0aGlzLmRhdGEucmVhZE9ubHk7XG4gICAgICBzZWxlY3RFbGVtZW50Lm5hbWUgPSB0aGlzLmRhdGEuZmllbGROYW1lO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgICBzZWxlY3RFbGVtZW50LnNpemUgPSB0aGlzLmRhdGEub3B0aW9ucy5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICAgIHNlbGVjdEVsZW1lbnQubXVsdGlwbGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIodGhpcy5kYXRhLm9wdGlvbnMpLFxuICAgICAgICAgIF9zdGVwMjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgb3B0aW9uID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIHZhciBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gb3B0aW9uLmV4cG9ydFZhbHVlO1xuXG4gICAgICAgICAgaWYgKHRoaXMuZGF0YS5maWVsZFZhbHVlLmluY2x1ZGVzKG9wdGlvbi5leHBvcnRWYWx1ZSkpIHtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmRDaGlsZChvcHRpb25FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICB9XG5cbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGV2ZW50LnRhcmdldC5vcHRpb25zO1xuICAgICAgICB2YXIgdmFsdWUgPSBvcHRpb25zW29wdGlvbnMuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQoc2VsZWN0RWxlbWVudCk7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENob2ljZVdpZGdldEFubm90YXRpb25FbGVtZW50O1xufShXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBQb3B1cEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQ0KSB7XG4gIF9pbmhlcml0cyhQb3B1cEFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQ0KTtcblxuICB2YXIgX3N1cGVyOSA9IF9jcmVhdGVTdXBlcihQb3B1cEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBQb3B1cEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgcmV0dXJuIF9zdXBlcjkuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgSUdOT1JFX1RZUEVTID0gW1wiTGluZVwiLCBcIlNxdWFyZVwiLCBcIkNpcmNsZVwiLCBcIlBvbHlMaW5lXCIsIFwiUG9seWdvblwiLCBcIklua1wiXTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwicG9wdXBBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGlmIChJR05PUkVfVFlQRVMuaW5jbHVkZXModGhpcy5kYXRhLnBhcmVudFR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNlbGVjdG9yID0gXCJbZGF0YS1hbm5vdGF0aW9uLWlkPVxcXCJcIi5jb25jYXQodGhpcy5kYXRhLnBhcmVudElkLCBcIlxcXCJdXCIpO1xuICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSB0aGlzLmxheWVyLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuXG4gICAgICBpZiAoIXBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9wdXAgPSBuZXcgUG9wdXBFbGVtZW50KHtcbiAgICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgdHJpZ2dlcjogcGFyZW50RWxlbWVudCxcbiAgICAgICAgY29sb3I6IHRoaXMuZGF0YS5jb2xvcixcbiAgICAgICAgdGl0bGU6IHRoaXMuZGF0YS50aXRsZSxcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICAgIGNvbnRlbnRzOiB0aGlzLmRhdGEuY29udGVudHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhcmVudExlZnQgPSBwYXJzZUZsb2F0KHBhcmVudEVsZW1lbnQuc3R5bGUubGVmdCk7XG4gICAgICB2YXIgcGFyZW50V2lkdGggPSBwYXJzZUZsb2F0KHBhcmVudEVsZW1lbnQuc3R5bGUud2lkdGgpO1xuICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gXCItXCIuY29uY2F0KHBhcmVudExlZnQgKyBwYXJlbnRXaWR0aCwgXCJweCAtXCIpLmNvbmNhdChwYXJlbnRFbGVtZW50LnN0eWxlLnRvcCk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gXCJcIi5jb25jYXQocGFyZW50TGVmdCArIHBhcmVudFdpZHRoLCBcInB4XCIpO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kQ2hpbGQocG9wdXAucmVuZGVyKCkpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb3B1cEFubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBQb3B1cEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQb3B1cEVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb3B1cEVsZW1lbnQpO1xuXG4gICAgdGhpcy5jb250YWluZXIgPSBwYXJhbWV0ZXJzLmNvbnRhaW5lcjtcbiAgICB0aGlzLnRyaWdnZXIgPSBwYXJhbWV0ZXJzLnRyaWdnZXI7XG4gICAgdGhpcy5jb2xvciA9IHBhcmFtZXRlcnMuY29sb3I7XG4gICAgdGhpcy50aXRsZSA9IHBhcmFtZXRlcnMudGl0bGU7XG4gICAgdGhpcy5tb2RpZmljYXRpb25EYXRlID0gcGFyYW1ldGVycy5tb2RpZmljYXRpb25EYXRlO1xuICAgIHRoaXMuY29udGVudHMgPSBwYXJhbWV0ZXJzLmNvbnRlbnRzO1xuICAgIHRoaXMuaGlkZVdyYXBwZXIgPSBwYXJhbWV0ZXJzLmhpZGVXcmFwcGVyIHx8IGZhbHNlO1xuICAgIHRoaXMucGlubmVkID0gZmFsc2U7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUG9wdXBFbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIEJBQ0tHUk9VTkRfRU5MSUdIVCA9IDAuNztcbiAgICAgIHZhciB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gXCJwb3B1cFdyYXBwZXJcIjtcbiAgICAgIHRoaXMuaGlkZUVsZW1lbnQgPSB0aGlzLmhpZGVXcmFwcGVyID8gd3JhcHBlciA6IHRoaXMuY29udGFpbmVyO1xuICAgICAgdGhpcy5oaWRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoaWRkZW5cIiwgdHJ1ZSk7XG4gICAgICB2YXIgcG9wdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcG9wdXAuY2xhc3NOYW1lID0gXCJwb3B1cFwiO1xuICAgICAgdmFyIGNvbG9yID0gdGhpcy5jb2xvcjtcblxuICAgICAgaWYgKGNvbG9yKSB7XG4gICAgICAgIHZhciByID0gQkFDS0dST1VORF9FTkxJR0hUICogKDI1NSAtIGNvbG9yWzBdKSArIGNvbG9yWzBdO1xuICAgICAgICB2YXIgZyA9IEJBQ0tHUk9VTkRfRU5MSUdIVCAqICgyNTUgLSBjb2xvclsxXSkgKyBjb2xvclsxXTtcbiAgICAgICAgdmFyIGIgPSBCQUNLR1JPVU5EX0VOTElHSFQgKiAoMjU1IC0gY29sb3JbMl0pICsgY29sb3JbMl07XG4gICAgICAgIHBvcHVwLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IF91dGlsLlV0aWwubWFrZUNzc1JnYihyIHwgMCwgZyB8IDAsIGIgfCAwKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgxXCIpO1xuICAgICAgdGl0bGUudGV4dENvbnRlbnQgPSB0aGlzLnRpdGxlO1xuICAgICAgcG9wdXAuYXBwZW5kQ2hpbGQodGl0bGUpO1xuXG4gICAgICB2YXIgZGF0ZU9iamVjdCA9IF9kaXNwbGF5X3V0aWxzLlBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KHRoaXMubW9kaWZpY2F0aW9uRGF0ZSk7XG5cbiAgICAgIGlmIChkYXRlT2JqZWN0KSB7XG4gICAgICAgIHZhciBtb2RpZmljYXRpb25EYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUudGV4dENvbnRlbnQgPSBcInt7ZGF0ZX19LCB7e3RpbWV9fVwiO1xuICAgICAgICBtb2RpZmljYXRpb25EYXRlLmRhdGFzZXQubDEwbklkID0gXCJhbm5vdGF0aW9uX2RhdGVfc3RyaW5nXCI7XG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUuZGF0YXNldC5sMTBuQXJncyA9IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBkYXRlOiBkYXRlT2JqZWN0LnRvTG9jYWxlRGF0ZVN0cmluZygpLFxuICAgICAgICAgIHRpbWU6IGRhdGVPYmplY3QudG9Mb2NhbGVUaW1lU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgICAgIHBvcHVwLmFwcGVuZENoaWxkKG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGVudHMgPSB0aGlzLl9mb3JtYXRDb250ZW50cyh0aGlzLmNvbnRlbnRzKTtcblxuICAgICAgcG9wdXAuYXBwZW5kQ2hpbGQoY29udGVudHMpO1xuICAgICAgdGhpcy50cmlnZ2VyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLl90b2dnbGUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLnRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlb3ZlclwiLCB0aGlzLl9zaG93LmJpbmQodGhpcywgZmFsc2UpKTtcbiAgICAgIHRoaXMudHJpZ2dlci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VvdXRcIiwgdGhpcy5faGlkZS5iaW5kKHRoaXMsIGZhbHNlKSk7XG4gICAgICBwb3B1cC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5faGlkZS5iaW5kKHRoaXMsIHRydWUpKTtcbiAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQocG9wdXApO1xuICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9mb3JtYXRDb250ZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZm9ybWF0Q29udGVudHMoY29udGVudHMpIHtcbiAgICAgIHZhciBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgICB2YXIgbGluZXMgPSBjb250ZW50cy5zcGxpdCgvKD86XFxyXFxuP3xcXG4pLyk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpaSA9IGxpbmVzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lc1tpXTtcbiAgICAgICAgcC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSk7XG5cbiAgICAgICAgaWYgKGkgPCBpaSAtIDEpIHtcbiAgICAgICAgICBwLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl90b2dnbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3RvZ2dsZSgpIHtcbiAgICAgIGlmICh0aGlzLnBpbm5lZCkge1xuICAgICAgICB0aGlzLl9oaWRlKHRydWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc2hvdyh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Nob3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Nob3coKSB7XG4gICAgICB2YXIgcGluID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKHBpbikge1xuICAgICAgICB0aGlzLnBpbm5lZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmhpZGVFbGVtZW50Lmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSkge1xuICAgICAgICB0aGlzLmhpZGVFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImhpZGRlblwiKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuekluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9oaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9oaWRlKCkge1xuICAgICAgdmFyIHVucGluID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuXG4gICAgICBpZiAodW5waW4pIHtcbiAgICAgICAgdGhpcy5waW5uZWQgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLmhpZGVFbGVtZW50Lmhhc0F0dHJpYnV0ZShcImhpZGRlblwiKSAmJiAhdGhpcy5waW5uZWQpIHtcbiAgICAgICAgdGhpcy5oaWRlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJoaWRkZW5cIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnpJbmRleCAtPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQb3B1cEVsZW1lbnQ7XG59KCk7XG5cbnZhciBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQ1KSB7XG4gIF9pbmhlcml0cyhGcmVlVGV4dEFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQ1KTtcblxuICB2YXIgX3N1cGVyMTAgPSBfY3JlYXRlU3VwZXIoRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMTAuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUsIHRydWUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImZyZWVUZXh0QW5ub3RhdGlvblwiO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cCh0aGlzLmNvbnRhaW5lciwgbnVsbCwgdGhpcy5kYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBMaW5lQW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDYpIHtcbiAgX2luaGVyaXRzKExpbmVBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50Nik7XG5cbiAgdmFyIF9zdXBlcjExID0gX2NyZWF0ZVN1cGVyKExpbmVBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGluZUFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgcmV0dXJuIF9zdXBlcjExLmNhbGwodGhpcywgcGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhMaW5lQW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImxpbmVBbm5vdGF0aW9uXCI7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciB3aWR0aCA9IGRhdGEucmVjdFsyXSAtIGRhdGEucmVjdFswXTtcbiAgICAgIHZhciBoZWlnaHQgPSBkYXRhLnJlY3RbM10gLSBkYXRhLnJlY3RbMV07XG4gICAgICB2YXIgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZVwiKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieDFcIiwgZGF0YS5yZWN0WzJdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbMF0pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJ5MVwiLCBkYXRhLnJlY3RbM10gLSBkYXRhLmxpbmVDb29yZGluYXRlc1sxXSk7XG4gICAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngyXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzJdKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlKFwieTJcIiwgZGF0YS5yZWN0WzNdIC0gZGF0YS5saW5lQ29vcmRpbmF0ZXNbM10pO1xuICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCB8fCAxKTtcbiAgICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICBzdmcuYXBwZW5kQ2hpbGQobGluZSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcblxuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIGxpbmUsIGRhdGEpO1xuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIExpbmVBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDcpIHtcbiAgX2luaGVyaXRzKFNxdWFyZUFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQ3KTtcblxuICB2YXIgX3N1cGVyMTIgPSBfY3JlYXRlU3VwZXIoU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFNxdWFyZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMTIuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUsIHRydWUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNxdWFyZUFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJzcXVhcmVBbm5vdGF0aW9uXCI7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciB3aWR0aCA9IGRhdGEucmVjdFsyXSAtIGRhdGEucmVjdFswXTtcbiAgICAgIHZhciBoZWlnaHQgPSBkYXRhLnJlY3RbM10gLSBkYXRhLnJlY3RbMV07XG4gICAgICB2YXIgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgICB2YXIgc3F1YXJlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoIC0gYm9yZGVyV2lkdGgpO1xuICAgICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQgLSBib3JkZXJXaWR0aCk7XG4gICAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgc3ZnLmFwcGVuZENoaWxkKHNxdWFyZSk7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcblxuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIHNxdWFyZSwgZGF0YSk7XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIENpcmNsZUFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQ4KSB7XG4gIF9pbmhlcml0cyhDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50OCk7XG5cbiAgdmFyIF9zdXBlcjEzID0gX2NyZWF0ZVN1cGVyKENpcmNsZUFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENpcmNsZUFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgcmV0dXJuIF9zdXBlcjEzLmNhbGwodGhpcywgcGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2lyY2xlQW5ub3RhdGlvblwiO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB2YXIgd2lkdGggPSBkYXRhLnJlY3RbMl0gLSBkYXRhLnJlY3RbMF07XG4gICAgICB2YXIgaGVpZ2h0ID0gZGF0YS5yZWN0WzNdIC0gZGF0YS5yZWN0WzFdO1xuICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG4gICAgICB2YXIgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgICAgdmFyIGNpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiY3hcIiwgd2lkdGggLyAyKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJjeVwiLCBoZWlnaHQgLyAyKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInJ5XCIsIGhlaWdodCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCB8fCAxKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChjaXJjbGUpO1xuICAgICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG5cbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBjaXJjbGUsIGRhdGEpO1xuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIENpcmNsZUFubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBQb2x5bGluZUFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQ5KSB7XG4gIF9pbmhlcml0cyhQb2x5bGluZUFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQ5KTtcblxuICB2YXIgX3N1cGVyMTQgPSBfY3JlYXRlU3VwZXIoUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF90aGlzMztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb2x5bGluZUFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgX3RoaXMzID0gX3N1cGVyMTQuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUsIHRydWUpO1xuICAgIF90aGlzMy5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlsaW5lQW5ub3RhdGlvblwiO1xuICAgIF90aGlzMy5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgcmV0dXJuIF90aGlzMztcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb2x5bGluZUFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5jb250YWluZXJDbGFzc05hbWU7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgIHZhciB3aWR0aCA9IGRhdGEucmVjdFsyXSAtIGRhdGEucmVjdFswXTtcbiAgICAgIHZhciBoZWlnaHQgPSBkYXRhLnJlY3RbM10gLSBkYXRhLnJlY3RbMV07XG4gICAgICB2YXIgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgICAgdmFyIF9pdGVyYXRvcjMgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihkYXRhLnZlcnRpY2VzKSxcbiAgICAgICAgICBfc3RlcDM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGNvb3JkaW5hdGUgPSBfc3RlcDMudmFsdWU7XG4gICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlLnggLSBkYXRhLnJlY3RbMF07XG4gICAgICAgICAgdmFyIHkgPSBkYXRhLnJlY3RbM10gLSBjb29yZGluYXRlLnk7XG4gICAgICAgICAgcG9pbnRzLnB1c2goeCArIFwiLFwiICsgeSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjMuZigpO1xuICAgICAgfVxuXG4gICAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgICB2YXIgcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgc3ZnLmFwcGVuZENoaWxkKHBvbHlsaW5lKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuXG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCh0aGlzLmNvbnRhaW5lciwgcG9seWxpbmUsIGRhdGEpO1xuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvbHlsaW5lQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1BvbHlsaW5lQW5ub3RhdGlvbkVsKSB7XG4gIF9pbmhlcml0cyhQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQsIF9Qb2x5bGluZUFubm90YXRpb25FbCk7XG5cbiAgdmFyIF9zdXBlcjE1ID0gX2NyZWF0ZVN1cGVyKFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gUG9seWdvbkFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICBfdGhpczQgPSBfc3VwZXIxNS5jYWxsKHRoaXMsIHBhcmFtZXRlcnMpO1xuICAgIF90aGlzNC5jb250YWluZXJDbGFzc05hbWUgPSBcInBvbHlnb25Bbm5vdGF0aW9uXCI7XG4gICAgX3RoaXM0LnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWdvblwiO1xuICAgIHJldHVybiBfdGhpczQ7XG4gIH1cblxuICByZXR1cm4gUG9seWdvbkFubm90YXRpb25FbGVtZW50O1xufShQb2x5bGluZUFubm90YXRpb25FbGVtZW50KTtcblxudmFyIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDEwKSB7XG4gIF9pbmhlcml0cyhDYXJldEFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQxMCk7XG5cbiAgdmFyIF9zdXBlcjE2ID0gX2NyZWF0ZVN1cGVyKENhcmV0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYXJldEFubm90YXRpb25FbGVtZW50KTtcblxuICAgIHZhciBpc1JlbmRlcmFibGUgPSAhIShwYXJhbWV0ZXJzLmRhdGEuaGFzUG9wdXAgfHwgcGFyYW1ldGVycy5kYXRhLnRpdGxlIHx8IHBhcmFtZXRlcnMuZGF0YS5jb250ZW50cyk7XG4gICAgcmV0dXJuIF9zdXBlcjE2LmNhbGwodGhpcywgcGFyYW1ldGVycywgaXNSZW5kZXJhYmxlLCB0cnVlKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhDYXJldEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJjYXJldEFubm90YXRpb25cIjtcblxuICAgICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXApIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIG51bGwsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQ2FyZXRBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgSW5rQW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDExKSB7XG4gIF9pbmhlcml0cyhJbmtBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTEpO1xuXG4gIHZhciBfc3VwZXIxNyA9IF9jcmVhdGVTdXBlcihJbmtBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gSW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5rQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICBfdGhpczUgPSBfc3VwZXIxNy5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSwgdHJ1ZSk7XG4gICAgX3RoaXM1LmNvbnRhaW5lckNsYXNzTmFtZSA9IFwiaW5rQW5ub3RhdGlvblwiO1xuICAgIF90aGlzNS5zdmdFbGVtZW50TmFtZSA9IFwic3ZnOnBvbHlsaW5lXCI7XG4gICAgcmV0dXJuIF90aGlzNTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhJbmtBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lO1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICB2YXIgd2lkdGggPSBkYXRhLnJlY3RbMl0gLSBkYXRhLnJlY3RbMF07XG4gICAgICB2YXIgaGVpZ2h0ID0gZGF0YS5yZWN0WzNdIC0gZGF0YS5yZWN0WzFdO1xuICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCk7XG5cbiAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoZGF0YS5pbmtMaXN0cyksXG4gICAgICAgICAgX3N0ZXA0O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpbmtMaXN0ID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgICAgICAgIHZhciBfaXRlcmF0b3I1ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoaW5rTGlzdCksXG4gICAgICAgICAgICAgIF9zdGVwNTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZSA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICAgICAgdmFyIHggPSBjb29yZGluYXRlLnggLSBkYXRhLnJlY3RbMF07XG4gICAgICAgICAgICAgIHZhciB5ID0gZGF0YS5yZWN0WzNdIC0gY29vcmRpbmF0ZS55O1xuICAgICAgICAgICAgICBwb2ludHMucHVzaChcIlwiLmNvbmNhdCh4LCBcIixcIikuY29uY2F0KHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I1LmYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgICAgICAgdmFyIHBvbHlsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQodGhpcy5zdmdFbGVtZW50TmFtZSk7XG4gICAgICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwicG9pbnRzXCIsIHBvaW50cyk7XG4gICAgICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcIm5vbmVcIik7XG5cbiAgICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cCh0aGlzLmNvbnRhaW5lciwgcG9seWxpbmUsIGRhdGEpO1xuXG4gICAgICAgICAgc3ZnLmFwcGVuZENoaWxkKHBvbHlsaW5lKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjQuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBJbmtBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDEyKSB7XG4gIF9pbmhlcml0cyhIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTIpO1xuXG4gIHZhciBfc3VwZXIxOCA9IF9jcmVhdGVTdXBlcihIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBIaWdobGlnaHRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXIxOC5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQsIFt7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc05hbWUgPSBcImhpZ2hsaWdodEFubm90YXRpb25cIjtcblxuICAgICAgaWYgKCF0aGlzLmRhdGEuaGFzUG9wdXApIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIG51bGwsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFVuZGVybGluZUFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQxMykge1xuICBfaW5oZXJpdHMoVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQsIF9Bbm5vdGF0aW9uRWxlbWVudDEzKTtcblxuICB2YXIgX3N1cGVyMTkgPSBfY3JlYXRlU3VwZXIoVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFVuZGVybGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMTkuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUsIHRydWUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFVuZGVybGluZUFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJ1bmRlcmxpbmVBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBudWxsLCB0aGlzLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFVuZGVybGluZUFubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQxNCkge1xuICBfaW5oZXJpdHMoU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTQpO1xuXG4gIHZhciBfc3VwZXIyMCA9IF9jcmVhdGVTdXBlcihTcXVpZ2dseUFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBTcXVpZ2dseUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXIyMC5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3F1aWdnbHlBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwic3F1aWdnbHlBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBudWxsLCB0aGlzLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQxNSkge1xuICBfaW5oZXJpdHMoU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQsIF9Bbm5vdGF0aW9uRWxlbWVudDE1KTtcblxuICB2YXIgX3N1cGVyMjEgPSBfY3JlYXRlU3VwZXIoU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RyaWtlT3V0QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gICAgdmFyIGlzUmVuZGVyYWJsZSA9ICEhKHBhcmFtZXRlcnMuZGF0YS5oYXNQb3B1cCB8fCBwYXJhbWV0ZXJzLmRhdGEudGl0bGUgfHwgcGFyYW1ldGVycy5kYXRhLmNvbnRlbnRzKTtcbiAgICByZXR1cm4gX3N1cGVyMjEuY2FsbCh0aGlzLCBwYXJhbWV0ZXJzLCBpc1JlbmRlcmFibGUsIHRydWUpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50LCBbe1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gXCJzdHJpa2VvdXRBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBudWxsLCB0aGlzLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50O1xufShBbm5vdGF0aW9uRWxlbWVudCk7XG5cbnZhciBTdGFtcEFubm90YXRpb25FbGVtZW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQW5ub3RhdGlvbkVsZW1lbnQxNikge1xuICBfaW5oZXJpdHMoU3RhbXBBbm5vdGF0aW9uRWxlbWVudCwgX0Fubm90YXRpb25FbGVtZW50MTYpO1xuXG4gIHZhciBfc3VwZXIyMiA9IF9jcmVhdGVTdXBlcihTdGFtcEFubm90YXRpb25FbGVtZW50KTtcblxuICBmdW5jdGlvbiBTdGFtcEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICB2YXIgaXNSZW5kZXJhYmxlID0gISEocGFyYW1ldGVycy5kYXRhLmhhc1BvcHVwIHx8IHBhcmFtZXRlcnMuZGF0YS50aXRsZSB8fCBwYXJhbWV0ZXJzLmRhdGEuY29udGVudHMpO1xuICAgIHJldHVybiBfc3VwZXIyMi5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIGlzUmVuZGVyYWJsZSwgdHJ1ZSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoU3RhbXBBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwic3RhbXBBbm5vdGF0aW9uXCI7XG5cbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc1BvcHVwKSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKHRoaXMuY29udGFpbmVyLCBudWxsLCB0aGlzLmRhdGEpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQ7XG59KEFubm90YXRpb25FbGVtZW50KTtcblxudmFyIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Bbm5vdGF0aW9uRWxlbWVudDE3KSB7XG4gIF9pbmhlcml0cyhGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50LCBfQW5ub3RhdGlvbkVsZW1lbnQxNyk7XG5cbiAgdmFyIF9zdXBlcjIzID0gX2NyZWF0ZVN1cGVyKEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEZpbGVBdHRhY2htZW50QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycykge1xuICAgIHZhciBfdGhpczY7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCk7XG5cbiAgICBfdGhpczYgPSBfc3VwZXIyMy5jYWxsKHRoaXMsIHBhcmFtZXRlcnMsIHRydWUpO1xuICAgIHZhciBfdGhpczYkZGF0YSRmaWxlID0gX3RoaXM2LmRhdGEuZmlsZSxcbiAgICAgICAgZmlsZW5hbWUgPSBfdGhpczYkZGF0YSRmaWxlLmZpbGVuYW1lLFxuICAgICAgICBjb250ZW50ID0gX3RoaXM2JGRhdGEkZmlsZS5jb250ZW50O1xuICAgIF90aGlzNi5maWxlbmFtZSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRGaWxlbmFtZUZyb21VcmwpKGZpbGVuYW1lKTtcbiAgICBfdGhpczYuY29udGVudCA9IGNvbnRlbnQ7XG5cbiAgICBpZiAoX3RoaXM2LmxpbmtTZXJ2aWNlLmV2ZW50QnVzKSB7XG4gICAgICBfdGhpczYubGlua1NlcnZpY2UuZXZlbnRCdXMuZGlzcGF0Y2goXCJmaWxlYXR0YWNobWVudGFubm90YXRpb25cIiwge1xuICAgICAgICBzb3VyY2U6IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXM2KSxcbiAgICAgICAgaWQ6ICgwLCBfdXRpbC5zdHJpbmdUb1BERlN0cmluZykoZmlsZW5hbWUpLFxuICAgICAgICBmaWxlbmFtZTogZmlsZW5hbWUsXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBfdGhpczY7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiZmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uXCI7XG4gICAgICB2YXIgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0cmlnZ2VyLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLnN0eWxlLmhlaWdodDtcbiAgICAgIHRyaWdnZXIuc3R5bGUud2lkdGggPSB0aGlzLmNvbnRhaW5lci5zdHlsZS53aWR0aDtcbiAgICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuX2Rvd25sb2FkLmJpbmQodGhpcykpO1xuXG4gICAgICBpZiAoIXRoaXMuZGF0YS5oYXNQb3B1cCAmJiAodGhpcy5kYXRhLnRpdGxlIHx8IHRoaXMuZGF0YS5jb250ZW50cykpIHtcbiAgICAgICAgdGhpcy5fY3JlYXRlUG9wdXAodGhpcy5jb250YWluZXIsIHRyaWdnZXIsIHRoaXMuZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRyaWdnZXIpO1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZG93bmxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Rvd25sb2FkKCkge1xuICAgICAgaWYgKCF0aGlzLmRvd25sb2FkTWFuYWdlcikge1xuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJEb3dubG9hZCBjYW5ub3QgYmUgc3RhcnRlZCBkdWUgdG8gdW5hdmFpbGFibGUgZG93bmxvYWQgbWFuYWdlclwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRvd25sb2FkTWFuYWdlci5kb3dubG9hZERhdGEodGhpcy5jb250ZW50LCB0aGlzLmZpbGVuYW1lLCBcIlwiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudDtcbn0oQW5ub3RhdGlvbkVsZW1lbnQpO1xuXG52YXIgQW5ub3RhdGlvbkxheWVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5ub3RhdGlvbkxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uTGF5ZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEFubm90YXRpb25MYXllciwgbnVsbCwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJhbWV0ZXJzKSB7XG4gICAgICB2YXIgc29ydGVkQW5ub3RhdGlvbnMgPSBbXSxcbiAgICAgICAgICBwb3B1cEFubm90YXRpb25zID0gW107XG5cbiAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGFyYW1ldGVycy5hbm5vdGF0aW9ucyksXG4gICAgICAgICAgX3N0ZXA2O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjYucygpOyAhKF9zdGVwNiA9IF9pdGVyYXRvcjYubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBfZGF0YSA9IF9zdGVwNi52YWx1ZTtcblxuICAgICAgICAgIGlmICghX2RhdGEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfZGF0YS5hbm5vdGF0aW9uVHlwZSA9PT0gX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9QVVApIHtcbiAgICAgICAgICAgIHBvcHVwQW5ub3RhdGlvbnMucHVzaChfZGF0YSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzb3J0ZWRBbm5vdGF0aW9ucy5wdXNoKF9kYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNi5mKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3B1cEFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICBzb3J0ZWRBbm5vdGF0aW9ucy5wdXNoLmFwcGx5KHNvcnRlZEFubm90YXRpb25zLCBwb3B1cEFubm90YXRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfc29ydGVkQW5ub3RhdGlvbnMgPSBzb3J0ZWRBbm5vdGF0aW9uczsgX2kgPCBfc29ydGVkQW5ub3RhdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3NvcnRlZEFubm90YXRpb25zW19pXTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKHtcbiAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgIGxheWVyOiBwYXJhbWV0ZXJzLmRpdixcbiAgICAgICAgICBwYWdlOiBwYXJhbWV0ZXJzLnBhZ2UsXG4gICAgICAgICAgdmlld3BvcnQ6IHBhcmFtZXRlcnMudmlld3BvcnQsXG4gICAgICAgICAgbGlua1NlcnZpY2U6IHBhcmFtZXRlcnMubGlua1NlcnZpY2UsXG4gICAgICAgICAgZG93bmxvYWRNYW5hZ2VyOiBwYXJhbWV0ZXJzLmRvd25sb2FkTWFuYWdlcixcbiAgICAgICAgICBpbWFnZVJlc291cmNlc1BhdGg6IHBhcmFtZXRlcnMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCIsXG4gICAgICAgICAgcmVuZGVySW50ZXJhY3RpdmVGb3JtczogdHlwZW9mIHBhcmFtZXRlcnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyA9PT0gXCJib29sZWFuXCIgPyBwYXJhbWV0ZXJzLnJlbmRlckludGVyYWN0aXZlRm9ybXMgOiB0cnVlLFxuICAgICAgICAgIHN2Z0ZhY3Rvcnk6IG5ldyBfZGlzcGxheV91dGlscy5ET01TVkdGYWN0b3J5KCksXG4gICAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2UgfHwgbmV3IF9hbm5vdGF0aW9uX3N0b3JhZ2UuQW5ub3RhdGlvblN0b3JhZ2UoKVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZWxlbWVudC5pc1JlbmRlcmFibGUpIHtcbiAgICAgICAgICBwYXJhbWV0ZXJzLmRpdi5hcHBlbmRDaGlsZChlbGVtZW50LnJlbmRlcigpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHBhcmFtZXRlcnMpIHtcbiAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIocGFyYW1ldGVycy5hbm5vdGF0aW9ucyksXG4gICAgICAgICAgX3N0ZXA3O1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBkYXRhID0gX3N0ZXA3LnZhbHVlO1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gcGFyYW1ldGVycy5kaXYucXVlcnlTZWxlY3RvcihcIltkYXRhLWFubm90YXRpb24taWQ9XFxcIlwiLmNvbmNhdChkYXRhLmlkLCBcIlxcXCJdXCIpKTtcblxuICAgICAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IFwibWF0cml4KFwiLmNvbmNhdChwYXJhbWV0ZXJzLnZpZXdwb3J0LnRyYW5zZm9ybS5qb2luKFwiLFwiKSwgXCIpXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICB9XG5cbiAgICAgIHBhcmFtZXRlcnMuZGl2LnJlbW92ZUF0dHJpYnV0ZShcImhpZGRlblwiKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQW5ub3RhdGlvbkxheWVyO1xufSgpO1xuXG5leHBvcnRzLkFubm90YXRpb25MYXllciA9IEFubm90YXRpb25MYXllcjtcblxuLyoqKi8gfSksXG4vKiAyMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMucmVuZGVyVGV4dExheWVyID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG52YXIgcmVuZGVyVGV4dExheWVyID0gZnVuY3Rpb24gcmVuZGVyVGV4dExheWVyQ2xvc3VyZSgpIHtcbiAgdmFyIE1BWF9URVhUX0RJVlNfVE9fUkVOREVSID0gMTAwMDAwO1xuICB2YXIgTm9uV2hpdGVzcGFjZVJlZ2V4cCA9IC9cXFMvO1xuXG4gIGZ1bmN0aW9uIGlzQWxsV2hpdGVzcGFjZShzdHIpIHtcbiAgICByZXR1cm4gIU5vbldoaXRlc3BhY2VSZWdleHAudGVzdChzdHIpO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kVGV4dCh0YXNrLCBnZW9tLCBzdHlsZXMpIHtcbiAgICB2YXIgdGV4dERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIHZhciB0ZXh0RGl2UHJvcGVydGllcyA9IHtcbiAgICAgIGFuZ2xlOiAwLFxuICAgICAgY2FudmFzV2lkdGg6IDAsXG4gICAgICBpc1doaXRlc3BhY2U6IGZhbHNlLFxuICAgICAgb3JpZ2luYWxUcmFuc2Zvcm06IG51bGwsXG4gICAgICBwYWRkaW5nQm90dG9tOiAwLFxuICAgICAgcGFkZGluZ0xlZnQ6IDAsXG4gICAgICBwYWRkaW5nUmlnaHQ6IDAsXG4gICAgICBwYWRkaW5nVG9wOiAwLFxuICAgICAgc2NhbGU6IDFcbiAgICB9O1xuXG4gICAgdGFzay5fdGV4dERpdnMucHVzaCh0ZXh0RGl2KTtcblxuICAgIGlmIChpc0FsbFdoaXRlc3BhY2UoZ2VvbS5zdHIpKSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5pc1doaXRlc3BhY2UgPSB0cnVlO1xuXG4gICAgICB0YXNrLl90ZXh0RGl2UHJvcGVydGllcy5zZXQodGV4dERpdiwgdGV4dERpdlByb3BlcnRpZXMpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHR4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGFzay5fdmlld3BvcnQudHJhbnNmb3JtLCBnZW9tLnRyYW5zZm9ybSk7XG5cbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHR4WzFdLCB0eFswXSk7XG4gICAgdmFyIHN0eWxlID0gc3R5bGVzW2dlb20uZm9udE5hbWVdO1xuXG4gICAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgICBhbmdsZSArPSBNYXRoLlBJIC8gMjtcbiAgICB9XG5cbiAgICB2YXIgZm9udEhlaWdodCA9IE1hdGguc3FydCh0eFsyXSAqIHR4WzJdICsgdHhbM10gKiB0eFszXSk7XG4gICAgdmFyIGZvbnRBc2NlbnQgPSBmb250SGVpZ2h0O1xuXG4gICAgaWYgKHN0eWxlLmFzY2VudCkge1xuICAgICAgZm9udEFzY2VudCA9IHN0eWxlLmFzY2VudCAqIGZvbnRBc2NlbnQ7XG4gICAgfSBlbHNlIGlmIChzdHlsZS5kZXNjZW50KSB7XG4gICAgICBmb250QXNjZW50ID0gKDEgKyBzdHlsZS5kZXNjZW50KSAqIGZvbnRBc2NlbnQ7XG4gICAgfVxuXG4gICAgdmFyIGxlZnQsIHRvcDtcblxuICAgIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgbGVmdCA9IHR4WzRdO1xuICAgICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gdHhbNF0gKyBmb250QXNjZW50ICogTWF0aC5zaW4oYW5nbGUpO1xuICAgICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50ICogTWF0aC5jb3MoYW5nbGUpO1xuICAgIH1cblxuICAgIHRleHREaXYuc3R5bGUubGVmdCA9IFwiXCIuY29uY2F0KGxlZnQsIFwicHhcIik7XG4gICAgdGV4dERpdi5zdHlsZS50b3AgPSBcIlwiLmNvbmNhdCh0b3AsIFwicHhcIik7XG4gICAgdGV4dERpdi5zdHlsZS5mb250U2l6ZSA9IFwiXCIuY29uY2F0KGZvbnRIZWlnaHQsIFwicHhcIik7XG4gICAgdGV4dERpdi5zdHlsZS5mb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgICB0ZXh0RGl2LnRleHRDb250ZW50ID0gZ2VvbS5zdHI7XG5cbiAgICBpZiAodGFzay5fZm9udEluc3BlY3RvckVuYWJsZWQpIHtcbiAgICAgIHRleHREaXYuZGF0YXNldC5mb250TmFtZSA9IGdlb20uZm9udE5hbWU7XG4gICAgfVxuXG4gICAgaWYgKGFuZ2xlICE9PSAwKSB7XG4gICAgICB0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRTY2FsZVRleHQgPSBmYWxzZTtcblxuICAgIGlmIChnZW9tLnN0ci5sZW5ndGggPiAxKSB7XG4gICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZ2VvbS50cmFuc2Zvcm1bMF0gIT09IGdlb20udHJhbnNmb3JtWzNdKSB7XG4gICAgICB2YXIgYWJzU2NhbGVYID0gTWF0aC5hYnMoZ2VvbS50cmFuc2Zvcm1bMF0pLFxuICAgICAgICAgIGFic1NjYWxlWSA9IE1hdGguYWJzKGdlb20udHJhbnNmb3JtWzNdKTtcblxuICAgICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRTY2FsZVRleHQpIHtcbiAgICAgIGlmIChzdHlsZS52ZXJ0aWNhbCkge1xuICAgICAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IGdlb20uaGVpZ2h0ICogdGFzay5fdmlld3BvcnQuc2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCA9IGdlb20ud2lkdGggKiB0YXNrLl92aWV3cG9ydC5zY2FsZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0YXNrLl90ZXh0RGl2UHJvcGVydGllcy5zZXQodGV4dERpdiwgdGV4dERpdlByb3BlcnRpZXMpO1xuXG4gICAgaWYgKHRhc2suX3RleHRDb250ZW50U3RyZWFtKSB7XG4gICAgICB0YXNrLl9sYXlvdXRUZXh0KHRleHREaXYpO1xuICAgIH1cblxuICAgIGlmICh0YXNrLl9lbmhhbmNlVGV4dFNlbGVjdGlvbikge1xuICAgICAgdmFyIGFuZ2xlQ29zID0gMSxcbiAgICAgICAgICBhbmdsZVNpbiA9IDA7XG5cbiAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgICBhbmdsZUNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgYW5nbGVTaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXZXaWR0aCA9IChzdHlsZS52ZXJ0aWNhbCA/IGdlb20uaGVpZ2h0IDogZ2VvbS53aWR0aCkgKiB0YXNrLl92aWV3cG9ydC5zY2FsZTtcbiAgICAgIHZhciBkaXZIZWlnaHQgPSBmb250SGVpZ2h0O1xuICAgICAgdmFyIG0sIGI7XG5cbiAgICAgIGlmIChhbmdsZSAhPT0gMCkge1xuICAgICAgICBtID0gW2FuZ2xlQ29zLCBhbmdsZVNpbiwgLWFuZ2xlU2luLCBhbmdsZUNvcywgbGVmdCwgdG9wXTtcbiAgICAgICAgYiA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIGRpdldpZHRoLCBkaXZIZWlnaHRdLCBtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIgPSBbbGVmdCwgdG9wLCBsZWZ0ICsgZGl2V2lkdGgsIHRvcCArIGRpdkhlaWdodF07XG4gICAgICB9XG5cbiAgICAgIHRhc2suX2JvdW5kcy5wdXNoKHtcbiAgICAgICAgbGVmdDogYlswXSxcbiAgICAgICAgdG9wOiBiWzFdLFxuICAgICAgICByaWdodDogYlsyXSxcbiAgICAgICAgYm90dG9tOiBiWzNdLFxuICAgICAgICBkaXY6IHRleHREaXYsXG4gICAgICAgIHNpemU6IFtkaXZXaWR0aCwgZGl2SGVpZ2h0XSxcbiAgICAgICAgbTogbVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyKHRhc2spIHtcbiAgICBpZiAodGFzay5fY2FuY2VsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dERpdnMgPSB0YXNrLl90ZXh0RGl2cztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IHRhc2suX2NhcGFiaWxpdHk7XG4gICAgdmFyIHRleHREaXZzTGVuZ3RoID0gdGV4dERpdnMubGVuZ3RoO1xuXG4gICAgaWYgKHRleHREaXZzTGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICAgIHRhc2suX3JlbmRlcmluZ0RvbmUgPSB0cnVlO1xuICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0YXNrLl90ZXh0Q29udGVudFN0cmVhbSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZXh0RGl2c0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRhc2suX2xheW91dFRleHQodGV4dERpdnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRhc2suX3JlbmRlcmluZ0RvbmUgPSB0cnVlO1xuICAgIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZFBvc2l0aXZlTWluKHRzLCBvZmZzZXQsIGNvdW50KSB7XG4gICAgdmFyIHJlc3VsdCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgIHZhciB0ID0gdHNbb2Zmc2V0KytdO1xuXG4gICAgICBpZiAodCA+IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gTWF0aC5taW4odCwgcmVzdWx0KSA6IHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4cGFuZCh0YXNrKSB7XG4gICAgdmFyIGJvdW5kcyA9IHRhc2suX2JvdW5kcztcbiAgICB2YXIgdmlld3BvcnQgPSB0YXNrLl92aWV3cG9ydDtcbiAgICB2YXIgZXhwYW5kZWQgPSBleHBhbmRCb3VuZHModmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCwgYm91bmRzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwYW5kZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkaXYgPSBib3VuZHNbaV0uZGl2O1xuXG4gICAgICB2YXIgZGl2UHJvcGVydGllcyA9IHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLmdldChkaXYpO1xuXG4gICAgICBpZiAoZGl2UHJvcGVydGllcy5hbmdsZSA9PT0gMCkge1xuICAgICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdMZWZ0ID0gYm91bmRzW2ldLmxlZnQgLSBleHBhbmRlZFtpXS5sZWZ0O1xuICAgICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdUb3AgPSBib3VuZHNbaV0udG9wIC0gZXhwYW5kZWRbaV0udG9wO1xuICAgICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdSaWdodCA9IGV4cGFuZGVkW2ldLnJpZ2h0IC0gYm91bmRzW2ldLnJpZ2h0O1xuICAgICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdCb3R0b20gPSBleHBhbmRlZFtpXS5ib3R0b20gLSBib3VuZHNbaV0uYm90dG9tO1xuXG4gICAgICAgIHRhc2suX3RleHREaXZQcm9wZXJ0aWVzLnNldChkaXYsIGRpdlByb3BlcnRpZXMpO1xuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZSA9IGV4cGFuZGVkW2ldLFxuICAgICAgICAgIGIgPSBib3VuZHNbaV07XG4gICAgICB2YXIgbSA9IGIubSxcbiAgICAgICAgICBjID0gbVswXSxcbiAgICAgICAgICBzID0gbVsxXTtcbiAgICAgIHZhciBwb2ludHMgPSBbWzAsIDBdLCBbMCwgYi5zaXplWzFdXSwgW2Iuc2l6ZVswXSwgMF0sIGIuc2l6ZV07XG4gICAgICB2YXIgdHMgPSBuZXcgRmxvYXQ2NEFycmF5KDY0KTtcbiAgICAgIHBvaW50cy5mb3JFYWNoKGZ1bmN0aW9uIChwLCBqKSB7XG4gICAgICAgIHZhciB0ID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShwLCBtKTtcblxuICAgICAgICB0c1tqICsgMF0gPSBjICYmIChlLmxlZnQgLSB0WzBdKSAvIGM7XG4gICAgICAgIHRzW2ogKyA0XSA9IHMgJiYgKGUudG9wIC0gdFsxXSkgLyBzO1xuICAgICAgICB0c1tqICsgOF0gPSBjICYmIChlLnJpZ2h0IC0gdFswXSkgLyBjO1xuICAgICAgICB0c1tqICsgMTJdID0gcyAmJiAoZS5ib3R0b20gLSB0WzFdKSAvIHM7XG4gICAgICAgIHRzW2ogKyAxNl0gPSBzICYmIChlLmxlZnQgLSB0WzBdKSAvIC1zO1xuICAgICAgICB0c1tqICsgMjBdID0gYyAmJiAoZS50b3AgLSB0WzFdKSAvIGM7XG4gICAgICAgIHRzW2ogKyAyNF0gPSBzICYmIChlLnJpZ2h0IC0gdFswXSkgLyAtcztcbiAgICAgICAgdHNbaiArIDI4XSA9IGMgJiYgKGUuYm90dG9tIC0gdFsxXSkgLyBjO1xuICAgICAgICB0c1tqICsgMzJdID0gYyAmJiAoZS5sZWZ0IC0gdFswXSkgLyAtYztcbiAgICAgICAgdHNbaiArIDM2XSA9IHMgJiYgKGUudG9wIC0gdFsxXSkgLyAtcztcbiAgICAgICAgdHNbaiArIDQwXSA9IGMgJiYgKGUucmlnaHQgLSB0WzBdKSAvIC1jO1xuICAgICAgICB0c1tqICsgNDRdID0gcyAmJiAoZS5ib3R0b20gLSB0WzFdKSAvIC1zO1xuICAgICAgICB0c1tqICsgNDhdID0gcyAmJiAoZS5sZWZ0IC0gdFswXSkgLyBzO1xuICAgICAgICB0c1tqICsgNTJdID0gYyAmJiAoZS50b3AgLSB0WzFdKSAvIC1jO1xuICAgICAgICB0c1tqICsgNTZdID0gcyAmJiAoZS5yaWdodCAtIHRbMF0pIC8gcztcbiAgICAgICAgdHNbaiArIDYwXSA9IGMgJiYgKGUuYm90dG9tIC0gdFsxXSkgLyAtYztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJveFNjYWxlID0gMSArIE1hdGgubWluKE1hdGguYWJzKGMpLCBNYXRoLmFicyhzKSk7XG4gICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdMZWZ0ID0gZmluZFBvc2l0aXZlTWluKHRzLCAzMiwgMTYpIC8gYm94U2NhbGU7XG4gICAgICBkaXZQcm9wZXJ0aWVzLnBhZGRpbmdUb3AgPSBmaW5kUG9zaXRpdmVNaW4odHMsIDQ4LCAxNikgLyBib3hTY2FsZTtcbiAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ1JpZ2h0ID0gZmluZFBvc2l0aXZlTWluKHRzLCAwLCAxNikgLyBib3hTY2FsZTtcbiAgICAgIGRpdlByb3BlcnRpZXMucGFkZGluZ0JvdHRvbSA9IGZpbmRQb3NpdGl2ZU1pbih0cywgMTYsIDE2KSAvIGJveFNjYWxlO1xuXG4gICAgICB0YXNrLl90ZXh0RGl2UHJvcGVydGllcy5zZXQoZGl2LCBkaXZQcm9wZXJ0aWVzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmRCb3VuZHMod2lkdGgsIGhlaWdodCwgYm94ZXMpIHtcbiAgICB2YXIgYm91bmRzID0gYm94ZXMubWFwKGZ1bmN0aW9uIChib3gsIGkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBib3gubGVmdCxcbiAgICAgICAgeTE6IGJveC50b3AsXG4gICAgICAgIHgyOiBib3gucmlnaHQsXG4gICAgICAgIHkyOiBib3guYm90dG9tLFxuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgeDFOZXc6IHVuZGVmaW5lZCxcbiAgICAgICAgeDJOZXc6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9KTtcbiAgICBleHBhbmRCb3VuZHNMVFIod2lkdGgsIGJvdW5kcyk7XG4gICAgdmFyIGV4cGFuZGVkID0gbmV3IEFycmF5KGJveGVzLmxlbmd0aCk7XG4gICAgYm91bmRzLmZvckVhY2goZnVuY3Rpb24gKGIpIHtcbiAgICAgIHZhciBpID0gYi5pbmRleDtcbiAgICAgIGV4cGFuZGVkW2ldID0ge1xuICAgICAgICBsZWZ0OiBiLngxTmV3LFxuICAgICAgICB0b3A6IDAsXG4gICAgICAgIHJpZ2h0OiBiLngyTmV3LFxuICAgICAgICBib3R0b206IDBcbiAgICAgIH07XG4gICAgfSk7XG4gICAgYm94ZXMubWFwKGZ1bmN0aW9uIChib3gsIGkpIHtcbiAgICAgIHZhciBlID0gZXhwYW5kZWRbaV0sXG4gICAgICAgICAgYiA9IGJvdW5kc1tpXTtcbiAgICAgIGIueDEgPSBib3gudG9wO1xuICAgICAgYi55MSA9IHdpZHRoIC0gZS5yaWdodDtcbiAgICAgIGIueDIgPSBib3guYm90dG9tO1xuICAgICAgYi55MiA9IHdpZHRoIC0gZS5sZWZ0O1xuICAgICAgYi5pbmRleCA9IGk7XG4gICAgICBiLngxTmV3ID0gdW5kZWZpbmVkO1xuICAgICAgYi54Mk5ldyA9IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBleHBhbmRCb3VuZHNMVFIoaGVpZ2h0LCBib3VuZHMpO1xuICAgIGJvdW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChiKSB7XG4gICAgICB2YXIgaSA9IGIuaW5kZXg7XG4gICAgICBleHBhbmRlZFtpXS50b3AgPSBiLngxTmV3O1xuICAgICAgZXhwYW5kZWRbaV0uYm90dG9tID0gYi54Mk5ldztcbiAgICB9KTtcbiAgICByZXR1cm4gZXhwYW5kZWQ7XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmRCb3VuZHNMVFIod2lkdGgsIGJvdW5kcykge1xuICAgIGJvdW5kcy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS54MSAtIGIueDEgfHwgYS5pbmRleCAtIGIuaW5kZXg7XG4gICAgfSk7XG4gICAgdmFyIGZha2VCb3VuZGFyeSA9IHtcbiAgICAgIHgxOiAtSW5maW5pdHksXG4gICAgICB5MTogLUluZmluaXR5LFxuICAgICAgeDI6IDAsXG4gICAgICB5MjogSW5maW5pdHksXG4gICAgICBpbmRleDogLTEsXG4gICAgICB4MU5ldzogMCxcbiAgICAgIHgyTmV3OiAwXG4gICAgfTtcbiAgICB2YXIgaG9yaXpvbiA9IFt7XG4gICAgICBzdGFydDogLUluZmluaXR5LFxuICAgICAgZW5kOiBJbmZpbml0eSxcbiAgICAgIGJvdW5kYXJ5OiBmYWtlQm91bmRhcnlcbiAgICB9XTtcbiAgICBib3VuZHMuZm9yRWFjaChmdW5jdGlvbiAoYm91bmRhcnkpIHtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKGkgPCBob3Jpem9uLmxlbmd0aCAmJiBob3Jpem9uW2ldLmVuZCA8PSBib3VuZGFyeS55MSkge1xuICAgICAgICBpKys7XG4gICAgICB9XG5cbiAgICAgIHZhciBqID0gaG9yaXpvbi5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAoaiA+PSAwICYmIGhvcml6b25bal0uc3RhcnQgPj0gYm91bmRhcnkueTIpIHtcbiAgICAgICAgai0tO1xuICAgICAgfVxuXG4gICAgICB2YXIgaG9yaXpvblBhcnQsIGFmZmVjdGVkQm91bmRhcnk7XG4gICAgICB2YXIgcSxcbiAgICAgICAgICBrLFxuICAgICAgICAgIG1heFhOZXcgPSAtSW5maW5pdHk7XG5cbiAgICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICAgIGhvcml6b25QYXJ0ID0gaG9yaXpvbltxXTtcbiAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeSA9IGhvcml6b25QYXJ0LmJvdW5kYXJ5O1xuICAgICAgICB2YXIgeE5ldztcblxuICAgICAgICBpZiAoYWZmZWN0ZWRCb3VuZGFyeS54MiA+IGJvdW5kYXJ5LngxKSB7XG4gICAgICAgICAgeE5ldyA9IGFmZmVjdGVkQm91bmRhcnkuaW5kZXggPiBib3VuZGFyeS5pbmRleCA/IGFmZmVjdGVkQm91bmRhcnkueDFOZXcgOiBib3VuZGFyeS54MTtcbiAgICAgICAgfSBlbHNlIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB4TmV3ID0gKGFmZmVjdGVkQm91bmRhcnkueDIgKyBib3VuZGFyeS54MSkgLyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhOZXcgPSBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHhOZXcgPiBtYXhYTmV3KSB7XG4gICAgICAgICAgbWF4WE5ldyA9IHhOZXc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYm91bmRhcnkueDFOZXcgPSBtYXhYTmV3O1xuXG4gICAgICBmb3IgKHEgPSBpOyBxIDw9IGo7IHErKykge1xuICAgICAgICBob3Jpem9uUGFydCA9IGhvcml6b25bcV07XG4gICAgICAgIGFmZmVjdGVkQm91bmRhcnkgPSBob3Jpem9uUGFydC5ib3VuZGFyeTtcblxuICAgICAgICBpZiAoYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKGFmZmVjdGVkQm91bmRhcnkueDIgPiBib3VuZGFyeS54MSkge1xuICAgICAgICAgICAgaWYgKGFmZmVjdGVkQm91bmRhcnkuaW5kZXggPiBib3VuZGFyeS5pbmRleCkge1xuICAgICAgICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gYWZmZWN0ZWRCb3VuZGFyeS54MjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA9IG1heFhOZXc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGFmZmVjdGVkQm91bmRhcnkueDJOZXcgPiBtYXhYTmV3KSB7XG4gICAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA9IE1hdGgubWF4KG1heFhOZXcsIGFmZmVjdGVkQm91bmRhcnkueDIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2VkSG9yaXpvbiA9IFtdLFxuICAgICAgICAgIGxhc3RCb3VuZGFyeSA9IG51bGw7XG5cbiAgICAgIGZvciAocSA9IGk7IHEgPD0gajsgcSsrKSB7XG4gICAgICAgIGhvcml6b25QYXJ0ID0gaG9yaXpvbltxXTtcbiAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeSA9IGhvcml6b25QYXJ0LmJvdW5kYXJ5O1xuICAgICAgICB2YXIgdXNlQm91bmRhcnkgPSBhZmZlY3RlZEJvdW5kYXJ5LngyID4gYm91bmRhcnkueDIgPyBhZmZlY3RlZEJvdW5kYXJ5IDogYm91bmRhcnk7XG5cbiAgICAgICAgaWYgKGxhc3RCb3VuZGFyeSA9PT0gdXNlQm91bmRhcnkpIHtcbiAgICAgICAgICBjaGFuZ2VkSG9yaXpvbltjaGFuZ2VkSG9yaXpvbi5sZW5ndGggLSAxXS5lbmQgPSBob3Jpem9uUGFydC5lbmQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2hhbmdlZEhvcml6b24ucHVzaCh7XG4gICAgICAgICAgICBzdGFydDogaG9yaXpvblBhcnQuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGhvcml6b25QYXJ0LmVuZCxcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB1c2VCb3VuZGFyeVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RCb3VuZGFyeSA9IHVzZUJvdW5kYXJ5O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChob3Jpem9uW2ldLnN0YXJ0IDwgYm91bmRhcnkueTEpIHtcbiAgICAgICAgY2hhbmdlZEhvcml6b25bMF0uc3RhcnQgPSBib3VuZGFyeS55MTtcbiAgICAgICAgY2hhbmdlZEhvcml6b24udW5zaGlmdCh7XG4gICAgICAgICAgc3RhcnQ6IGhvcml6b25baV0uc3RhcnQsXG4gICAgICAgICAgZW5kOiBib3VuZGFyeS55MSxcbiAgICAgICAgICBib3VuZGFyeTogaG9yaXpvbltpXS5ib3VuZGFyeVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJvdW5kYXJ5LnkyIDwgaG9yaXpvbltqXS5lbmQpIHtcbiAgICAgICAgY2hhbmdlZEhvcml6b25bY2hhbmdlZEhvcml6b24ubGVuZ3RoIC0gMV0uZW5kID0gYm91bmRhcnkueTI7XG4gICAgICAgIGNoYW5nZWRIb3Jpem9uLnB1c2goe1xuICAgICAgICAgIHN0YXJ0OiBib3VuZGFyeS55MixcbiAgICAgICAgICBlbmQ6IGhvcml6b25bal0uZW5kLFxuICAgICAgICAgIGJvdW5kYXJ5OiBob3Jpem9uW2pdLmJvdW5kYXJ5XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHEgPSBpOyBxIDw9IGo7IHErKykge1xuICAgICAgICBob3Jpem9uUGFydCA9IGhvcml6b25bcV07XG4gICAgICAgIGFmZmVjdGVkQm91bmRhcnkgPSBob3Jpem9uUGFydC5ib3VuZGFyeTtcblxuICAgICAgICBpZiAoYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdXNlZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAoayA9IGkgLSAxOyAhdXNlZCAmJiBrID49IDAgJiYgaG9yaXpvbltrXS5zdGFydCA+PSBhZmZlY3RlZEJvdW5kYXJ5LnkxOyBrLS0pIHtcbiAgICAgICAgICB1c2VkID0gaG9yaXpvbltrXS5ib3VuZGFyeSA9PT0gYWZmZWN0ZWRCb3VuZGFyeTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoayA9IGogKyAxOyAhdXNlZCAmJiBrIDwgaG9yaXpvbi5sZW5ndGggJiYgaG9yaXpvbltrXS5lbmQgPD0gYWZmZWN0ZWRCb3VuZGFyeS55MjsgaysrKSB7XG4gICAgICAgICAgdXNlZCA9IGhvcml6b25ba10uYm91bmRhcnkgPT09IGFmZmVjdGVkQm91bmRhcnk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGsgPSAwOyAhdXNlZCAmJiBrIDwgY2hhbmdlZEhvcml6b24ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICB1c2VkID0gY2hhbmdlZEhvcml6b25ba10uYm91bmRhcnkgPT09IGFmZmVjdGVkQm91bmRhcnk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVzZWQpIHtcbiAgICAgICAgICBhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID0gbWF4WE5ldztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmFwcGx5KGhvcml6b24sIFtpLCBqIC0gaSArIDFdLmNvbmNhdChjaGFuZ2VkSG9yaXpvbikpO1xuICAgIH0pO1xuICAgIGhvcml6b24uZm9yRWFjaChmdW5jdGlvbiAoaG9yaXpvblBhcnQpIHtcbiAgICAgIHZhciBhZmZlY3RlZEJvdW5kYXJ5ID0gaG9yaXpvblBhcnQuYm91bmRhcnk7XG5cbiAgICAgIGlmIChhZmZlY3RlZEJvdW5kYXJ5LngyTmV3ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYWZmZWN0ZWRCb3VuZGFyeS54Mk5ldyA9IE1hdGgubWF4KHdpZHRoLCBhZmZlY3RlZEJvdW5kYXJ5LngyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRleHRMYXllclJlbmRlclRhc2soX3JlZikge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB2YXIgdGV4dENvbnRlbnQgPSBfcmVmLnRleHRDb250ZW50LFxuICAgICAgICB0ZXh0Q29udGVudFN0cmVhbSA9IF9yZWYudGV4dENvbnRlbnRTdHJlYW0sXG4gICAgICAgIGNvbnRhaW5lciA9IF9yZWYuY29udGFpbmVyLFxuICAgICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICAgIHRleHREaXZzID0gX3JlZi50ZXh0RGl2cyxcbiAgICAgICAgdGV4dENvbnRlbnRJdGVtc1N0ciA9IF9yZWYudGV4dENvbnRlbnRJdGVtc1N0cixcbiAgICAgICAgZW5oYW5jZVRleHRTZWxlY3Rpb24gPSBfcmVmLmVuaGFuY2VUZXh0U2VsZWN0aW9uO1xuICAgIHRoaXMuX3RleHRDb250ZW50ID0gdGV4dENvbnRlbnQ7XG4gICAgdGhpcy5fdGV4dENvbnRlbnRTdHJlYW0gPSB0ZXh0Q29udGVudFN0cmVhbTtcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBjb250YWluZXIub3duZXJEb2N1bWVudDtcbiAgICB0aGlzLl92aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuX3RleHREaXZzID0gdGV4dERpdnMgfHwgW107XG4gICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRleHRDb250ZW50SXRlbXNTdHIgfHwgW107XG4gICAgdGhpcy5fZW5oYW5jZVRleHRTZWxlY3Rpb24gPSAhIWVuaGFuY2VUZXh0U2VsZWN0aW9uO1xuICAgIHRoaXMuX2ZvbnRJbnNwZWN0b3JFbmFibGVkID0gISEoZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yICYmIGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvci5lbmFibGVkKTtcbiAgICB0aGlzLl9yZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX2xheW91dFRleHRMYXN0Rm9udFNpemUgPSBudWxsO1xuICAgIHRoaXMuX2xheW91dFRleHRMYXN0Rm9udEZhbWlseSA9IG51bGw7XG4gICAgdGhpcy5fbGF5b3V0VGV4dEN0eCA9IG51bGw7XG4gICAgdGhpcy5fdGV4dERpdlByb3BlcnRpZXMgPSBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX3JlbmRlcmluZ0RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9jYW5jZWxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5fcmVuZGVyVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2JvdW5kcyA9IFtdO1xuXG4gICAgdGhpcy5fY2FwYWJpbGl0eS5wcm9taXNlW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoX3RoaXMuX2xheW91dFRleHRDdHgpIHtcbiAgICAgICAgX3RoaXMuX2xheW91dFRleHRDdHguY2FudmFzLndpZHRoID0gMDtcbiAgICAgICAgX3RoaXMuX2xheW91dFRleHRDdHguY2FudmFzLmhlaWdodCA9IDA7XG4gICAgICAgIF90aGlzLl9sYXlvdXRUZXh0Q3R4ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuXG4gIFRleHRMYXllclJlbmRlclRhc2sucHJvdG90eXBlID0ge1xuICAgIGdldCBwcm9taXNlKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9LFxuXG4gICAgY2FuY2VsOiBmdW5jdGlvbiBUZXh0TGF5ZXJfY2FuY2VsKCkge1xuICAgICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fcmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSk7XG5cbiAgICAgICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3JlbmRlclRpbWVyICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZW5kZXJUaW1lcik7XG4gICAgICAgIHRoaXMuX3JlbmRlclRpbWVyID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fY2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSk7XG4gICAgfSxcbiAgICBfcHJvY2Vzc0l0ZW1zOiBmdW5jdGlvbiBfcHJvY2Vzc0l0ZW1zKGl0ZW1zLCBzdHlsZUNhY2hlKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaXRlbXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW1zW2ldLnN0cik7XG5cbiAgICAgICAgYXBwZW5kVGV4dCh0aGlzLCBpdGVtc1tpXSwgc3R5bGVDYWNoZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfbGF5b3V0VGV4dDogZnVuY3Rpb24gX2xheW91dFRleHQodGV4dERpdikge1xuICAgICAgdmFyIHRleHREaXZQcm9wZXJ0aWVzID0gdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KHRleHREaXYpO1xuXG4gICAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaXNXaGl0ZXNwYWNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybSA9IFwiXCI7XG5cbiAgICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5jYW52YXNXaWR0aCAhPT0gMCkge1xuICAgICAgICB2YXIgX3RleHREaXYkc3R5bGUgPSB0ZXh0RGl2LnN0eWxlLFxuICAgICAgICAgICAgZm9udFNpemUgPSBfdGV4dERpdiRzdHlsZS5mb250U2l6ZSxcbiAgICAgICAgICAgIGZvbnRGYW1pbHkgPSBfdGV4dERpdiRzdHlsZS5mb250RmFtaWx5O1xuXG4gICAgICAgIGlmIChmb250U2l6ZSAhPT0gdGhpcy5fbGF5b3V0VGV4dExhc3RGb250U2l6ZSB8fCBmb250RmFtaWx5ICE9PSB0aGlzLl9sYXlvdXRUZXh0TGFzdEZvbnRGYW1pbHkpIHtcbiAgICAgICAgICB0aGlzLl9sYXlvdXRUZXh0Q3R4LmZvbnQgPSBcIlwiLmNvbmNhdChmb250U2l6ZSwgXCIgXCIpLmNvbmNhdChmb250RmFtaWx5KTtcbiAgICAgICAgICB0aGlzLl9sYXlvdXRUZXh0TGFzdEZvbnRTaXplID0gZm9udFNpemU7XG4gICAgICAgICAgdGhpcy5fbGF5b3V0VGV4dExhc3RGb250RmFtaWx5ID0gZm9udEZhbWlseTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfdGhpcyRfbGF5b3V0VGV4dEN0eCQgPSB0aGlzLl9sYXlvdXRUZXh0Q3R4Lm1lYXN1cmVUZXh0KHRleHREaXYudGV4dENvbnRlbnQpLFxuICAgICAgICAgICAgd2lkdGggPSBfdGhpcyRfbGF5b3V0VGV4dEN0eCQud2lkdGg7XG5cbiAgICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICAgIHRleHREaXZQcm9wZXJ0aWVzLnNjYWxlID0gdGV4dERpdlByb3BlcnRpZXMuY2FudmFzV2lkdGggLyB3aWR0aDtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBcInNjYWxlWChcIi5jb25jYXQodGV4dERpdlByb3BlcnRpZXMuc2NhbGUsIFwiKVwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuYW5nbGUgIT09IDApIHtcbiAgICAgICAgdHJhbnNmb3JtID0gXCJyb3RhdGUoXCIuY29uY2F0KHRleHREaXZQcm9wZXJ0aWVzLmFuZ2xlLCBcImRlZykgXCIpLmNvbmNhdCh0cmFuc2Zvcm0pO1xuICAgICAgfVxuXG4gICAgICBpZiAodHJhbnNmb3JtLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMuX2VuaGFuY2VUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgdGV4dERpdlByb3BlcnRpZXMub3JpZ2luYWxUcmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0RGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcblxuICAgICAgdGhpcy5fY29udGFpbmVyLmFwcGVuZENoaWxkKHRleHREaXYpO1xuICAgIH0sXG4gICAgX3JlbmRlcjogZnVuY3Rpb24gVGV4dExheWVyX3JlbmRlcih0aW1lb3V0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICB2YXIgc3R5bGVDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG4gICAgICBjYW52YXMubW96T3BhcXVlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2xheW91dFRleHRDdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgICAgYWxwaGE6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuX3RleHRDb250ZW50KSB7XG4gICAgICAgIHZhciB0ZXh0SXRlbXMgPSB0aGlzLl90ZXh0Q29udGVudC5pdGVtcztcbiAgICAgICAgdmFyIHRleHRTdHlsZXMgPSB0aGlzLl90ZXh0Q29udGVudC5zdHlsZXM7XG5cbiAgICAgICAgdGhpcy5fcHJvY2Vzc0l0ZW1zKHRleHRJdGVtcywgdGV4dFN0eWxlcyk7XG5cbiAgICAgICAgY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3RleHRDb250ZW50U3RyZWFtKSB7XG4gICAgICAgIHZhciBwdW1wID0gZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgICBfdGhpczIuX3JlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IF9yZWYyLnZhbHVlLFxuICAgICAgICAgICAgICAgIGRvbmUgPSBfcmVmMi5kb25lO1xuXG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlQ2FjaGUsIHZhbHVlLnN0eWxlcyk7XG5cbiAgICAgICAgICAgIF90aGlzMi5fcHJvY2Vzc0l0ZW1zKHZhbHVlLml0ZW1zLCBzdHlsZUNhY2hlKTtcblxuICAgICAgICAgICAgcHVtcCgpO1xuICAgICAgICAgIH0sIGNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9yZWFkZXIgPSB0aGlzLl90ZXh0Q29udGVudFN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOZWl0aGVyIFwidGV4dENvbnRlbnRcIiBub3IgXCJ0ZXh0Q29udGVudFN0cmVhbVwiJyArIFwiIHBhcmFtZXRlcnMgc3BlY2lmaWVkLlwiKTtcbiAgICAgIH1cblxuICAgICAgY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZUNhY2hlID0gbnVsbDtcblxuICAgICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgICByZW5kZXIoX3RoaXMyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpczIuX3JlbmRlclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZW5kZXIoX3RoaXMyKTtcbiAgICAgICAgICAgIF90aGlzMi5fcmVuZGVyVGltZXIgPSBudWxsO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgfSxcbiAgICBleHBhbmRUZXh0RGl2czogZnVuY3Rpb24gVGV4dExheWVyX2V4cGFuZFRleHREaXZzKGV4cGFuZERpdnMpIHtcbiAgICAgIGlmICghdGhpcy5fZW5oYW5jZVRleHRTZWxlY3Rpb24gfHwgIXRoaXMuX3JlbmRlcmluZ0RvbmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYm91bmRzICE9PSBudWxsKSB7XG4gICAgICAgIGV4cGFuZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fYm91bmRzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHRyYW5zZm9ybUJ1ZiA9IFtdLFxuICAgICAgICAgIHBhZGRpbmdCdWYgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5fdGV4dERpdnMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB2YXIgZGl2ID0gdGhpcy5fdGV4dERpdnNbaV07XG5cbiAgICAgICAgdmFyIGRpdlByb3BzID0gdGhpcy5fdGV4dERpdlByb3BlcnRpZXMuZ2V0KGRpdik7XG5cbiAgICAgICAgaWYgKGRpdlByb3BzLmlzV2hpdGVzcGFjZSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGV4cGFuZERpdnMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm1CdWYubGVuZ3RoID0gMDtcbiAgICAgICAgICBwYWRkaW5nQnVmLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgICBpZiAoZGl2UHJvcHMub3JpZ2luYWxUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUJ1Zi5wdXNoKGRpdlByb3BzLm9yaWdpbmFsVHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGl2UHJvcHMucGFkZGluZ1RvcCA+IDApIHtcbiAgICAgICAgICAgIHBhZGRpbmdCdWYucHVzaChcIlwiLmNvbmNhdChkaXZQcm9wcy5wYWRkaW5nVG9wLCBcInB4XCIpKTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUJ1Zi5wdXNoKFwidHJhbnNsYXRlWShcIi5jb25jYXQoLWRpdlByb3BzLnBhZGRpbmdUb3AsIFwicHgpXCIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGFkZGluZ0J1Zi5wdXNoKDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChkaXZQcm9wcy5wYWRkaW5nUmlnaHQgPiAwKSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goXCJcIi5jb25jYXQoZGl2UHJvcHMucGFkZGluZ1JpZ2h0IC8gZGl2UHJvcHMuc2NhbGUsIFwicHhcIikpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGRpdlByb3BzLnBhZGRpbmdCb3R0b20gPiAwKSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goXCJcIi5jb25jYXQoZGl2UHJvcHMucGFkZGluZ0JvdHRvbSwgXCJweFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhZGRpbmdCdWYucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGl2UHJvcHMucGFkZGluZ0xlZnQgPiAwKSB7XG4gICAgICAgICAgICBwYWRkaW5nQnVmLnB1c2goXCJcIi5jb25jYXQoZGl2UHJvcHMucGFkZGluZ0xlZnQgLyBkaXZQcm9wcy5zY2FsZSwgXCJweFwiKSk7XG4gICAgICAgICAgICB0cmFuc2Zvcm1CdWYucHVzaChcInRyYW5zbGF0ZVgoXCIuY29uY2F0KC1kaXZQcm9wcy5wYWRkaW5nTGVmdCAvIGRpdlByb3BzLnNjYWxlLCBcInB4KVwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhZGRpbmdCdWYucHVzaCgwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaXYuc3R5bGUucGFkZGluZyA9IHBhZGRpbmdCdWYuam9pbihcIiBcIik7XG5cbiAgICAgICAgICBpZiAodHJhbnNmb3JtQnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUJ1Zi5qb2luKFwiIFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGl2LnN0eWxlLnBhZGRpbmcgPSBudWxsO1xuICAgICAgICAgIGRpdi5zdHlsZS50cmFuc2Zvcm0gPSBkaXZQcm9wcy5vcmlnaW5hbFRyYW5zZm9ybTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiByZW5kZXJUZXh0TGF5ZXIocmVuZGVyUGFyYW1ldGVycykge1xuICAgIHZhciB0YXNrID0gbmV3IFRleHRMYXllclJlbmRlclRhc2soe1xuICAgICAgdGV4dENvbnRlbnQ6IHJlbmRlclBhcmFtZXRlcnMudGV4dENvbnRlbnQsXG4gICAgICB0ZXh0Q29udGVudFN0cmVhbTogcmVuZGVyUGFyYW1ldGVycy50ZXh0Q29udGVudFN0cmVhbSxcbiAgICAgIGNvbnRhaW5lcjogcmVuZGVyUGFyYW1ldGVycy5jb250YWluZXIsXG4gICAgICB2aWV3cG9ydDogcmVuZGVyUGFyYW1ldGVycy52aWV3cG9ydCxcbiAgICAgIHRleHREaXZzOiByZW5kZXJQYXJhbWV0ZXJzLnRleHREaXZzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0cjogcmVuZGVyUGFyYW1ldGVycy50ZXh0Q29udGVudEl0ZW1zU3RyLFxuICAgICAgZW5oYW5jZVRleHRTZWxlY3Rpb246IHJlbmRlclBhcmFtZXRlcnMuZW5oYW5jZVRleHRTZWxlY3Rpb25cbiAgICB9KTtcblxuICAgIHRhc2suX3JlbmRlcihyZW5kZXJQYXJhbWV0ZXJzLnRpbWVvdXQpO1xuXG4gICAgcmV0dXJuIHRhc2s7XG4gIH1cblxuICByZXR1cm4gcmVuZGVyVGV4dExheWVyO1xufSgpO1xuXG5leHBvcnRzLnJlbmRlclRleHRMYXllciA9IHJlbmRlclRleHRMYXllcjtcblxuLyoqKi8gfSksXG4vKiAyMTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU1ZHR3JhcGhpY3MgPSB2b2lkIDA7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5cbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5cbnZhciBfaXNfbm9kZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGl0ZXIpKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpOyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IHRocm93IF9lMjsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gb1tTeW1ib2wuaXRlcmF0b3JdKCk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTMpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UzOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IH1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIFNWR0dyYXBoaWNzID0gZnVuY3Rpb24gU1ZHR3JhcGhpY3MoKSB7XG4gIHRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZDogU1ZHR3JhcGhpY3NcIik7XG59O1xuXG5leHBvcnRzLlNWR0dyYXBoaWNzID0gU1ZHR3JhcGhpY3M7XG57XG4gIHZhciBvcExpc3RUb1RyZWUgPSBmdW5jdGlvbiBvcExpc3RUb1RyZWUob3BMaXN0KSB7XG4gICAgdmFyIG9wVHJlZSA9IFtdO1xuICAgIHZhciB0bXAgPSBbXTtcblxuICAgIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvcExpc3QpLFxuICAgICAgICBfc3RlcDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICB2YXIgb3BMaXN0RWxlbWVudCA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICAgIGlmIChvcExpc3RFbGVtZW50LmZuID09PSBcInNhdmVcIikge1xuICAgICAgICAgIG9wVHJlZS5wdXNoKHtcbiAgICAgICAgICAgIGZuSWQ6IDkyLFxuICAgICAgICAgICAgZm46IFwiZ3JvdXBcIixcbiAgICAgICAgICAgIGl0ZW1zOiBbXVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRtcC5wdXNoKG9wVHJlZSk7XG4gICAgICAgICAgb3BUcmVlID0gb3BUcmVlW29wVHJlZS5sZW5ndGggLSAxXS5pdGVtcztcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvcExpc3RFbGVtZW50LmZuID09PSBcInJlc3RvcmVcIikge1xuICAgICAgICAgIG9wVHJlZSA9IHRtcC5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcFRyZWUucHVzaChvcExpc3RFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3BUcmVlO1xuICB9O1xuXG4gIHZhciBwZiA9IGZ1bmN0aW9uIHBmKHZhbHVlKSB7XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9XG5cbiAgICB2YXIgcyA9IHZhbHVlLnRvRml4ZWQoMTApO1xuICAgIHZhciBpID0gcy5sZW5ndGggLSAxO1xuXG4gICAgaWYgKHNbaV0gIT09IFwiMFwiKSB7XG4gICAgICByZXR1cm4gcztcbiAgICB9XG5cbiAgICBkbyB7XG4gICAgICBpLS07XG4gICAgfSB3aGlsZSAoc1tpXSA9PT0gXCIwXCIpO1xuXG4gICAgcmV0dXJuIHMuc3Vic3RyaW5nKDAsIHNbaV0gPT09IFwiLlwiID8gaSA6IGkgKyAxKTtcbiAgfTtcblxuICB2YXIgcG0gPSBmdW5jdGlvbiBwbShtKSB7XG4gICAgaWYgKG1bNF0gPT09IDAgJiYgbVs1XSA9PT0gMCkge1xuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICBpZiAobVswXSA9PT0gMSAmJiBtWzNdID09PSAxKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gXCJzY2FsZShcIi5jb25jYXQocGYobVswXSksIFwiIFwiKS5jb25jYXQocGYobVszXSksIFwiKVwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1bMF0gPT09IG1bM10gJiYgbVsxXSA9PT0gLW1bMl0pIHtcbiAgICAgICAgdmFyIGEgPSBNYXRoLmFjb3MobVswXSkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICByZXR1cm4gXCJyb3RhdGUoXCIuY29uY2F0KHBmKGEpLCBcIilcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtWzBdID09PSAxICYmIG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCAmJiBtWzNdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcInRyYW5zbGF0ZShcIi5jb25jYXQocGYobVs0XSksIFwiIFwiKS5jb25jYXQocGYobVs1XSksIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gXCJtYXRyaXgoXCIuY29uY2F0KHBmKG1bMF0pLCBcIiBcIikuY29uY2F0KHBmKG1bMV0pLCBcIiBcIikuY29uY2F0KHBmKG1bMl0pLCBcIiBcIikuY29uY2F0KHBmKG1bM10pLCBcIiBcIikuY29uY2F0KHBmKG1bNF0pLCBcIiBcIikgKyBcIlwiLmNvbmNhdChwZihtWzVdKSwgXCIpXCIpO1xuICB9O1xuXG4gIHZhciBTVkdfREVGQVVMVFMgPSB7XG4gICAgZm9udFN0eWxlOiBcIm5vcm1hbFwiLFxuICAgIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gICAgZmlsbENvbG9yOiBcIiMwMDAwMDBcIlxuICB9O1xuICB2YXIgWE1MX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIjtcbiAgdmFyIFhMSU5LX05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCI7XG4gIHZhciBMSU5FX0NBUF9TVFlMRVMgPSBbXCJidXR0XCIsIFwicm91bmRcIiwgXCJzcXVhcmVcIl07XG4gIHZhciBMSU5FX0pPSU5fU1RZTEVTID0gW1wibWl0ZXJcIiwgXCJyb3VuZFwiLCBcImJldmVsXCJdO1xuXG4gIHZhciBjb252ZXJ0SW1nRGF0YVRvUG5nID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBQTkdfSEVBREVSID0gbmV3IFVpbnQ4QXJyYXkoWzB4ODksIDB4NTAsIDB4NGUsIDB4NDcsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdKTtcbiAgICB2YXIgQ0hVTktfV1JBUFBFUl9TSVpFID0gMTI7XG4gICAgdmFyIGNyY1RhYmxlID0gbmV3IEludDMyQXJyYXkoMjU2KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgIHZhciBjID0gaTtcblxuICAgICAgZm9yICh2YXIgaCA9IDA7IGggPCA4OyBoKyspIHtcbiAgICAgICAgaWYgKGMgJiAxKSB7XG4gICAgICAgICAgYyA9IDB4ZWRiODgzMjAgXiBjID4+IDEgJiAweDdmZmZmZmZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGMgPSBjID4+IDEgJiAweDdmZmZmZmZmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNyY1RhYmxlW2ldID0gYztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmMzMihkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgY3JjID0gLTE7XG5cbiAgICAgIGZvciAodmFyIF9pID0gc3RhcnQ7IF9pIDwgZW5kOyBfaSsrKSB7XG4gICAgICAgIHZhciBhID0gKGNyYyBeIGRhdGFbX2ldKSAmIDB4ZmY7XG4gICAgICAgIHZhciBiID0gY3JjVGFibGVbYV07XG4gICAgICAgIGNyYyA9IGNyYyA+Pj4gOCBeIGI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmMgXiAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB3cml0ZVBuZ0NodW5rKHR5cGUsIGJvZHksIGRhdGEsIG9mZnNldCkge1xuICAgICAgdmFyIHAgPSBvZmZzZXQ7XG4gICAgICB2YXIgbGVuID0gYm9keS5sZW5ndGg7XG4gICAgICBkYXRhW3BdID0gbGVuID4+IDI0ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDFdID0gbGVuID4+IDE2ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDJdID0gbGVuID4+IDggJiAweGZmO1xuICAgICAgZGF0YVtwICsgM10gPSBsZW4gJiAweGZmO1xuICAgICAgcCArPSA0O1xuICAgICAgZGF0YVtwXSA9IHR5cGUuY2hhckNvZGVBdCgwKSAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAxXSA9IHR5cGUuY2hhckNvZGVBdCgxKSAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAyXSA9IHR5cGUuY2hhckNvZGVBdCgyKSAmIDB4ZmY7XG4gICAgICBkYXRhW3AgKyAzXSA9IHR5cGUuY2hhckNvZGVBdCgzKSAmIDB4ZmY7XG4gICAgICBwICs9IDQ7XG4gICAgICBkYXRhLnNldChib2R5LCBwKTtcbiAgICAgIHAgKz0gYm9keS5sZW5ndGg7XG4gICAgICB2YXIgY3JjID0gY3JjMzIoZGF0YSwgb2Zmc2V0ICsgNCwgcCk7XG4gICAgICBkYXRhW3BdID0gY3JjID4+IDI0ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDFdID0gY3JjID4+IDE2ICYgMHhmZjtcbiAgICAgIGRhdGFbcCArIDJdID0gY3JjID4+IDggJiAweGZmO1xuICAgICAgZGF0YVtwICsgM10gPSBjcmMgJiAweGZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkbGVyMzIoZGF0YSwgc3RhcnQsIGVuZCkge1xuICAgICAgdmFyIGEgPSAxO1xuICAgICAgdmFyIGIgPSAwO1xuXG4gICAgICBmb3IgKHZhciBfaTIgPSBzdGFydDsgX2kyIDwgZW5kOyArK19pMikge1xuICAgICAgICBhID0gKGEgKyAoZGF0YVtfaTJdICYgMHhmZikpICUgNjU1MjE7XG4gICAgICAgIGIgPSAoYiArIGEpICUgNjU1MjE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiIDw8IDE2IHwgYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZsYXRlU3luYyhsaXRlcmFscykge1xuICAgICAgaWYgKCFfaXNfbm9kZS5pc05vZGVKUykge1xuICAgICAgICByZXR1cm4gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgaW5wdXQ7XG5cbiAgICAgICAgaWYgKHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbnMubm9kZSkgPj0gOCkge1xuICAgICAgICAgIGlucHV0ID0gbGl0ZXJhbHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQgPSBCdWZmZXIuZnJvbShsaXRlcmFscyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3V0cHV0ID0gcmVxdWlyZShcInpsaWJcIikuZGVmbGF0ZVN5bmMoaW5wdXQsIHtcbiAgICAgICAgICBsZXZlbDogOVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gb3V0cHV0IGluc3RhbmNlb2YgVWludDhBcnJheSA/IG91dHB1dCA6IG5ldyBVaW50OEFycmF5KG91dHB1dCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShcIk5vdCBjb21wcmVzc2luZyBQTkcgYmVjYXVzZSB6bGliLmRlZmxhdGVTeW5jIGlzIHVuYXZhaWxhYmxlOiBcIiArIGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKSB7XG4gICAgICB2YXIgbGVuID0gbGl0ZXJhbHMubGVuZ3RoO1xuICAgICAgdmFyIG1heEJsb2NrTGVuZ3RoID0gMHhmZmZmO1xuICAgICAgdmFyIGRlZmxhdGVCbG9ja3MgPSBNYXRoLmNlaWwobGVuIC8gbWF4QmxvY2tMZW5ndGgpO1xuICAgICAgdmFyIGlkYXQgPSBuZXcgVWludDhBcnJheSgyICsgbGVuICsgZGVmbGF0ZUJsb2NrcyAqIDUgKyA0KTtcbiAgICAgIHZhciBwaSA9IDA7XG4gICAgICBpZGF0W3BpKytdID0gMHg3ODtcbiAgICAgIGlkYXRbcGkrK10gPSAweDljO1xuICAgICAgdmFyIHBvcyA9IDA7XG5cbiAgICAgIHdoaWxlIChsZW4gPiBtYXhCbG9ja0xlbmd0aCkge1xuICAgICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgICAgaWRhdFtwaSsrXSA9IDB4ZmY7XG4gICAgICAgIGlkYXRbcGkrK10gPSAweGZmO1xuICAgICAgICBpZGF0W3BpKytdID0gMHgwMDtcbiAgICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICAgIGlkYXQuc2V0KGxpdGVyYWxzLnN1YmFycmF5KHBvcywgcG9zICsgbWF4QmxvY2tMZW5ndGgpLCBwaSk7XG4gICAgICAgIHBpICs9IG1heEJsb2NrTGVuZ3RoO1xuICAgICAgICBwb3MgKz0gbWF4QmxvY2tMZW5ndGg7XG4gICAgICAgIGxlbiAtPSBtYXhCbG9ja0xlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWRhdFtwaSsrXSA9IDB4MDE7XG4gICAgICBpZGF0W3BpKytdID0gbGVuICYgMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSBsZW4gPj4gOCAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gfmxlbiAmIDB4ZmZmZiAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gKH5sZW4gJiAweGZmZmYpID4+IDggJiAweGZmO1xuICAgICAgaWRhdC5zZXQobGl0ZXJhbHMuc3ViYXJyYXkocG9zKSwgcGkpO1xuICAgICAgcGkgKz0gbGl0ZXJhbHMubGVuZ3RoIC0gcG9zO1xuICAgICAgdmFyIGFkbGVyID0gYWRsZXIzMihsaXRlcmFscywgMCwgbGl0ZXJhbHMubGVuZ3RoKTtcbiAgICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiAyNCAmIDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gMTYgJiAweGZmO1xuICAgICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDggJiAweGZmO1xuICAgICAgaWRhdFtwaSsrXSA9IGFkbGVyICYgMHhmZjtcbiAgICAgIHJldHVybiBpZGF0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuY29kZShpbWdEYXRhLCBraW5kLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzaykge1xuICAgICAgdmFyIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICAgIHZhciBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICAgIHZhciBiaXREZXB0aCwgY29sb3JUeXBlLCBsaW5lU2l6ZTtcbiAgICAgIHZhciBieXRlcyA9IGltZ0RhdGEuZGF0YTtcblxuICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgICAgIGNvbG9yVHlwZSA9IDA7XG4gICAgICAgICAgYml0RGVwdGggPSAxO1xuICAgICAgICAgIGxpbmVTaXplID0gd2lkdGggKyA3ID4+IDM7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgICAgIGNvbG9yVHlwZSA9IDI7XG4gICAgICAgICAgYml0RGVwdGggPSA4O1xuICAgICAgICAgIGxpbmVTaXplID0gd2lkdGggKiAzO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLlJHQkFfMzJCUFA6XG4gICAgICAgICAgY29sb3JUeXBlID0gNjtcbiAgICAgICAgICBiaXREZXB0aCA9IDg7XG4gICAgICAgICAgbGluZVNpemUgPSB3aWR0aCAqIDQ7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZvcm1hdFwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxpdGVyYWxzID0gbmV3IFVpbnQ4QXJyYXkoKDEgKyBsaW5lU2l6ZSkgKiBoZWlnaHQpO1xuICAgICAgdmFyIG9mZnNldExpdGVyYWxzID0gMCxcbiAgICAgICAgICBvZmZzZXRCeXRlcyA9IDA7XG5cbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgICAgbGl0ZXJhbHNbb2Zmc2V0TGl0ZXJhbHMrK10gPSAwO1xuICAgICAgICBsaXRlcmFscy5zZXQoYnl0ZXMuc3ViYXJyYXkob2Zmc2V0Qnl0ZXMsIG9mZnNldEJ5dGVzICsgbGluZVNpemUpLCBvZmZzZXRMaXRlcmFscyk7XG4gICAgICAgIG9mZnNldEJ5dGVzICs9IGxpbmVTaXplO1xuICAgICAgICBvZmZzZXRMaXRlcmFscyArPSBsaW5lU2l6ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGtpbmQgPT09IF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCAmJiBpc01hc2spIHtcbiAgICAgICAgb2Zmc2V0TGl0ZXJhbHMgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIF95ID0gMDsgX3kgPCBoZWlnaHQ7IF95KyspIHtcbiAgICAgICAgICBvZmZzZXRMaXRlcmFscysrO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kzID0gMDsgX2kzIDwgbGluZVNpemU7IF9pMysrKSB7XG4gICAgICAgICAgICBsaXRlcmFsc1tvZmZzZXRMaXRlcmFscysrXSBePSAweGZmO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgaWhkciA9IG5ldyBVaW50OEFycmF5KFt3aWR0aCA+PiAyNCAmIDB4ZmYsIHdpZHRoID4+IDE2ICYgMHhmZiwgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgaGVpZ2h0ID4+IDI0ICYgMHhmZiwgaGVpZ2h0ID4+IDE2ICYgMHhmZiwgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLCBiaXREZXB0aCwgY29sb3JUeXBlLCAweDAwLCAweDAwLCAweDAwXSk7XG4gICAgICB2YXIgaWRhdCA9IGRlZmxhdGVTeW5jKGxpdGVyYWxzKTtcbiAgICAgIHZhciBwbmdMZW5ndGggPSBQTkdfSEVBREVSLmxlbmd0aCArIENIVU5LX1dSQVBQRVJfU0laRSAqIDMgKyBpaGRyLmxlbmd0aCArIGlkYXQubGVuZ3RoO1xuICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShwbmdMZW5ndGgpO1xuICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICBkYXRhLnNldChQTkdfSEVBREVSLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IFBOR19IRUFERVIubGVuZ3RoO1xuICAgICAgd3JpdGVQbmdDaHVuayhcIklIRFJcIiwgaWhkciwgZGF0YSwgb2Zmc2V0KTtcbiAgICAgIG9mZnNldCArPSBDSFVOS19XUkFQUEVSX1NJWkUgKyBpaGRyLmxlbmd0aDtcbiAgICAgIHdyaXRlUG5nQ2h1bmsoXCJJREFUQVwiLCBpZGF0LCBkYXRhLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IENIVU5LX1dSQVBQRVJfU0laRSArIGlkYXQubGVuZ3RoO1xuICAgICAgd3JpdGVQbmdDaHVuayhcIklFTkRcIiwgbmV3IFVpbnQ4QXJyYXkoMCksIGRhdGEsIG9mZnNldCk7XG4gICAgICByZXR1cm4gKDAsIF91dGlsLmNyZWF0ZU9iamVjdFVSTCkoZGF0YSwgXCJpbWFnZS9wbmdcIiwgZm9yY2VEYXRhU2NoZW1hKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY29udmVydEltZ0RhdGFUb1BuZyhpbWdEYXRhLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzaykge1xuICAgICAgdmFyIGtpbmQgPSBpbWdEYXRhLmtpbmQgPT09IHVuZGVmaW5lZCA/IF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCA6IGltZ0RhdGEua2luZDtcbiAgICAgIHJldHVybiBlbmNvZGUoaW1nRGF0YSwga2luZCwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgU1ZHRXh0cmFTdGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU1ZHRXh0cmFTdGF0ZSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTVkdFeHRyYVN0YXRlKTtcblxuICAgICAgdGhpcy5mb250U2l6ZVNjYWxlID0gMTtcbiAgICAgIHRoaXMuZm9udFdlaWdodCA9IFNWR19ERUZBVUxUUy5mb250V2VpZ2h0O1xuICAgICAgdGhpcy5mb250U2l6ZSA9IDA7XG4gICAgICB0aGlzLnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLmZvbnRNYXRyaXggPSBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICAgIHRoaXMubGVhZGluZyA9IDA7XG4gICAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICAgIHRoaXMudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnkgPSAwO1xuICAgICAgdGhpcy5saW5lWCA9IDA7XG4gICAgICB0aGlzLmxpbmVZID0gMDtcbiAgICAgIHRoaXMuY2hhclNwYWNpbmcgPSAwO1xuICAgICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgICB0aGlzLnRleHRIU2NhbGUgPSAxO1xuICAgICAgdGhpcy50ZXh0UmlzZSA9IDA7XG4gICAgICB0aGlzLmZpbGxDb2xvciA9IFNWR19ERUZBVUxUUy5maWxsQ29sb3I7XG4gICAgICB0aGlzLnN0cm9rZUNvbG9yID0gXCIjMDAwMDAwXCI7XG4gICAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG4gICAgICB0aGlzLnN0cm9rZUFscGhhID0gMTtcbiAgICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICAgIHRoaXMubGluZUpvaW4gPSBcIlwiO1xuICAgICAgdGhpcy5saW5lQ2FwID0gXCJcIjtcbiAgICAgIHRoaXMubWl0ZXJMaW1pdCA9IDA7XG4gICAgICB0aGlzLmRhc2hBcnJheSA9IFtdO1xuICAgICAgdGhpcy5kYXNoUGhhc2UgPSAwO1xuICAgICAgdGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgIHRoaXMuYWN0aXZlQ2xpcFVybCA9IG51bGw7XG4gICAgICB0aGlzLmNsaXBHcm91cCA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tJZCA9IFwiXCI7XG4gICAgfVxuXG4gICAgX2NyZWF0ZUNsYXNzKFNWR0V4dHJhU3RhdGUsIFt7XG4gICAgICBrZXk6IFwiY2xvbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5jcmVhdGUodGhpcyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEN1cnJlbnRQb2ludFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1cnJlbnRQb2ludCh4LCB5KSB7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMueSA9IHk7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNWR0V4dHJhU3RhdGU7XG4gIH0oKTtcblxuICB2YXIgY2xpcENvdW50ID0gMDtcbiAgdmFyIG1hc2tDb3VudCA9IDA7XG4gIHZhciBzaGFkaW5nQ291bnQgPSAwO1xuXG4gIGV4cG9ydHMuU1ZHR3JhcGhpY3MgPSBTVkdHcmFwaGljcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU1ZHR3JhcGhpY3MoY29tbW9uT2Jqcywgb2Jqcykge1xuICAgICAgdmFyIGZvcmNlRGF0YVNjaGVtYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTVkdHcmFwaGljcyk7XG5cbiAgICAgIHRoaXMuc3ZnRmFjdG9yeSA9IG5ldyBfZGlzcGxheV91dGlscy5ET01TVkdGYWN0b3J5KCk7XG4gICAgICB0aGlzLmN1cnJlbnQgPSBuZXcgU1ZHRXh0cmFTdGF0ZSgpO1xuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLnRyYW5zZm9ybVN0YWNrID0gW107XG4gICAgICB0aGlzLmV4dHJhU3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICAgIHRoaXMuZW1iZWRGb250cyA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWJlZGRlZEZvbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIHRoaXMuY3NzU3R5bGUgPSBudWxsO1xuICAgICAgdGhpcy5mb3JjZURhdGFTY2hlbWEgPSAhIWZvcmNlRGF0YVNjaGVtYTtcbiAgICAgIHRoaXMuX29wZXJhdG9ySWRNYXBwaW5nID0gW107XG5cbiAgICAgIGZvciAodmFyIG9wIGluIF91dGlsLk9QUykge1xuICAgICAgICB0aGlzLl9vcGVyYXRvcklkTWFwcGluZ1tfdXRpbC5PUFNbb3BdXSA9IG9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9jcmVhdGVDbGFzcyhTVkdHcmFwaGljcywgW3tcbiAgICAgIGtleTogXCJzYXZlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2F2ZSgpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICAgICAgdmFyIG9sZCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdGhpcy5leHRyYVN0YWNrLnB1c2gob2xkKTtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gb2xkLmNsb25lKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlc3RvcmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXN0b3JlKCkge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IHRoaXMudHJhbnNmb3JtU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuY3VycmVudCA9IHRoaXMuZXh0cmFTdGFjay5wb3AoKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICAgIHRoaXMudGdycCA9IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImdyb3VwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ3JvdXAoaXRlbXMpIHtcbiAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wVHJlZShpdGVtcyk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJsb2FkRGVwZW5kZW5jaWVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gbG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgICAgICB2YXIgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBmbkFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgICBpZiAoZm5BcnJheVtpXSAhPT0gX3V0aWwuT1BTLmRlcGVuZGVuY3kpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoYXJnc0FycmF5W2ldKSxcbiAgICAgICAgICAgICAgX3N0ZXAyO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCkge1xuICAgICAgICAgICAgICB2YXIgb2JqID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgb2Jqc1Bvb2wgPSBvYmouc3RhcnRzV2l0aChcImdfXCIpID8gX3RoaXMuY29tbW9uT2JqcyA6IF90aGlzLm9ianM7XG4gICAgICAgICAgICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBvYmpzUG9vbC5nZXQob2JqLCByZXNvbHZlKTtcbiAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgX3RoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMucHVzaChwcm9taXNlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJ0cmFuc2Zvcm1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgICB2YXIgdHJhbnNmb3JtTWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IF91dGlsLlV0aWwudHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtTWF0cml4LCB0cmFuc2Zvcm1NYXRyaXgpO1xuICAgICAgICB0aGlzLnRncnAgPSBudWxsO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJnZXRTVkdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTVkcob3BlcmF0b3JMaXN0LCB2aWV3cG9ydCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG5cbiAgICAgICAgdmFyIHN2Z0VsZW1lbnQgPSB0aGlzLl9pbml0aWFsaXplKHZpZXdwb3J0KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkRGVwZW5kZW5jaWVzKG9wZXJhdG9yTGlzdCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMyLnRyYW5zZm9ybU1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcblxuICAgICAgICAgIF90aGlzMi5leGVjdXRlT3BUcmVlKF90aGlzMi5jb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkpO1xuXG4gICAgICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb252ZXJ0T3BMaXN0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpIHtcbiAgICAgICAgdmFyIG9wZXJhdG9ySWRNYXBwaW5nID0gdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmc7XG4gICAgICAgIHZhciBhcmdzQXJyYXkgPSBvcGVyYXRvckxpc3QuYXJnc0FycmF5O1xuICAgICAgICB2YXIgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgICAgICB2YXIgb3BMaXN0ID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gZm5BcnJheS5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZuSWQgPSBmbkFycmF5W2ldO1xuICAgICAgICAgIG9wTGlzdC5wdXNoKHtcbiAgICAgICAgICAgIGZuSWQ6IGZuSWQsXG4gICAgICAgICAgICBmbjogb3BlcmF0b3JJZE1hcHBpbmdbZm5JZF0sXG4gICAgICAgICAgICBhcmdzOiBhcmdzQXJyYXlbaV1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvcExpc3RUb1RyZWUob3BMaXN0KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZXhlY3V0ZU9wVHJlZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGV4ZWN1dGVPcFRyZWUob3BUcmVlKSB7XG4gICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3BUcmVlKSxcbiAgICAgICAgICAgIF9zdGVwMztcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMy5zKCk7ICEoX3N0ZXAzID0gX2l0ZXJhdG9yMy5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgb3BUcmVlRWxlbWVudCA9IF9zdGVwMy52YWx1ZTtcbiAgICAgICAgICAgIHZhciBmbiA9IG9wVHJlZUVsZW1lbnQuZm47XG4gICAgICAgICAgICB2YXIgZm5JZCA9IG9wVHJlZUVsZW1lbnQuZm5JZDtcbiAgICAgICAgICAgIHZhciBhcmdzID0gb3BUcmVlRWxlbWVudC5hcmdzO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGZuSWQgfCAwKSB7XG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmJlZ2luVGV4dDpcbiAgICAgICAgICAgICAgICB0aGlzLmJlZ2luVGV4dCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmRlcGVuZGVuY3k6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGVhZGluZzpcbiAgICAgICAgICAgICAgICB0aGlzLnNldExlYWRpbmcoYXJncyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGVhZGluZ01vdmVUZXh0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGVhZGluZ01vdmVUZXh0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZvbnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGb250KGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNob3dUZXh0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2hvd1RleHQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hvd1NwYWNlZFRleHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93VGV4dChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5lbmRUZXh0OlxuICAgICAgICAgICAgICAgIHRoaXMuZW5kVGV4dCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLm1vdmVUZXh0OlxuICAgICAgICAgICAgICAgIHRoaXMubW92ZVRleHQoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0Q2hhclNwYWNpbmc6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDaGFyU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRXb3JkU3BhY2luZzpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFdvcmRTcGFjaW5nKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEhTY2FsZTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldEhTY2FsZShhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0TWF0cml4OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGV4dE1hdHJpeChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0UmlzZTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRleHRSaXNlKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFRleHRSZW5kZXJpbmdNb2RlOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0VGV4dFJlbmRlcmluZ01vZGUoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGluZVdpZHRoOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldExpbmVKb2luOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0TGluZUpvaW4oYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGluZUNhcDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldExpbmVDYXAoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TWl0ZXJMaW1pdDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RmlsbFJHQkNvbG9yOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmlsbFJHQkNvbG9yKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFN0cm9rZVJHQkNvbG9yOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlUkdCQ29sb3IoYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0U3Ryb2tlQ29sb3JOOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3JOKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZpbGxDb2xvck46XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGaWxsQ29sb3JOKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNoYWRpbmdGaWxsOlxuICAgICAgICAgICAgICAgIHRoaXMuc2hhZGluZ0ZpbGwoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RGFzaDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldERhc2goYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0UmVuZGVyaW5nSW50ZW50OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZsYXRuZXNzOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3MoYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0R1N0YXRlOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0R1N0YXRlKGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmZpbGw6XG4gICAgICAgICAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW9GaWxsOlxuICAgICAgICAgICAgICAgIHRoaXMuZW9GaWxsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuc3Ryb2tlOlxuICAgICAgICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZmlsbFN0cm9rZTpcbiAgICAgICAgICAgICAgICB0aGlzLmZpbGxTdHJva2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5lb0ZpbGxTdHJva2U6XG4gICAgICAgICAgICAgICAgdGhpcy5lb0ZpbGxTdHJva2UoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jbGlwOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW9DbGlwOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrOlxuICAgICAgICAgICAgICAgIHRoaXMucGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludEltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludElubGluZUltYWdlWE9iamVjdDpcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50SW1hZ2VNYXNrWE9iamVjdDpcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50SW1hZ2VNYXNrWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEZvcm1YT2JqZWN0QmVnaW46XG4gICAgICAgICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0QmVnaW4oYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRGb3JtWE9iamVjdEVuZDpcbiAgICAgICAgICAgICAgICB0aGlzLnBhaW50Rm9ybVhPYmplY3RFbmQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVBhdGg6XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVN0cm9rZTpcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlU3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VGaWxsU3Ryb2tlOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VGaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VFT0ZpbGxTdHJva2U6XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZUVPRmlsbFN0cm9rZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLm5leHRMaW5lOlxuICAgICAgICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIF91dGlsLk9QUy50cmFuc2Zvcm06XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm0oYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSwgYXJnc1szXSwgYXJnc1s0XSwgYXJnc1s1XSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY29uc3RydWN0UGF0aDpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cnVjdFBhdGgoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kUGF0aDpcbiAgICAgICAgICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHRoaXMuZ3JvdXAob3BUcmVlRWxlbWVudC5pdGVtcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIG9wZXJhdG9yIFwiLmNvbmNhdChmbikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0V29yZFNwYWNpbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRXb3JkU3BhY2luZyh3b3JkU3BhY2luZykge1xuICAgICAgICB0aGlzLmN1cnJlbnQud29yZFNwYWNpbmcgPSB3b3JkU3BhY2luZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0Q2hhclNwYWNpbmdcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDaGFyU3BhY2luZyhjaGFyU3BhY2luZykge1xuICAgICAgICB0aGlzLmN1cnJlbnQuY2hhclNwYWNpbmcgPSBjaGFyU3BhY2luZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibmV4dExpbmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBuZXh0TGluZSgpIHtcbiAgICAgICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFRleHRNYXRyaXhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0TWF0cml4KGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnQudGV4dE1hdHJpeCA9IGN1cnJlbnQubGluZU1hdHJpeCA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgICAgY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgICAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZID0gMDtcbiAgICAgICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgICAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LWZhbWlseVwiLCBjdXJyZW50LmZvbnRGYW1pbHkpO1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIFwiXCIuY29uY2F0KHBmKGN1cnJlbnQuZm9udFNpemUpLCBcInB4XCIpKTtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgICAgICBjdXJyZW50LnR4dEVsZW1lbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0ZXh0XCIpO1xuICAgICAgICBjdXJyZW50LnR4dEVsZW1lbnQuYXBwZW5kQ2hpbGQoY3VycmVudC50c3Bhbik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImJlZ2luVGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGJlZ2luVGV4dCgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgICAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZID0gMDtcbiAgICAgICAgY3VycmVudC50ZXh0TWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgICAgICBjdXJyZW50LmxpbmVNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICAgICAgY3VycmVudC50c3BhbiA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRzcGFuXCIpO1xuICAgICAgICBjdXJyZW50LnR4dEVsZW1lbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0ZXh0XCIpO1xuICAgICAgICBjdXJyZW50LnR4dGdycCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgICAgICBjdXJyZW50Lnljb29yZHMgPSBbXTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwibW92ZVRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtb3ZlVGV4dCh4LCB5KSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYICs9IHg7XG4gICAgICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgKz0geTtcbiAgICAgICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgICAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LWZhbWlseVwiLCBjdXJyZW50LmZvbnRGYW1pbHkpO1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIFwiXCIuY29uY2F0KHBmKGN1cnJlbnQuZm9udFNpemUpLCBcInB4XCIpKTtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzaG93VGV4dFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3dUZXh0KGdseXBocykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdmFyIGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgICAgIHZhciBmb250U2l6ZSA9IGN1cnJlbnQuZm9udFNpemU7XG5cbiAgICAgICAgaWYgKGZvbnRTaXplID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZvbnRTaXplU2NhbGUgPSBjdXJyZW50LmZvbnRTaXplU2NhbGU7XG4gICAgICAgIHZhciBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgICAgIHZhciB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgICAgIHZhciBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgICAgICB2YXIgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgICAgIHZhciB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgICAgIHZhciBzcGFjaW5nRGlyID0gdmVydGljYWwgPyAxIDogLTE7XG4gICAgICAgIHZhciBkZWZhdWx0Vk1ldHJpY3MgPSBmb250LmRlZmF1bHRWTWV0cmljcztcbiAgICAgICAgdmFyIHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgICAgIHZhciB4ID0gMDtcblxuICAgICAgICB2YXIgX2l0ZXJhdG9yNCA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGdseXBocyksXG4gICAgICAgICAgICBfc3RlcDQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIGdseXBoID0gX3N0ZXA0LnZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoZ2x5cGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgeCArPSBmb250RGlyZWN0aW9uICogd29yZFNwYWNpbmc7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoMCwgX3V0aWwuaXNOdW0pKGdseXBoKSkge1xuICAgICAgICAgICAgICB4ICs9IHNwYWNpbmdEaXIgKiBnbHlwaCAqIGZvbnRTaXplIC8gMTAwMDtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICAgICAgICB2YXIgc2NhbGVkWCA9IHZvaWQgMCxcbiAgICAgICAgICAgICAgICBzY2FsZWRZID0gdm9pZCAwO1xuICAgICAgICAgICAgdmFyIHdpZHRoID0gZ2x5cGgud2lkdGg7XG5cbiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgICAgICAgICB2YXIgdnggPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHZhciB2bWV0cmljID0gZ2x5cGgudm1ldHJpYyB8fCBkZWZhdWx0Vk1ldHJpY3M7XG4gICAgICAgICAgICAgIHZ4ID0gZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNTtcbiAgICAgICAgICAgICAgdnggPSAtdnggKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgICAgICAgdmFyIHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGdseXBoLmlzSW5Gb250IHx8IGZvbnQubWlzc2luZ0ZpbGUpIHtcbiAgICAgICAgICAgICAgY3VycmVudC54Y29vcmRzLnB1c2goY3VycmVudC54ICsgc2NhbGVkWCk7XG5cbiAgICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudC55Y29vcmRzLnB1c2goLWN1cnJlbnQueSArIHNjYWxlZFkpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgY3VycmVudC50c3Bhbi50ZXh0Q29udGVudCArPSBjaGFyYWN0ZXI7XG4gICAgICAgICAgICB9IGVsc2Uge31cblxuICAgICAgICAgICAgdmFyIGNoYXJXaWR0aCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgIGNoYXJXaWR0aCA9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgLSBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNoYXJXaWR0aCA9IHdpZHRoICogd2lkdGhBZHZhbmNlU2NhbGUgKyBzcGFjaW5nICogZm9udERpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeCArPSBjaGFyV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I0LmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGN1cnJlbnQueGNvb3Jkcy5tYXAocGYpLmpvaW4oXCIgXCIpKTtcblxuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBjdXJyZW50Lnljb29yZHMubWFwKHBmKS5qb2luKFwiIFwiKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgICAgY3VycmVudC55IC09IHg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudC54ICs9IHggKiB0ZXh0SFNjYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgXCJcIi5jb25jYXQocGYoY3VycmVudC5mb250U2l6ZSksIFwicHhcIikpO1xuXG4gICAgICAgIGlmIChjdXJyZW50LmZvbnRTdHlsZSAhPT0gU1ZHX0RFRkFVTFRTLmZvbnRTdHlsZSkge1xuICAgICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXN0eWxlXCIsIGN1cnJlbnQuZm9udFN0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50LmZvbnRXZWlnaHQgIT09IFNWR19ERUZBVUxUUy5mb250V2VpZ2h0KSB7XG4gICAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtd2VpZ2h0XCIsIGN1cnJlbnQuZm9udFdlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcblxuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTEwgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQuZmlsbENvbG9yICE9PSBTVkdfREVGQVVMVFMuZmlsbENvbG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBjdXJyZW50LmZpbGxDb2xvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtb3BhY2l0eVwiLCBjdXJyZW50LmZpbGxBbHBoYSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIKSB7XG4gICAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgICB2YXIgbGluZVdpZHRoU2NhbGUgPSAxIC8gKGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlIHx8IDEpO1xuXG4gICAgICAgICAgdGhpcy5fc2V0U3Ryb2tlQXR0cmlidXRlcyhjdXJyZW50LnRzcGFuLCBsaW5lV2lkdGhTY2FsZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdGV4dE1hdHJpeCA9IGN1cnJlbnQudGV4dE1hdHJpeDtcblxuICAgICAgICBpZiAoY3VycmVudC50ZXh0UmlzZSAhPT0gMCkge1xuICAgICAgICAgIHRleHRNYXRyaXggPSB0ZXh0TWF0cml4LnNsaWNlKCk7XG4gICAgICAgICAgdGV4dE1hdHJpeFs1XSArPSBjdXJyZW50LnRleHRSaXNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC50eHRFbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIFwiXCIuY29uY2F0KHBtKHRleHRNYXRyaXgpLCBcIiBzY2FsZShcIikuY29uY2F0KHBmKHRleHRIU2NhbGUpLCBcIiwgLTEpXCIpKTtcbiAgICAgICAgY3VycmVudC50eHRFbGVtZW50LnNldEF0dHJpYnV0ZU5TKFhNTF9OUywgXCJ4bWw6c3BhY2VcIiwgXCJwcmVzZXJ2ZVwiKTtcbiAgICAgICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZENoaWxkKGN1cnJlbnQudHNwYW4pO1xuICAgICAgICBjdXJyZW50LnR4dGdycC5hcHBlbmRDaGlsZChjdXJyZW50LnR4dEVsZW1lbnQpO1xuXG4gICAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kQ2hpbGQoY3VycmVudC50eHRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0TGVhZGluZ01vdmVUZXh0XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGVhZGluZ01vdmVUZXh0KHgsIHkpIHtcbiAgICAgICAgdGhpcy5zZXRMZWFkaW5nKC15KTtcbiAgICAgICAgdGhpcy5tb3ZlVGV4dCh4LCB5KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYWRkRm9udFN0eWxlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRm9udFN0eWxlKGZvbnRPYmopIHtcbiAgICAgICAgaWYgKCFmb250T2JqLmRhdGEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRGb250U3R5bGU6IE5vIGZvbnQgZGF0YSBhdmFpbGFibGUsIFwiICsgJ2Vuc3VyZSB0aGF0IHRoZSBcImZvbnRFeHRyYVByb3BlcnRpZXNcIiBBUEkgcGFyYW1ldGVyIGlzIHNldC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5jc3NTdHlsZSkge1xuICAgICAgICAgIHRoaXMuY3NzU3R5bGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpzdHlsZVwiKTtcbiAgICAgICAgICB0aGlzLmNzc1N0eWxlLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHlwZVwiLCBcInRleHQvY3NzXCIpO1xuICAgICAgICAgIHRoaXMuZGVmcy5hcHBlbmRDaGlsZCh0aGlzLmNzc1N0eWxlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB1cmwgPSAoMCwgX3V0aWwuY3JlYXRlT2JqZWN0VVJMKShmb250T2JqLmRhdGEsIGZvbnRPYmoubWltZXR5cGUsIHRoaXMuZm9yY2VEYXRhU2NoZW1hKTtcbiAgICAgICAgdGhpcy5jc3NTdHlsZS50ZXh0Q29udGVudCArPSBcIkBmb250LWZhY2UgeyBmb250LWZhbWlseTogXFxcIlwiLmNvbmNhdChmb250T2JqLmxvYWRlZE5hbWUsIFwiXFxcIjtcIikgKyBcIiBzcmM6IHVybChcIi5jb25jYXQodXJsLCBcIik7IH1cXG5cIik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEZvbnRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGb250KGRldGFpbHMpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHZhciBmb250T2JqID0gdGhpcy5jb21tb25PYmpzLmdldChkZXRhaWxzWzBdKTtcbiAgICAgICAgdmFyIHNpemUgPSBkZXRhaWxzWzFdO1xuICAgICAgICBjdXJyZW50LmZvbnQgPSBmb250T2JqO1xuXG4gICAgICAgIGlmICh0aGlzLmVtYmVkRm9udHMgJiYgIWZvbnRPYmoubWlzc2luZ0ZpbGUgJiYgIXRoaXMuZW1iZWRkZWRGb250c1tmb250T2JqLmxvYWRlZE5hbWVdKSB7XG4gICAgICAgICAgdGhpcy5hZGRGb250U3R5bGUoZm9udE9iaik7XG4gICAgICAgICAgdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0gPSBmb250T2JqO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC5mb250TWF0cml4ID0gZm9udE9iai5mb250TWF0cml4ID8gZm9udE9iai5mb250TWF0cml4IDogX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgICAgIHZhciBib2xkID0gXCJub3JtYWxcIjtcblxuICAgICAgICBpZiAoZm9udE9iai5ibGFjaykge1xuICAgICAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgICAgIGJvbGQgPSBcImJvbGRcIjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuXG4gICAgICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgICAgIHNpemUgPSAtc2l6ZTtcbiAgICAgICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgICAgIGN1cnJlbnQuZm9udEZhbWlseSA9IGZvbnRPYmoubG9hZGVkTmFtZTtcbiAgICAgICAgY3VycmVudC5mb250V2VpZ2h0ID0gYm9sZDtcbiAgICAgICAgY3VycmVudC5mb250U3R5bGUgPSBpdGFsaWM7XG4gICAgICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgICAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICAgICAgY3VycmVudC55Y29vcmRzID0gW107XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuZFRleHRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRUZXh0KCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcblxuICAgICAgICBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSAmIF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkFERF9UT19QQVRIX0ZMQUcgJiYgY3VycmVudC50eHRFbGVtZW50ICYmIGN1cnJlbnQudHh0RWxlbWVudC5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjdXJyZW50LmVsZW1lbnQgPSBjdXJyZW50LnR4dEVsZW1lbnQ7XG4gICAgICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRMaW5lV2lkdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICAgICAgaWYgKHdpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuY3VycmVudC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRMaW5lQ2FwXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGluZUNhcChzdHlsZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldExpbmVKb2luXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldE1pdGVyTGltaXRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRNaXRlckxpbWl0KGxpbWl0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5taXRlckxpbWl0ID0gbGltaXQ7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFN0cm9rZUFscGhhXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3Ryb2tlQWxwaGEoc3Ryb2tlQWxwaGEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhID0gc3Ryb2tlQWxwaGE7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFN0cm9rZVJHQkNvbG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3Ryb2tlUkdCQ29sb3IociwgZywgYikge1xuICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VDc3NSZ2IociwgZywgYik7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldEZpbGxBbHBoYVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbGxBbHBoYShmaWxsQWxwaGEpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IGZpbGxBbHBoYTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RmlsbFJHQkNvbG9yXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RmlsbFJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IF91dGlsLlV0aWwubWFrZUNzc1JnYihyLCBnLCBiKTtcbiAgICAgICAgdGhpcy5jdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgICAgIHRoaXMuY3VycmVudC54Y29vcmRzID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudC55Y29vcmRzID0gW107XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFN0cm9rZUNvbG9yTlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0cm9rZUNvbG9yTihhcmdzKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IHRoaXMuX21ha2VDb2xvck5fUGF0dGVybihhcmdzKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RmlsbENvbG9yTlwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldEZpbGxDb2xvck4oYXJncykge1xuICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbENvbG9yID0gdGhpcy5fbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzaGFkaW5nRmlsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNoYWRpbmdGaWxsKGFyZ3MpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy52aWV3cG9ydC53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMudmlld3BvcnQuaGVpZ2h0O1xuXG4gICAgICAgIHZhciBpbnYgPSBfdXRpbC5VdGlsLmludmVyc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuXG4gICAgICAgIHZhciBibCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCBpbnYpO1xuXG4gICAgICAgIHZhciBiciA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIGhlaWdodF0sIGludik7XG5cbiAgICAgICAgdmFyIHVsID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIDBdLCBpbnYpO1xuXG4gICAgICAgIHZhciB1ciA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3dpZHRoLCBoZWlnaHRdLCBpbnYpO1xuXG4gICAgICAgIHZhciB4MCA9IE1hdGgubWluKGJsWzBdLCBiclswXSwgdWxbMF0sIHVyWzBdKTtcbiAgICAgICAgdmFyIHkwID0gTWF0aC5taW4oYmxbMV0sIGJyWzFdLCB1bFsxXSwgdXJbMV0pO1xuICAgICAgICB2YXIgeDEgPSBNYXRoLm1heChibFswXSwgYnJbMF0sIHVsWzBdLCB1clswXSk7XG4gICAgICAgIHZhciB5MSA9IE1hdGgubWF4KGJsWzFdLCBiclsxXSwgdWxbMV0sIHVyWzFdKTtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4MCk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHkwKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHgxIC0geDApO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHkxIC0geTApO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCB0aGlzLl9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncykpO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZENoaWxkKHJlY3QpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJfbWFrZUNvbG9yTl9QYXR0ZXJuXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VDb2xvck5fUGF0dGVybihhcmdzKSB7XG4gICAgICAgIGlmIChhcmdzWzBdID09PSBcIlRpbGluZ1BhdHRlcm5cIikge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9tYWtlVGlsaW5nUGF0dGVybihhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9tYWtlVGlsaW5nUGF0dGVyblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlVGlsaW5nUGF0dGVybihhcmdzKSB7XG4gICAgICAgIHZhciBjb2xvciA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBvcGVyYXRvckxpc3QgPSBhcmdzWzJdO1xuICAgICAgICB2YXIgbWF0cml4ID0gYXJnc1szXSB8fCBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG5cbiAgICAgICAgdmFyIF9hcmdzJCA9IF9zbGljZWRUb0FycmF5KGFyZ3NbNF0sIDQpLFxuICAgICAgICAgICAgeDAgPSBfYXJncyRbMF0sXG4gICAgICAgICAgICB5MCA9IF9hcmdzJFsxXSxcbiAgICAgICAgICAgIHgxID0gX2FyZ3MkWzJdLFxuICAgICAgICAgICAgeTEgPSBfYXJncyRbM107XG5cbiAgICAgICAgdmFyIHhzdGVwID0gYXJnc1s1XTtcbiAgICAgICAgdmFyIHlzdGVwID0gYXJnc1s2XTtcbiAgICAgICAgdmFyIHBhaW50VHlwZSA9IGFyZ3NbN107XG4gICAgICAgIHZhciB0aWxpbmdJZCA9IFwic2hhZGluZ1wiLmNvbmNhdChzaGFkaW5nQ291bnQrKyk7XG5cbiAgICAgICAgdmFyIF9VdGlsJGFwcGx5VHJhbnNmb3JtID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeDAsIHkwXSwgbWF0cml4KSxcbiAgICAgICAgICAgIF9VdGlsJGFwcGx5VHJhbnNmb3JtMiA9IF9zbGljZWRUb0FycmF5KF9VdGlsJGFwcGx5VHJhbnNmb3JtLCAyKSxcbiAgICAgICAgICAgIHR4MCA9IF9VdGlsJGFwcGx5VHJhbnNmb3JtMlswXSxcbiAgICAgICAgICAgIHR5MCA9IF9VdGlsJGFwcGx5VHJhbnNmb3JtMlsxXTtcblxuICAgICAgICB2YXIgX1V0aWwkYXBwbHlUcmFuc2Zvcm0zID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeDEsIHkxXSwgbWF0cml4KSxcbiAgICAgICAgICAgIF9VdGlsJGFwcGx5VHJhbnNmb3JtNCA9IF9zbGljZWRUb0FycmF5KF9VdGlsJGFwcGx5VHJhbnNmb3JtMywgMiksXG4gICAgICAgICAgICB0eDEgPSBfVXRpbCRhcHBseVRyYW5zZm9ybTRbMF0sXG4gICAgICAgICAgICB0eTEgPSBfVXRpbCRhcHBseVRyYW5zZm9ybTRbMV07XG5cbiAgICAgICAgdmFyIF9VdGlsJHNpbmd1bGFyVmFsdWVEZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobWF0cml4KSxcbiAgICAgICAgICAgIF9VdGlsJHNpbmd1bGFyVmFsdWVEZTIgPSBfc2xpY2VkVG9BcnJheShfVXRpbCRzaW5ndWxhclZhbHVlRGUsIDIpLFxuICAgICAgICAgICAgeHNjYWxlID0gX1V0aWwkc2luZ3VsYXJWYWx1ZURlMlswXSxcbiAgICAgICAgICAgIHlzY2FsZSA9IF9VdGlsJHNpbmd1bGFyVmFsdWVEZTJbMV07XG5cbiAgICAgICAgdmFyIHR4c3RlcCA9IHhzdGVwICogeHNjYWxlO1xuICAgICAgICB2YXIgdHlzdGVwID0geXN0ZXAgKiB5c2NhbGU7XG4gICAgICAgIHZhciB0aWxpbmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXR0ZXJuXCIpO1xuICAgICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCB0aWxpbmdJZCk7XG4gICAgICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInBhdHRlcm5Vbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB0eHN0ZXApO1xuICAgICAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgdHlzdGVwKTtcbiAgICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIlwiLmNvbmNhdCh0eDApKTtcbiAgICAgICAgdGlsaW5nLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIlwiLmNvbmNhdCh0eTApKTtcbiAgICAgICAgdmFyIHN2ZyA9IHRoaXMuc3ZnO1xuICAgICAgICB2YXIgdHJhbnNmb3JtTWF0cml4ID0gdGhpcy50cmFuc2Zvcm1NYXRyaXg7XG4gICAgICAgIHZhciBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgICAgICB2YXIgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh0eDEgLSB0eDAsIHR5MSAtIHR5MCk7XG4gICAgICAgIHRoaXMuc3ZnID0gYmJveDtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBtYXRyaXg7XG5cbiAgICAgICAgaWYgKHBhaW50VHlwZSA9PT0gMikge1xuICAgICAgICAgIHZhciBjc3NDb2xvciA9IF91dGlsLlV0aWwubWFrZUNzc1JnYi5hcHBseShfdXRpbC5VdGlsLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sb3IpKTtcblxuICAgICAgICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZXhlY3V0ZU9wVHJlZSh0aGlzLmNvbnZlcnRPcExpc3Qob3BlcmF0b3JMaXN0KSk7XG4gICAgICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IHRyYW5zZm9ybU1hdHJpeDtcbiAgICAgICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IGZpbGxDb2xvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3I7XG4gICAgICAgIHRpbGluZy5hcHBlbmRDaGlsZChiYm94LmNoaWxkTm9kZXNbMF0pO1xuICAgICAgICB0aGlzLmRlZnMuYXBwZW5kQ2hpbGQodGlsaW5nKTtcbiAgICAgICAgcmV0dXJuIFwidXJsKCNcIi5jb25jYXQodGlsaW5nSWQsIFwiKVwiKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX21ha2VTaGFkaW5nUGF0dGVyblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU2hhZGluZ1BhdHRlcm4oYXJncykge1xuICAgICAgICBzd2l0Y2ggKGFyZ3NbMF0pIHtcbiAgICAgICAgICBjYXNlIFwiUmFkaWFsQXhpYWxcIjpcbiAgICAgICAgICAgIHZhciBzaGFkaW5nSWQgPSBcInNoYWRpbmdcIi5jb25jYXQoc2hhZGluZ0NvdW50KyspO1xuICAgICAgICAgICAgdmFyIGNvbG9yU3RvcHMgPSBhcmdzWzNdO1xuICAgICAgICAgICAgdmFyIGdyYWRpZW50O1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGFyZ3NbMV0pIHtcbiAgICAgICAgICAgICAgY2FzZSBcImF4aWFsXCI6XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50MCA9IGFyZ3NbNF07XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50MSA9IGFyZ3NbNV07XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpsaW5lYXJHcmFkaWVudFwiKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJncmFkaWVudFVuaXRzXCIsIFwidXNlclNwYWNlT25Vc2VcIik7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4MVwiLCBwb2ludDBbMF0pO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieTFcIiwgcG9pbnQwWzFdKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIngyXCIsIHBvaW50MVswXSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5MlwiLCBwb2ludDFbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJyYWRpYWxcIjpcbiAgICAgICAgICAgICAgICB2YXIgZm9jYWxQb2ludCA9IGFyZ3NbNF07XG4gICAgICAgICAgICAgICAgdmFyIGNpcmNsZVBvaW50ID0gYXJnc1s1XTtcbiAgICAgICAgICAgICAgICB2YXIgZm9jYWxSYWRpdXMgPSBhcmdzWzZdO1xuICAgICAgICAgICAgICAgIHZhciBjaXJjbGVSYWRpdXMgPSBhcmdzWzddO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmFkaWFsR3JhZGllbnRcIik7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBzaGFkaW5nSWQpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZ3JhZGllbnRVbml0c1wiLCBcInVzZXJTcGFjZU9uVXNlXCIpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgY2lyY2xlUG9pbnRbMF0pO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3lcIiwgY2lyY2xlUG9pbnRbMV0pO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiclwiLCBjaXJjbGVSYWRpdXMpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnhcIiwgZm9jYWxQb2ludFswXSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmeVwiLCBmb2NhbFBvaW50WzFdKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZyXCIsIGZvY2FsUmFkaXVzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gUmFkaWFsQXhpYWwgdHlwZTogXCIuY29uY2F0KGFyZ3NbMV0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihjb2xvclN0b3BzKSxcbiAgICAgICAgICAgICAgICBfc3RlcDU7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNS5zKCk7ICEoX3N0ZXA1ID0gX2l0ZXJhdG9yNS5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbG9yU3RvcCA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgc3RvcCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnN0b3BcIik7XG4gICAgICAgICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9mZnNldFwiLCBjb2xvclN0b3BbMF0pO1xuICAgICAgICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdG9wLWNvbG9yXCIsIGNvbG9yU3RvcFsxXSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuYXBwZW5kQ2hpbGQoc3RvcCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBfaXRlcmF0b3I1LmUoZXJyKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIF9pdGVyYXRvcjUuZigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmRlZnMuYXBwZW5kQ2hpbGQoZ3JhZGllbnQpO1xuICAgICAgICAgICAgcmV0dXJuIFwidXJsKCNcIi5jb25jYXQoc2hhZGluZ0lkLCBcIilcIik7XG5cbiAgICAgICAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiVW5pbXBsZW1lbnRlZCBwYXR0ZXJuIE1lc2hcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcblxuICAgICAgICAgIGNhc2UgXCJEdW1teVwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiaG90cGlua1wiO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gSVIgdHlwZTogXCIuY29uY2F0KGFyZ3NbMF0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXREYXNoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgICAgICB0aGlzLmN1cnJlbnQuZGFzaEFycmF5ID0gZGFzaEFycmF5O1xuICAgICAgICB0aGlzLmN1cnJlbnQuZGFzaFBoYXNlID0gZGFzaFBoYXNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJjb25zdHJ1Y3RQYXRoXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3RydWN0UGF0aChvcHMsIGFyZ3MpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIHZhciB4ID0gY3VycmVudC54LFxuICAgICAgICAgICAgeSA9IGN1cnJlbnQueTtcbiAgICAgICAgdmFyIGQgPSBbXTtcbiAgICAgICAgdmFyIGogPSAwO1xuXG4gICAgICAgIHZhciBfaXRlcmF0b3I2ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIob3BzKSxcbiAgICAgICAgICAgIF9zdGVwNjtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAoX2l0ZXJhdG9yNi5zKCk7ICEoX3N0ZXA2ID0gX2l0ZXJhdG9yNi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICB2YXIgb3AgPSBfc3RlcDYudmFsdWU7XG5cbiAgICAgICAgICAgIHN3aXRjaCAob3AgfCAwKSB7XG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLnJlY3RhbmdsZTpcbiAgICAgICAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgICAgICAgdmFyIHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBhcmdzW2orK107XG4gICAgICAgICAgICAgICAgdmFyIHh3ID0geCArIHdpZHRoO1xuICAgICAgICAgICAgICAgIHZhciB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSksIFwiTFwiLCBwZih4dyksIHBmKHkpLCBcIkxcIiwgcGYoeHcpLCBwZih5aCksIFwiTFwiLCBwZih4KSwgcGYoeWgpLCBcIlpcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRvOlxuICAgICAgICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgICAgICBkLnB1c2goXCJNXCIsIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMubGluZVRvOlxuICAgICAgICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICAgICAgICBkLnB1c2goXCJMXCIsIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzpcbiAgICAgICAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgICAgICAgeSA9IGFyZ3NbaiArIDVdO1xuICAgICAgICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSksIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgICAgICAgaiArPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG8yOlxuICAgICAgICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoeCksIHBmKHkpLCBwZihhcmdzW2pdKSwgcGYoYXJnc1tqICsgMV0pLCBwZihhcmdzW2ogKyAyXSksIHBmKGFyZ3NbaiArIDNdKSk7XG4gICAgICAgICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzM6XG4gICAgICAgICAgICAgICAgeCA9IGFyZ3NbaiArIDJdO1xuICAgICAgICAgICAgICAgIHkgPSBhcmdzW2ogKyAzXTtcbiAgICAgICAgICAgICAgICBkLnB1c2goXCJDXCIsIHBmKGFyZ3Nbal0pLCBwZihhcmdzW2ogKyAxXSksIHBmKHgpLCBwZih5KSwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgICAgICAgIGQucHVzaChcIlpcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBfaXRlcmF0b3I2LmYoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGQgPSBkLmpvaW4oXCIgXCIpO1xuXG4gICAgICAgIGlmIChjdXJyZW50LnBhdGggJiYgb3BzLmxlbmd0aCA+IDAgJiYgb3BzWzBdICE9PSBfdXRpbC5PUFMucmVjdGFuZ2xlICYmIG9wc1swXSAhPT0gX3V0aWwuT1BTLm1vdmVUbykge1xuICAgICAgICAgIGQgPSBjdXJyZW50LnBhdGguZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIpICsgZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50LnBhdGggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXRoXCIpO1xuXG4gICAgICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmRDaGlsZChjdXJyZW50LnBhdGgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICAgICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBcIm5vbmVcIik7XG4gICAgICAgIGN1cnJlbnQuZWxlbWVudCA9IGN1cnJlbnQucGF0aDtcbiAgICAgICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVuZFBhdGhcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlbmRQYXRoKCkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgY3VycmVudC5wYXRoID0gbnVsbDtcblxuICAgICAgICBpZiAoIXRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjbGlwSWQgPSBcImNsaXBwYXRoXCIuY29uY2F0KGNsaXBDb3VudCsrKTtcbiAgICAgICAgdmFyIGNsaXBQYXRoID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Y2xpcFBhdGhcIik7XG4gICAgICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgY2xpcElkKTtcbiAgICAgICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgcG0odGhpcy50cmFuc2Zvcm1NYXRyaXgpKTtcbiAgICAgICAgdmFyIGNsaXBFbGVtZW50ID0gY3VycmVudC5lbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICBpZiAodGhpcy5wZW5kaW5nQ2xpcCA9PT0gXCJldmVub2RkXCIpIHtcbiAgICAgICAgICBjbGlwRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpcEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXJ1bGVcIiwgXCJub256ZXJvXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgICAgIGNsaXBQYXRoLmFwcGVuZENoaWxkKGNsaXBFbGVtZW50KTtcbiAgICAgICAgdGhpcy5kZWZzLmFwcGVuZENoaWxkKGNsaXBQYXRoKTtcblxuICAgICAgICBpZiAoY3VycmVudC5hY3RpdmVDbGlwVXJsKSB7XG4gICAgICAgICAgY3VycmVudC5jbGlwR3JvdXAgPSBudWxsO1xuICAgICAgICAgIHRoaXMuZXh0cmFTdGFjay5mb3JFYWNoKGZ1bmN0aW9uIChwcmV2KSB7XG4gICAgICAgICAgICBwcmV2LmNsaXBHcm91cCA9IG51bGw7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXBhdGhcIiwgY3VycmVudC5hY3RpdmVDbGlwVXJsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQuYWN0aXZlQ2xpcFVybCA9IFwidXJsKCNcIi5jb25jYXQoY2xpcElkLCBcIilcIik7XG4gICAgICAgIHRoaXMudGdycCA9IG51bGw7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsaXBcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbGlwKHR5cGUpIHtcbiAgICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IHR5cGU7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlUGF0aFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlUGF0aCgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQucGF0aCkge1xuICAgICAgICAgIHZhciBkID0gXCJcIi5jb25jYXQoY3VycmVudC5wYXRoLmdldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiKSwgXCJaXCIpO1xuICAgICAgICAgIGN1cnJlbnQucGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIiwgZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0TGVhZGluZ1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldExlYWRpbmcobGVhZGluZykge1xuICAgICAgICB0aGlzLmN1cnJlbnQubGVhZGluZyA9IC1sZWFkaW5nO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRUZXh0UmlzZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRleHRSaXNlKHRleHRSaXNlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHRleHRSaXNlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRUZXh0UmVuZGVyaW5nTW9kZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRleHRSZW5kZXJpbmdNb2RlKHRleHRSZW5kZXJpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMuY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9IHRleHRSZW5kZXJpbmdNb2RlO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRIU2NhbGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIU2NhbGUoc2NhbGUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0UmVuZGVyaW5nSW50ZW50XCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UmVuZGVyaW5nSW50ZW50KGludGVudCkge31cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0RmxhdG5lc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRGbGF0bmVzcyhmbGF0bmVzcykge31cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0R1N0YXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0R1N0YXRlKHN0YXRlcykge1xuICAgICAgICB2YXIgX2l0ZXJhdG9yNyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHN0YXRlcyksXG4gICAgICAgICAgICBfc3RlcDc7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmb3IgKF9pdGVyYXRvcjcucygpOyAhKF9zdGVwNyA9IF9pdGVyYXRvcjcubigpKS5kb25lOykge1xuICAgICAgICAgICAgdmFyIF9zdGVwNyR2YWx1ZSA9IF9zbGljZWRUb0FycmF5KF9zdGVwNy52YWx1ZSwgMiksXG4gICAgICAgICAgICAgICAga2V5ID0gX3N0ZXA3JHZhbHVlWzBdLFxuICAgICAgICAgICAgICAgIHZhbHVlID0gX3N0ZXA3JHZhbHVlWzFdO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICBjYXNlIFwiTFdcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldExpbmVXaWR0aCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldExpbmVKb2luKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiTUxcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREYXNoKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQodmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJGTFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmxhdG5lc3ModmFsdWUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGb250KHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0cm9rZUFscGhhKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICBjYXNlIFwiY2FcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnNldEZpbGxBbHBoYSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGdyYXBoaWMgc3RhdGUgb3BlcmF0b3IgXCIuY29uY2F0KGtleSkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNy5lKGVycik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiZmlsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbGwoKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuXG4gICAgICAgIGlmIChjdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIGN1cnJlbnQuZmlsbENvbG9yKTtcbiAgICAgICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInN0cm9rZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHN0cm9rZSgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuX3NldFN0cm9rZUF0dHJpYnV0ZXMoY3VycmVudC5lbGVtZW50KTtcblxuICAgICAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9zZXRTdHJva2VBdHRyaWJ1dGVzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0cm9rZUF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgICAgICB2YXIgbGluZVdpZHRoU2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICB2YXIgZGFzaEFycmF5ID0gY3VycmVudC5kYXNoQXJyYXk7XG5cbiAgICAgICAgaWYgKGxpbmVXaWR0aFNjYWxlICE9PSAxICYmIGRhc2hBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGFzaEFycmF5ID0gZGFzaEFycmF5Lm1hcChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lV2lkdGhTY2FsZSAqIHZhbHVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZVwiLCBjdXJyZW50LnN0cm9rZUNvbG9yKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1vcGFjaXR5XCIsIGN1cnJlbnQuc3Ryb2tlQWxwaGEpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgcGYoY3VycmVudC5taXRlckxpbWl0KSk7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2UtbGluZWNhcFwiLCBjdXJyZW50LmxpbmVDYXApO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWxpbmVqb2luXCIsIGN1cnJlbnQubGluZUpvaW4pO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLXdpZHRoXCIsIHBmKGxpbmVXaWR0aFNjYWxlICogY3VycmVudC5saW5lV2lkdGgpICsgXCJweFwiKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1kYXNoYXJyYXlcIiwgZGFzaEFycmF5Lm1hcChwZikuam9pbihcIiBcIikpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIiwgcGYobGluZVdpZHRoU2NhbGUgKiBjdXJyZW50LmRhc2hQaGFzZSkgKyBcInB4XCIpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJlb0ZpbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBlb0ZpbGwoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgICAgIHRoaXMuY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJmaWxsU3Ryb2tlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmlsbFN0cm9rZSgpIHtcbiAgICAgICAgdGhpcy5zdHJva2UoKTtcbiAgICAgICAgdGhpcy5maWxsKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImVvRmlsbFN0cm9rZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGVvRmlsbFN0cm9rZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudC5lbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlU3Ryb2tlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VTdHJva2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlRmlsbFN0cm9rZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICAgICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImNsb3NlRU9GaWxsU3Ryb2tlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2VFT0ZpbGxTdHJva2UoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuZW9GaWxsU3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhaW50U29saWRDb2xvckltYWdlTWFza1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhaW50U29saWRDb2xvckltYWdlTWFzaygpIHtcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpyZWN0XCIpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIjBcIik7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIFwiMXB4XCIpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIFwiMXB4XCIpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCB0aGlzLmN1cnJlbnQuZmlsbENvbG9yKTtcblxuICAgICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZENoaWxkKHJlY3QpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYWludEltYWdlWE9iamVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhaW50SW1hZ2VYT2JqZWN0KG9iaklkKSB7XG4gICAgICAgIHZhciBpbWdEYXRhID0gb2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChvYmpJZCkgOiB0aGlzLm9ianMuZ2V0KG9iaklkKTtcblxuICAgICAgICBpZiAoIWltZ0RhdGEpIHtcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJEZXBlbmRlbnQgaW1hZ2Ugd2l0aCBvYmplY3QgSUQgXCIuY29uY2F0KG9iaklkLCBcIiBpcyBub3QgcmVhZHkgeWV0XCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYWludElubGluZUltYWdlWE9iamVjdFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEsIG1hc2spIHtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgICB2YXIgaW1nU3JjID0gY29udmVydEltZ0RhdGFUb1BuZyhpbWdEYXRhLCB0aGlzLmZvcmNlRGF0YVNjaGVtYSwgISFtYXNrKTtcbiAgICAgICAgdmFyIGNsaXByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQgPSBjbGlwcmVjdDtcbiAgICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgICAgdmFyIGltZ0VsID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6aW1hZ2VcIik7XG4gICAgICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKFhMSU5LX05TLCBcInhsaW5rOmhyZWZcIiwgaW1nU3JjKTtcbiAgICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1oZWlnaHQpKTtcbiAgICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkgKyBcInB4XCIpO1xuICAgICAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpICsgXCJweFwiKTtcbiAgICAgICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgXCJzY2FsZShcIi5jb25jYXQocGYoMSAvIHdpZHRoKSwgXCIgXCIpLmNvbmNhdChwZigtMSAvIGhlaWdodCksIFwiKVwiKSk7XG5cbiAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICBtYXNrLmFwcGVuZENoaWxkKGltZ0VsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZENoaWxkKGltZ0VsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwYWludEltYWdlTWFza1hPYmplY3RcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYWludEltYWdlTWFza1hPYmplY3QoaW1nRGF0YSkge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgdmFyIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgICAgICB2YXIgZmlsbENvbG9yID0gY3VycmVudC5maWxsQ29sb3I7XG4gICAgICAgIGN1cnJlbnQubWFza0lkID0gXCJtYXNrXCIuY29uY2F0KG1hc2tDb3VudCsrKTtcbiAgICAgICAgdmFyIG1hc2sgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzptYXNrXCIpO1xuICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaWRcIiwgY3VycmVudC5tYXNrSWQpO1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIFwiMFwiKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgcGYod2lkdGgpKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgZmlsbENvbG9yKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm1hc2tcIiwgXCJ1cmwoI1wiLmNvbmNhdChjdXJyZW50Lm1hc2tJZCwgXCIpXCIpKTtcbiAgICAgICAgdGhpcy5kZWZzLmFwcGVuZENoaWxkKG1hc2spO1xuXG4gICAgICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kQ2hpbGQocmVjdCk7XG5cbiAgICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhLCBtYXNrKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicGFpbnRGb3JtWE9iamVjdEJlZ2luXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRyaXgpICYmIG1hdHJpeC5sZW5ndGggPT09IDYpIHtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybShtYXRyaXhbMF0sIG1hdHJpeFsxXSwgbWF0cml4WzJdLCBtYXRyaXhbM10sIG1hdHJpeFs0XSwgbWF0cml4WzVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiYm94KSB7XG4gICAgICAgICAgdmFyIHdpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gICAgICAgICAgdmFyIGhlaWdodCA9IGJib3hbM10gLSBiYm94WzFdO1xuICAgICAgICAgIHZhciBjbGlwcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGJib3hbMF0pO1xuICAgICAgICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBiYm94WzFdKTtcbiAgICAgICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSk7XG4gICAgICAgICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSk7XG4gICAgICAgICAgdGhpcy5jdXJyZW50LmVsZW1lbnQgPSBjbGlwcmVjdDtcbiAgICAgICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInBhaW50Rm9ybVhPYmplY3RFbmRcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwYWludEZvcm1YT2JqZWN0RW5kKCkge31cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2luaXRpYWxpemVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdGlhbGl6ZSh2aWV3cG9ydCkge1xuICAgICAgICB2YXIgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh2aWV3cG9ydC53aWR0aCwgdmlld3BvcnQuaGVpZ2h0KTtcbiAgICAgICAgdmFyIGRlZmluaXRpb25zID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6ZGVmc1wiKTtcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGRlZmluaXRpb25zKTtcbiAgICAgICAgdGhpcy5kZWZzID0gZGVmaW5pdGlvbnM7XG4gICAgICAgIHZhciByb290R3JvdXAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgICAgICByb290R3JvdXAuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0cmFuc2Zvcm1cIiwgcG0odmlld3BvcnQudHJhbnNmb3JtKSk7XG4gICAgICAgIHN2Zy5hcHBlbmRDaGlsZChyb290R3JvdXApO1xuICAgICAgICB0aGlzLnN2ZyA9IHJvb3RHcm91cDtcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiX2Vuc3VyZUNsaXBHcm91cFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVDbGlwR3JvdXAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50LmNsaXBHcm91cCkge1xuICAgICAgICAgIHZhciBjbGlwR3JvdXAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgICAgICAgIGNsaXBHcm91cC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCB0aGlzLmN1cnJlbnQuYWN0aXZlQ2xpcFVybCk7XG4gICAgICAgICAgdGhpcy5zdmcuYXBwZW5kQ2hpbGQoY2xpcEdyb3VwKTtcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuY2xpcEdyb3VwID0gY2xpcEdyb3VwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudC5jbGlwR3JvdXA7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcIl9lbnN1cmVUcmFuc2Zvcm1Hcm91cFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRncnApIHtcbiAgICAgICAgICB0aGlzLnRncnAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgICAgICAgIHRoaXMudGdycC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBwbSh0aGlzLnRyYW5zZm9ybU1hdHJpeCkpO1xuXG4gICAgICAgICAgaWYgKHRoaXMuY3VycmVudC5hY3RpdmVDbGlwVXJsKSB7XG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVDbGlwR3JvdXAoKS5hcHBlbmRDaGlsZCh0aGlzLnRncnApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN2Zy5hcHBlbmRDaGlsZCh0aGlzLnRncnApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRncnA7XG4gICAgICB9XG4gICAgfV0pO1xuXG4gICAgcmV0dXJuIFNWR0dyYXBoaWNzO1xuICB9KCk7XG59XG5cbi8qKiovIH0pLFxuLyogMjE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd19wZGZqc19yZXF1aXJlX18oMikpO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG52YXIgX25ldHdvcmtfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyMCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IFwiZGVmYXVsdFwiOiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbjtcblxudmFyIGZzID0gcmVxdWlyZShcImZzXCIpO1xuXG52YXIgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuXG52YXIgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG5cbnZhciB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuXG52YXIgZmlsZVVyaVJlZ2V4ID0gL15maWxlOlxcL1xcL1xcL1thLXpBLVpdOlxcLy87XG5cbmZ1bmN0aW9uIHBhcnNlVXJsKHNvdXJjZVVybCkge1xuICB2YXIgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHNvdXJjZVVybCk7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gXCJmaWxlOlwiIHx8IHBhcnNlZFVybC5ob3N0KSB7XG4gICAgcmV0dXJuIHBhcnNlZFVybDtcbiAgfVxuXG4gIGlmICgvXlthLXpdOlsvXFxcXF0vaS50ZXN0KHNvdXJjZVVybCkpIHtcbiAgICByZXR1cm4gdXJsLnBhcnNlKFwiZmlsZTovLy9cIi5jb25jYXQoc291cmNlVXJsKSk7XG4gIH1cblxuICBpZiAoIXBhcnNlZFVybC5ob3N0KSB7XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gXCJmaWxlOlwiO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlZFVybDtcbn1cblxudmFyIFBERk5vZGVTdHJlYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZOb2RlU3RyZWFtKHNvdXJjZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOb2RlU3RyZWFtKTtcblxuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmwoc291cmNlLnVybCk7XG4gICAgdGhpcy5pc0h0dHAgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICAgIHRoaXMuaXNGc1VybCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCI7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERk5vZGVTdHJlYW0sIFt7XG4gICAga2V5OiBcImdldEZ1bGxSZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RnVsbFJlYWRlcigpIHtcbiAgICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZOb2RlU3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKSA6IG5ldyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VSZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByYW5nZVJlYWRlciA9IHRoaXMuaXNGc1VybCA/IG5ldyBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcih0aGlzLCBzdGFydCwgZW5kKSA6IG5ldyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCk7XG5cbiAgICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG5cbiAgICAgIHJldHVybiByYW5nZVJlYWRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsQWxsUmVxdWVzdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgICBpZiAodGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWFkZXJzID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zbGljZSgwKTtcblxuICAgICAgcmVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uIChyZWFkZXIpIHtcbiAgICAgICAgcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wcm9ncmVzc2l2ZURhdGFMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA/IHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9sb2FkZWQgOiAwO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZOb2RlU3RyZWFtO1xufSgpO1xuXG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSBQREZOb2RlU3RyZWFtO1xuXG52YXIgQmFzZUZ1bGxSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlRnVsbFJlYWRlcihzdHJlYW0pIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQmFzZUZ1bGxSZWFkZXIpO1xuXG4gICAgdGhpcy5fdXJsID0gc3RyZWFtLnVybDtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdmFyIHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fY29udGVudExlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcblxuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEJhc2VGdWxsUmVhZGVyLCBbe1xuICAgIGtleTogXCJyZWFkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVhZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICAgIHZhciBjaHVuaywgYnVmZmVyO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcblxuICAgICAgICAgICAgICAgIGlmICghKGNodW5rID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0aGlzLnJlYWQoKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub25Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICAgICAgICAgICAgbG9hZGVkOiB0aGlzLl9sb2FkZWQsXG4gICAgICAgICAgICAgICAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBidWZmZXIgPSBuZXcgVWludDhBcnJheShjaHVuaykuYnVmZmVyO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgICAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwocmVhc29uKSB7XG4gICAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICAgIHRoaXMuX2Vycm9yKHJlYXNvbik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHJlYXNvbik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZXJyb3IocmVhc29uKSB7XG4gICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcblxuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0UmVhZGFibGVTdHJlYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlYWRhYmxlU3RyZWFtLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVhZGFibGVTdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICBfdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICAgICAgX3RoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIF90aGlzLl9lcnJvcihyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICB0aGlzLl9lcnJvcihuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJzdHJlYW1pbmcgaXMgZGlzYWJsZWRcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhlYWRlcnNSZWFkeVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpbGVuYW1lXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1JhbmdlU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNSYW5nZVN1cHBvcnRlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNTdHJlYW1pbmdTdXBwb3J0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gQmFzZUZ1bGxSZWFkZXI7XG59KCk7XG5cbnZhciBCYXNlUmFuZ2VSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCYXNlUmFuZ2VSZWFkZXIoc3RyZWFtKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJhc2VSYW5nZVJlYWRlcik7XG5cbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtID0gbnVsbDtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB2YXIgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCYXNlUmFuZ2VSZWFkZXIsIFt7XG4gICAga2V5OiBcInJlYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZWFkMiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKCkge1xuICAgICAgICB2YXIgY2h1bmssIGJ1ZmZlcjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5wcm9taXNlO1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICBjaHVuayA9IHRoaXMuX3JlYWRhYmxlU3RyZWFtLnJlYWQoKTtcblxuICAgICAgICAgICAgICAgIGlmICghKGNodW5rID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHRoaXMucmVhZCgpKTtcblxuICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBfcmVhZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGlmICghdGhpcy5fcmVhZGFibGVTdHJlYW0pIHtcbiAgICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RyZWFtLmRlc3Ryb3kocmVhc29uKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2Vycm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lcnJvcihyZWFzb24pIHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuXG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRSZWFkYWJsZVN0cmVhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UmVhZGFibGVTdHJlYW0ocmVhZGFibGVTdHJlYW0pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgICAgcmVhZGFibGVTdHJlYW0ub24oXCJyZWFkYWJsZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5fcmVhZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlYWRhYmxlU3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgX3RoaXMyLl9kb25lID0gdHJ1ZTtcblxuICAgICAgICBfdGhpczIuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIH0pO1xuICAgICAgcmVhZGFibGVTdHJlYW0ub24oXCJlcnJvclwiLCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIF90aGlzMi5fZXJyb3IocmVhc29uKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RyZWFtaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJhc2VSYW5nZVJlYWRlcjtcbn0oKTtcblxuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdE9wdGlvbnMocGFyc2VkVXJsLCBoZWFkZXJzKSB7XG4gIHJldHVybiB7XG4gICAgcHJvdG9jb2w6IHBhcnNlZFVybC5wcm90b2NvbCxcbiAgICBhdXRoOiBwYXJzZWRVcmwuYXV0aCxcbiAgICBob3N0OiBwYXJzZWRVcmwuaG9zdG5hbWUsXG4gICAgcG9ydDogcGFyc2VkVXJsLnBvcnQsXG4gICAgcGF0aDogcGFyc2VkVXJsLnBhdGgsXG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IGhlYWRlcnNcbiAgfTtcbn1cblxudmFyIFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUZ1bGxSZWFkZXIpIHtcbiAgX2luaGVyaXRzKFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyLCBfQmFzZUZ1bGxSZWFkZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIpO1xuXG4gIGZ1bmN0aW9uIFBERk5vZGVTdHJlYW1GdWxsUmVhZGVyKHN0cmVhbSkge1xuICAgIHZhciBfdGhpczM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIpO1xuXG4gICAgX3RoaXMzID0gX3N1cGVyLmNhbGwodGhpcywgc3RyZWFtKTtcblxuICAgIHZhciBoYW5kbGVSZXNwb25zZSA9IGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKFwiTWlzc2luZyBQREYgXFxcIlwiLmNvbmNhdChfdGhpczMuX3VybCwgXCJcXFwiLlwiKSk7XG4gICAgICAgIF90aGlzMy5fc3RvcmVkRXJyb3IgPSBlcnJvcjtcblxuICAgICAgICBfdGhpczMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpczMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgX3RoaXMzLl9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG5cbiAgICAgIHZhciBnZXRSZXNwb25zZUhlYWRlciA9IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMy5fcmVhZGFibGVTdHJlYW0uaGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldO1xuICAgICAgfTtcblxuICAgICAgdmFyIF92YWxpZGF0ZVJhbmdlUmVxdWVzdCA9ICgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcykoe1xuICAgICAgICBnZXRSZXNwb25zZUhlYWRlcjogZ2V0UmVzcG9uc2VIZWFkZXIsXG4gICAgICAgIGlzSHR0cDogc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IF90aGlzMy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogX3RoaXMzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pLFxuICAgICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyA9IF92YWxpZGF0ZVJhbmdlUmVxdWVzdC5hbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoID0gX3ZhbGlkYXRlUmFuZ2VSZXF1ZXN0LnN1Z2dlc3RlZExlbmd0aDtcblxuICAgICAgX3RoaXMzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgX3RoaXMzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IF90aGlzMy5fY29udGVudExlbmd0aDtcbiAgICAgIF90aGlzMy5fZmlsZW5hbWUgPSAoMCwgX25ldHdvcmtfdXRpbHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcikoZ2V0UmVzcG9uc2VIZWFkZXIpO1xuICAgIH07XG5cbiAgICBfdGhpczMuX3JlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKF90aGlzMy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIF90aGlzMy5fcmVxdWVzdCA9IGh0dHAucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyhfdGhpczMuX3VybCwgc3RyZWFtLmh0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfdGhpczMuX3JlcXVlc3QgPSBodHRwcy5yZXF1ZXN0KGNyZWF0ZVJlcXVlc3RPcHRpb25zKF90aGlzMy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfVxuXG4gICAgX3RoaXMzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgX3RoaXMzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcblxuICAgICAgX3RoaXMzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcblxuICAgIF90aGlzMy5fcmVxdWVzdC5lbmQoKTtcblxuICAgIHJldHVybiBfdGhpczM7XG4gIH1cblxuICByZXR1cm4gUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXI7XG59KEJhc2VGdWxsUmVhZGVyKTtcblxudmFyIFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Jhc2VSYW5nZVJlYWRlcikge1xuICBfaW5oZXJpdHMoUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyLCBfQmFzZVJhbmdlUmVhZGVyKTtcblxuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlcihQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIpO1xuXG4gIGZ1bmN0aW9uIFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgX3RoaXM0O1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERk5vZGVTdHJlYW1SYW5nZVJlYWRlcik7XG5cbiAgICBfdGhpczQgPSBfc3VwZXIyLmNhbGwodGhpcywgc3RyZWFtKTtcbiAgICBfdGhpczQuX2h0dHBIZWFkZXJzID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzdHJlYW0uaHR0cEhlYWRlcnMpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHN0cmVhbS5odHRwSGVhZGVyc1twcm9wZXJ0eV07XG5cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIF90aGlzNC5faHR0cEhlYWRlcnNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgX3RoaXM0Ll9odHRwSGVhZGVycy5SYW5nZSA9IFwiYnl0ZXM9XCIuY29uY2F0KHN0YXJ0LCBcIi1cIikuY29uY2F0KGVuZCAtIDEpO1xuXG4gICAgdmFyIGhhbmRsZVJlc3BvbnNlID0gZnVuY3Rpb24gaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oXCJNaXNzaW5nIFBERiBcXFwiXCIuY29uY2F0KF90aGlzNC5fdXJsLCBcIlxcXCIuXCIpKTtcbiAgICAgICAgX3RoaXM0Ll9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIF90aGlzNC5fc2V0UmVhZGFibGVTdHJlYW0ocmVzcG9uc2UpO1xuICAgIH07XG5cbiAgICBfdGhpczQuX3JlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKF90aGlzNC5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIF90aGlzNC5fcmVxdWVzdCA9IGh0dHAucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyhfdGhpczQuX3VybCwgX3RoaXM0Ll9odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3RoaXM0Ll9yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyhfdGhpczQuX3VybCwgX3RoaXM0Ll9odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBfdGhpczQuX3JlcXVlc3Qub24oXCJlcnJvclwiLCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICBfdGhpczQuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIH0pO1xuXG4gICAgX3RoaXM0Ll9yZXF1ZXN0LmVuZCgpO1xuXG4gICAgcmV0dXJuIF90aGlzNDtcbiAgfVxuXG4gIHJldHVybiBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXI7XG59KEJhc2VSYW5nZVJlYWRlcik7XG5cbnZhciBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZUZ1bGxSZWFkZXIyKSB7XG4gIF9pbmhlcml0cyhQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyLCBfQmFzZUZ1bGxSZWFkZXIyKTtcblxuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlcihQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKTtcblxuICBmdW5jdGlvbiBQREZOb2RlU3RyZWFtRnNGdWxsUmVhZGVyKHN0cmVhbSkge1xuICAgIHZhciBfdGhpczU7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcik7XG5cbiAgICBfdGhpczUgPSBfc3VwZXIzLmNhbGwodGhpcywgc3RyZWFtKTtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudChfdGhpczUuX3VybC5wYXRoKTtcblxuICAgIGlmIChmaWxlVXJpUmVnZXgudGVzdChfdGhpczUuX3VybC5ocmVmKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIH1cblxuICAgIGZzLmxzdGF0KHBhdGgsIGZ1bmN0aW9uIChlcnJvciwgc3RhdCkge1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvci5jb2RlID09PSBcIkVOT0VOVFwiKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihcIk1pc3NpbmcgUERGIFxcXCJcIi5jb25jYXQocGF0aCwgXCJcXFwiLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBfdGhpczUuX3N0b3JlZEVycm9yID0gZXJyb3I7XG5cbiAgICAgICAgX3RoaXM1Ll9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgX3RoaXM1Ll9jb250ZW50TGVuZ3RoID0gc3RhdC5zaXplO1xuXG4gICAgICBfdGhpczUuX3NldFJlYWRhYmxlU3RyZWFtKGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aCkpO1xuXG4gICAgICBfdGhpczUuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM1O1xuICB9XG5cbiAgcmV0dXJuIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXI7XG59KEJhc2VGdWxsUmVhZGVyKTtcblxudmFyIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVJhbmdlUmVhZGVyMikge1xuICBfaW5oZXJpdHMoUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIsIF9CYXNlUmFuZ2VSZWFkZXIyKTtcblxuICB2YXIgX3N1cGVyNCA9IF9jcmVhdGVTdXBlcihQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcik7XG5cbiAgZnVuY3Rpb24gUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIoc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIF90aGlzNjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOb2RlU3RyZWFtRnNSYW5nZVJlYWRlcik7XG5cbiAgICBfdGhpczYgPSBfc3VwZXI0LmNhbGwodGhpcywgc3RyZWFtKTtcbiAgICB2YXIgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudChfdGhpczYuX3VybC5wYXRoKTtcblxuICAgIGlmIChmaWxlVXJpUmVnZXgudGVzdChfdGhpczYuX3VybC5ocmVmKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIH1cblxuICAgIF90aGlzNi5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoLCB7XG4gICAgICBzdGFydDogc3RhcnQsXG4gICAgICBlbmQ6IGVuZCAtIDFcbiAgICB9KSk7XG5cbiAgICByZXR1cm4gX3RoaXM2O1xuICB9XG5cbiAgcmV0dXJuIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyO1xufShCYXNlUmFuZ2VSZWFkZXIpO1xuXG4vKioqLyB9KSxcbi8qIDIyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yID0gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcjtcbmV4cG9ydHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlciA9IGV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXI7XG5leHBvcnRzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzID0gdmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXM7XG5leHBvcnRzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMgPSB2YWxpZGF0ZVJlc3BvbnNlU3RhdHVzO1xuXG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUpO1xuXG52YXIgX2NvbnRlbnRfZGlzcG9zaXRpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyMSk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKF9yZWYpIHtcbiAgdmFyIGdldFJlc3BvbnNlSGVhZGVyID0gX3JlZi5nZXRSZXNwb25zZUhlYWRlcixcbiAgICAgIGlzSHR0cCA9IF9yZWYuaXNIdHRwLFxuICAgICAgcmFuZ2VDaHVua1NpemUgPSBfcmVmLnJhbmdlQ2h1bmtTaXplLFxuICAgICAgZGlzYWJsZVJhbmdlID0gX3JlZi5kaXNhYmxlUmFuZ2U7XG4gICgwLCBfdXRpbC5hc3NlcnQpKHJhbmdlQ2h1bmtTaXplID4gMCwgXCJSYW5nZSBjaHVuayBzaXplIG11c3QgYmUgbGFyZ2VyIHRoYW4gemVyb1wiKTtcbiAgdmFyIHJldHVyblZhbHVlcyA9IHtcbiAgICBhbGxvd1JhbmdlUmVxdWVzdHM6IGZhbHNlLFxuICAgIHN1Z2dlc3RlZExlbmd0aDogdW5kZWZpbmVkXG4gIH07XG4gIHZhciBsZW5ndGggPSBwYXJzZUludChnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtTGVuZ3RoXCIpLCAxMCk7XG5cbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGxlbmd0aCkpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG5cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDw9IDIgKiByYW5nZUNodW5rU2l6ZSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cblxuICBpZiAoZGlzYWJsZVJhbmdlIHx8ICFpc0h0dHApIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG5cbiAgaWYgKGdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuXG4gIHZhciBjb250ZW50RW5jb2RpbmcgPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuXG4gIGlmIChjb250ZW50RW5jb2RpbmcgIT09IFwiaWRlbnRpdHlcIikge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cblxuICByZXR1cm5WYWx1ZXMuYWxsb3dSYW5nZVJlcXVlc3RzID0gdHJ1ZTtcbiAgcmV0dXJuIHJldHVyblZhbHVlcztcbn1cblxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihnZXRSZXNwb25zZUhlYWRlcikge1xuICB2YXIgY29udGVudERpc3Bvc2l0aW9uID0gZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LURpc3Bvc2l0aW9uXCIpO1xuXG4gIGlmIChjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICB2YXIgZmlsZW5hbWUgPSAoMCwgX2NvbnRlbnRfZGlzcG9zaXRpb24uZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKShjb250ZW50RGlzcG9zaXRpb24pO1xuXG4gICAgaWYgKGZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZmlsZW5hbWUgPSBkZWNvZGVVUklDb21wb25lbnQoZmlsZW5hbWUpO1xuICAgICAgfSBjYXRjaCAoZXgpIHt9XG4gICAgfVxuXG4gICAgaWYgKC9cXC5wZGYkL2kudGVzdChmaWxlbmFtZSkpIHtcbiAgICAgIHJldHVybiBmaWxlbmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcihzdGF0dXMsIHVybCkge1xuICBpZiAoc3RhdHVzID09PSA0MDQgfHwgc3RhdHVzID09PSAwICYmIHVybC5zdGFydHNXaXRoKFwiZmlsZTpcIikpIHtcbiAgICByZXR1cm4gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oJ01pc3NpbmcgUERGIFwiJyArIHVybCArICdcIi4nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgX3V0aWwuVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uKFwiVW5leHBlY3RlZCBzZXJ2ZXIgcmVzcG9uc2UgKFwiICsgc3RhdHVzICsgJykgd2hpbGUgcmV0cmlldmluZyBQREYgXCInICsgdXJsICsgJ1wiLicsIHN0YXR1cyk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuLyoqKi8gfSksXG4vKiAyMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyID0gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyO1xuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHsgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTsgfVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhKFN5bWJvbC5pdGVyYXRvciBpbiBPYmplY3QoYXJyKSkpIHJldHVybjsgdmFyIF9hcnIgPSBbXTsgdmFyIF9uID0gdHJ1ZTsgdmFyIF9kID0gZmFsc2U7IHZhciBfZSA9IHVuZGVmaW5lZDsgdHJ5IHsgZm9yICh2YXIgX2kgPSBhcnJbU3ltYm9sLml0ZXJhdG9yXSgpLCBfczsgIShfbiA9IChfcyA9IF9pLm5leHQoKSkuZG9uZSk7IF9uID0gdHJ1ZSkgeyBfYXJyLnB1c2goX3MudmFsdWUpOyBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7IH0gfSBjYXRjaCAoZXJyKSB7IF9kID0gdHJ1ZTsgX2UgPSBlcnI7IH0gZmluYWxseSB7IHRyeSB7IGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjsgfVxuXG5mdW5jdGlvbiBnZXRGaWxlbmFtZUZyb21Db250ZW50RGlzcG9zaXRpb25IZWFkZXIoY29udGVudERpc3Bvc2l0aW9uKSB7XG4gIHZhciBuZWVkc0VuY29kaW5nRml4dXAgPSB0cnVlO1xuICB2YXIgdG1wID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCpcIiwgXCJpXCIpLmV4ZWMoY29udGVudERpc3Bvc2l0aW9uKTtcblxuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIHZhciBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSB1bmVzY2FwZShmaWxlbmFtZSk7XG4gICAgZmlsZW5hbWUgPSByZmM1OTg3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzIwNDdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIHJldHVybiBmaXh1cEVuY29kaW5nKGZpbGVuYW1lKTtcbiAgfVxuXG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuXG4gIGlmICh0bXApIHtcbiAgICB2YXIgX2ZpbGVuYW1lID0gcmZjMjA0N2RlY29kZSh0bXApO1xuXG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoX2ZpbGVuYW1lKTtcbiAgfVxuXG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuXG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG5cbiAgICB2YXIgX2ZpbGVuYW1lMiA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG5cbiAgICBfZmlsZW5hbWUyID0gcmZjMjA0N2RlY29kZShfZmlsZW5hbWUyKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhfZmlsZW5hbWUyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRvUGFyYW1SZWdFeHAoYXR0cmlidXRlUGF0dGVybiwgZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChcIig/Ol58OylcXFxccypcIiArIGF0dHJpYnV0ZVBhdHRlcm4gKyBcIlxcXFxzKj1cXFxccypcIiArIFwiKFwiICsgJ1teXCI7XFxcXHNdW147XFxcXHNdKicgKyBcInxcIiArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFxcIj8pK1wiPycgKyBcIilcIiwgZmxhZ3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGJ5dGVzID0gQXJyYXkuZnJvbSh2YWx1ZSwgZnVuY3Rpb24gKGNoKSB7XG4gICAgICAgICAgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKC9edXRmLT84JC9pLnRlc3QoZW5jb2RpbmcpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZSh2YWx1ZSkpO1xuICAgICAgICAgICAgbmVlZHNFbmNvZGluZ0ZpeHVwID0gZmFsc2U7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZml4dXBFbmNvZGluZyh2YWx1ZSkge1xuICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXAgJiYgL1tcXHg4MC1cXHhmZl0vLnRlc3QodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJ1dGYtOFwiLCB2YWx1ZSk7XG5cbiAgICAgIGlmIChuZWVkc0VuY29kaW5nRml4dXApIHtcbiAgICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwiaXNvLTg4NTktMVwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmZjMjIzMWdldHBhcmFtKGNvbnRlbnREaXNwb3NpdGlvblN0cikge1xuICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgdmFyIG1hdGNoO1xuICAgIHZhciBpdGVyID0gdG9QYXJhbVJlZ0V4cChcImZpbGVuYW1lXFxcXCooKD8hMFxcXFxkKVxcXFxkKykoXFxcXCo/KVwiLCBcImlnXCIpO1xuXG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9tYXRjaCA9IG1hdGNoLFxuICAgICAgICAgIF9tYXRjaDIgPSBfc2xpY2VkVG9BcnJheShfbWF0Y2gsIDQpLFxuICAgICAgICAgIG4gPSBfbWF0Y2gyWzFdLFxuICAgICAgICAgIHF1b3QgPSBfbWF0Y2gyWzJdLFxuICAgICAgICAgIHBhcnQgPSBfbWF0Y2gyWzNdO1xuXG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuXG4gICAgICBpZiAobiBpbiBtYXRjaGVzKSB7XG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG5cbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIGZvciAodmFyIF9uMiA9IDA7IF9uMiA8IG1hdGNoZXMubGVuZ3RoOyArK19uMikge1xuICAgICAgaWYgKCEoX24yIGluIG1hdGNoZXMpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgX21hdGNoZXMkX24gPSBfc2xpY2VkVG9BcnJheShtYXRjaGVzW19uMl0sIDIpLFxuICAgICAgICAgIF9xdW90ID0gX21hdGNoZXMkX25bMF0sXG4gICAgICAgICAgX3BhcnQgPSBfbWF0Y2hlcyRfblsxXTtcblxuICAgICAgX3BhcnQgPSByZmMyNjE2dW5xdW90ZShfcGFydCk7XG5cbiAgICAgIGlmIChfcXVvdCkge1xuICAgICAgICBfcGFydCA9IHVuZXNjYXBlKF9wYXJ0KTtcblxuICAgICAgICBpZiAoX24yID09PSAwKSB7XG4gICAgICAgICAgX3BhcnQgPSByZmM1OTg3ZGVjb2RlKF9wYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwYXJ0cy5wdXNoKF9wYXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFydHMuam9pbihcIlwiKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJmYzI2MTZ1bnF1b3RlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykpIHtcbiAgICAgIHZhciBwYXJ0cyA9IHZhbHVlLnNsaWNlKDEpLnNwbGl0KCdcXFxcXCInKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcXVvdGluZGV4ID0gcGFydHNbaV0uaW5kZXhPZignXCInKTtcblxuICAgICAgICBpZiAocXVvdGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0uc2xpY2UoMCwgcXVvdGluZGV4KTtcbiAgICAgICAgICBwYXJ0cy5sZW5ndGggPSBpICsgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0ucmVwbGFjZSgvXFxcXCguKS9nLCBcIiQxXCIpO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZSA9IHBhcnRzLmpvaW4oJ1wiJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmZjNTk4N2RlY29kZShleHR2YWx1ZSkge1xuICAgIHZhciBlbmNvZGluZ2VuZCA9IGV4dHZhbHVlLmluZGV4T2YoXCInXCIpO1xuXG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICB2YXIgbGFuZ3ZhbHVlID0gZXh0dmFsdWUuc2xpY2UoZW5jb2RpbmdlbmQgKyAxKTtcbiAgICB2YXIgdmFsdWUgPSBsYW5ndmFsdWUucmVwbGFjZSgvXlteJ10qJy8sIFwiXCIpO1xuICAgIHJldHVybiB0ZXh0ZGVjb2RlKGVuY29kaW5nLCB2YWx1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZmMyMDQ3ZGVjb2RlKHZhbHVlKSB7XG4gICAgaWYgKCF2YWx1ZS5zdGFydHNXaXRoKFwiPT9cIikgfHwgL1tcXHgwMC1cXHgxOVxceDgwLVxceGZmXS8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZSgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXy9nLCBcIiBcIik7XG4gICAgICAgIHRleHQgPSB0ZXh0LnJlcGxhY2UoLz0oWzAtOWEtZkEtRl17Mn0pL2csIGZ1bmN0aW9uIChtYXRjaCwgaGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoaGV4LCAxNikpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRleHQgPSBhdG9iKHRleHQpO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgcmV0dXJuIHRleHRkZWNvZGUoY2hhcnNldCwgdGV4dCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gXCJcIjtcbn1cblxuLyoqKi8gfSksXG4vKiAyMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193X3BkZmpzX3JlcXVpcmVfXygyKSk7XG5cbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5cbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMjIwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG47XG52YXIgT0tfUkVTUE9OU0UgPSAyMDA7XG52YXIgUEFSVElBTF9DT05URU5UX1JFU1BPTlNFID0gMjA2O1xuXG5mdW5jdGlvbiBnZXRBcnJheUJ1ZmZlcih4aHIpIHtcbiAgdmFyIGRhdGEgPSB4aHIucmVzcG9uc2U7XG5cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYXJyYXkgPSAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykoZGF0YSk7XG4gIHJldHVybiBhcnJheS5idWZmZXI7XG59XG5cbnZhciBOZXR3b3JrTWFuYWdlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE5ldHdvcmtNYW5hZ2VyKHVybCwgYXJncykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOZXR3b3JrTWFuYWdlcik7XG5cbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3QodXJsKTtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgYXJncy5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGFyZ3Mud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuXG4gICAgdGhpcy5nZXRYaHIgPSBhcmdzLmdldFhociB8fCBmdW5jdGlvbiBOZXR3b3JrTWFuYWdlcl9nZXRYaHIoKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfTtcblxuICAgIHRoaXMuY3VyclhocklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoTmV0d29ya01hbmFnZXIsIFt7XG4gICAga2V5OiBcInJlcXVlc3RSYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgbGlzdGVuZXJzKSB7XG4gICAgICB2YXIgYXJncyA9IHtcbiAgICAgICAgYmVnaW46IGJlZ2luLFxuICAgICAgICBlbmQ6IGVuZFxuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcmdzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVxdWVzdEZ1bGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdEZ1bGwobGlzdGVuZXJzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGxpc3RlbmVycyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWVzdChhcmdzKSB7XG4gICAgICB2YXIgeGhyID0gdGhpcy5nZXRYaHIoKTtcbiAgICAgIHZhciB4aHJJZCA9IHRoaXMuY3VyclhocklkKys7XG4gICAgICB2YXIgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF0gPSB7XG4gICAgICAgIHhocjogeGhyXG4gICAgICB9O1xuICAgICAgeGhyLm9wZW4oXCJHRVRcIiwgdGhpcy51cmwpO1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuXG4gICAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiB0aGlzLmh0dHBIZWFkZXJzKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmlzSHR0cCAmJiBcImJlZ2luXCIgaW4gYXJncyAmJiBcImVuZFwiIGluIGFyZ3MpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBcImJ5dGVzPVwiLmNvbmNhdChhcmdzLmJlZ2luLCBcIi1cIikuY29uY2F0KGFyZ3MuZW5kIC0gMSkpO1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gT0tfUkVTUE9OU0U7XG4gICAgICB9XG5cbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG5cbiAgICAgIGlmIChhcmdzLm9uRXJyb3IpIHtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgYXJncy5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgICAgeGhyLm9ucHJvZ3Jlc3MgPSB0aGlzLm9uUHJvZ3Jlc3MuYmluZCh0aGlzLCB4aHJJZCk7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCA9IGFyZ3Mub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IgPSBhcmdzLm9uRXJyb3I7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzID0gYXJncy5vblByb2dyZXNzO1xuICAgICAgeGhyLnNlbmQobnVsbCk7XG4gICAgICByZXR1cm4geGhySWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uUHJvZ3Jlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9ncmVzcyh4aHJJZCwgZXZ0KSB7XG4gICAgICB2YXIgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG5cbiAgICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAocGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcykge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vblByb2dyZXNzKGV2dCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm9uU3RhdGVDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgICB2YXIgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG5cbiAgICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgeGhyID0gcGVuZGluZ1JlcXVlc3QueGhyO1xuXG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPj0gMiAmJiBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCkge1xuICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkhlYWRlcnNSZWNlaXZlZCgpO1xuICAgICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghKHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG5cbiAgICAgIGlmICh4aHIuc3RhdHVzID09PSAwICYmIHRoaXMuaXNIdHRwKSB7XG4gICAgICAgIGlmIChwZW5kaW5nUmVxdWVzdC5vbkVycm9yKSB7XG4gICAgICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcih4aHIuc3RhdHVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHhoclN0YXR1cyA9IHhoci5zdGF0dXMgfHwgT0tfUkVTUE9OU0U7XG4gICAgICB2YXIgb2tfcmVzcG9uc2Vfb25fcmFuZ2VfcmVxdWVzdCA9IHhoclN0YXR1cyA9PT0gT0tfUkVTUE9OU0UgJiYgcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRTtcblxuICAgICAgaWYgKCFva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ICYmIHhoclN0YXR1cyAhPT0gcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IpIHtcbiAgICAgICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2h1bmsgPSBnZXRBcnJheUJ1ZmZlcih4aHIpO1xuXG4gICAgICBpZiAoeGhyU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0UpIHtcbiAgICAgICAgdmFyIHJhbmdlSGVhZGVyID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAvYnl0ZXMgKFxcZCspLShcXGQrKVxcLyhcXGQrKS8uZXhlYyhyYW5nZUhlYWRlcik7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgICAgYmVnaW46IHBhcnNlSW50KG1hdGNoZXNbMV0sIDEwKSxcbiAgICAgICAgICBjaHVuazogY2h1bmtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgICAgYmVnaW46IDAsXG4gICAgICAgICAgY2h1bms6IGNodW5rXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChwZW5kaW5nUmVxdWVzdC5vbkVycm9yKSB7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFJlcXVlc3RYaHJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmVxdWVzdFhocih4aHJJZCkge1xuICAgICAgcmV0dXJuIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUGVuZGluZ1JlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQZW5kaW5nUmVxdWVzdCh4aHJJZCkge1xuICAgICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhYm9ydFJlcXVlc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWJvcnRSZXF1ZXN0KHhocklkKSB7XG4gICAgICB2YXIgeGhyID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgICB4aHIuYWJvcnQoKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTmV0d29ya01hbmFnZXI7XG59KCk7XG5cbnZhciBQREZOZXR3b3JrU3RyZWFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGTmV0d29ya1N0cmVhbShzb3VyY2UpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGTmV0d29ya1N0cmVhbSk7XG5cbiAgICB0aGlzLl9zb3VyY2UgPSBzb3VyY2U7XG4gICAgdGhpcy5fbWFuYWdlciA9IG5ldyBOZXR3b3JrTWFuYWdlcihzb3VyY2UudXJsLCB7XG4gICAgICBodHRwSGVhZGVyczogc291cmNlLmh0dHBIZWFkZXJzLFxuICAgICAgd2l0aENyZWRlbnRpYWxzOiBzb3VyY2Uud2l0aENyZWRlbnRpYWxzXG4gICAgfSk7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBudWxsO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMgPSBbXTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZOZXR3b3JrU3RyZWFtLCBbe1xuICAgIGtleTogXCJfb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uUmFuZ2VSZXF1ZXN0UmVhZGVyQ2xvc2VkKHJlYWRlcikge1xuICAgICAgdmFyIGkgPSB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcblxuICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNwbGljZShpLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RnVsbFJlYWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRGdWxsUmVhZGVyKCkge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIodGhpcy5fbWFuYWdlciwgdGhpcy5fc291cmNlKTtcbiAgICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VSZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgICAgdmFyIHJlYWRlciA9IG5ldyBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIGJlZ2luLCBlbmQpO1xuICAgICAgcmVhZGVyLm9uQ2xvc2VkID0gdGhpcy5fb25SYW5nZVJlcXVlc3RSZWFkZXJDbG9zZWQuYmluZCh0aGlzKTtcblxuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG5cbiAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbEFsbFJlcXVlc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVhZGVycyA9IHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCk7XG5cbiAgICAgIHJlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZOZXR3b3JrU3RyZWFtO1xufSgpO1xuXG5leHBvcnRzLlBERk5ldHdvcmtTdHJlYW0gPSBQREZOZXR3b3JrU3RyZWFtO1xuXG52YXIgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKG1hbmFnZXIsIHNvdXJjZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIpO1xuXG4gICAgdGhpcy5fbWFuYWdlciA9IG1hbmFnZXI7XG4gICAgdmFyIGFyZ3MgPSB7XG4gICAgICBvbkhlYWRlcnNSZWNlaXZlZDogdGhpcy5fb25IZWFkZXJzUmVjZWl2ZWQuYmluZCh0aGlzKSxcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvbkVycm9yOiB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3VybCA9IHNvdXJjZS51cmw7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdEZ1bGwoYXJncyk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuXG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2NhY2hlZENodW5rcyA9IFtdO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlciwgW3tcbiAgICBrZXk6IFwiX29uSGVhZGVyc1JlY2VpdmVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkhlYWRlcnNSZWNlaXZlZCgpIHtcbiAgICAgIHZhciBmdWxsUmVxdWVzdFhocklkID0gdGhpcy5fZnVsbFJlcXVlc3RJZDtcblxuICAgICAgdmFyIGZ1bGxSZXF1ZXN0WGhyID0gdGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKGZ1bGxSZXF1ZXN0WGhySWQpO1xuXG4gICAgICB2YXIgZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiBmdWxsUmVxdWVzdFhoci5nZXRSZXNwb25zZUhlYWRlcihuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfdmFsaWRhdGVSYW5nZVJlcXVlc3QgPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IHRoaXMuX21hbmFnZXIuaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KSxcbiAgICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMgPSBfdmFsaWRhdGVSYW5nZVJlcXVlc3QuYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICAgIHN1Z2dlc3RlZExlbmd0aCA9IF92YWxpZGF0ZVJhbmdlUmVxdWVzdC5zdWdnZXN0ZWRMZW5ndGg7XG5cbiAgICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgICAgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzdWdnZXN0ZWRMZW5ndGggfHwgdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIHRoaXMuX2ZpbGVuYW1lID0gKDAsIF9uZXR3b3JrX3V0aWxzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIpKGdldFJlc3BvbnNlSGVhZGVyKTtcblxuICAgICAgaWYgKHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QoZnVsbFJlcXVlc3RYaHJJZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25Eb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvbmUoYXJncykge1xuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB2YXIgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuXG4gICAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogYXJncy5jaHVuayxcbiAgICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzLnB1c2goYXJncy5jaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fZG9uZSA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLl9jYWNoZWRDaHVua3MubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmZvckVhY2goZnVuY3Rpb24gKHJlcXVlc3RDYXBhYmlsaXR5KSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25FcnJvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25FcnJvcihzdGF0dXMpIHtcbiAgICAgIHZhciB1cmwgPSB0aGlzLl91cmw7XG4gICAgICB2YXIgZXhjZXB0aW9uID0gKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHN0YXR1cywgdXJsKTtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXhjZXB0aW9uO1xuXG4gICAgICB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnJlamVjdChleGNlcHRpb24pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0Q2FwYWJpbGl0eSkge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZWplY3QoZXhjZXB0aW9uKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgICAgdGhpcy5fY2FjaGVkQ2h1bmtzID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblByb2dyZXNzKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLm9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5vblByb2dyZXNzKHtcbiAgICAgICAgICBsb2FkZWQ6IGRhdGEubG9hZGVkLFxuICAgICAgICAgIHRvdGFsOiBkYXRhLmxlbmd0aENvbXB1dGFibGUgPyBkYXRhLnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgY2h1bmssIHJlcXVlc3RDYXBhYmlsaXR5O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjaHVuayA9IHRoaXMuX2NhY2hlZENodW5rcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgICAgcmV0dXJuIF9yZWFkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZWFkO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYW5jZWwocmVhc29uKSB7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdENhcGFiaWxpdHkpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG5cbiAgICAgIGlmICh0aGlzLl9tYW5hZ2VyLmlzUGVuZGluZ1JlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCkpIHtcbiAgICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlsZW5hbWVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9maWxlbmFtZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSYW5nZVN1cHBvcnRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RyZWFtaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbnRlbnRMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWFkZXJzUmVhZHlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERk5ldHdvcmtTdHJlYW1GdWxsUmVxdWVzdFJlYWRlcjtcbn0oKTtcblxudmFyIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZOZXR3b3JrU3RyZWFtUmFuZ2VSZXF1ZXN0UmVhZGVyKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcik7XG5cbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICB2YXIgYXJncyA9IHtcbiAgICAgIG9uRG9uZTogdGhpcy5fb25Eb25lLmJpbmQodGhpcyksXG4gICAgICBvblByb2dyZXNzOiB0aGlzLl9vblByb2dyZXNzLmJpbmQodGhpcylcbiAgICB9O1xuICAgIHRoaXMuX3JlcXVlc3RJZCA9IG1hbmFnZXIucmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGFyZ3MpO1xuICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMub25DbG9zZWQgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXIsIFt7XG4gICAga2V5OiBcIl9jbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2xvc2UoKSB7XG4gICAgICBpZiAodGhpcy5vbkNsb3NlZCkge1xuICAgICAgICB0aGlzLm9uQ2xvc2VkKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfb25Eb25lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbkRvbmUoZGF0YSkge1xuICAgICAgdmFyIGNodW5rID0gZGF0YS5jaHVuaztcblxuICAgICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcblxuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IGNodW5rO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMuZm9yRWFjaChmdW5jdGlvbiAocmVxdWVzdENhcGFiaWxpdHkpIHtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBkb25lOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3JlcXVlc3RzID0gW107XG5cbiAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vblByb2dyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblByb2dyZXNzKGV2dCkge1xuICAgICAgaWYgKCF0aGlzLmlzU3RyZWFtaW5nU3VwcG9ydGVkICYmIHRoaXMub25Qcm9ncmVzcykge1xuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBjaHVuaywgcmVxdWVzdENhcGFiaWxpdHk7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX3F1ZXVlZENodW5rICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgICAgICAgICAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwge1xuICAgICAgICAgICAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9kb25lKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eSA9ICgwLCBfdXRpbC5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBfcmVhZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuXG4gICAgICB0aGlzLl9yZXF1ZXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1ZXN0Q2FwYWJpbGl0eSkge1xuICAgICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcblxuICAgICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9yZXF1ZXN0SWQpKSB7XG4gICAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2Nsb3NlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RyZWFtaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERk5ldHdvcmtTdHJlYW1SYW5nZVJlcXVlc3RSZWFkZXI7XG59KCk7XG5cbi8qKiovIH0pLFxuLyogMjIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBERkZldGNoU3RyZWFtID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dfcGRmanNfcmVxdWlyZV9fKDIpKTtcblxudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXyg1KTtcblxudmFyIF9uZXR3b3JrX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygyMjApO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7IHRyeSB7IHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTsgdmFyIHZhbHVlID0gaW5mby52YWx1ZTsgfSBjYXRjaCAoZXJyb3IpIHsgcmVqZWN0KGVycm9yKTsgcmV0dXJuOyB9IGlmIChpbmZvLmRvbmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0gZWxzZSB7IFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTsgfSB9XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHZhciBzZWxmID0gdGhpcywgYXJncyA9IGFyZ3VtZW50czsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpOyBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7IH0gZnVuY3Rpb24gX3Rocm93KGVycikgeyBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTsgfSBfbmV4dCh1bmRlZmluZWQpOyB9KTsgfTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbjtcblxuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIgJiYgYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICBtb2RlOiBcImNvcnNcIixcbiAgICBjcmVkZW50aWFsczogd2l0aENyZWRlbnRpYWxzID8gXCJpbmNsdWRlXCIgOiBcInNhbWUtb3JpZ2luXCIsXG4gICAgcmVkaXJlY3Q6IFwiZm9sbG93XCJcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhodHRwSGVhZGVycykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG5cbiAgZm9yICh2YXIgcHJvcGVydHkgaW4gaHR0cEhlYWRlcnMpIHtcbiAgICB2YXIgdmFsdWUgPSBodHRwSGVhZGVyc1twcm9wZXJ0eV07XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBoZWFkZXJzLmFwcGVuZChwcm9wZXJ0eSwgdmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbnZhciBQREZGZXRjaFN0cmVhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERkZldGNoU3RyZWFtKHNvdXJjZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZGZXRjaFN0cmVhbSk7XG5cbiAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLmlzSHR0cCA9IC9eaHR0cHM/Oi9pLnRlc3Qoc291cmNlLnVybCk7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERkZldGNoU3RyZWFtLCBbe1xuICAgIGtleTogXCJnZXRGdWxsUmVhZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRmV0Y2hTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJlYWRlcih0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmFuZ2VSZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UmFuZ2VSZWFkZXIoYmVnaW4sIGVuZCkge1xuICAgICAgaWYgKGVuZCA8PSB0aGlzLl9wcm9ncmVzc2l2ZURhdGFMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcih0aGlzLCBiZWdpbiwgZW5kKTtcblxuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5wdXNoKHJlYWRlcik7XG5cbiAgICAgIHJldHVybiByZWFkZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbmNlbEFsbFJlcXVlc3RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVhZGVycyA9IHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCk7XG5cbiAgICAgIHJlYWRlcnMuZm9yRWFjaChmdW5jdGlvbiAocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPyB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlci5fbG9hZGVkIDogMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGRmV0Y2hTdHJlYW07XG59KCk7XG5cbmV4cG9ydHMuUERGRmV0Y2hTdHJlYW0gPSBQREZGZXRjaFN0cmVhbTtcblxudmFyIFBERkZldGNoU3RyZWFtUmVhZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGRmV0Y2hTdHJlYW1SZWFkZXIoc3RyZWFtKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZGZXRjaFN0cmVhbVJlYWRlcik7XG5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHRoaXMuX2ZpbGVuYW1lID0gbnVsbDtcbiAgICB2YXIgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gKDAsIF91dGlsLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG5cbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5faGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5fc3RyZWFtLmh0dHBIZWFkZXJzKTtcbiAgICB2YXIgdXJsID0gc291cmNlLnVybDtcbiAgICBmZXRjaCh1cmwsIGNyZWF0ZUZldGNoT3B0aW9ucyh0aGlzLl9oZWFkZXJzLCB0aGlzLl93aXRoQ3JlZGVudGlhbHMsIHRoaXMuX2Fib3J0Q29udHJvbGxlcikpLnRoZW4oZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICBpZiAoISgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuXG4gICAgICBfdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuXG4gICAgICB2YXIgZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiBnZXRSZXNwb25zZUhlYWRlcihuYW1lKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5oZWFkZXJzLmdldChuYW1lKTtcbiAgICAgIH07XG5cbiAgICAgIHZhciBfdmFsaWRhdGVSYW5nZVJlcXVlc3QgPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXI6IGdldFJlc3BvbnNlSGVhZGVyLFxuICAgICAgICBpc0h0dHA6IF90aGlzLl9zdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogX3RoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IF90aGlzLl9kaXNhYmxlUmFuZ2VcbiAgICAgIH0pLFxuICAgICAgICAgIGFsbG93UmFuZ2VSZXF1ZXN0cyA9IF92YWxpZGF0ZVJhbmdlUmVxdWVzdC5hbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgICAgc3VnZ2VzdGVkTGVuZ3RoID0gX3ZhbGlkYXRlUmFuZ2VSZXF1ZXN0LnN1Z2dlc3RlZExlbmd0aDtcblxuICAgICAgX3RoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICBfdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCBfdGhpcy5fY29udGVudExlbmd0aDtcbiAgICAgIF90aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG5cbiAgICAgIGlmICghX3RoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkICYmIF90aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIF90aGlzLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJTdHJlYW1pbmcgaXMgZGlzYWJsZWQuXCIpKTtcbiAgICAgIH1cbiAgICB9KVtcImNhdGNoXCJdKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZGZXRjaFN0cmVhbVJlYWRlciwgW3tcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlKCkge1xuICAgICAgICB2YXIgX3lpZWxkJHRoaXMkX3JlYWRlciRyLCB2YWx1ZSwgZG9uZSwgYnVmZmVyO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkZXIucmVhZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfeWllbGQkdGhpcyRfcmVhZGVyJHIgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgIHZhbHVlID0gX3lpZWxkJHRoaXMkX3JlYWRlciRyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvbmUgPSBfeWllbGQkdGhpcyRfcmVhZGVyJHIuZG9uZTtcblxuICAgICAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgICAgICAgICAgICAgICAgdG90YWw6IHRoaXMuX2NvbnRlbnRMZW5ndGhcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHZhbHVlKS5idWZmZXI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiByZWFkKCkge1xuICAgICAgICByZXR1cm4gX3JlYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoZWFkZXJzUmVhZHlcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaWxlbmFtZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250ZW50TGVuZ3RoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNSYW5nZVN1cHBvcnRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzU3RyZWFtaW5nU3VwcG9ydGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkZldGNoU3RyZWFtUmVhZGVyO1xufSgpO1xuXG52YXIgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIoc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlcik7XG5cbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIHZhciBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IHNvdXJjZS53aXRoQ3JlZGVudGlhbHMgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSAoMCwgX3V0aWwuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhc291cmNlLmRpc2FibGVTdHJlYW07XG5cbiAgICBpZiAodHlwZW9mIEFib3J0Q29udHJvbGxlciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIH1cblxuICAgIHRoaXMuX2hlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKHRoaXMuX3N0cmVhbS5odHRwSGVhZGVycyk7XG5cbiAgICB0aGlzLl9oZWFkZXJzLmFwcGVuZChcIlJhbmdlXCIsIFwiYnl0ZXM9XCIuY29uY2F0KGJlZ2luLCBcIi1cIikuY29uY2F0KGVuZCAtIDEpKTtcblxuICAgIHZhciB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKHRoaXMuX2hlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGlmICghKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmVzcG9uc2VTdGF0dXMpKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgICAgdGhyb3cgKDAsIF9uZXR3b3JrX3V0aWxzLmNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3IpKHJlc3BvbnNlLnN0YXR1cywgdXJsKTtcbiAgICAgIH1cblxuICAgICAgX3RoaXMyLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG5cbiAgICAgIF90aGlzMi5fcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgcmVhc29uO1xuICAgIH0pO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRmV0Y2hTdHJlYW1SYW5nZVJlYWRlciwgW3tcbiAgICBrZXk6IFwicmVhZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlYWQyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRfcmVhZGVyJHIyLCB2YWx1ZSwgZG9uZSwgYnVmZmVyO1xuXG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWFkZXIucmVhZCgpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICBfeWllbGQkdGhpcyRfcmVhZGVyJHIyID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBfeWllbGQkdGhpcyRfcmVhZGVyJHIyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGRvbmUgPSBfeWllbGQkdGhpcyRfcmVhZGVyJHIyLmRvbmU7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIGRvbmU6IGRvbmVcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9hZGVkICs9IHZhbHVlLmJ5dGVMZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLm9uUHJvZ3Jlc3Moe1xuICAgICAgICAgICAgICAgICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkodmFsdWUpLmJ1ZmZlcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZTogYnVmZmVyLFxuICAgICAgICAgICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgICAgIHJldHVybiBfcmVhZDIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlYWQ7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FuY2VsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGlmICh0aGlzLl9yZWFkZXIpIHtcbiAgICAgICAgdGhpcy5fcmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fYWJvcnRDb250cm9sbGVyKSB7XG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1N0cmVhbWluZ1N1cHBvcnRlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyO1xufSgpO1xuXG4vKioqLyB9KVxuLyoqKioqKi8gXSk7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBkZi5qcy5tYXAiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/pdfjs-dist-sig/es5/build/pdf.js\n");

/***/ }),

/***/ "./node_modules/pdfjs-dist-sig/es5/web/pdf_viewer.js":
/*!***********************************************************!*\
  !*** ./node_modules/pdfjs-dist-sig/es5/web/pdf_viewer.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/**\n * @licstart The following is the entire license notice for the\n * Javascript code in this page\n *\n * Copyright 2020 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * Javascript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__w_pdfjs_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__w_pdfjs_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__w_pdfjs_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__w_pdfjs_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__w_pdfjs_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__w_pdfjs_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __w_pdfjs_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__w_pdfjs_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __w_pdfjs_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__w_pdfjs_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__w_pdfjs_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__w_pdfjs_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __w_pdfjs_require__(__w_pdfjs_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"AnnotationLayerBuilder\", {\n  enumerable: true,\n  get: function get() {\n    return _annotation_layer_builder.AnnotationLayerBuilder;\n  }\n});\nObject.defineProperty(exports, \"DefaultAnnotationLayerFactory\", {\n  enumerable: true,\n  get: function get() {\n    return _annotation_layer_builder.DefaultAnnotationLayerFactory;\n  }\n});\nObject.defineProperty(exports, \"DefaultTextLayerFactory\", {\n  enumerable: true,\n  get: function get() {\n    return _text_layer_builder.DefaultTextLayerFactory;\n  }\n});\nObject.defineProperty(exports, \"TextLayerBuilder\", {\n  enumerable: true,\n  get: function get() {\n    return _text_layer_builder.TextLayerBuilder;\n  }\n});\nObject.defineProperty(exports, \"EventBus\", {\n  enumerable: true,\n  get: function get() {\n    return _ui_utils.EventBus;\n  }\n});\nObject.defineProperty(exports, \"NullL10n\", {\n  enumerable: true,\n  get: function get() {\n    return _ui_utils.NullL10n;\n  }\n});\nObject.defineProperty(exports, \"ProgressBar\", {\n  enumerable: true,\n  get: function get() {\n    return _ui_utils.ProgressBar;\n  }\n});\nObject.defineProperty(exports, \"PDFLinkService\", {\n  enumerable: true,\n  get: function get() {\n    return _pdf_link_service.PDFLinkService;\n  }\n});\nObject.defineProperty(exports, \"SimpleLinkService\", {\n  enumerable: true,\n  get: function get() {\n    return _pdf_link_service.SimpleLinkService;\n  }\n});\nObject.defineProperty(exports, \"DownloadManager\", {\n  enumerable: true,\n  get: function get() {\n    return _download_manager.DownloadManager;\n  }\n});\nObject.defineProperty(exports, \"GenericL10n\", {\n  enumerable: true,\n  get: function get() {\n    return _genericl10n.GenericL10n;\n  }\n});\nObject.defineProperty(exports, \"PDFFindController\", {\n  enumerable: true,\n  get: function get() {\n    return _pdf_find_controller.PDFFindController;\n  }\n});\nObject.defineProperty(exports, \"PDFHistory\", {\n  enumerable: true,\n  get: function get() {\n    return _pdf_history.PDFHistory;\n  }\n});\nObject.defineProperty(exports, \"PDFPageView\", {\n  enumerable: true,\n  get: function get() {\n    return _pdf_page_view.PDFPageView;\n  }\n});\nObject.defineProperty(exports, \"PDFSinglePageViewer\", {\n  enumerable: true,\n  get: function get() {\n    return _pdf_single_page_viewer.PDFSinglePageViewer;\n  }\n});\nObject.defineProperty(exports, \"PDFViewer\", {\n  enumerable: true,\n  get: function get() {\n    return _pdf_viewer.PDFViewer;\n  }\n});\n\nvar _annotation_layer_builder = __w_pdfjs_require__(1);\n\nvar _text_layer_builder = __w_pdfjs_require__(8);\n\nvar _ui_utils = __w_pdfjs_require__(3);\n\nvar _pdf_link_service = __w_pdfjs_require__(7);\n\nvar _download_manager = __w_pdfjs_require__(9);\n\nvar _genericl10n = __w_pdfjs_require__(11);\n\nvar _pdf_find_controller = __w_pdfjs_require__(13);\n\nvar _pdf_history = __w_pdfjs_require__(15);\n\nvar _pdf_page_view = __w_pdfjs_require__(16);\n\nvar _pdf_single_page_viewer = __w_pdfjs_require__(18);\n\nvar _pdf_viewer = __w_pdfjs_require__(20);\n\nvar pdfjsVersion = '2.6.347';\nvar pdfjsBuild = '3be9c65f';\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultAnnotationLayerFactory = exports.AnnotationLayerBuilder = void 0;\n\nvar _pdfjsLib = __w_pdfjs_require__(2);\n\nvar _ui_utils = __w_pdfjs_require__(3);\n\nvar _pdf_link_service = __w_pdfjs_require__(7);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar AnnotationLayerBuilder = /*#__PURE__*/function () {\n  function AnnotationLayerBuilder(_ref) {\n    var pageDiv = _ref.pageDiv,\n        pdfPage = _ref.pdfPage,\n        linkService = _ref.linkService,\n        downloadManager = _ref.downloadManager,\n        _ref$annotationStorag = _ref.annotationStorage,\n        annotationStorage = _ref$annotationStorag === void 0 ? null : _ref$annotationStorag,\n        _ref$imageResourcesPa = _ref.imageResourcesPath,\n        imageResourcesPath = _ref$imageResourcesPa === void 0 ? \"\" : _ref$imageResourcesPa,\n        _ref$renderInteractiv = _ref.renderInteractiveForms,\n        renderInteractiveForms = _ref$renderInteractiv === void 0 ? true : _ref$renderInteractiv,\n        _ref$l10n = _ref.l10n,\n        l10n = _ref$l10n === void 0 ? _ui_utils.NullL10n : _ref$l10n;\n\n    _classCallCheck(this, AnnotationLayerBuilder);\n\n    this.pageDiv = pageDiv;\n    this.pdfPage = pdfPage;\n    this.linkService = linkService;\n    this.downloadManager = downloadManager;\n    this.imageResourcesPath = imageResourcesPath;\n    this.renderInteractiveForms = renderInteractiveForms;\n    this.l10n = l10n;\n    this.annotationStorage = annotationStorage;\n    this.div = null;\n    this._cancelled = false;\n  }\n\n  _createClass(AnnotationLayerBuilder, [{\n    key: \"render\",\n    value: function render(viewport) {\n      var _this = this;\n\n      var intent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"display\";\n      return this.pdfPage.getAnnotations({\n        intent: intent\n      }).then(function (annotations) {\n        if (_this._cancelled) {\n          return;\n        }\n\n        if (annotations.length === 0) {\n          return;\n        }\n\n        var parameters = {\n          viewport: viewport.clone({\n            dontFlip: true\n          }),\n          div: _this.div,\n          annotations: annotations,\n          page: _this.pdfPage,\n          imageResourcesPath: _this.imageResourcesPath,\n          renderInteractiveForms: _this.renderInteractiveForms,\n          linkService: _this.linkService,\n          downloadManager: _this.downloadManager,\n          annotationStorage: _this.annotationStorage\n        };\n\n        if (_this.div) {\n          _pdfjsLib.AnnotationLayer.update(parameters);\n        } else {\n          _this.div = document.createElement(\"div\");\n          _this.div.className = \"annotationLayer\";\n\n          _this.pageDiv.appendChild(_this.div);\n\n          parameters.div = _this.div;\n\n          _pdfjsLib.AnnotationLayer.render(parameters);\n\n          _this.l10n.translate(_this.div);\n        }\n      });\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      this._cancelled = true;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (!this.div) {\n        return;\n      }\n\n      this.div.setAttribute(\"hidden\", \"true\");\n    }\n  }]);\n\n  return AnnotationLayerBuilder;\n}();\n\nexports.AnnotationLayerBuilder = AnnotationLayerBuilder;\n\nvar DefaultAnnotationLayerFactory = /*#__PURE__*/function () {\n  function DefaultAnnotationLayerFactory() {\n    _classCallCheck(this, DefaultAnnotationLayerFactory);\n  }\n\n  _createClass(DefaultAnnotationLayerFactory, [{\n    key: \"createAnnotationLayerBuilder\",\n    value: function createAnnotationLayerBuilder(pageDiv, pdfPage) {\n      var annotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var imageResourcesPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n      var renderInteractiveForms = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;\n      var l10n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _ui_utils.NullL10n;\n      return new AnnotationLayerBuilder({\n        pageDiv: pageDiv,\n        pdfPage: pdfPage,\n        imageResourcesPath: imageResourcesPath,\n        renderInteractiveForms: renderInteractiveForms,\n        linkService: new _pdf_link_service.SimpleLinkService(),\n        l10n: l10n,\n        annotationStorage: annotationStorage\n      });\n    }\n  }]);\n\n  return DefaultAnnotationLayerFactory;\n}();\n\nexports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nvar pdfjsLib;\n\nif (typeof window !== \"undefined\" && window[\"pdfjs-dist/build/pdf\"]) {\n  pdfjsLib = window[\"pdfjs-dist/build/pdf\"];\n} else {\n  pdfjsLib = __webpack_require__(/*! ../build/pdf.js */ \"./node_modules/pdfjs-dist-sig/es5/build/pdf.js\");\n}\n\nmodule.exports = pdfjsLib;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isValidRotation = isValidRotation;\nexports.isValidScrollMode = isValidScrollMode;\nexports.isValidSpreadMode = isValidSpreadMode;\nexports.isPortraitOrientation = isPortraitOrientation;\nexports.clamp = clamp;\nexports.getPDFFileNameFromURL = getPDFFileNameFromURL;\nexports.noContextMenuHandler = noContextMenuHandler;\nexports.parseQueryString = parseQueryString;\nexports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements;\nexports.getVisibleElements = getVisibleElements;\nexports.roundToDivide = roundToDivide;\nexports.getPageSizeInches = getPageSizeInches;\nexports.approximateFraction = approximateFraction;\nexports.getOutputScale = getOutputScale;\nexports.scrollIntoView = scrollIntoView;\nexports.watchScroll = watchScroll;\nexports.binarySearchFirstItem = binarySearchFirstItem;\nexports.normalizeWheelEventDirection = normalizeWheelEventDirection;\nexports.normalizeWheelEventDelta = normalizeWheelEventDelta;\nexports.waitOnEventOrTimeout = waitOnEventOrTimeout;\nexports.moveToEndOfArray = moveToEndOfArray;\nexports.WaitOnType = exports.animationStarted = exports.ProgressBar = exports.EventBus = exports.NullL10n = exports.SpreadMode = exports.ScrollMode = exports.TextLayerMode = exports.RendererType = exports.PresentationModeState = exports.VERTICAL_PADDING = exports.SCROLLBAR_PADDING = exports.MAX_AUTO_SCALE = exports.UNKNOWN_SCALE = exports.MAX_SCALE = exports.MIN_SCALE = exports.DEFAULT_SCALE = exports.DEFAULT_SCALE_VALUE = exports.CSS_UNITS = exports.AutoPrintRegExp = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(4));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nvar CSS_UNITS = 96.0 / 72.0;\nexports.CSS_UNITS = CSS_UNITS;\nvar DEFAULT_SCALE_VALUE = \"auto\";\nexports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE;\nvar DEFAULT_SCALE = 1.0;\nexports.DEFAULT_SCALE = DEFAULT_SCALE;\nvar MIN_SCALE = 0.1;\nexports.MIN_SCALE = MIN_SCALE;\nvar MAX_SCALE = 10.0;\nexports.MAX_SCALE = MAX_SCALE;\nvar UNKNOWN_SCALE = 0;\nexports.UNKNOWN_SCALE = UNKNOWN_SCALE;\nvar MAX_AUTO_SCALE = 1.25;\nexports.MAX_AUTO_SCALE = MAX_AUTO_SCALE;\nvar SCROLLBAR_PADDING = 40;\nexports.SCROLLBAR_PADDING = SCROLLBAR_PADDING;\nvar VERTICAL_PADDING = 5;\nexports.VERTICAL_PADDING = VERTICAL_PADDING;\nvar PresentationModeState = {\n  UNKNOWN: 0,\n  NORMAL: 1,\n  CHANGING: 2,\n  FULLSCREEN: 3\n};\nexports.PresentationModeState = PresentationModeState;\nvar RendererType = {\n  CANVAS: \"canvas\",\n  SVG: \"svg\"\n};\nexports.RendererType = RendererType;\nvar TextLayerMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_ENHANCE: 2\n};\nexports.TextLayerMode = TextLayerMode;\nvar ScrollMode = {\n  UNKNOWN: -1,\n  VERTICAL: 0,\n  HORIZONTAL: 1,\n  WRAPPED: 2\n};\nexports.ScrollMode = ScrollMode;\nvar SpreadMode = {\n  UNKNOWN: -1,\n  NONE: 0,\n  ODD: 1,\n  EVEN: 2\n};\nexports.SpreadMode = SpreadMode;\nvar AutoPrintRegExp = /\\bprint\\s*\\(/;\nexports.AutoPrintRegExp = AutoPrintRegExp;\n\nfunction formatL10nValue(text, args) {\n  if (!args) {\n    return text;\n  }\n\n  return text.replace(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, function (all, name) {\n    return name in args ? args[name] : \"{{\" + name + \"}}\";\n  });\n}\n\nvar NullL10n = {\n  getLanguage: function getLanguage() {\n    return _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n      return _regenerator[\"default\"].wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", \"en-us\");\n\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }))();\n  },\n  getDirection: function getDirection() {\n    return _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n      return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", \"ltr\");\n\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }))();\n  },\n  get: function get(property, args, fallback) {\n    return _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3() {\n      return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", formatL10nValue(fallback, args));\n\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3);\n    }))();\n  },\n  translate: function translate(element) {\n    return _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4() {\n      return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }))();\n  }\n};\nexports.NullL10n = NullL10n;\n\nfunction getOutputScale(ctx) {\n  var devicePixelRatio = window.devicePixelRatio || 1;\n  var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;\n  var pixelRatio = devicePixelRatio / backingStoreRatio;\n  return {\n    sx: pixelRatio,\n    sy: pixelRatio,\n    scaled: pixelRatio !== 1\n  };\n}\n\nfunction scrollIntoView(element, spot) {\n  var skipOverflowHiddenElements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var parent = element.offsetParent;\n\n  if (!parent) {\n    console.error(\"offsetParent is not set -- cannot scroll\");\n    return;\n  }\n\n  var offsetY = element.offsetTop + element.clientTop;\n  var offsetX = element.offsetLeft + element.clientLeft;\n\n  while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === \"hidden\") {\n    if (parent.dataset._scaleY) {\n      offsetY /= parent.dataset._scaleY;\n      offsetX /= parent.dataset._scaleX;\n    }\n\n    offsetY += parent.offsetTop;\n    offsetX += parent.offsetLeft;\n    parent = parent.offsetParent;\n\n    if (!parent) {\n      return;\n    }\n  }\n\n  if (spot) {\n    if (spot.top !== undefined) {\n      offsetY += spot.top;\n    }\n\n    if (spot.left !== undefined) {\n      offsetX += spot.left;\n      parent.scrollLeft = offsetX;\n    }\n  }\n\n  parent.scrollTop = offsetY;\n}\n\nfunction watchScroll(viewAreaElement, callback) {\n  var debounceScroll = function debounceScroll(evt) {\n    if (rAF) {\n      return;\n    }\n\n    rAF = window.requestAnimationFrame(function viewAreaElementScrolled() {\n      rAF = null;\n      var currentX = viewAreaElement.scrollLeft;\n      var lastX = state.lastX;\n\n      if (currentX !== lastX) {\n        state.right = currentX > lastX;\n      }\n\n      state.lastX = currentX;\n      var currentY = viewAreaElement.scrollTop;\n      var lastY = state.lastY;\n\n      if (currentY !== lastY) {\n        state.down = currentY > lastY;\n      }\n\n      state.lastY = currentY;\n      callback(state);\n    });\n  };\n\n  var state = {\n    right: true,\n    down: true,\n    lastX: viewAreaElement.scrollLeft,\n    lastY: viewAreaElement.scrollTop,\n    _eventHandler: debounceScroll\n  };\n  var rAF = null;\n  viewAreaElement.addEventListener(\"scroll\", debounceScroll, true);\n  return state;\n}\n\nfunction parseQueryString(query) {\n  var parts = query.split(\"&\");\n  var params = Object.create(null);\n\n  for (var i = 0, ii = parts.length; i < ii; ++i) {\n    var param = parts[i].split(\"=\");\n    var key = param[0].toLowerCase();\n    var value = param.length > 1 ? param[1] : null;\n    params[decodeURIComponent(key)] = decodeURIComponent(value);\n  }\n\n  return params;\n}\n\nfunction binarySearchFirstItem(items, condition) {\n  var minIndex = 0;\n  var maxIndex = items.length - 1;\n\n  if (maxIndex < 0 || !condition(items[maxIndex])) {\n    return items.length;\n  }\n\n  if (condition(items[minIndex])) {\n    return minIndex;\n  }\n\n  while (minIndex < maxIndex) {\n    var currentIndex = minIndex + maxIndex >> 1;\n    var currentItem = items[currentIndex];\n\n    if (condition(currentItem)) {\n      maxIndex = currentIndex;\n    } else {\n      minIndex = currentIndex + 1;\n    }\n  }\n\n  return minIndex;\n}\n\nfunction approximateFraction(x) {\n  if (Math.floor(x) === x) {\n    return [x, 1];\n  }\n\n  var xinv = 1 / x;\n  var limit = 8;\n\n  if (xinv > limit) {\n    return [1, limit];\n  } else if (Math.floor(xinv) === xinv) {\n    return [1, xinv];\n  }\n\n  var x_ = x > 1 ? xinv : x;\n  var a = 0,\n      b = 1,\n      c = 1,\n      d = 1;\n\n  while (true) {\n    var p = a + c,\n        q = b + d;\n\n    if (q > limit) {\n      break;\n    }\n\n    if (x_ <= p / q) {\n      c = p;\n      d = q;\n    } else {\n      a = p;\n      b = q;\n    }\n  }\n\n  var result;\n\n  if (x_ - a / b < c / d - x_) {\n    result = x_ === x ? [a, b] : [b, a];\n  } else {\n    result = x_ === x ? [c, d] : [d, c];\n  }\n\n  return result;\n}\n\nfunction roundToDivide(x, div) {\n  var r = x % div;\n  return r === 0 ? x : Math.round(x - r + div);\n}\n\nfunction getPageSizeInches(_ref) {\n  var view = _ref.view,\n      userUnit = _ref.userUnit,\n      rotate = _ref.rotate;\n\n  var _view = _slicedToArray(view, 4),\n      x1 = _view[0],\n      y1 = _view[1],\n      x2 = _view[2],\n      y2 = _view[3];\n\n  var changeOrientation = rotate % 180 !== 0;\n  var width = (x2 - x1) / 72 * userUnit;\n  var height = (y2 - y1) / 72 * userUnit;\n  return {\n    width: changeOrientation ? height : width,\n    height: changeOrientation ? width : height\n  };\n}\n\nfunction backtrackBeforeAllVisibleElements(index, views, top) {\n  if (index < 2) {\n    return index;\n  }\n\n  var elt = views[index].div;\n  var pageTop = elt.offsetTop + elt.clientTop;\n\n  if (pageTop >= top) {\n    elt = views[index - 1].div;\n    pageTop = elt.offsetTop + elt.clientTop;\n  }\n\n  for (var i = index - 2; i >= 0; --i) {\n    elt = views[i].div;\n\n    if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) {\n      break;\n    }\n\n    index = i;\n  }\n\n  return index;\n}\n\nfunction getVisibleElements(scrollEl, views) {\n  var sortByVisibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var horizontal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var top = scrollEl.scrollTop,\n      bottom = top + scrollEl.clientHeight;\n  var left = scrollEl.scrollLeft,\n      right = left + scrollEl.clientWidth;\n\n  function isElementBottomAfterViewTop(view) {\n    var element = view.div;\n    var elementBottom = element.offsetTop + element.clientTop + element.clientHeight;\n    return elementBottom > top;\n  }\n\n  function isElementRightAfterViewLeft(view) {\n    var element = view.div;\n    var elementRight = element.offsetLeft + element.clientLeft + element.clientWidth;\n    return elementRight > left;\n  }\n\n  var visible = [],\n      numViews = views.length;\n  var firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop);\n\n  if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) {\n    firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top);\n  }\n\n  var lastEdge = horizontal ? right : -1;\n\n  for (var i = firstVisibleElementInd; i < numViews; i++) {\n    var view = views[i],\n        element = view.div;\n    var currentWidth = element.offsetLeft + element.clientLeft;\n    var currentHeight = element.offsetTop + element.clientTop;\n    var viewWidth = element.clientWidth,\n        viewHeight = element.clientHeight;\n    var viewRight = currentWidth + viewWidth;\n    var viewBottom = currentHeight + viewHeight;\n\n    if (lastEdge === -1) {\n      if (viewBottom >= bottom) {\n        lastEdge = viewBottom;\n      }\n    } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) {\n      break;\n    }\n\n    if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) {\n      continue;\n    }\n\n    var hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom);\n    var hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right);\n    var percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0;\n    visible.push({\n      id: view.id,\n      x: currentWidth,\n      y: currentHeight,\n      view: view,\n      percent: percent\n    });\n  }\n\n  var first = visible[0],\n      last = visible[visible.length - 1];\n\n  if (sortByVisibility) {\n    visible.sort(function (a, b) {\n      var pc = a.percent - b.percent;\n\n      if (Math.abs(pc) > 0.001) {\n        return -pc;\n      }\n\n      return a.id - b.id;\n    });\n  }\n\n  return {\n    first: first,\n    last: last,\n    views: visible\n  };\n}\n\nfunction noContextMenuHandler(evt) {\n  evt.preventDefault();\n}\n\nfunction isDataSchema(url) {\n  var i = 0;\n  var ii = url.length;\n\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\n\nfunction getPDFFileNameFromURL(url) {\n  var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"document.pdf\";\n\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n\n  if (isDataSchema(url)) {\n    console.warn(\"getPDFFileNameFromURL: \" + 'ignoring \"data:\" URL for performance reasons.');\n    return defaultFilename;\n  }\n\n  var reURI = /^(?:(?:[^:]+:)?\\/\\/[^\\/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  var reFilename = /[^\\/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  var splitURI = reURI.exec(url);\n  var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n\n    if (suggestedFilename.includes(\"%\")) {\n      try {\n        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n      } catch (ex) {}\n    }\n  }\n\n  return suggestedFilename || defaultFilename;\n}\n\nfunction normalizeWheelEventDirection(evt) {\n  var delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY);\n  var angle = Math.atan2(evt.deltaY, evt.deltaX);\n\n  if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) {\n    delta = -delta;\n  }\n\n  return delta;\n}\n\nfunction normalizeWheelEventDelta(evt) {\n  var delta = normalizeWheelEventDirection(evt);\n  var MOUSE_DOM_DELTA_PIXEL_MODE = 0;\n  var MOUSE_DOM_DELTA_LINE_MODE = 1;\n  var MOUSE_PIXELS_PER_LINE = 30;\n  var MOUSE_LINES_PER_PAGE = 30;\n\n  if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) {\n    delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE;\n  } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) {\n    delta /= MOUSE_LINES_PER_PAGE;\n  }\n\n  return delta;\n}\n\nfunction isValidRotation(angle) {\n  return Number.isInteger(angle) && angle % 90 === 0;\n}\n\nfunction isValidScrollMode(mode) {\n  return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN;\n}\n\nfunction isValidSpreadMode(mode) {\n  return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN;\n}\n\nfunction isPortraitOrientation(size) {\n  return size.width <= size.height;\n}\n\nvar WaitOnType = {\n  EVENT: \"event\",\n  TIMEOUT: \"timeout\"\n};\nexports.WaitOnType = WaitOnType;\n\nfunction waitOnEventOrTimeout(_ref2) {\n  var target = _ref2.target,\n      name = _ref2.name,\n      _ref2$delay = _ref2.delay,\n      delay = _ref2$delay === void 0 ? 0 : _ref2$delay;\n  return new Promise(function (resolve, reject) {\n    if (_typeof(target) !== \"object\" || !(name && typeof name === \"string\") || !(Number.isInteger(delay) && delay >= 0)) {\n      throw new Error(\"waitOnEventOrTimeout - invalid parameters.\");\n    }\n\n    function handler(type) {\n      if (target instanceof EventBus) {\n        target._off(name, eventHandler);\n      } else {\n        target.removeEventListener(name, eventHandler);\n      }\n\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      resolve(type);\n    }\n\n    var eventHandler = handler.bind(null, WaitOnType.EVENT);\n\n    if (target instanceof EventBus) {\n      target._on(name, eventHandler);\n    } else {\n      target.addEventListener(name, eventHandler);\n    }\n\n    var timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT);\n    var timeout = setTimeout(timeoutHandler, delay);\n  });\n}\n\nvar animationStarted = new Promise(function (resolve) {\n  window.requestAnimationFrame(resolve);\n});\nexports.animationStarted = animationStarted;\n\nfunction dispatchDOMEvent(eventName) {\n  var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  throw new Error(\"Not implemented: dispatchDOMEvent\");\n}\n\nvar EventBus = /*#__PURE__*/function () {\n  function EventBus(options) {\n    _classCallCheck(this, EventBus);\n\n    this._listeners = Object.create(null);\n  }\n\n  _createClass(EventBus, [{\n    key: \"on\",\n    value: function on(eventName, listener) {\n      this._on(eventName, listener, {\n        external: true\n      });\n    }\n  }, {\n    key: \"off\",\n    value: function off(eventName, listener) {\n      this._off(eventName, listener, {\n        external: true\n      });\n    }\n  }, {\n    key: \"dispatch\",\n    value: function dispatch(eventName) {\n      var eventListeners = this._listeners[eventName];\n\n      if (!eventListeners || eventListeners.length === 0) {\n        return;\n      }\n\n      var args = Array.prototype.slice.call(arguments, 1);\n      var externalListeners;\n      eventListeners.slice(0).forEach(function (_ref3) {\n        var listener = _ref3.listener,\n            external = _ref3.external;\n\n        if (external) {\n          if (!externalListeners) {\n            externalListeners = [];\n          }\n\n          externalListeners.push(listener);\n          return;\n        }\n\n        listener.apply(null, args);\n      });\n\n      if (externalListeners) {\n        externalListeners.forEach(function (listener) {\n          listener.apply(null, args);\n        });\n        externalListeners = null;\n      }\n    }\n  }, {\n    key: \"_on\",\n    value: function _on(eventName, listener) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var eventListeners = this._listeners[eventName];\n\n      if (!eventListeners) {\n        this._listeners[eventName] = eventListeners = [];\n      }\n\n      eventListeners.push({\n        listener: listener,\n        external: (options && options.external) === true\n      });\n    }\n  }, {\n    key: \"_off\",\n    value: function _off(eventName, listener) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var eventListeners = this._listeners[eventName];\n\n      if (!eventListeners) {\n        return;\n      }\n\n      for (var i = 0, ii = eventListeners.length; i < ii; i++) {\n        if (eventListeners[i].listener === listener) {\n          eventListeners.splice(i, 1);\n          return;\n        }\n      }\n    }\n  }]);\n\n  return EventBus;\n}();\n\nexports.EventBus = EventBus;\n\nfunction clamp(v, min, max) {\n  return Math.min(Math.max(v, min), max);\n}\n\nvar ProgressBar = /*#__PURE__*/function () {\n  function ProgressBar(id) {\n    var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        height = _ref4.height,\n        width = _ref4.width,\n        units = _ref4.units;\n\n    _classCallCheck(this, ProgressBar);\n\n    this.visible = true;\n    this.div = document.querySelector(id + \" .progress\");\n    this.bar = this.div.parentNode;\n    this.height = height || 100;\n    this.width = width || 100;\n    this.units = units || \"%\";\n    this.div.style.height = this.height + this.units;\n    this.percent = 0;\n  }\n\n  _createClass(ProgressBar, [{\n    key: \"_updateBar\",\n    value: function _updateBar() {\n      if (this._indeterminate) {\n        this.div.classList.add(\"indeterminate\");\n        this.div.style.width = this.width + this.units;\n        return;\n      }\n\n      this.div.classList.remove(\"indeterminate\");\n      var progressSize = this.width * this._percent / 100;\n      this.div.style.width = progressSize + this.units;\n    }\n  }, {\n    key: \"setWidth\",\n    value: function setWidth(viewer) {\n      if (!viewer) {\n        return;\n      }\n\n      var container = viewer.parentNode;\n      var scrollbarWidth = container.offsetWidth - viewer.offsetWidth;\n\n      if (scrollbarWidth > 0) {\n        this.bar.style.width = \"calc(100% - \".concat(scrollbarWidth, \"px)\");\n      }\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      if (!this.visible) {\n        return;\n      }\n\n      this.visible = false;\n      this.bar.classList.add(\"hidden\");\n      document.body.classList.remove(\"loadingInProgress\");\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      if (this.visible) {\n        return;\n      }\n\n      this.visible = true;\n      document.body.classList.add(\"loadingInProgress\");\n      this.bar.classList.remove(\"hidden\");\n    }\n  }, {\n    key: \"percent\",\n    get: function get() {\n      return this._percent;\n    },\n    set: function set(val) {\n      this._indeterminate = isNaN(val);\n      this._percent = clamp(val, 0, 100);\n\n      this._updateBar();\n    }\n  }]);\n\n  return ProgressBar;\n}();\n\nexports.ProgressBar = ProgressBar;\n\nfunction moveToEndOfArray(arr, condition) {\n  var moved = [],\n      len = arr.length;\n  var write = 0;\n\n  for (var read = 0; read < len; ++read) {\n    if (condition(arr[read])) {\n      moved.push(arr[read]);\n    } else {\n      arr[write] = arr[read];\n      ++write;\n    }\n  }\n\n  for (var _read = 0; write < len; ++_read, ++write) {\n    arr[write] = moved[_read];\n  }\n}\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __w_pdfjs_require__(5);\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(module) {\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar runtime = function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined;\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n    return generator;\n  }\n\n  exports.wrap = wrap;\n\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n  var ContinueSentinel = {};\n\n  function Generator() {}\n\n  function GeneratorFunction() {}\n\n  function GeneratorFunctionPrototype() {}\n\n  var IteratorPrototype = {};\n\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\n  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\");\n\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function (genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === \"GeneratorFunction\" : false;\n  };\n\n  exports.mark = function (genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n\n        if (value && _typeof(value) === \"object\" && hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function (value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function (err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped;\n          resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function (resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n    }\n\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n\n  exports.AsyncIterator = AsyncIterator;\n\n  exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          context.sent = context._sent = context.arg;\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n        var record = tryCatch(innerFn, self, context);\n\n        if (record.type === \"normal\") {\n          state = context.done ? GenStateCompleted : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n\n    if (method === undefined) {\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator[\"return\"]) {\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (!info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      context[delegate.resultName] = info.value;\n      context.next = delegate.nextLoc;\n\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n    } else {\n      return info;\n    }\n\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  defineIteratorMethods(Gp);\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  Gp[iteratorSymbol] = function () {\n    return this;\n  };\n\n  Gp.toString = function () {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function (object) {\n    var keys = [];\n\n    for (var key in object) {\n      keys.push(key);\n    }\n\n    keys.reverse();\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n            next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    return {\n      next: doneResult\n    };\n  }\n\n  exports.values = values;\n\n  function doneResult() {\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n      this.method = \"next\";\n      this.arg = undefined;\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          if (name.charAt(0) === \"t\" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n    stop: function stop() {\n      this.done = true;\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry && (type === \"break\" || type === \"continue\") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" || record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n\n          return thrown;\n        }\n      }\n\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n  return exports;\n}((  false ? 0 : _typeof(module)) === \"object\" ? module.exports : {});\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n/* WEBPACK VAR INJECTION */}.call(this, __w_pdfjs_require__(6)(module)))\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nmodule.exports = function (module) {\n  if (!module.webpackPolyfill) {\n    module.deprecate = function () {};\n\n    module.paths = [];\n    if (!module.children) module.children = [];\n    Object.defineProperty(module, \"loaded\", {\n      enumerable: true,\n      get: function get() {\n        return module.l;\n      }\n    });\n    Object.defineProperty(module, \"id\", {\n      enumerable: true,\n      get: function get() {\n        return module.i;\n      }\n    });\n    module.webpackPolyfill = 1;\n  }\n\n  return module;\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleLinkService = exports.PDFLinkService = void 0;\n\nvar _ui_utils = __w_pdfjs_require__(3);\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar PDFLinkService = /*#__PURE__*/function () {\n  function PDFLinkService() {\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        eventBus = _ref.eventBus,\n        _ref$externalLinkTarg = _ref.externalLinkTarget,\n        externalLinkTarget = _ref$externalLinkTarg === void 0 ? null : _ref$externalLinkTarg,\n        _ref$externalLinkRel = _ref.externalLinkRel,\n        externalLinkRel = _ref$externalLinkRel === void 0 ? null : _ref$externalLinkRel,\n        _ref$externalLinkEnab = _ref.externalLinkEnabled,\n        externalLinkEnabled = _ref$externalLinkEnab === void 0 ? true : _ref$externalLinkEnab,\n        _ref$ignoreDestinatio = _ref.ignoreDestinationZoom,\n        ignoreDestinationZoom = _ref$ignoreDestinatio === void 0 ? false : _ref$ignoreDestinatio;\n\n    _classCallCheck(this, PDFLinkService);\n\n    this.eventBus = eventBus;\n    this.externalLinkTarget = externalLinkTarget;\n    this.externalLinkRel = externalLinkRel;\n    this.externalLinkEnabled = externalLinkEnabled;\n    this._ignoreDestinationZoom = ignoreDestinationZoom;\n    this.baseUrl = null;\n    this.pdfDocument = null;\n    this.pdfViewer = null;\n    this.pdfHistory = null;\n    this._pagesRefCache = null;\n  }\n\n  _createClass(PDFLinkService, [{\n    key: \"setDocument\",\n    value: function setDocument(pdfDocument) {\n      var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      this.baseUrl = baseUrl;\n      this.pdfDocument = pdfDocument;\n      this._pagesRefCache = Object.create(null);\n    }\n  }, {\n    key: \"setViewer\",\n    value: function setViewer(pdfViewer) {\n      this.pdfViewer = pdfViewer;\n    }\n  }, {\n    key: \"setHistory\",\n    value: function setHistory(pdfHistory) {\n      this.pdfHistory = pdfHistory;\n    }\n  }, {\n    key: \"navigateTo\",\n    value: function navigateTo(dest) {\n      var _this = this;\n\n      var goToDestination = function goToDestination(_ref2) {\n        var namedDest = _ref2.namedDest,\n            explicitDest = _ref2.explicitDest;\n        var destRef = explicitDest[0];\n        var pageNumber;\n\n        if (destRef instanceof Object) {\n          pageNumber = _this._cachedPageNumber(destRef);\n\n          if (pageNumber === null) {\n            _this.pdfDocument.getPageIndex(destRef).then(function (pageIndex) {\n              _this.cachePageRef(pageIndex + 1, destRef);\n\n              goToDestination({\n                namedDest: namedDest,\n                explicitDest: explicitDest\n              });\n            })[\"catch\"](function () {\n              console.error(\"PDFLinkService.navigateTo: \\\"\".concat(destRef, \"\\\" is not \") + \"a valid page reference, for dest=\\\"\".concat(dest, \"\\\".\"));\n            });\n\n            return;\n          }\n        } else if (Number.isInteger(destRef)) {\n          pageNumber = destRef + 1;\n        } else {\n          console.error(\"PDFLinkService.navigateTo: \\\"\".concat(destRef, \"\\\" is not \") + \"a valid destination reference, for dest=\\\"\".concat(dest, \"\\\".\"));\n          return;\n        }\n\n        if (!pageNumber || pageNumber < 1 || pageNumber > _this.pagesCount) {\n          console.error(\"PDFLinkService.navigateTo: \\\"\".concat(pageNumber, \"\\\" is not \") + \"a valid page number, for dest=\\\"\".concat(dest, \"\\\".\"));\n          return;\n        }\n\n        if (_this.pdfHistory) {\n          _this.pdfHistory.pushCurrentPosition();\n\n          _this.pdfHistory.push({\n            namedDest: namedDest,\n            explicitDest: explicitDest,\n            pageNumber: pageNumber\n          });\n        }\n\n        _this.pdfViewer.scrollPageIntoView({\n          pageNumber: pageNumber,\n          destArray: explicitDest,\n          ignoreDestinationZoom: _this._ignoreDestinationZoom\n        });\n      };\n\n      new Promise(function (resolve, reject) {\n        if (typeof dest === \"string\") {\n          _this.pdfDocument.getDestination(dest).then(function (destArray) {\n            resolve({\n              namedDest: dest,\n              explicitDest: destArray\n            });\n          });\n\n          return;\n        }\n\n        resolve({\n          namedDest: \"\",\n          explicitDest: dest\n        });\n      }).then(function (data) {\n        if (!Array.isArray(data.explicitDest)) {\n          console.error(\"PDFLinkService.navigateTo: \\\"\".concat(data.explicitDest, \"\\\" is\") + \" not a valid destination array, for dest=\\\"\".concat(dest, \"\\\".\"));\n          return;\n        }\n\n        goToDestination(data);\n      });\n    }\n  }, {\n    key: \"getDestinationHash\",\n    value: function getDestinationHash(dest) {\n      if (typeof dest === \"string\") {\n        return this.getAnchorUrl(\"#\" + escape(dest));\n      }\n\n      if (Array.isArray(dest)) {\n        var str = JSON.stringify(dest);\n        return this.getAnchorUrl(\"#\" + escape(str));\n      }\n\n      return this.getAnchorUrl(\"\");\n    }\n  }, {\n    key: \"getAnchorUrl\",\n    value: function getAnchorUrl(anchor) {\n      return (this.baseUrl || \"\") + anchor;\n    }\n  }, {\n    key: \"setHash\",\n    value: function setHash(hash) {\n      var pageNumber, dest;\n\n      if (hash.includes(\"=\")) {\n        var params = (0, _ui_utils.parseQueryString)(hash);\n\n        if (\"search\" in params) {\n          this.eventBus.dispatch(\"findfromurlhash\", {\n            source: this,\n            query: params.search.replace(/\"/g, \"\"),\n            phraseSearch: params.phrase === \"true\"\n          });\n        }\n\n        if (\"page\" in params) {\n          pageNumber = params.page | 0 || 1;\n        }\n\n        if (\"zoom\" in params) {\n          var zoomArgs = params.zoom.split(\",\");\n          var zoomArg = zoomArgs[0];\n          var zoomArgNumber = parseFloat(zoomArg);\n\n          if (!zoomArg.includes(\"Fit\")) {\n            dest = [null, {\n              name: \"XYZ\"\n            }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg];\n          } else {\n            if (zoomArg === \"Fit\" || zoomArg === \"FitB\") {\n              dest = [null, {\n                name: zoomArg\n              }];\n            } else if (zoomArg === \"FitH\" || zoomArg === \"FitBH\" || zoomArg === \"FitV\" || zoomArg === \"FitBV\") {\n              dest = [null, {\n                name: zoomArg\n              }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null];\n            } else if (zoomArg === \"FitR\") {\n              if (zoomArgs.length !== 5) {\n                console.error('PDFLinkService.setHash: Not enough parameters for \"FitR\".');\n              } else {\n                dest = [null, {\n                  name: zoomArg\n                }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0];\n              }\n            } else {\n              console.error(\"PDFLinkService.setHash: \\\"\".concat(zoomArg, \"\\\" is not \") + \"a valid zoom value.\");\n            }\n          }\n        }\n\n        if (dest) {\n          this.pdfViewer.scrollPageIntoView({\n            pageNumber: pageNumber || this.page,\n            destArray: dest,\n            allowNegativeOffset: true\n          });\n        } else if (pageNumber) {\n          this.page = pageNumber;\n        }\n\n        if (\"pagemode\" in params) {\n          this.eventBus.dispatch(\"pagemode\", {\n            source: this,\n            mode: params.pagemode\n          });\n        }\n\n        if (\"nameddest\" in params) {\n          this.navigateTo(params.nameddest);\n        }\n      } else {\n        dest = unescape(hash);\n\n        try {\n          dest = JSON.parse(dest);\n\n          if (!Array.isArray(dest)) {\n            dest = dest.toString();\n          }\n        } catch (ex) {}\n\n        if (typeof dest === \"string\" || isValidExplicitDestination(dest)) {\n          this.navigateTo(dest);\n          return;\n        }\n\n        console.error(\"PDFLinkService.setHash: \\\"\".concat(unescape(hash), \"\\\" is not \") + \"a valid destination.\");\n      }\n    }\n  }, {\n    key: \"executeNamedAction\",\n    value: function executeNamedAction(action) {\n      switch (action) {\n        case \"GoBack\":\n          if (this.pdfHistory) {\n            this.pdfHistory.back();\n          }\n\n          break;\n\n        case \"GoForward\":\n          if (this.pdfHistory) {\n            this.pdfHistory.forward();\n          }\n\n          break;\n\n        case \"NextPage\":\n          if (this.page < this.pagesCount) {\n            this.page++;\n          }\n\n          break;\n\n        case \"PrevPage\":\n          if (this.page > 1) {\n            this.page--;\n          }\n\n          break;\n\n        case \"LastPage\":\n          this.page = this.pagesCount;\n          break;\n\n        case \"FirstPage\":\n          this.page = 1;\n          break;\n\n        default:\n          break;\n      }\n\n      this.eventBus.dispatch(\"namedaction\", {\n        source: this,\n        action: action\n      });\n    }\n  }, {\n    key: \"cachePageRef\",\n    value: function cachePageRef(pageNum, pageRef) {\n      if (!pageRef) {\n        return;\n      }\n\n      var refStr = pageRef.gen === 0 ? \"\".concat(pageRef.num, \"R\") : \"\".concat(pageRef.num, \"R\").concat(pageRef.gen);\n      this._pagesRefCache[refStr] = pageNum;\n    }\n  }, {\n    key: \"_cachedPageNumber\",\n    value: function _cachedPageNumber(pageRef) {\n      var refStr = pageRef.gen === 0 ? \"\".concat(pageRef.num, \"R\") : \"\".concat(pageRef.num, \"R\").concat(pageRef.gen);\n      return this._pagesRefCache && this._pagesRefCache[refStr] || null;\n    }\n  }, {\n    key: \"isPageVisible\",\n    value: function isPageVisible(pageNumber) {\n      return this.pdfViewer.isPageVisible(pageNumber);\n    }\n  }, {\n    key: \"pagesCount\",\n    get: function get() {\n      return this.pdfDocument ? this.pdfDocument.numPages : 0;\n    }\n  }, {\n    key: \"page\",\n    get: function get() {\n      return this.pdfViewer.currentPageNumber;\n    },\n    set: function set(value) {\n      this.pdfViewer.currentPageNumber = value;\n    }\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return this.pdfViewer.pagesRotation;\n    },\n    set: function set(value) {\n      this.pdfViewer.pagesRotation = value;\n    }\n  }]);\n\n  return PDFLinkService;\n}();\n\nexports.PDFLinkService = PDFLinkService;\n\nfunction isValidExplicitDestination(dest) {\n  if (!Array.isArray(dest)) {\n    return false;\n  }\n\n  var destLength = dest.length;\n\n  if (destLength < 2) {\n    return false;\n  }\n\n  var page = dest[0];\n\n  if (!(_typeof(page) === \"object\" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) {\n    return false;\n  }\n\n  var zoom = dest[1];\n\n  if (!(_typeof(zoom) === \"object\" && typeof zoom.name === \"string\")) {\n    return false;\n  }\n\n  var allowNull = true;\n\n  switch (zoom.name) {\n    case \"XYZ\":\n      if (destLength !== 5) {\n        return false;\n      }\n\n      break;\n\n    case \"Fit\":\n    case \"FitB\":\n      return destLength === 2;\n\n    case \"FitH\":\n    case \"FitBH\":\n    case \"FitV\":\n    case \"FitBV\":\n      if (destLength !== 3) {\n        return false;\n      }\n\n      break;\n\n    case \"FitR\":\n      if (destLength !== 6) {\n        return false;\n      }\n\n      allowNull = false;\n      break;\n\n    default:\n      return false;\n  }\n\n  for (var i = 2; i < destLength; i++) {\n    var param = dest[i];\n\n    if (!(typeof param === \"number\" || allowNull && param === null)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nvar SimpleLinkService = /*#__PURE__*/function () {\n  function SimpleLinkService() {\n    _classCallCheck(this, SimpleLinkService);\n\n    this.externalLinkTarget = null;\n    this.externalLinkRel = null;\n    this.externalLinkEnabled = true;\n    this._ignoreDestinationZoom = false;\n  }\n\n  _createClass(SimpleLinkService, [{\n    key: \"navigateTo\",\n    value: function navigateTo(dest) {}\n  }, {\n    key: \"getDestinationHash\",\n    value: function getDestinationHash(dest) {\n      return \"#\";\n    }\n  }, {\n    key: \"getAnchorUrl\",\n    value: function getAnchorUrl(hash) {\n      return \"#\";\n    }\n  }, {\n    key: \"setHash\",\n    value: function setHash(hash) {}\n  }, {\n    key: \"executeNamedAction\",\n    value: function executeNamedAction(action) {}\n  }, {\n    key: \"cachePageRef\",\n    value: function cachePageRef(pageNum, pageRef) {}\n  }, {\n    key: \"isPageVisible\",\n    value: function isPageVisible(pageNumber) {\n      return true;\n    }\n  }, {\n    key: \"pagesCount\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"page\",\n    get: function get() {\n      return 0;\n    },\n    set: function set(value) {}\n  }, {\n    key: \"rotation\",\n    get: function get() {\n      return 0;\n    },\n    set: function set(value) {}\n  }]);\n\n  return SimpleLinkService;\n}();\n\nexports.SimpleLinkService = SimpleLinkService;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DefaultTextLayerFactory = exports.TextLayerBuilder = void 0;\n\nvar _pdfjsLib = __w_pdfjs_require__(2);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar EXPAND_DIVS_TIMEOUT = 300;\n\nvar TextLayerBuilder = /*#__PURE__*/function () {\n  function TextLayerBuilder(_ref) {\n    var textLayerDiv = _ref.textLayerDiv,\n        eventBus = _ref.eventBus,\n        pageIndex = _ref.pageIndex,\n        viewport = _ref.viewport,\n        _ref$findController = _ref.findController,\n        findController = _ref$findController === void 0 ? null : _ref$findController,\n        _ref$enhanceTextSelec = _ref.enhanceTextSelection,\n        enhanceTextSelection = _ref$enhanceTextSelec === void 0 ? false : _ref$enhanceTextSelec;\n\n    _classCallCheck(this, TextLayerBuilder);\n\n    this.textLayerDiv = textLayerDiv;\n    this.eventBus = eventBus;\n    this.textContent = null;\n    this.textContentItemsStr = [];\n    this.textContentStream = null;\n    this.renderingDone = false;\n    this.pageIdx = pageIndex;\n    this.pageNumber = this.pageIdx + 1;\n    this.matches = [];\n    this.viewport = viewport;\n    this.textDivs = [];\n    this.findController = findController;\n    this.textLayerRenderTask = null;\n    this.enhanceTextSelection = enhanceTextSelection;\n    this._onUpdateTextLayerMatches = null;\n\n    this._bindMouse();\n  }\n\n  _createClass(TextLayerBuilder, [{\n    key: \"_finishRendering\",\n    value: function _finishRendering() {\n      this.renderingDone = true;\n\n      if (!this.enhanceTextSelection) {\n        var endOfContent = document.createElement(\"div\");\n        endOfContent.className = \"endOfContent\";\n        this.textLayerDiv.appendChild(endOfContent);\n      }\n\n      this.eventBus.dispatch(\"textlayerrendered\", {\n        source: this,\n        pageNumber: this.pageNumber,\n        numTextDivs: this.textDivs.length\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (!(this.textContent || this.textContentStream) || this.renderingDone) {\n        return;\n      }\n\n      this.cancel();\n      this.textDivs = [];\n      var textLayerFrag = document.createDocumentFragment();\n      this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({\n        textContent: this.textContent,\n        textContentStream: this.textContentStream,\n        container: textLayerFrag,\n        viewport: this.viewport,\n        textDivs: this.textDivs,\n        textContentItemsStr: this.textContentItemsStr,\n        timeout: timeout,\n        enhanceTextSelection: this.enhanceTextSelection\n      });\n      this.textLayerRenderTask.promise.then(function () {\n        _this.textLayerDiv.appendChild(textLayerFrag);\n\n        _this._finishRendering();\n\n        _this._updateMatches();\n      }, function (reason) {});\n\n      if (!this._onUpdateTextLayerMatches) {\n        this._onUpdateTextLayerMatches = function (evt) {\n          if (evt.pageIndex === _this.pageIdx || evt.pageIndex === -1) {\n            _this._updateMatches();\n          }\n        };\n\n        this.eventBus._on(\"updatetextlayermatches\", this._onUpdateTextLayerMatches);\n      }\n    }\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.textLayerRenderTask) {\n        this.textLayerRenderTask.cancel();\n        this.textLayerRenderTask = null;\n      }\n\n      if (this._onUpdateTextLayerMatches) {\n        this.eventBus._off(\"updatetextlayermatches\", this._onUpdateTextLayerMatches);\n\n        this._onUpdateTextLayerMatches = null;\n      }\n    }\n  }, {\n    key: \"setTextContentStream\",\n    value: function setTextContentStream(readableStream) {\n      this.cancel();\n      this.textContentStream = readableStream;\n    }\n  }, {\n    key: \"setTextContent\",\n    value: function setTextContent(textContent) {\n      this.cancel();\n      this.textContent = textContent;\n    }\n  }, {\n    key: \"_convertMatches\",\n    value: function _convertMatches(matches, matchesLength) {\n      if (!matches) {\n        return [];\n      }\n\n      var findController = this.findController,\n          textContentItemsStr = this.textContentItemsStr;\n      var i = 0,\n          iIndex = 0;\n      var end = textContentItemsStr.length - 1;\n      var queryLen = findController.state.query.length;\n      var result = [];\n\n      for (var m = 0, mm = matches.length; m < mm; m++) {\n        var matchIdx = matches[m];\n\n        while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) {\n          iIndex += textContentItemsStr[i].length;\n          i++;\n        }\n\n        if (i === textContentItemsStr.length) {\n          console.error(\"Could not find a matching mapping\");\n        }\n\n        var match = {\n          begin: {\n            divIdx: i,\n            offset: matchIdx - iIndex\n          }\n        };\n\n        if (matchesLength) {\n          matchIdx += matchesLength[m];\n        } else {\n          matchIdx += queryLen;\n        }\n\n        while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) {\n          iIndex += textContentItemsStr[i].length;\n          i++;\n        }\n\n        match.end = {\n          divIdx: i,\n          offset: matchIdx - iIndex\n        };\n        result.push(match);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"_renderMatches\",\n    value: function _renderMatches(matches) {\n      if (matches.length === 0) {\n        return;\n      }\n\n      var findController = this.findController,\n          pageIdx = this.pageIdx,\n          textContentItemsStr = this.textContentItemsStr,\n          textDivs = this.textDivs;\n      var isSelectedPage = pageIdx === findController.selected.pageIdx;\n      var selectedMatchIdx = findController.selected.matchIdx;\n      var highlightAll = findController.state.highlightAll;\n      var prevEnd = null;\n      var infinity = {\n        divIdx: -1,\n        offset: undefined\n      };\n\n      function beginText(begin, className) {\n        var divIdx = begin.divIdx;\n        textDivs[divIdx].textContent = \"\";\n        appendTextToDiv(divIdx, 0, begin.offset, className);\n      }\n\n      function appendTextToDiv(divIdx, fromOffset, toOffset, className) {\n        var div = textDivs[divIdx];\n        var content = textContentItemsStr[divIdx].substring(fromOffset, toOffset);\n        var node = document.createTextNode(content);\n\n        if (className) {\n          var span = document.createElement(\"span\");\n          span.className = className;\n          span.appendChild(node);\n          div.appendChild(span);\n          return;\n        }\n\n        div.appendChild(node);\n      }\n\n      var i0 = selectedMatchIdx,\n          i1 = i0 + 1;\n\n      if (highlightAll) {\n        i0 = 0;\n        i1 = matches.length;\n      } else if (!isSelectedPage) {\n        return;\n      }\n\n      for (var i = i0; i < i1; i++) {\n        var match = matches[i];\n        var begin = match.begin;\n        var end = match.end;\n        var isSelected = isSelectedPage && i === selectedMatchIdx;\n        var highlightSuffix = isSelected ? \" selected\" : \"\";\n\n        if (isSelected) {\n          findController.scrollMatchIntoView({\n            element: textDivs[begin.divIdx],\n            pageIndex: pageIdx,\n            matchIndex: selectedMatchIdx\n          });\n        }\n\n        if (!prevEnd || begin.divIdx !== prevEnd.divIdx) {\n          if (prevEnd !== null) {\n            appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n          }\n\n          beginText(begin);\n        } else {\n          appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset);\n        }\n\n        if (begin.divIdx === end.divIdx) {\n          appendTextToDiv(begin.divIdx, begin.offset, end.offset, \"highlight\" + highlightSuffix);\n        } else {\n          appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, \"highlight begin\" + highlightSuffix);\n\n          for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) {\n            textDivs[n0].className = \"highlight middle\" + highlightSuffix;\n          }\n\n          beginText(end, \"highlight end\" + highlightSuffix);\n        }\n\n        prevEnd = end;\n      }\n\n      if (prevEnd) {\n        appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset);\n      }\n    }\n  }, {\n    key: \"_updateMatches\",\n    value: function _updateMatches() {\n      if (!this.renderingDone) {\n        return;\n      }\n\n      var findController = this.findController,\n          matches = this.matches,\n          pageIdx = this.pageIdx,\n          textContentItemsStr = this.textContentItemsStr,\n          textDivs = this.textDivs;\n      var clearedUntilDivIdx = -1;\n\n      for (var i = 0, ii = matches.length; i < ii; i++) {\n        var match = matches[i];\n        var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx);\n\n        for (var n = begin, end = match.end.divIdx; n <= end; n++) {\n          var div = textDivs[n];\n          div.textContent = textContentItemsStr[n];\n          div.className = \"\";\n        }\n\n        clearedUntilDivIdx = match.end.divIdx + 1;\n      }\n\n      if (!findController || !findController.highlightMatches) {\n        return;\n      }\n\n      var pageMatches = findController.pageMatches[pageIdx] || null;\n      var pageMatchesLength = findController.pageMatchesLength[pageIdx] || null;\n      this.matches = this._convertMatches(pageMatches, pageMatchesLength);\n\n      this._renderMatches(this.matches);\n    }\n  }, {\n    key: \"_bindMouse\",\n    value: function _bindMouse() {\n      var _this2 = this;\n\n      var div = this.textLayerDiv;\n      var expandDivsTimer = null;\n      div.addEventListener(\"mousedown\", function (evt) {\n        if (_this2.enhanceTextSelection && _this2.textLayerRenderTask) {\n          _this2.textLayerRenderTask.expandTextDivs(true);\n\n          if (expandDivsTimer) {\n            clearTimeout(expandDivsTimer);\n            expandDivsTimer = null;\n          }\n\n          return;\n        }\n\n        var end = div.querySelector(\".endOfContent\");\n\n        if (!end) {\n          return;\n        }\n\n        var adjustTop = evt.target !== div;\n        adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue(\"-moz-user-select\") !== \"none\";\n\n        if (adjustTop) {\n          var divBounds = div.getBoundingClientRect();\n          var r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height);\n          end.style.top = (r * 100).toFixed(2) + \"%\";\n        }\n\n        end.classList.add(\"active\");\n      });\n      div.addEventListener(\"mouseup\", function () {\n        if (_this2.enhanceTextSelection && _this2.textLayerRenderTask) {\n          expandDivsTimer = setTimeout(function () {\n            if (_this2.textLayerRenderTask) {\n              _this2.textLayerRenderTask.expandTextDivs(false);\n            }\n\n            expandDivsTimer = null;\n          }, EXPAND_DIVS_TIMEOUT);\n          return;\n        }\n\n        var end = div.querySelector(\".endOfContent\");\n\n        if (!end) {\n          return;\n        }\n\n        end.style.top = \"\";\n        end.classList.remove(\"active\");\n      });\n    }\n  }]);\n\n  return TextLayerBuilder;\n}();\n\nexports.TextLayerBuilder = TextLayerBuilder;\n\nvar DefaultTextLayerFactory = /*#__PURE__*/function () {\n  function DefaultTextLayerFactory() {\n    _classCallCheck(this, DefaultTextLayerFactory);\n  }\n\n  _createClass(DefaultTextLayerFactory, [{\n    key: \"createTextLayerBuilder\",\n    value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {\n      var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var eventBus = arguments.length > 4 ? arguments[4] : undefined;\n      return new TextLayerBuilder({\n        textLayerDiv: textLayerDiv,\n        pageIndex: pageIndex,\n        viewport: viewport,\n        enhanceTextSelection: enhanceTextSelection,\n        eventBus: eventBus\n      });\n    }\n  }]);\n\n  return DefaultTextLayerFactory;\n}();\n\nexports.DefaultTextLayerFactory = DefaultTextLayerFactory;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownloadManager = void 0;\n\nvar _pdfjsLib = __w_pdfjs_require__(2);\n\nvar _viewer_compatibility = __w_pdfjs_require__(10);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n;\n\nfunction _download(blobUrl, filename) {\n  var a = document.createElement(\"a\");\n\n  if (!a.click) {\n    throw new Error('DownloadManager: \"a.click()\" is not supported.');\n  }\n\n  a.href = blobUrl;\n  a.target = \"_parent\";\n\n  if (\"download\" in a) {\n    a.download = filename;\n  }\n\n  (document.body || document.documentElement).appendChild(a);\n  a.click();\n  a.remove();\n}\n\nvar DownloadManager = /*#__PURE__*/function () {\n  function DownloadManager() {\n    _classCallCheck(this, DownloadManager);\n  }\n\n  _createClass(DownloadManager, [{\n    key: \"downloadUrl\",\n    value: function downloadUrl(url, filename) {\n      if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, \"http://example.com\")) {\n        return;\n      }\n\n      _download(url + \"#pdfjs.action=download\", filename);\n    }\n  }, {\n    key: \"downloadData\",\n    value: function downloadData(data, filename, contentType) {\n      if (navigator.msSaveBlob) {\n        navigator.msSaveBlob(new Blob([data], {\n          type: contentType\n        }), filename);\n        return;\n      }\n\n      var blobUrl = (0, _pdfjsLib.createObjectURL)(data, contentType, _viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL);\n\n      _download(blobUrl, filename);\n    }\n  }, {\n    key: \"download\",\n    value: function download(blob, url, filename) {\n      var sourceEventType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"download\";\n\n      if (navigator.msSaveBlob) {\n        if (!navigator.msSaveBlob(blob, filename)) {\n          this.downloadUrl(url, filename);\n        }\n\n        return;\n      }\n\n      if (_viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL) {\n        this.downloadUrl(url, filename);\n        return;\n      }\n\n      var blobUrl = URL.createObjectURL(blob);\n\n      _download(blobUrl, filename);\n    }\n  }]);\n\n  return DownloadManager;\n}();\n\nexports.DownloadManager = DownloadManager;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.viewerCompatibilityParams = void 0;\nvar compatibilityParams = Object.create(null);\n{\n  var userAgent = typeof navigator !== \"undefined\" && navigator.userAgent || \"\";\n  var platform = typeof navigator !== \"undefined\" && navigator.platform || \"\";\n  var maxTouchPoints = typeof navigator !== \"undefined\" && navigator.maxTouchPoints || 1;\n  var isAndroid = /Android/.test(userAgent);\n  var isIE = /Trident/.test(userAgent);\n  var isIOS = /\\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === \"MacIntel\" && maxTouchPoints > 1;\n  var isIOSChrome = /CriOS/.test(userAgent);\n\n  (function checkOnBlobSupport() {\n    if (isIE || isIOSChrome) {\n      compatibilityParams.disableCreateObjectURL = true;\n    }\n  })();\n\n  (function checkCanvasSizeLimitation() {\n    if (isIOS || isAndroid) {\n      compatibilityParams.maxCanvasPixels = 5242880;\n    }\n  })();\n}\nvar viewerCompatibilityParams = Object.freeze(compatibilityParams);\nexports.viewerCompatibilityParams = viewerCompatibilityParams;\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GenericL10n = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(4));\n\n__w_pdfjs_require__(12);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar webL10n = document.webL10n;\n\nvar GenericL10n = /*#__PURE__*/function () {\n  function GenericL10n(lang) {\n    _classCallCheck(this, GenericL10n);\n\n    this._lang = lang;\n    this._ready = new Promise(function (resolve, reject) {\n      webL10n.setLanguage(lang, function () {\n        resolve(webL10n);\n      });\n    });\n  }\n\n  _createClass(GenericL10n, [{\n    key: \"getLanguage\",\n    value: function () {\n      var _getLanguage = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var l10n;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._ready;\n\n              case 2:\n                l10n = _context.sent;\n                return _context.abrupt(\"return\", l10n.getLanguage());\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getLanguage() {\n        return _getLanguage.apply(this, arguments);\n      }\n\n      return getLanguage;\n    }()\n  }, {\n    key: \"getDirection\",\n    value: function () {\n      var _getDirection = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        var l10n;\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this._ready;\n\n              case 2:\n                l10n = _context2.sent;\n                return _context2.abrupt(\"return\", l10n.getDirection());\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function getDirection() {\n        return _getDirection.apply(this, arguments);\n      }\n\n      return getDirection;\n    }()\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(property, args, fallback) {\n        var l10n;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this._ready;\n\n              case 2:\n                l10n = _context3.sent;\n                return _context3.abrupt(\"return\", l10n.get(property, args, fallback));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function get(_x, _x2, _x3) {\n        return _get.apply(this, arguments);\n      }\n\n      return get;\n    }()\n  }, {\n    key: \"translate\",\n    value: function () {\n      var _translate = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(element) {\n        var l10n;\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this._ready;\n\n              case 2:\n                l10n = _context4.sent;\n                return _context4.abrupt(\"return\", l10n.translate(element));\n\n              case 4:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function translate(_x4) {\n        return _translate.apply(this, arguments);\n      }\n\n      return translate;\n    }()\n  }]);\n\n  return GenericL10n;\n}();\n\nexports.GenericL10n = GenericL10n;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\ndocument.webL10n = function (window, document, undefined) {\n  var gL10nData = {};\n  var gTextData = '';\n  var gTextProp = 'textContent';\n  var gLanguage = '';\n  var gMacros = {};\n  var gReadyState = 'loading';\n  var gAsyncResourceLoading = true;\n\n  function getL10nResourceLinks() {\n    return document.querySelectorAll('link[type=\"application/l10n\"]');\n  }\n\n  function getL10nDictionary() {\n    var script = document.querySelector('script[type=\"application/l10n\"]');\n    return script ? JSON.parse(script.innerHTML) : null;\n  }\n\n  function getTranslatableChildren(element) {\n    return element ? element.querySelectorAll('*[data-l10n-id]') : [];\n  }\n\n  function getL10nAttributes(element) {\n    if (!element) return {};\n    var l10nId = element.getAttribute('data-l10n-id');\n    var l10nArgs = element.getAttribute('data-l10n-args');\n    var args = {};\n\n    if (l10nArgs) {\n      try {\n        args = JSON.parse(l10nArgs);\n      } catch (e) {\n        console.warn('could not parse arguments for #' + l10nId);\n      }\n    }\n\n    return {\n      id: l10nId,\n      args: args\n    };\n  }\n\n  function xhrLoadText(url, onSuccess, onFailure) {\n    onSuccess = onSuccess || function _onSuccess(data) {};\n\n    onFailure = onFailure || function _onFailure() {};\n\n    var xhr = new XMLHttpRequest();\n    xhr.open('GET', url, gAsyncResourceLoading);\n\n    if (xhr.overrideMimeType) {\n      xhr.overrideMimeType('text/plain; charset=utf-8');\n    }\n\n    xhr.onreadystatechange = function () {\n      if (xhr.readyState == 4) {\n        if (xhr.status == 200 || xhr.status === 0) {\n          onSuccess(xhr.responseText);\n        } else {\n          onFailure();\n        }\n      }\n    };\n\n    xhr.onerror = onFailure;\n    xhr.ontimeout = onFailure;\n\n    try {\n      xhr.send(null);\n    } catch (e) {\n      onFailure();\n    }\n  }\n\n  function parseResource(href, lang, successCallback, failureCallback) {\n    var baseURL = href.replace(/[^\\/]*$/, '') || './';\n\n    function evalString(text) {\n      if (text.lastIndexOf('\\\\') < 0) return text;\n      return text.replace(/\\\\\\\\/g, '\\\\').replace(/\\\\n/g, '\\n').replace(/\\\\r/g, '\\r').replace(/\\\\t/g, '\\t').replace(/\\\\b/g, '\\b').replace(/\\\\f/g, '\\f').replace(/\\\\{/g, '{').replace(/\\\\}/g, '}').replace(/\\\\\"/g, '\"').replace(/\\\\'/g, \"'\");\n    }\n\n    function parseProperties(text, parsedPropertiesCallback) {\n      var dictionary = {};\n      var reBlank = /^\\s*|\\s*$/;\n      var reComment = /^\\s*#|^\\s*$/;\n      var reSection = /^\\s*\\[(.*)\\]\\s*$/;\n      var reImport = /^\\s*@import\\s+url\\((.*)\\)\\s*$/i;\n      var reSplit = /^([^=\\s]*)\\s*=\\s*(.+)$/;\n\n      function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) {\n        var entries = rawText.replace(reBlank, '').split(/[\\r\\n]+/);\n        var currentLang = '*';\n        var genericLang = lang.split('-', 1)[0];\n        var skipLang = false;\n        var match = '';\n\n        function nextEntry() {\n          while (true) {\n            if (!entries.length) {\n              parsedRawLinesCallback();\n              return;\n            }\n\n            var line = entries.shift();\n            if (reComment.test(line)) continue;\n\n            if (extendedSyntax) {\n              match = reSection.exec(line);\n\n              if (match) {\n                currentLang = match[1].toLowerCase();\n                skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang;\n                continue;\n              } else if (skipLang) {\n                continue;\n              }\n\n              match = reImport.exec(line);\n\n              if (match) {\n                loadImport(baseURL + match[1], nextEntry);\n                return;\n              }\n            }\n\n            var tmp = line.match(reSplit);\n\n            if (tmp && tmp.length == 3) {\n              dictionary[tmp[1]] = evalString(tmp[2]);\n            }\n          }\n        }\n\n        nextEntry();\n      }\n\n      function loadImport(url, callback) {\n        xhrLoadText(url, function (content) {\n          parseRawLines(content, false, callback);\n        }, function () {\n          console.warn(url + ' not found.');\n          callback();\n        });\n      }\n\n      parseRawLines(text, true, function () {\n        parsedPropertiesCallback(dictionary);\n      });\n    }\n\n    xhrLoadText(href, function (response) {\n      gTextData += response;\n      parseProperties(response, function (data) {\n        for (var key in data) {\n          var id,\n              prop,\n              index = key.lastIndexOf('.');\n\n          if (index > 0) {\n            id = key.substring(0, index);\n            prop = key.substring(index + 1);\n          } else {\n            id = key;\n            prop = gTextProp;\n          }\n\n          if (!gL10nData[id]) {\n            gL10nData[id] = {};\n          }\n\n          gL10nData[id][prop] = data[key];\n        }\n\n        if (successCallback) {\n          successCallback();\n        }\n      });\n    }, failureCallback);\n  }\n\n  function loadLocale(lang, callback) {\n    if (lang) {\n      lang = lang.toLowerCase();\n    }\n\n    callback = callback || function _callback() {};\n\n    clear();\n    gLanguage = lang;\n    var langLinks = getL10nResourceLinks();\n    var langCount = langLinks.length;\n\n    if (langCount === 0) {\n      var dict = getL10nDictionary();\n\n      if (dict && dict.locales && dict.default_locale) {\n        console.log('using the embedded JSON directory, early way out');\n        gL10nData = dict.locales[lang];\n\n        if (!gL10nData) {\n          var defaultLocale = dict.default_locale.toLowerCase();\n\n          for (var anyCaseLang in dict.locales) {\n            anyCaseLang = anyCaseLang.toLowerCase();\n\n            if (anyCaseLang === lang) {\n              gL10nData = dict.locales[lang];\n              break;\n            } else if (anyCaseLang === defaultLocale) {\n              gL10nData = dict.locales[defaultLocale];\n            }\n          }\n        }\n\n        callback();\n      } else {\n        console.log('no resource to load, early way out');\n      }\n\n      gReadyState = 'complete';\n      return;\n    }\n\n    var onResourceLoaded = null;\n    var gResourceCount = 0;\n\n    onResourceLoaded = function onResourceLoaded() {\n      gResourceCount++;\n\n      if (gResourceCount >= langCount) {\n        callback();\n        gReadyState = 'complete';\n      }\n    };\n\n    function L10nResourceLink(link) {\n      var href = link.href;\n\n      this.load = function (lang, callback) {\n        parseResource(href, lang, callback, function () {\n          console.warn(href + ' not found.');\n          console.warn('\"' + lang + '\" resource not found');\n          gLanguage = '';\n          callback();\n        });\n      };\n    }\n\n    for (var i = 0; i < langCount; i++) {\n      var resource = new L10nResourceLink(langLinks[i]);\n      resource.load(lang, onResourceLoaded);\n    }\n  }\n\n  function clear() {\n    gL10nData = {};\n    gTextData = '';\n    gLanguage = '';\n  }\n\n  function getPluralRules(lang) {\n    var locales2rules = {\n      'af': 3,\n      'ak': 4,\n      'am': 4,\n      'ar': 1,\n      'asa': 3,\n      'az': 0,\n      'be': 11,\n      'bem': 3,\n      'bez': 3,\n      'bg': 3,\n      'bh': 4,\n      'bm': 0,\n      'bn': 3,\n      'bo': 0,\n      'br': 20,\n      'brx': 3,\n      'bs': 11,\n      'ca': 3,\n      'cgg': 3,\n      'chr': 3,\n      'cs': 12,\n      'cy': 17,\n      'da': 3,\n      'de': 3,\n      'dv': 3,\n      'dz': 0,\n      'ee': 3,\n      'el': 3,\n      'en': 3,\n      'eo': 3,\n      'es': 3,\n      'et': 3,\n      'eu': 3,\n      'fa': 0,\n      'ff': 5,\n      'fi': 3,\n      'fil': 4,\n      'fo': 3,\n      'fr': 5,\n      'fur': 3,\n      'fy': 3,\n      'ga': 8,\n      'gd': 24,\n      'gl': 3,\n      'gsw': 3,\n      'gu': 3,\n      'guw': 4,\n      'gv': 23,\n      'ha': 3,\n      'haw': 3,\n      'he': 2,\n      'hi': 4,\n      'hr': 11,\n      'hu': 0,\n      'id': 0,\n      'ig': 0,\n      'ii': 0,\n      'is': 3,\n      'it': 3,\n      'iu': 7,\n      'ja': 0,\n      'jmc': 3,\n      'jv': 0,\n      'ka': 0,\n      'kab': 5,\n      'kaj': 3,\n      'kcg': 3,\n      'kde': 0,\n      'kea': 0,\n      'kk': 3,\n      'kl': 3,\n      'km': 0,\n      'kn': 0,\n      'ko': 0,\n      'ksb': 3,\n      'ksh': 21,\n      'ku': 3,\n      'kw': 7,\n      'lag': 18,\n      'lb': 3,\n      'lg': 3,\n      'ln': 4,\n      'lo': 0,\n      'lt': 10,\n      'lv': 6,\n      'mas': 3,\n      'mg': 4,\n      'mk': 16,\n      'ml': 3,\n      'mn': 3,\n      'mo': 9,\n      'mr': 3,\n      'ms': 0,\n      'mt': 15,\n      'my': 0,\n      'nah': 3,\n      'naq': 7,\n      'nb': 3,\n      'nd': 3,\n      'ne': 3,\n      'nl': 3,\n      'nn': 3,\n      'no': 3,\n      'nr': 3,\n      'nso': 4,\n      'ny': 3,\n      'nyn': 3,\n      'om': 3,\n      'or': 3,\n      'pa': 3,\n      'pap': 3,\n      'pl': 13,\n      'ps': 3,\n      'pt': 3,\n      'rm': 3,\n      'ro': 9,\n      'rof': 3,\n      'ru': 11,\n      'rwk': 3,\n      'sah': 0,\n      'saq': 3,\n      'se': 7,\n      'seh': 3,\n      'ses': 0,\n      'sg': 0,\n      'sh': 11,\n      'shi': 19,\n      'sk': 12,\n      'sl': 14,\n      'sma': 7,\n      'smi': 7,\n      'smj': 7,\n      'smn': 7,\n      'sms': 7,\n      'sn': 3,\n      'so': 3,\n      'sq': 3,\n      'sr': 11,\n      'ss': 3,\n      'ssy': 3,\n      'st': 3,\n      'sv': 3,\n      'sw': 3,\n      'syr': 3,\n      'ta': 3,\n      'te': 3,\n      'teo': 3,\n      'th': 0,\n      'ti': 4,\n      'tig': 3,\n      'tk': 3,\n      'tl': 4,\n      'tn': 3,\n      'to': 0,\n      'tr': 0,\n      'ts': 3,\n      'tzm': 22,\n      'uk': 11,\n      'ur': 3,\n      've': 3,\n      'vi': 0,\n      'vun': 3,\n      'wa': 4,\n      'wae': 3,\n      'wo': 0,\n      'xh': 3,\n      'xog': 3,\n      'yo': 0,\n      'zh': 0,\n      'zu': 3\n    };\n\n    function isIn(n, list) {\n      return list.indexOf(n) !== -1;\n    }\n\n    function isBetween(n, start, end) {\n      return start <= n && n <= end;\n    }\n\n    var pluralRules = {\n      '0': function _(n) {\n        return 'other';\n      },\n      '1': function _(n) {\n        if (isBetween(n % 100, 3, 10)) return 'few';\n        if (n === 0) return 'zero';\n        if (isBetween(n % 100, 11, 99)) return 'many';\n        if (n == 2) return 'two';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '2': function _(n) {\n        if (n !== 0 && n % 10 === 0) return 'many';\n        if (n == 2) return 'two';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '3': function _(n) {\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '4': function _(n) {\n        if (isBetween(n, 0, 1)) return 'one';\n        return 'other';\n      },\n      '5': function _(n) {\n        if (isBetween(n, 0, 2) && n != 2) return 'one';\n        return 'other';\n      },\n      '6': function _(n) {\n        if (n === 0) return 'zero';\n        if (n % 10 == 1 && n % 100 != 11) return 'one';\n        return 'other';\n      },\n      '7': function _(n) {\n        if (n == 2) return 'two';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '8': function _(n) {\n        if (isBetween(n, 3, 6)) return 'few';\n        if (isBetween(n, 7, 10)) return 'many';\n        if (n == 2) return 'two';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '9': function _(n) {\n        if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '10': function _(n) {\n        if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few';\n        if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one';\n        return 'other';\n      },\n      '11': function _(n) {\n        if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';\n        if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many';\n        if (n % 10 == 1 && n % 100 != 11) return 'one';\n        return 'other';\n      },\n      '12': function _(n) {\n        if (isBetween(n, 2, 4)) return 'few';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '13': function _(n) {\n        if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few';\n        if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '14': function _(n) {\n        if (isBetween(n % 100, 3, 4)) return 'few';\n        if (n % 100 == 2) return 'two';\n        if (n % 100 == 1) return 'one';\n        return 'other';\n      },\n      '15': function _(n) {\n        if (n === 0 || isBetween(n % 100, 2, 10)) return 'few';\n        if (isBetween(n % 100, 11, 19)) return 'many';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '16': function _(n) {\n        if (n % 10 == 1 && n != 11) return 'one';\n        return 'other';\n      },\n      '17': function _(n) {\n        if (n == 3) return 'few';\n        if (n === 0) return 'zero';\n        if (n == 6) return 'many';\n        if (n == 2) return 'two';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '18': function _(n) {\n        if (n === 0) return 'zero';\n        if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one';\n        return 'other';\n      },\n      '19': function _(n) {\n        if (isBetween(n, 2, 10)) return 'few';\n        if (isBetween(n, 0, 1)) return 'one';\n        return 'other';\n      },\n      '20': function _(n) {\n        if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few';\n        if (n % 1000000 === 0 && n !== 0) return 'many';\n        if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two';\n        if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one';\n        return 'other';\n      },\n      '21': function _(n) {\n        if (n === 0) return 'zero';\n        if (n == 1) return 'one';\n        return 'other';\n      },\n      '22': function _(n) {\n        if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one';\n        return 'other';\n      },\n      '23': function _(n) {\n        if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one';\n        return 'other';\n      },\n      '24': function _(n) {\n        if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few';\n        if (isIn(n, [2, 12])) return 'two';\n        if (isIn(n, [1, 11])) return 'one';\n        return 'other';\n      }\n    };\n    var index = locales2rules[lang.replace(/-.*$/, '')];\n\n    if (!(index in pluralRules)) {\n      console.warn('plural form unknown for [' + lang + ']');\n      return function () {\n        return 'other';\n      };\n    }\n\n    return pluralRules[index];\n  }\n\n  gMacros.plural = function (str, param, key, prop) {\n    var n = parseFloat(param);\n    if (isNaN(n)) return str;\n    if (prop != gTextProp) return str;\n\n    if (!gMacros._pluralRules) {\n      gMacros._pluralRules = getPluralRules(gLanguage);\n    }\n\n    var index = '[' + gMacros._pluralRules(n) + ']';\n\n    if (n === 0 && key + '[zero]' in gL10nData) {\n      str = gL10nData[key + '[zero]'][prop];\n    } else if (n == 1 && key + '[one]' in gL10nData) {\n      str = gL10nData[key + '[one]'][prop];\n    } else if (n == 2 && key + '[two]' in gL10nData) {\n      str = gL10nData[key + '[two]'][prop];\n    } else if (key + index in gL10nData) {\n      str = gL10nData[key + index][prop];\n    } else if (key + '[other]' in gL10nData) {\n      str = gL10nData[key + '[other]'][prop];\n    }\n\n    return str;\n  };\n\n  function getL10nData(key, args, fallback) {\n    var data = gL10nData[key];\n\n    if (!data) {\n      console.warn('#' + key + ' is undefined.');\n\n      if (!fallback) {\n        return null;\n      }\n\n      data = fallback;\n    }\n\n    var rv = {};\n\n    for (var prop in data) {\n      var str = data[prop];\n      str = substIndexes(str, args, key, prop);\n      str = substArguments(str, args, key);\n      rv[prop] = str;\n    }\n\n    return rv;\n  }\n\n  function substIndexes(str, args, key, prop) {\n    var reIndex = /\\{\\[\\s*([a-zA-Z]+)\\(([a-zA-Z]+)\\)\\s*\\]\\}/;\n    var reMatch = reIndex.exec(str);\n    if (!reMatch || !reMatch.length) return str;\n    var macroName = reMatch[1];\n    var paramName = reMatch[2];\n    var param;\n\n    if (args && paramName in args) {\n      param = args[paramName];\n    } else if (paramName in gL10nData) {\n      param = gL10nData[paramName];\n    }\n\n    if (macroName in gMacros) {\n      var macro = gMacros[macroName];\n      str = macro(str, param, key, prop);\n    }\n\n    return str;\n  }\n\n  function substArguments(str, args, key) {\n    var reArgs = /\\{\\{\\s*(.+?)\\s*\\}\\}/g;\n    return str.replace(reArgs, function (matched_text, arg) {\n      if (args && arg in args) {\n        return args[arg];\n      }\n\n      if (arg in gL10nData) {\n        return gL10nData[arg];\n      }\n\n      console.log('argument {{' + arg + '}} for #' + key + ' is undefined.');\n      return matched_text;\n    });\n  }\n\n  function translateElement(element) {\n    var l10n = getL10nAttributes(element);\n    if (!l10n.id) return;\n    var data = getL10nData(l10n.id, l10n.args);\n\n    if (!data) {\n      console.warn('#' + l10n.id + ' is undefined.');\n      return;\n    }\n\n    if (data[gTextProp]) {\n      if (getChildElementCount(element) === 0) {\n        element[gTextProp] = data[gTextProp];\n      } else {\n        var children = element.childNodes;\n        var found = false;\n\n        for (var i = 0, l = children.length; i < l; i++) {\n          if (children[i].nodeType === 3 && /\\S/.test(children[i].nodeValue)) {\n            if (found) {\n              children[i].nodeValue = '';\n            } else {\n              children[i].nodeValue = data[gTextProp];\n              found = true;\n            }\n          }\n        }\n\n        if (!found) {\n          var textNode = document.createTextNode(data[gTextProp]);\n          element.insertBefore(textNode, element.firstChild);\n        }\n      }\n\n      delete data[gTextProp];\n    }\n\n    for (var k in data) {\n      element[k] = data[k];\n    }\n  }\n\n  function getChildElementCount(element) {\n    if (element.children) {\n      return element.children.length;\n    }\n\n    if (typeof element.childElementCount !== 'undefined') {\n      return element.childElementCount;\n    }\n\n    var count = 0;\n\n    for (var i = 0; i < element.childNodes.length; i++) {\n      count += element.nodeType === 1 ? 1 : 0;\n    }\n\n    return count;\n  }\n\n  function translateFragment(element) {\n    element = element || document.documentElement;\n    var children = getTranslatableChildren(element);\n    var elementCount = children.length;\n\n    for (var i = 0; i < elementCount; i++) {\n      translateElement(children[i]);\n    }\n\n    translateElement(element);\n  }\n\n  return {\n    get: function get(key, args, fallbackString) {\n      var index = key.lastIndexOf('.');\n      var prop = gTextProp;\n\n      if (index > 0) {\n        prop = key.substring(index + 1);\n        key = key.substring(0, index);\n      }\n\n      var fallback;\n\n      if (fallbackString) {\n        fallback = {};\n        fallback[prop] = fallbackString;\n      }\n\n      var data = getL10nData(key, args, fallback);\n\n      if (data && prop in data) {\n        return data[prop];\n      }\n\n      return '{{' + key + '}}';\n    },\n    getData: function getData() {\n      return gL10nData;\n    },\n    getText: function getText() {\n      return gTextData;\n    },\n    getLanguage: function getLanguage() {\n      return gLanguage;\n    },\n    setLanguage: function setLanguage(lang, callback) {\n      loadLocale(lang, function () {\n        if (callback) callback();\n      });\n    },\n    getDirection: function getDirection() {\n      var rtlList = ['ar', 'he', 'fa', 'ps', 'ur'];\n      var shortCode = gLanguage.split('-', 1)[0];\n      return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr';\n    },\n    translate: translateFragment,\n    getReadyState: function getReadyState() {\n      return gReadyState;\n    },\n    ready: function ready(callback) {\n      if (!callback) {\n        return;\n      } else if (gReadyState == 'complete' || gReadyState == 'interactive') {\n        window.setTimeout(function () {\n          callback();\n        });\n      } else if (document.addEventListener) {\n        document.addEventListener('localized', function once() {\n          document.removeEventListener('localized', once);\n          callback();\n        });\n      }\n    }\n  };\n}(window, document);\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFFindController = exports.FindState = void 0;\n\nvar _pdfjsLib = __w_pdfjs_require__(2);\n\nvar _pdf_find_utils = __w_pdfjs_require__(14);\n\nvar _ui_utils = __w_pdfjs_require__(3);\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar FindState = {\n  FOUND: 0,\n  NOT_FOUND: 1,\n  WRAPPED: 2,\n  PENDING: 3\n};\nexports.FindState = FindState;\nvar FIND_TIMEOUT = 250;\nvar MATCH_SCROLL_OFFSET_TOP = -50;\nvar MATCH_SCROLL_OFFSET_LEFT = -400;\nvar CHARACTERS_TO_NORMALIZE = {\n  \"\\u2018\": \"'\",\n  \"\\u2019\": \"'\",\n  \"\\u201A\": \"'\",\n  \"\\u201B\": \"'\",\n  \"\\u201C\": '\"',\n  \"\\u201D\": '\"',\n  \"\\u201E\": '\"',\n  \"\\u201F\": '\"',\n  \"\\xBC\": \"1/4\",\n  \"\\xBD\": \"1/2\",\n  \"\\xBE\": \"3/4\"\n};\nvar normalizationRegex = null;\n\nfunction normalize(text) {\n  if (!normalizationRegex) {\n    var replace = Object.keys(CHARACTERS_TO_NORMALIZE).join(\"\");\n    normalizationRegex = new RegExp(\"[\".concat(replace, \"]\"), \"g\");\n  }\n\n  return text.replace(normalizationRegex, function (ch) {\n    return CHARACTERS_TO_NORMALIZE[ch];\n  });\n}\n\nvar PDFFindController = /*#__PURE__*/function () {\n  function PDFFindController(_ref) {\n    var linkService = _ref.linkService,\n        eventBus = _ref.eventBus;\n\n    _classCallCheck(this, PDFFindController);\n\n    this._linkService = linkService;\n    this._eventBus = eventBus;\n\n    this._reset();\n\n    eventBus._on(\"findbarclose\", this._onFindBarClose.bind(this));\n  }\n\n  _createClass(PDFFindController, [{\n    key: \"setDocument\",\n    value: function setDocument(pdfDocument) {\n      if (this._pdfDocument) {\n        this._reset();\n      }\n\n      if (!pdfDocument) {\n        return;\n      }\n\n      this._pdfDocument = pdfDocument;\n\n      this._firstPageCapability.resolve();\n    }\n  }, {\n    key: \"executeCommand\",\n    value: function executeCommand(cmd, state) {\n      var _this = this;\n\n      if (!state) {\n        return;\n      }\n\n      var pdfDocument = this._pdfDocument;\n\n      if (this._state === null || this._shouldDirtyMatch(cmd, state)) {\n        this._dirtyMatch = true;\n      }\n\n      this._state = state;\n\n      if (cmd !== \"findhighlightallchange\") {\n        this._updateUIState(FindState.PENDING);\n      }\n\n      this._firstPageCapability.promise.then(function () {\n        if (!_this._pdfDocument || pdfDocument && _this._pdfDocument !== pdfDocument) {\n          return;\n        }\n\n        _this._extractText();\n\n        var findbarClosed = !_this._highlightMatches;\n        var pendingTimeout = !!_this._findTimeout;\n\n        if (_this._findTimeout) {\n          clearTimeout(_this._findTimeout);\n          _this._findTimeout = null;\n        }\n\n        if (cmd === \"find\") {\n          _this._findTimeout = setTimeout(function () {\n            _this._nextMatch();\n\n            _this._findTimeout = null;\n          }, FIND_TIMEOUT);\n        } else if (_this._dirtyMatch) {\n          _this._nextMatch();\n        } else if (cmd === \"findagain\") {\n          _this._nextMatch();\n\n          if (findbarClosed && _this._state.highlightAll) {\n            _this._updateAllPages();\n          }\n        } else if (cmd === \"findhighlightallchange\") {\n          if (pendingTimeout) {\n            _this._nextMatch();\n          } else {\n            _this._highlightMatches = true;\n          }\n\n          _this._updateAllPages();\n        } else {\n          _this._nextMatch();\n        }\n      });\n    }\n  }, {\n    key: \"scrollMatchIntoView\",\n    value: function scrollMatchIntoView(_ref2) {\n      var _ref2$element = _ref2.element,\n          element = _ref2$element === void 0 ? null : _ref2$element,\n          _ref2$pageIndex = _ref2.pageIndex,\n          pageIndex = _ref2$pageIndex === void 0 ? -1 : _ref2$pageIndex,\n          _ref2$matchIndex = _ref2.matchIndex,\n          matchIndex = _ref2$matchIndex === void 0 ? -1 : _ref2$matchIndex;\n\n      if (!this._scrollMatches || !element) {\n        return;\n      } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) {\n        return;\n      } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) {\n        return;\n      }\n\n      this._scrollMatches = false;\n      var spot = {\n        top: MATCH_SCROLL_OFFSET_TOP,\n        left: MATCH_SCROLL_OFFSET_LEFT\n      };\n      (0, _ui_utils.scrollIntoView)(element, spot, true);\n    }\n  }, {\n    key: \"_reset\",\n    value: function _reset() {\n      this._highlightMatches = false;\n      this._scrollMatches = false;\n      this._pdfDocument = null;\n      this._pageMatches = [];\n      this._pageMatchesLength = [];\n      this._state = null;\n      this._selected = {\n        pageIdx: -1,\n        matchIdx: -1\n      };\n      this._offset = {\n        pageIdx: null,\n        matchIdx: null,\n        wrapped: false\n      };\n      this._extractTextPromises = [];\n      this._pageContents = [];\n      this._matchesCountTotal = 0;\n      this._pagesToSearch = null;\n      this._pendingFindMatches = Object.create(null);\n      this._resumePageIdx = null;\n      this._dirtyMatch = false;\n      clearTimeout(this._findTimeout);\n      this._findTimeout = null;\n      this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();\n    }\n  }, {\n    key: \"_shouldDirtyMatch\",\n    value: function _shouldDirtyMatch(cmd, state) {\n      if (state.query !== this._state.query) {\n        return true;\n      }\n\n      switch (cmd) {\n        case \"findagain\":\n          var pageNumber = this._selected.pageIdx + 1;\n          var linkService = this._linkService;\n\n          if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) {\n            return true;\n          }\n\n          return false;\n\n        case \"findhighlightallchange\":\n          return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_prepareMatches\",\n    value: function _prepareMatches(matchesWithLength, matches, matchesLength) {\n      function isSubTerm(currentIndex) {\n        var currentElem = matchesWithLength[currentIndex];\n        var nextElem = matchesWithLength[currentIndex + 1];\n\n        if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) {\n          currentElem.skipped = true;\n          return true;\n        }\n\n        for (var i = currentIndex - 1; i >= 0; i--) {\n          var prevElem = matchesWithLength[i];\n\n          if (prevElem.skipped) {\n            continue;\n          }\n\n          if (prevElem.match + prevElem.matchLength < currentElem.match) {\n            break;\n          }\n\n          if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) {\n            currentElem.skipped = true;\n            return true;\n          }\n        }\n\n        return false;\n      }\n\n      matchesWithLength.sort(function (a, b) {\n        return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match;\n      });\n\n      for (var i = 0, len = matchesWithLength.length; i < len; i++) {\n        if (isSubTerm(i)) {\n          continue;\n        }\n\n        matches.push(matchesWithLength[i].match);\n        matchesLength.push(matchesWithLength[i].matchLength);\n      }\n    }\n  }, {\n    key: \"_isEntireWord\",\n    value: function _isEntireWord(content, startIdx, length) {\n      if (startIdx > 0) {\n        var first = content.charCodeAt(startIdx);\n        var limit = content.charCodeAt(startIdx - 1);\n\n        if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) {\n          return false;\n        }\n      }\n\n      var endIdx = startIdx + length - 1;\n\n      if (endIdx < content.length - 1) {\n        var last = content.charCodeAt(endIdx);\n\n        var _limit = content.charCodeAt(endIdx + 1);\n\n        if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(_limit)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_calculatePhraseMatch\",\n    value: function _calculatePhraseMatch(query, pageIndex, pageContent, entireWord) {\n      var matches = [];\n      var queryLen = query.length;\n      var matchIdx = -queryLen;\n\n      while (true) {\n        matchIdx = pageContent.indexOf(query, matchIdx + queryLen);\n\n        if (matchIdx === -1) {\n          break;\n        }\n\n        if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) {\n          continue;\n        }\n\n        matches.push(matchIdx);\n      }\n\n      this._pageMatches[pageIndex] = matches;\n    }\n  }, {\n    key: \"_calculateWordMatch\",\n    value: function _calculateWordMatch(query, pageIndex, pageContent, entireWord) {\n      var matchesWithLength = [];\n      var queryArray = query.match(/\\S+/g);\n\n      for (var i = 0, len = queryArray.length; i < len; i++) {\n        var subquery = queryArray[i];\n        var subqueryLen = subquery.length;\n        var matchIdx = -subqueryLen;\n\n        while (true) {\n          matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen);\n\n          if (matchIdx === -1) {\n            break;\n          }\n\n          if (entireWord && !this._isEntireWord(pageContent, matchIdx, subqueryLen)) {\n            continue;\n          }\n\n          matchesWithLength.push({\n            match: matchIdx,\n            matchLength: subqueryLen,\n            skipped: false\n          });\n        }\n      }\n\n      this._pageMatchesLength[pageIndex] = [];\n      this._pageMatches[pageIndex] = [];\n\n      this._prepareMatches(matchesWithLength, this._pageMatches[pageIndex], this._pageMatchesLength[pageIndex]);\n    }\n  }, {\n    key: \"_calculateMatch\",\n    value: function _calculateMatch(pageIndex) {\n      var pageContent = this._pageContents[pageIndex];\n      var query = this._query;\n      var _this$_state = this._state,\n          caseSensitive = _this$_state.caseSensitive,\n          entireWord = _this$_state.entireWord,\n          phraseSearch = _this$_state.phraseSearch;\n\n      if (query.length === 0) {\n        return;\n      }\n\n      if (!caseSensitive) {\n        pageContent = pageContent.toLowerCase();\n        query = query.toLowerCase();\n      }\n\n      if (phraseSearch) {\n        this._calculatePhraseMatch(query, pageIndex, pageContent, entireWord);\n      } else {\n        this._calculateWordMatch(query, pageIndex, pageContent, entireWord);\n      }\n\n      if (this._state.highlightAll) {\n        this._updatePage(pageIndex);\n      }\n\n      if (this._resumePageIdx === pageIndex) {\n        this._resumePageIdx = null;\n\n        this._nextPageMatch();\n      }\n\n      var pageMatchesCount = this._pageMatches[pageIndex].length;\n\n      if (pageMatchesCount > 0) {\n        this._matchesCountTotal += pageMatchesCount;\n\n        this._updateUIResultsCount();\n      }\n    }\n  }, {\n    key: \"_extractText\",\n    value: function _extractText() {\n      var _this2 = this;\n\n      if (this._extractTextPromises.length > 0) {\n        return;\n      }\n\n      var promise = Promise.resolve();\n\n      var _loop = function _loop(i, ii) {\n        var extractTextCapability = (0, _pdfjsLib.createPromiseCapability)();\n        _this2._extractTextPromises[i] = extractTextCapability.promise;\n        promise = promise.then(function () {\n          return _this2._pdfDocument.getPage(i + 1).then(function (pdfPage) {\n            return pdfPage.getTextContent({\n              normalizeWhitespace: true\n            });\n          }).then(function (textContent) {\n            var textItems = textContent.items;\n            var strBuf = [];\n\n            for (var j = 0, jj = textItems.length; j < jj; j++) {\n              strBuf.push(textItems[j].str);\n            }\n\n            _this2._pageContents[i] = normalize(strBuf.join(\"\"));\n            extractTextCapability.resolve(i);\n          }, function (reason) {\n            console.error(\"Unable to get text content for page \".concat(i + 1), reason);\n            _this2._pageContents[i] = \"\";\n            extractTextCapability.resolve(i);\n          });\n        });\n      };\n\n      for (var i = 0, ii = this._linkService.pagesCount; i < ii; i++) {\n        _loop(i, ii);\n      }\n    }\n  }, {\n    key: \"_updatePage\",\n    value: function _updatePage(index) {\n      if (this._scrollMatches && this._selected.pageIdx === index) {\n        this._linkService.page = index + 1;\n      }\n\n      this._eventBus.dispatch(\"updatetextlayermatches\", {\n        source: this,\n        pageIndex: index\n      });\n    }\n  }, {\n    key: \"_updateAllPages\",\n    value: function _updateAllPages() {\n      this._eventBus.dispatch(\"updatetextlayermatches\", {\n        source: this,\n        pageIndex: -1\n      });\n    }\n  }, {\n    key: \"_nextMatch\",\n    value: function _nextMatch() {\n      var _this3 = this;\n\n      var previous = this._state.findPrevious;\n      var currentPageIndex = this._linkService.page - 1;\n      var numPages = this._linkService.pagesCount;\n      this._highlightMatches = true;\n\n      if (this._dirtyMatch) {\n        this._dirtyMatch = false;\n        this._selected.pageIdx = this._selected.matchIdx = -1;\n        this._offset.pageIdx = currentPageIndex;\n        this._offset.matchIdx = null;\n        this._offset.wrapped = false;\n        this._resumePageIdx = null;\n        this._pageMatches.length = 0;\n        this._pageMatchesLength.length = 0;\n        this._matchesCountTotal = 0;\n\n        this._updateAllPages();\n\n        for (var i = 0; i < numPages; i++) {\n          if (this._pendingFindMatches[i] === true) {\n            continue;\n          }\n\n          this._pendingFindMatches[i] = true;\n\n          this._extractTextPromises[i].then(function (pageIdx) {\n            delete _this3._pendingFindMatches[pageIdx];\n\n            _this3._calculateMatch(pageIdx);\n          });\n        }\n      }\n\n      if (this._query === \"\") {\n        this._updateUIState(FindState.FOUND);\n\n        return;\n      }\n\n      if (this._resumePageIdx) {\n        return;\n      }\n\n      var offset = this._offset;\n      this._pagesToSearch = numPages;\n\n      if (offset.matchIdx !== null) {\n        var numPageMatches = this._pageMatches[offset.pageIdx].length;\n\n        if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) {\n          offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1;\n\n          this._updateMatch(true);\n\n          return;\n        }\n\n        this._advanceOffsetPage(previous);\n      }\n\n      this._nextPageMatch();\n    }\n  }, {\n    key: \"_matchesReady\",\n    value: function _matchesReady(matches) {\n      var offset = this._offset;\n      var numMatches = matches.length;\n      var previous = this._state.findPrevious;\n\n      if (numMatches) {\n        offset.matchIdx = previous ? numMatches - 1 : 0;\n\n        this._updateMatch(true);\n\n        return true;\n      }\n\n      this._advanceOffsetPage(previous);\n\n      if (offset.wrapped) {\n        offset.matchIdx = null;\n\n        if (this._pagesToSearch < 0) {\n          this._updateMatch(false);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"_nextPageMatch\",\n    value: function _nextPageMatch() {\n      if (this._resumePageIdx !== null) {\n        console.error(\"There can only be one pending page.\");\n      }\n\n      var matches = null;\n\n      do {\n        var pageIdx = this._offset.pageIdx;\n        matches = this._pageMatches[pageIdx];\n\n        if (!matches) {\n          this._resumePageIdx = pageIdx;\n          break;\n        }\n      } while (!this._matchesReady(matches));\n    }\n  }, {\n    key: \"_advanceOffsetPage\",\n    value: function _advanceOffsetPage(previous) {\n      var offset = this._offset;\n      var numPages = this._linkService.pagesCount;\n      offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1;\n      offset.matchIdx = null;\n      this._pagesToSearch--;\n\n      if (offset.pageIdx >= numPages || offset.pageIdx < 0) {\n        offset.pageIdx = previous ? numPages - 1 : 0;\n        offset.wrapped = true;\n      }\n    }\n  }, {\n    key: \"_updateMatch\",\n    value: function _updateMatch() {\n      var found = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var state = FindState.NOT_FOUND;\n      var wrapped = this._offset.wrapped;\n      this._offset.wrapped = false;\n\n      if (found) {\n        var previousPage = this._selected.pageIdx;\n        this._selected.pageIdx = this._offset.pageIdx;\n        this._selected.matchIdx = this._offset.matchIdx;\n        state = wrapped ? FindState.WRAPPED : FindState.FOUND;\n\n        if (previousPage !== -1 && previousPage !== this._selected.pageIdx) {\n          this._updatePage(previousPage);\n        }\n      }\n\n      this._updateUIState(state, this._state.findPrevious);\n\n      if (this._selected.pageIdx !== -1) {\n        this._scrollMatches = true;\n\n        this._updatePage(this._selected.pageIdx);\n      }\n    }\n  }, {\n    key: \"_onFindBarClose\",\n    value: function _onFindBarClose(evt) {\n      var _this4 = this;\n\n      var pdfDocument = this._pdfDocument;\n\n      this._firstPageCapability.promise.then(function () {\n        if (!_this4._pdfDocument || pdfDocument && _this4._pdfDocument !== pdfDocument) {\n          return;\n        }\n\n        if (_this4._findTimeout) {\n          clearTimeout(_this4._findTimeout);\n          _this4._findTimeout = null;\n        }\n\n        if (_this4._resumePageIdx) {\n          _this4._resumePageIdx = null;\n          _this4._dirtyMatch = true;\n        }\n\n        _this4._updateUIState(FindState.FOUND);\n\n        _this4._highlightMatches = false;\n\n        _this4._updateAllPages();\n      });\n    }\n  }, {\n    key: \"_requestMatchesCount\",\n    value: function _requestMatchesCount() {\n      var _this$_selected = this._selected,\n          pageIdx = _this$_selected.pageIdx,\n          matchIdx = _this$_selected.matchIdx;\n      var current = 0,\n          total = this._matchesCountTotal;\n\n      if (matchIdx !== -1) {\n        for (var i = 0; i < pageIdx; i++) {\n          current += this._pageMatches[i] && this._pageMatches[i].length || 0;\n        }\n\n        current += matchIdx + 1;\n      }\n\n      if (current < 1 || current > total) {\n        current = total = 0;\n      }\n\n      return {\n        current: current,\n        total: total\n      };\n    }\n  }, {\n    key: \"_updateUIResultsCount\",\n    value: function _updateUIResultsCount() {\n      this._eventBus.dispatch(\"updatefindmatchescount\", {\n        source: this,\n        matchesCount: this._requestMatchesCount()\n      });\n    }\n  }, {\n    key: \"_updateUIState\",\n    value: function _updateUIState(state, previous) {\n      this._eventBus.dispatch(\"updatefindcontrolstate\", {\n        source: this,\n        state: state,\n        previous: previous,\n        matchesCount: this._requestMatchesCount(),\n        rawQuery: this._state ? this._state.query : null\n      });\n    }\n  }, {\n    key: \"highlightMatches\",\n    get: function get() {\n      return this._highlightMatches;\n    }\n  }, {\n    key: \"pageMatches\",\n    get: function get() {\n      return this._pageMatches;\n    }\n  }, {\n    key: \"pageMatchesLength\",\n    get: function get() {\n      return this._pageMatchesLength;\n    }\n  }, {\n    key: \"selected\",\n    get: function get() {\n      return this._selected;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._state;\n    }\n  }, {\n    key: \"_query\",\n    get: function get() {\n      if (this._state.query !== this._rawQuery) {\n        this._rawQuery = this._state.query;\n        this._normalizedQuery = normalize(this._state.query);\n      }\n\n      return this._normalizedQuery;\n    }\n  }]);\n\n  return PDFFindController;\n}();\n\nexports.PDFFindController = PDFFindController;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getCharacterType = getCharacterType;\nexports.CharacterType = void 0;\nvar CharacterType = {\n  SPACE: 0,\n  ALPHA_LETTER: 1,\n  PUNCT: 2,\n  HAN_LETTER: 3,\n  KATAKANA_LETTER: 4,\n  HIRAGANA_LETTER: 5,\n  HALFWIDTH_KATAKANA_LETTER: 6,\n  THAI_LETTER: 7\n};\nexports.CharacterType = CharacterType;\n\nfunction isAlphabeticalScript(charCode) {\n  return charCode < 0x2e80;\n}\n\nfunction isAscii(charCode) {\n  return (charCode & 0xff80) === 0;\n}\n\nfunction isAsciiAlpha(charCode) {\n  return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a;\n}\n\nfunction isAsciiDigit(charCode) {\n  return charCode >= 0x30 && charCode <= 0x39;\n}\n\nfunction isAsciiSpace(charCode) {\n  return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a;\n}\n\nfunction isHan(charCode) {\n  return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff;\n}\n\nfunction isKatakana(charCode) {\n  return charCode >= 0x30a0 && charCode <= 0x30ff;\n}\n\nfunction isHiragana(charCode) {\n  return charCode >= 0x3040 && charCode <= 0x309f;\n}\n\nfunction isHalfwidthKatakana(charCode) {\n  return charCode >= 0xff60 && charCode <= 0xff9f;\n}\n\nfunction isThai(charCode) {\n  return (charCode & 0xff80) === 0x0e00;\n}\n\nfunction getCharacterType(charCode) {\n  if (isAlphabeticalScript(charCode)) {\n    if (isAscii(charCode)) {\n      if (isAsciiSpace(charCode)) {\n        return CharacterType.SPACE;\n      } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) {\n        return CharacterType.ALPHA_LETTER;\n      }\n\n      return CharacterType.PUNCT;\n    } else if (isThai(charCode)) {\n      return CharacterType.THAI_LETTER;\n    } else if (charCode === 0xa0) {\n      return CharacterType.SPACE;\n    }\n\n    return CharacterType.ALPHA_LETTER;\n  }\n\n  if (isHan(charCode)) {\n    return CharacterType.HAN_LETTER;\n  } else if (isKatakana(charCode)) {\n    return CharacterType.KATAKANA_LETTER;\n  } else if (isHiragana(charCode)) {\n    return CharacterType.HIRAGANA_LETTER;\n  } else if (isHalfwidthKatakana(charCode)) {\n    return CharacterType.HALFWIDTH_KATAKANA_LETTER;\n  }\n\n  return CharacterType.ALPHA_LETTER;\n}\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isDestHashesEqual = isDestHashesEqual;\nexports.isDestArraysEqual = isDestArraysEqual;\nexports.PDFHistory = void 0;\n\nvar _ui_utils = __w_pdfjs_require__(3);\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar HASH_CHANGE_TIMEOUT = 1000;\nvar POSITION_UPDATED_THRESHOLD = 50;\nvar UPDATE_VIEWAREA_TIMEOUT = 1000;\n\nfunction getCurrentHash() {\n  return document.location.hash;\n}\n\nvar PDFHistory = /*#__PURE__*/function () {\n  function PDFHistory(_ref) {\n    var _this = this;\n\n    var linkService = _ref.linkService,\n        eventBus = _ref.eventBus;\n\n    _classCallCheck(this, PDFHistory);\n\n    this.linkService = linkService;\n    this.eventBus = eventBus;\n    this._initialized = false;\n    this._fingerprint = \"\";\n    this.reset();\n    this._boundEvents = null;\n    this._isViewerInPresentationMode = false;\n\n    this.eventBus._on(\"presentationmodechanged\", function (evt) {\n      _this._isViewerInPresentationMode = evt.active || evt.switchInProgress;\n    });\n\n    this.eventBus._on(\"pagesinit\", function () {\n      _this._isPagesLoaded = false;\n\n      var onPagesLoaded = function onPagesLoaded(evt) {\n        _this.eventBus._off(\"pagesloaded\", onPagesLoaded);\n\n        _this._isPagesLoaded = !!evt.pagesCount;\n      };\n\n      _this.eventBus._on(\"pagesloaded\", onPagesLoaded);\n    });\n  }\n\n  _createClass(PDFHistory, [{\n    key: \"initialize\",\n    value: function initialize(_ref2) {\n      var fingerprint = _ref2.fingerprint,\n          _ref2$resetHistory = _ref2.resetHistory,\n          resetHistory = _ref2$resetHistory === void 0 ? false : _ref2$resetHistory,\n          _ref2$updateUrl = _ref2.updateUrl,\n          updateUrl = _ref2$updateUrl === void 0 ? false : _ref2$updateUrl;\n\n      if (!fingerprint || typeof fingerprint !== \"string\") {\n        console.error('PDFHistory.initialize: The \"fingerprint\" must be a non-empty string.');\n        return;\n      }\n\n      if (this._initialized) {\n        this.reset();\n      }\n\n      var reInitialized = this._fingerprint !== \"\" && this._fingerprint !== fingerprint;\n      this._fingerprint = fingerprint;\n      this._updateUrl = updateUrl === true;\n      this._initialized = true;\n\n      this._bindEvents();\n\n      var state = window.history.state;\n      this._popStateInProgress = false;\n      this._blockHashChange = 0;\n      this._currentHash = getCurrentHash();\n      this._numPositionUpdates = 0;\n      this._uid = this._maxUid = 0;\n      this._destination = null;\n      this._position = null;\n\n      if (!this._isValidState(state, true) || resetHistory) {\n        var _this$_parseCurrentHa = this._parseCurrentHash(true),\n            hash = _this$_parseCurrentHa.hash,\n            page = _this$_parseCurrentHa.page,\n            rotation = _this$_parseCurrentHa.rotation;\n\n        if (!hash || reInitialized || resetHistory) {\n          this._pushOrReplaceState(null, true);\n\n          return;\n        }\n\n        this._pushOrReplaceState({\n          hash: hash,\n          page: page,\n          rotation: rotation\n        }, true);\n\n        return;\n      }\n\n      var destination = state.destination;\n\n      this._updateInternalState(destination, state.uid, true);\n\n      if (this._uid > this._maxUid) {\n        this._maxUid = this._uid;\n      }\n\n      if (destination.rotation !== undefined) {\n        this._initialRotation = destination.rotation;\n      }\n\n      if (destination.dest) {\n        this._initialBookmark = JSON.stringify(destination.dest);\n        this._destination.page = null;\n      } else if (destination.hash) {\n        this._initialBookmark = destination.hash;\n      } else if (destination.page) {\n        this._initialBookmark = \"page=\".concat(destination.page);\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      if (this._initialized) {\n        this._pageHide();\n\n        this._initialized = false;\n\n        this._unbindEvents();\n      }\n\n      if (this._updateViewareaTimeout) {\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n\n      this._initialBookmark = null;\n      this._initialRotation = null;\n    }\n  }, {\n    key: \"push\",\n    value: function push(_ref3) {\n      var _this2 = this;\n\n      var _ref3$namedDest = _ref3.namedDest,\n          namedDest = _ref3$namedDest === void 0 ? null : _ref3$namedDest,\n          explicitDest = _ref3.explicitDest,\n          pageNumber = _ref3.pageNumber;\n\n      if (!this._initialized) {\n        return;\n      }\n\n      if (namedDest && typeof namedDest !== \"string\") {\n        console.error(\"PDFHistory.push: \" + \"\\\"\".concat(namedDest, \"\\\" is not a valid namedDest parameter.\"));\n        return;\n      } else if (!Array.isArray(explicitDest)) {\n        console.error(\"PDFHistory.push: \" + \"\\\"\".concat(explicitDest, \"\\\" is not a valid explicitDest parameter.\"));\n        return;\n      } else if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.linkService.pagesCount)) {\n        if (pageNumber !== null || this._destination) {\n          console.error(\"PDFHistory.push: \" + \"\\\"\".concat(pageNumber, \"\\\" is not a valid pageNumber parameter.\"));\n          return;\n        }\n      }\n\n      var hash = namedDest || JSON.stringify(explicitDest);\n\n      if (!hash) {\n        return;\n      }\n\n      var forceReplace = false;\n\n      if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) {\n        if (this._destination.page) {\n          return;\n        }\n\n        forceReplace = true;\n      }\n\n      if (this._popStateInProgress && !forceReplace) {\n        return;\n      }\n\n      this._pushOrReplaceState({\n        dest: explicitDest,\n        hash: hash,\n        page: pageNumber,\n        rotation: this.linkService.rotation\n      }, forceReplace);\n\n      if (!this._popStateInProgress) {\n        this._popStateInProgress = true;\n        Promise.resolve().then(function () {\n          _this2._popStateInProgress = false;\n        });\n      }\n    }\n  }, {\n    key: \"pushCurrentPosition\",\n    value: function pushCurrentPosition() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n\n      this._tryPushCurrentPosition();\n    }\n  }, {\n    key: \"back\",\n    value: function back() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n\n      var state = window.history.state;\n\n      if (this._isValidState(state) && state.uid > 0) {\n        window.history.back();\n      }\n    }\n  }, {\n    key: \"forward\",\n    value: function forward() {\n      if (!this._initialized || this._popStateInProgress) {\n        return;\n      }\n\n      var state = window.history.state;\n\n      if (this._isValidState(state) && state.uid < this._maxUid) {\n        window.history.forward();\n      }\n    }\n  }, {\n    key: \"_pushOrReplaceState\",\n    value: function _pushOrReplaceState(destination) {\n      var forceReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var shouldReplace = forceReplace || !this._destination;\n      var newState = {\n        fingerprint: this._fingerprint,\n        uid: shouldReplace ? this._uid : this._uid + 1,\n        destination: destination\n      };\n\n      this._updateInternalState(destination, newState.uid);\n\n      var newUrl;\n\n      if (this._updateUrl && destination && destination.hash) {\n        var baseUrl = document.location.href.split(\"#\")[0];\n\n        if (!baseUrl.startsWith(\"file://\")) {\n          newUrl = \"\".concat(baseUrl, \"#\").concat(destination.hash);\n        }\n      }\n\n      if (shouldReplace) {\n        window.history.replaceState(newState, \"\", newUrl);\n      } else {\n        this._maxUid = this._uid;\n        window.history.pushState(newState, \"\", newUrl);\n      }\n    }\n  }, {\n    key: \"_tryPushCurrentPosition\",\n    value: function _tryPushCurrentPosition() {\n      var temporary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this._position) {\n        return;\n      }\n\n      var position = this._position;\n\n      if (temporary) {\n        position = Object.assign(Object.create(null), this._position);\n        position.temporary = true;\n      }\n\n      if (!this._destination) {\n        this._pushOrReplaceState(position);\n\n        return;\n      }\n\n      if (this._destination.temporary) {\n        this._pushOrReplaceState(position, true);\n\n        return;\n      }\n\n      if (this._destination.hash === position.hash) {\n        return;\n      }\n\n      if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) {\n        return;\n      }\n\n      var forceReplace = false;\n\n      if (this._destination.page >= position.first && this._destination.page <= position.page) {\n        if (this._destination.dest || !this._destination.first) {\n          return;\n        }\n\n        forceReplace = true;\n      }\n\n      this._pushOrReplaceState(position, forceReplace);\n    }\n  }, {\n    key: \"_isValidState\",\n    value: function _isValidState(state) {\n      var checkReload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (!state) {\n        return false;\n      }\n\n      if (state.fingerprint !== this._fingerprint) {\n        if (checkReload) {\n          if (typeof state.fingerprint !== \"string\" || state.fingerprint.length !== this._fingerprint.length) {\n            return false;\n          }\n\n          var _performance$getEntri = performance.getEntriesByType(\"navigation\"),\n              _performance$getEntri2 = _slicedToArray(_performance$getEntri, 1),\n              perfEntry = _performance$getEntri2[0];\n\n          if (!perfEntry || perfEntry.type !== \"reload\") {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      if (!Number.isInteger(state.uid) || state.uid < 0) {\n        return false;\n      }\n\n      if (state.destination === null || _typeof(state.destination) !== \"object\") {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_updateInternalState\",\n    value: function _updateInternalState(destination, uid) {\n      var removeTemporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      if (this._updateViewareaTimeout) {\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n\n      if (removeTemporary && destination && destination.temporary) {\n        delete destination.temporary;\n      }\n\n      this._destination = destination;\n      this._uid = uid;\n      this._numPositionUpdates = 0;\n    }\n  }, {\n    key: \"_parseCurrentHash\",\n    value: function _parseCurrentHash() {\n      var checkNameddest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var hash = unescape(getCurrentHash()).substring(1);\n      var params = (0, _ui_utils.parseQueryString)(hash);\n      var nameddest = params.nameddest || \"\";\n      var page = params.page | 0;\n\n      if (!(Number.isInteger(page) && page > 0 && page <= this.linkService.pagesCount) || checkNameddest && nameddest.length > 0) {\n        page = null;\n      }\n\n      return {\n        hash: hash,\n        page: page,\n        rotation: this.linkService.rotation\n      };\n    }\n  }, {\n    key: \"_updateViewarea\",\n    value: function _updateViewarea(_ref4) {\n      var _this3 = this;\n\n      var location = _ref4.location;\n\n      if (this._updateViewareaTimeout) {\n        clearTimeout(this._updateViewareaTimeout);\n        this._updateViewareaTimeout = null;\n      }\n\n      this._position = {\n        hash: this._isViewerInPresentationMode ? \"page=\".concat(location.pageNumber) : location.pdfOpenParams.substring(1),\n        page: this.linkService.page,\n        first: location.pageNumber,\n        rotation: location.rotation\n      };\n\n      if (this._popStateInProgress) {\n        return;\n      }\n\n      if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) {\n        this._numPositionUpdates++;\n      }\n\n      if (UPDATE_VIEWAREA_TIMEOUT > 0) {\n        this._updateViewareaTimeout = setTimeout(function () {\n          if (!_this3._popStateInProgress) {\n            _this3._tryPushCurrentPosition(true);\n          }\n\n          _this3._updateViewareaTimeout = null;\n        }, UPDATE_VIEWAREA_TIMEOUT);\n      }\n    }\n  }, {\n    key: \"_popState\",\n    value: function _popState(_ref5) {\n      var _this4 = this;\n\n      var state = _ref5.state;\n      var newHash = getCurrentHash(),\n          hashChanged = this._currentHash !== newHash;\n      this._currentHash = newHash;\n\n      if (!state) {\n        this._uid++;\n\n        var _this$_parseCurrentHa2 = this._parseCurrentHash(),\n            hash = _this$_parseCurrentHa2.hash,\n            page = _this$_parseCurrentHa2.page,\n            rotation = _this$_parseCurrentHa2.rotation;\n\n        this._pushOrReplaceState({\n          hash: hash,\n          page: page,\n          rotation: rotation\n        }, true);\n\n        return;\n      }\n\n      if (!this._isValidState(state)) {\n        return;\n      }\n\n      this._popStateInProgress = true;\n\n      if (hashChanged) {\n        this._blockHashChange++;\n        (0, _ui_utils.waitOnEventOrTimeout)({\n          target: window,\n          name: \"hashchange\",\n          delay: HASH_CHANGE_TIMEOUT\n        }).then(function () {\n          _this4._blockHashChange--;\n        });\n      }\n\n      var destination = state.destination;\n\n      this._updateInternalState(destination, state.uid, true);\n\n      if (this._uid > this._maxUid) {\n        this._maxUid = this._uid;\n      }\n\n      if ((0, _ui_utils.isValidRotation)(destination.rotation)) {\n        this.linkService.rotation = destination.rotation;\n      }\n\n      if (destination.dest) {\n        this.linkService.navigateTo(destination.dest);\n      } else if (destination.hash) {\n        this.linkService.setHash(destination.hash);\n      } else if (destination.page) {\n        this.linkService.page = destination.page;\n      }\n\n      Promise.resolve().then(function () {\n        _this4._popStateInProgress = false;\n      });\n    }\n  }, {\n    key: \"_pageHide\",\n    value: function _pageHide() {\n      if (!this._destination || this._destination.temporary) {\n        this._tryPushCurrentPosition();\n      }\n    }\n  }, {\n    key: \"_bindEvents\",\n    value: function _bindEvents() {\n      if (this._boundEvents) {\n        return;\n      }\n\n      this._boundEvents = {\n        updateViewarea: this._updateViewarea.bind(this),\n        popState: this._popState.bind(this),\n        pageHide: this._pageHide.bind(this)\n      };\n\n      this.eventBus._on(\"updateviewarea\", this._boundEvents.updateViewarea);\n\n      window.addEventListener(\"popstate\", this._boundEvents.popState);\n      window.addEventListener(\"pagehide\", this._boundEvents.pageHide);\n    }\n  }, {\n    key: \"_unbindEvents\",\n    value: function _unbindEvents() {\n      if (!this._boundEvents) {\n        return;\n      }\n\n      this.eventBus._off(\"updateviewarea\", this._boundEvents.updateViewarea);\n\n      window.removeEventListener(\"popstate\", this._boundEvents.popState);\n      window.removeEventListener(\"pagehide\", this._boundEvents.pageHide);\n      this._boundEvents = null;\n    }\n  }, {\n    key: \"popStateInProgress\",\n    get: function get() {\n      return this._initialized && (this._popStateInProgress || this._blockHashChange > 0);\n    }\n  }, {\n    key: \"initialBookmark\",\n    get: function get() {\n      return this._initialized ? this._initialBookmark : null;\n    }\n  }, {\n    key: \"initialRotation\",\n    get: function get() {\n      return this._initialized ? this._initialRotation : null;\n    }\n  }]);\n\n  return PDFHistory;\n}();\n\nexports.PDFHistory = PDFHistory;\n\nfunction isDestHashesEqual(destHash, pushHash) {\n  if (typeof destHash !== \"string\" || typeof pushHash !== \"string\") {\n    return false;\n  }\n\n  if (destHash === pushHash) {\n    return true;\n  }\n\n  var _parseQueryString = (0, _ui_utils.parseQueryString)(destHash),\n      nameddest = _parseQueryString.nameddest;\n\n  if (nameddest === pushHash) {\n    return true;\n  }\n\n  return false;\n}\n\nfunction isDestArraysEqual(firstDest, secondDest) {\n  function isEntryEqual(first, second) {\n    if (_typeof(first) !== _typeof(second)) {\n      return false;\n    }\n\n    if (Array.isArray(first) || Array.isArray(second)) {\n      return false;\n    }\n\n    if (first !== null && _typeof(first) === \"object\" && second !== null) {\n      if (Object.keys(first).length !== Object.keys(second).length) {\n        return false;\n      }\n\n      for (var key in first) {\n        if (!isEntryEqual(first[key], second[key])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return first === second || Number.isNaN(first) && Number.isNaN(second);\n  }\n\n  if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) {\n    return false;\n  }\n\n  if (firstDest.length !== secondDest.length) {\n    return false;\n  }\n\n  for (var i = 0, ii = firstDest.length; i < ii; i++) {\n    if (!isEntryEqual(firstDest[i], secondDest[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFPageView = void 0;\n\nvar _regenerator = _interopRequireDefault(__w_pdfjs_require__(4));\n\nvar _ui_utils = __w_pdfjs_require__(3);\n\nvar _pdfjsLib = __w_pdfjs_require__(2);\n\nvar _pdf_rendering_queue = __w_pdfjs_require__(17);\n\nvar _viewer_compatibility = __w_pdfjs_require__(10);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar MAX_CANVAS_PIXELS = _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels || 16777216;\n\nvar PDFPageView = /*#__PURE__*/function () {\n  function PDFPageView(options) {\n    _classCallCheck(this, PDFPageView);\n\n    var container = options.container;\n    var defaultViewport = options.defaultViewport;\n    this.id = options.id;\n    this.renderingId = \"page\" + this.id;\n    this.pdfPage = null;\n    this.pageLabel = null;\n    this.rotation = 0;\n    this.scale = options.scale || _ui_utils.DEFAULT_SCALE;\n    this.viewport = defaultViewport;\n    this.pdfPageRotate = defaultViewport.rotation;\n    this._annotationStorage = options.annotationStorage || null;\n    this._optionalContentConfigPromise = options.optionalContentConfigPromise || null;\n    this.hasRestrictedScaling = false;\n    this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;\n    this.imageResourcesPath = options.imageResourcesPath || \"\";\n    this.renderInteractiveForms = typeof options.renderInteractiveForms === \"boolean\" ? options.renderInteractiveForms : true;\n    this.useOnlyCssZoom = options.useOnlyCssZoom || false;\n    this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS;\n    this.eventBus = options.eventBus;\n    this.renderingQueue = options.renderingQueue;\n    this.textLayerFactory = options.textLayerFactory;\n    this.annotationLayerFactory = options.annotationLayerFactory;\n    this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;\n    this.enableWebGL = options.enableWebGL || false;\n    this.l10n = options.l10n || _ui_utils.NullL10n;\n    this.paintTask = null;\n    this.paintedViewportMap = new WeakMap();\n    this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;\n    this.resume = null;\n    this.error = null;\n    this.annotationLayer = null;\n    this.textLayer = null;\n    this.zoomLayer = null;\n    var div = document.createElement(\"div\");\n    div.className = \"page\";\n    div.style.width = Math.floor(this.viewport.width) + \"px\";\n    div.style.height = Math.floor(this.viewport.height) + \"px\";\n    div.setAttribute(\"data-page-number\", this.id);\n    this.div = div;\n    container.appendChild(div);\n  }\n\n  _createClass(PDFPageView, [{\n    key: \"setPdfPage\",\n    value: function setPdfPage(pdfPage) {\n      this.pdfPage = pdfPage;\n      this.pdfPageRotate = pdfPage.rotate;\n      var totalRotation = (this.rotation + this.pdfPageRotate) % 360;\n      this.viewport = pdfPage.getViewport({\n        scale: this.scale * _ui_utils.CSS_UNITS,\n        rotation: totalRotation\n      });\n      this.stats = pdfPage.stats;\n      this.reset();\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.reset();\n\n      if (this.pdfPage) {\n        this.pdfPage.cleanup();\n      }\n    }\n  }, {\n    key: \"_renderAnnotationLayer\",\n    value: function () {\n      var _renderAnnotationLayer2 = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee() {\n        var error;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                error = null;\n                _context.prev = 1;\n                _context.next = 4;\n                return this.annotationLayer.render(this.viewport, \"display\");\n\n              case 4:\n                _context.next = 9;\n                break;\n\n              case 6:\n                _context.prev = 6;\n                _context.t0 = _context[\"catch\"](1);\n                error = _context.t0;\n\n              case 9:\n                _context.prev = 9;\n                this.eventBus.dispatch(\"annotationlayerrendered\", {\n                  source: this,\n                  pageNumber: this.id,\n                  error: error\n                });\n                return _context.finish(9);\n\n              case 12:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[1, 6, 9, 12]]);\n      }));\n\n      function _renderAnnotationLayer() {\n        return _renderAnnotationLayer2.apply(this, arguments);\n      }\n\n      return _renderAnnotationLayer;\n    }()\n  }, {\n    key: \"_resetZoomLayer\",\n    value: function _resetZoomLayer() {\n      var removeFromDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this.zoomLayer) {\n        return;\n      }\n\n      var zoomLayerCanvas = this.zoomLayer.firstChild;\n      this.paintedViewportMap[\"delete\"](zoomLayerCanvas);\n      zoomLayerCanvas.width = 0;\n      zoomLayerCanvas.height = 0;\n\n      if (removeFromDOM) {\n        this.zoomLayer.remove();\n      }\n\n      this.zoomLayer = null;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      var keepZoomLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var keepAnnotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      this.cancelRendering(keepAnnotations);\n      this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL;\n      var div = this.div;\n      div.style.width = Math.floor(this.viewport.width) + \"px\";\n      div.style.height = Math.floor(this.viewport.height) + \"px\";\n      var childNodes = div.childNodes;\n      var currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null;\n      var currentAnnotationNode = keepAnnotations && this.annotationLayer && this.annotationLayer.div || null;\n\n      for (var i = childNodes.length - 1; i >= 0; i--) {\n        var node = childNodes[i];\n\n        if (currentZoomLayerNode === node || currentAnnotationNode === node) {\n          continue;\n        }\n\n        div.removeChild(node);\n      }\n\n      div.removeAttribute(\"data-loaded\");\n\n      if (currentAnnotationNode) {\n        this.annotationLayer.hide();\n      } else if (this.annotationLayer) {\n        this.annotationLayer.cancel();\n        this.annotationLayer = null;\n      }\n\n      if (!currentZoomLayerNode) {\n        if (this.canvas) {\n          this.paintedViewportMap[\"delete\"](this.canvas);\n          this.canvas.width = 0;\n          this.canvas.height = 0;\n          delete this.canvas;\n        }\n\n        this._resetZoomLayer();\n      }\n\n      if (this.svg) {\n        this.paintedViewportMap[\"delete\"](this.svg);\n        delete this.svg;\n      }\n\n      this.loadingIconDiv = document.createElement(\"div\");\n      this.loadingIconDiv.className = \"loadingIcon\";\n      div.appendChild(this.loadingIconDiv);\n    }\n  }, {\n    key: \"update\",\n    value: function update(scale, rotation) {\n      var optionalContentConfigPromise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      this.scale = scale || this.scale;\n\n      if (typeof rotation !== \"undefined\") {\n        this.rotation = rotation;\n      }\n\n      if (optionalContentConfigPromise instanceof Promise) {\n        this._optionalContentConfigPromise = optionalContentConfigPromise;\n      }\n\n      var totalRotation = (this.rotation + this.pdfPageRotate) % 360;\n      this.viewport = this.viewport.clone({\n        scale: this.scale * _ui_utils.CSS_UNITS,\n        rotation: totalRotation\n      });\n\n      if (this.svg) {\n        this.cssTransform(this.svg, true);\n        this.eventBus.dispatch(\"pagerendered\", {\n          source: this,\n          pageNumber: this.id,\n          cssTransform: true,\n          timestamp: performance.now()\n        });\n        return;\n      }\n\n      var isScalingRestricted = false;\n\n      if (this.canvas && this.maxCanvasPixels > 0) {\n        var outputScale = this.outputScale;\n\n        if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) {\n          isScalingRestricted = true;\n        }\n      }\n\n      if (this.canvas) {\n        if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) {\n          this.cssTransform(this.canvas, true);\n          this.eventBus.dispatch(\"pagerendered\", {\n            source: this,\n            pageNumber: this.id,\n            cssTransform: true,\n            timestamp: performance.now()\n          });\n          return;\n        }\n\n        if (!this.zoomLayer && !this.canvas.hasAttribute(\"hidden\")) {\n          this.zoomLayer = this.canvas.parentNode;\n          this.zoomLayer.style.position = \"absolute\";\n        }\n      }\n\n      if (this.zoomLayer) {\n        this.cssTransform(this.zoomLayer.firstChild);\n      }\n\n      this.reset(true, true);\n    }\n  }, {\n    key: \"cancelRendering\",\n    value: function cancelRendering() {\n      var keepAnnotations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (this.paintTask) {\n        this.paintTask.cancel();\n        this.paintTask = null;\n      }\n\n      this.resume = null;\n\n      if (this.textLayer) {\n        this.textLayer.cancel();\n        this.textLayer = null;\n      }\n\n      if (!keepAnnotations && this.annotationLayer) {\n        this.annotationLayer.cancel();\n        this.annotationLayer = null;\n      }\n    }\n  }, {\n    key: \"cssTransform\",\n    value: function cssTransform(target) {\n      var redrawAnnotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var width = this.viewport.width;\n      var height = this.viewport.height;\n      var div = this.div;\n      target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + \"px\";\n      target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + \"px\";\n      var relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation;\n      var absRotation = Math.abs(relativeRotation);\n      var scaleX = 1,\n          scaleY = 1;\n\n      if (absRotation === 90 || absRotation === 270) {\n        scaleX = height / width;\n        scaleY = width / height;\n      }\n\n      var cssTransform = \"rotate(\" + relativeRotation + \"deg) \" + \"scale(\" + scaleX + \",\" + scaleY + \")\";\n      target.style.transform = cssTransform;\n\n      if (this.textLayer) {\n        var textLayerViewport = this.textLayer.viewport;\n        var textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation;\n        var textAbsRotation = Math.abs(textRelativeRotation);\n        var scale = width / textLayerViewport.width;\n\n        if (textAbsRotation === 90 || textAbsRotation === 270) {\n          scale = width / textLayerViewport.height;\n        }\n\n        var textLayerDiv = this.textLayer.textLayerDiv;\n        var transX, transY;\n\n        switch (textAbsRotation) {\n          case 0:\n            transX = transY = 0;\n            break;\n\n          case 90:\n            transX = 0;\n            transY = \"-\" + textLayerDiv.style.height;\n            break;\n\n          case 180:\n            transX = \"-\" + textLayerDiv.style.width;\n            transY = \"-\" + textLayerDiv.style.height;\n            break;\n\n          case 270:\n            transX = \"-\" + textLayerDiv.style.width;\n            transY = 0;\n            break;\n\n          default:\n            console.error(\"Bad rotation value.\");\n            break;\n        }\n\n        textLayerDiv.style.transform = \"rotate(\" + textAbsRotation + \"deg) \" + \"scale(\" + scale + \", \" + scale + \") \" + \"translate(\" + transX + \", \" + transY + \")\";\n        textLayerDiv.style.transformOrigin = \"0% 0%\";\n      }\n\n      if (redrawAnnotations && this.annotationLayer) {\n        this._renderAnnotationLayer();\n      }\n    }\n  }, {\n    key: \"getPagePoint\",\n    value: function getPagePoint(x, y) {\n      return this.viewport.convertToPdfPoint(x, y);\n    }\n  }, {\n    key: \"draw\",\n    value: function draw() {\n      var _this = this;\n\n      if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) {\n        console.error(\"Must be in new state before drawing\");\n        this.reset();\n      }\n\n      var div = this.div,\n          pdfPage = this.pdfPage;\n\n      if (!pdfPage) {\n        this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;\n\n        if (this.loadingIconDiv) {\n          div.removeChild(this.loadingIconDiv);\n          delete this.loadingIconDiv;\n        }\n\n        return Promise.reject(new Error(\"pdfPage is not loaded\"));\n      }\n\n      this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;\n      var canvasWrapper = document.createElement(\"div\");\n      canvasWrapper.style.width = div.style.width;\n      canvasWrapper.style.height = div.style.height;\n      canvasWrapper.classList.add(\"canvasWrapper\");\n\n      if (this.annotationLayer && this.annotationLayer.div) {\n        div.insertBefore(canvasWrapper, this.annotationLayer.div);\n      } else {\n        div.appendChild(canvasWrapper);\n      }\n\n      var textLayer = null;\n\n      if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) {\n        var textLayerDiv = document.createElement(\"div\");\n        textLayerDiv.className = \"textLayer\";\n        textLayerDiv.style.width = canvasWrapper.style.width;\n        textLayerDiv.style.height = canvasWrapper.style.height;\n\n        if (this.annotationLayer && this.annotationLayer.div) {\n          div.insertBefore(textLayerDiv, this.annotationLayer.div);\n        } else {\n          div.appendChild(textLayerDiv);\n        }\n\n        textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus);\n      }\n\n      this.textLayer = textLayer;\n      var renderContinueCallback = null;\n\n      if (this.renderingQueue) {\n        renderContinueCallback = function renderContinueCallback(cont) {\n          if (!_this.renderingQueue.isHighestPriority(_this)) {\n            _this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED;\n\n            _this.resume = function () {\n              _this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING;\n              cont();\n            };\n\n            return;\n          }\n\n          cont();\n        };\n      }\n\n      var finishPaintTask = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2(error) {\n          return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  if (paintTask === _this.paintTask) {\n                    _this.paintTask = null;\n                  }\n\n                  if (!(error instanceof _pdfjsLib.RenderingCancelledException)) {\n                    _context2.next = 4;\n                    break;\n                  }\n\n                  _this.error = null;\n                  return _context2.abrupt(\"return\");\n\n                case 4:\n                  _this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;\n\n                  if (_this.loadingIconDiv) {\n                    div.removeChild(_this.loadingIconDiv);\n                    delete _this.loadingIconDiv;\n                  }\n\n                  _this._resetZoomLayer(true);\n\n                  _this.error = error;\n                  _this.stats = pdfPage.stats;\n\n                  _this.eventBus.dispatch(\"pagerendered\", {\n                    source: _this,\n                    pageNumber: _this.id,\n                    cssTransform: false,\n                    timestamp: performance.now()\n                  });\n\n                  if (!error) {\n                    _context2.next = 12;\n                    break;\n                  }\n\n                  throw error;\n\n                case 12:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function finishPaintTask(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      var paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper);\n      paintTask.onRenderContinue = renderContinueCallback;\n      this.paintTask = paintTask;\n      var resultPromise = paintTask.promise.then(function () {\n        return finishPaintTask(null).then(function () {\n          if (textLayer) {\n            var readableStream = pdfPage.streamTextContent({\n              normalizeWhitespace: true\n            });\n            textLayer.setTextContentStream(readableStream);\n            textLayer.render();\n          }\n        });\n      }, function (reason) {\n        return finishPaintTask(reason);\n      });\n\n      if (this.annotationLayerFactory) {\n        if (!this.annotationLayer) {\n          this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, this._annotationStorage, this.imageResourcesPath, this.renderInteractiveForms, this.l10n);\n        }\n\n        this._renderAnnotationLayer();\n      }\n\n      div.setAttribute(\"data-loaded\", true);\n      this.eventBus.dispatch(\"pagerender\", {\n        source: this,\n        pageNumber: this.id\n      });\n      return resultPromise;\n    }\n  }, {\n    key: \"paintOnCanvas\",\n    value: function paintOnCanvas(canvasWrapper) {\n      var renderCapability = (0, _pdfjsLib.createPromiseCapability)();\n      var result = {\n        promise: renderCapability.promise,\n        onRenderContinue: function onRenderContinue(cont) {\n          cont();\n        },\n        cancel: function cancel() {\n          renderTask.cancel();\n        }\n      };\n      var viewport = this.viewport;\n      var canvas = document.createElement(\"canvas\");\n      this.l10n.get(\"page_canvas\", {\n        page: this.id\n      }, \"Page {{page}}\").then(function (msg) {\n        canvas.setAttribute(\"aria-label\", msg);\n      });\n      canvas.setAttribute(\"hidden\", \"hidden\");\n      var isCanvasHidden = true;\n\n      var showCanvas = function showCanvas() {\n        if (isCanvasHidden) {\n          canvas.removeAttribute(\"hidden\");\n          isCanvasHidden = false;\n        }\n      };\n\n      canvasWrapper.appendChild(canvas);\n      this.canvas = canvas;\n      canvas.mozOpaque = true;\n      var ctx = canvas.getContext(\"2d\", {\n        alpha: false\n      });\n      var outputScale = (0, _ui_utils.getOutputScale)(ctx);\n      this.outputScale = outputScale;\n\n      if (this.useOnlyCssZoom) {\n        var actualSizeViewport = viewport.clone({\n          scale: _ui_utils.CSS_UNITS\n        });\n        outputScale.sx *= actualSizeViewport.width / viewport.width;\n        outputScale.sy *= actualSizeViewport.height / viewport.height;\n        outputScale.scaled = true;\n      }\n\n      if (this.maxCanvasPixels > 0) {\n        var pixelsInViewport = viewport.width * viewport.height;\n        var maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport);\n\n        if (outputScale.sx > maxScale || outputScale.sy > maxScale) {\n          outputScale.sx = maxScale;\n          outputScale.sy = maxScale;\n          outputScale.scaled = true;\n          this.hasRestrictedScaling = true;\n        } else {\n          this.hasRestrictedScaling = false;\n        }\n      }\n\n      var sfx = (0, _ui_utils.approximateFraction)(outputScale.sx);\n      var sfy = (0, _ui_utils.approximateFraction)(outputScale.sy);\n      canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]);\n      canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]);\n      canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + \"px\";\n      canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + \"px\";\n      this.paintedViewportMap.set(canvas, viewport);\n      var transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0];\n      var renderContext = {\n        canvasContext: ctx,\n        transform: transform,\n        viewport: this.viewport,\n        enableWebGL: this.enableWebGL,\n        renderInteractiveForms: this.renderInteractiveForms,\n        optionalContentConfigPromise: this._optionalContentConfigPromise\n      };\n      var renderTask = this.pdfPage.render(renderContext);\n\n      renderTask.onContinue = function (cont) {\n        showCanvas();\n\n        if (result.onRenderContinue) {\n          result.onRenderContinue(cont);\n        } else {\n          cont();\n        }\n      };\n\n      renderTask.promise.then(function () {\n        showCanvas();\n        renderCapability.resolve(undefined);\n      }, function (error) {\n        showCanvas();\n        renderCapability.reject(error);\n      });\n      return result;\n    }\n  }, {\n    key: \"paintOnSvg\",\n    value: function paintOnSvg(wrapper) {\n      var _this2 = this;\n\n      var cancelled = false;\n\n      var ensureNotCancelled = function ensureNotCancelled() {\n        if (cancelled) {\n          throw new _pdfjsLib.RenderingCancelledException(\"Rendering cancelled, page \".concat(_this2.id), \"svg\");\n        }\n      };\n\n      var pdfPage = this.pdfPage;\n      var actualSizeViewport = this.viewport.clone({\n        scale: _ui_utils.CSS_UNITS\n      });\n      var promise = pdfPage.getOperatorList().then(function (opList) {\n        ensureNotCancelled();\n        var svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs);\n        return svgGfx.getSVG(opList, actualSizeViewport).then(function (svg) {\n          ensureNotCancelled();\n          _this2.svg = svg;\n\n          _this2.paintedViewportMap.set(svg, actualSizeViewport);\n\n          svg.style.width = wrapper.style.width;\n          svg.style.height = wrapper.style.height;\n          _this2.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED;\n          wrapper.appendChild(svg);\n        });\n      });\n      return {\n        promise: promise,\n        onRenderContinue: function onRenderContinue(cont) {\n          cont();\n        },\n        cancel: function cancel() {\n          cancelled = true;\n        }\n      };\n    }\n  }, {\n    key: \"setPageLabel\",\n    value: function setPageLabel(label) {\n      this.pageLabel = typeof label === \"string\" ? label : null;\n\n      if (this.pageLabel !== null) {\n        this.div.setAttribute(\"data-page-label\", this.pageLabel);\n      } else {\n        this.div.removeAttribute(\"data-page-label\");\n      }\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.viewport.width;\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.viewport.height;\n    }\n  }]);\n\n  return PDFPageView;\n}();\n\nexports.PDFPageView = PDFPageView;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFRenderingQueue = exports.RenderingStates = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar CLEANUP_TIMEOUT = 30000;\nvar RenderingStates = {\n  INITIAL: 0,\n  RUNNING: 1,\n  PAUSED: 2,\n  FINISHED: 3\n};\nexports.RenderingStates = RenderingStates;\n\nvar PDFRenderingQueue = /*#__PURE__*/function () {\n  function PDFRenderingQueue() {\n    _classCallCheck(this, PDFRenderingQueue);\n\n    this.pdfViewer = null;\n    this.pdfThumbnailViewer = null;\n    this.onIdle = null;\n    this.highestPriorityPage = null;\n    this.idleTimeout = null;\n    this.printing = false;\n    this.isThumbnailViewEnabled = false;\n  }\n\n  _createClass(PDFRenderingQueue, [{\n    key: \"setViewer\",\n    value: function setViewer(pdfViewer) {\n      this.pdfViewer = pdfViewer;\n    }\n  }, {\n    key: \"setThumbnailViewer\",\n    value: function setThumbnailViewer(pdfThumbnailViewer) {\n      this.pdfThumbnailViewer = pdfThumbnailViewer;\n    }\n  }, {\n    key: \"isHighestPriority\",\n    value: function isHighestPriority(view) {\n      return this.highestPriorityPage === view.renderingId;\n    }\n  }, {\n    key: \"renderHighestPriority\",\n    value: function renderHighestPriority(currentlyVisiblePages) {\n      if (this.idleTimeout) {\n        clearTimeout(this.idleTimeout);\n        this.idleTimeout = null;\n      }\n\n      if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {\n        return;\n      }\n\n      if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {\n        if (this.pdfThumbnailViewer.forceRendering()) {\n          return;\n        }\n      }\n\n      if (this.printing) {\n        return;\n      }\n\n      if (this.onIdle) {\n        this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT);\n      }\n    }\n  }, {\n    key: \"getHighestPriority\",\n    value: function getHighestPriority(visible, views, scrolledDown) {\n      var visibleViews = visible.views;\n      var numVisible = visibleViews.length;\n\n      if (numVisible === 0) {\n        return null;\n      }\n\n      for (var i = 0; i < numVisible; ++i) {\n        var view = visibleViews[i].view;\n\n        if (!this.isViewFinished(view)) {\n          return view;\n        }\n      }\n\n      if (scrolledDown) {\n        var nextPageIndex = visible.last.id;\n\n        if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {\n          return views[nextPageIndex];\n        }\n      } else {\n        var previousPageIndex = visible.first.id - 2;\n\n        if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {\n          return views[previousPageIndex];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"isViewFinished\",\n    value: function isViewFinished(view) {\n      return view.renderingState === RenderingStates.FINISHED;\n    }\n  }, {\n    key: \"renderView\",\n    value: function renderView(view) {\n      var _this = this;\n\n      switch (view.renderingState) {\n        case RenderingStates.FINISHED:\n          return false;\n\n        case RenderingStates.PAUSED:\n          this.highestPriorityPage = view.renderingId;\n          view.resume();\n          break;\n\n        case RenderingStates.RUNNING:\n          this.highestPriorityPage = view.renderingId;\n          break;\n\n        case RenderingStates.INITIAL:\n          this.highestPriorityPage = view.renderingId;\n          view.draw()[\"finally\"](function () {\n            _this.renderHighestPriority();\n          })[\"catch\"](function (reason) {\n            console.error(\"renderView: \\\"\".concat(reason, \"\\\"\"));\n          });\n          break;\n      }\n\n      return true;\n    }\n  }]);\n\n  return PDFRenderingQueue;\n}();\n\nexports.PDFRenderingQueue = PDFRenderingQueue;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFSinglePageViewer = void 0;\n\nvar _base_viewer = __w_pdfjs_require__(19);\n\nvar _pdfjsLib = __w_pdfjs_require__(2);\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar PDFSinglePageViewer = /*#__PURE__*/function (_BaseViewer) {\n  _inherits(PDFSinglePageViewer, _BaseViewer);\n\n  var _super = _createSuper(PDFSinglePageViewer);\n\n  function PDFSinglePageViewer(options) {\n    var _this;\n\n    _classCallCheck(this, PDFSinglePageViewer);\n\n    _this = _super.call(this, options);\n\n    _this.eventBus._on(\"pagesinit\", function (evt) {\n      _this._ensurePageViewVisible();\n    });\n\n    return _this;\n  }\n\n  _createClass(PDFSinglePageViewer, [{\n    key: \"_resetView\",\n    value: function _resetView() {\n      _get(_getPrototypeOf(PDFSinglePageViewer.prototype), \"_resetView\", this).call(this);\n\n      this._previousPageNumber = 1;\n      this._shadowViewer = document.createDocumentFragment();\n      this._updateScrollDown = null;\n    }\n  }, {\n    key: \"_ensurePageViewVisible\",\n    value: function _ensurePageViewVisible() {\n      var pageView = this._pages[this._currentPageNumber - 1];\n      var previousPageView = this._pages[this._previousPageNumber - 1];\n      var viewerNodes = this.viewer.childNodes;\n\n      switch (viewerNodes.length) {\n        case 0:\n          this.viewer.appendChild(pageView.div);\n          break;\n\n        case 1:\n          if (viewerNodes[0] !== previousPageView.div) {\n            throw new Error(\"_ensurePageViewVisible: Unexpected previously visible page.\");\n          }\n\n          if (pageView === previousPageView) {\n            break;\n          }\n\n          this._shadowViewer.appendChild(previousPageView.div);\n\n          this.viewer.appendChild(pageView.div);\n          this.container.scrollTop = 0;\n          break;\n\n        default:\n          throw new Error(\"_ensurePageViewVisible: Only one page should be visible at a time.\");\n      }\n\n      this._previousPageNumber = this._currentPageNumber;\n    }\n  }, {\n    key: \"_scrollUpdate\",\n    value: function _scrollUpdate() {\n      if (this._updateScrollDown) {\n        this._updateScrollDown();\n      }\n\n      _get(_getPrototypeOf(PDFSinglePageViewer.prototype), \"_scrollUpdate\", this).call(this);\n    }\n  }, {\n    key: \"_scrollIntoView\",\n    value: function _scrollIntoView(_ref) {\n      var _this2 = this;\n\n      var pageDiv = _ref.pageDiv,\n          _ref$pageSpot = _ref.pageSpot,\n          pageSpot = _ref$pageSpot === void 0 ? null : _ref$pageSpot,\n          _ref$pageNumber = _ref.pageNumber,\n          pageNumber = _ref$pageNumber === void 0 ? null : _ref$pageNumber;\n\n      if (pageNumber) {\n        this._setCurrentPageNumber(pageNumber);\n      }\n\n      var scrolledDown = this._currentPageNumber >= this._previousPageNumber;\n\n      this._ensurePageViewVisible();\n\n      this.update();\n\n      _get(_getPrototypeOf(PDFSinglePageViewer.prototype), \"_scrollIntoView\", this).call(this, {\n        pageDiv: pageDiv,\n        pageSpot: pageSpot,\n        pageNumber: pageNumber\n      });\n\n      this._updateScrollDown = function () {\n        _this2.scroll.down = scrolledDown;\n        _this2._updateScrollDown = null;\n      };\n    }\n  }, {\n    key: \"_getVisiblePages\",\n    value: function _getVisiblePages() {\n      return this._getCurrentVisiblePage();\n    }\n  }, {\n    key: \"_updateHelper\",\n    value: function _updateHelper(visiblePages) {}\n  }, {\n    key: \"_updateScrollMode\",\n    value: function _updateScrollMode() {}\n  }, {\n    key: \"_updateSpreadMode\",\n    value: function _updateSpreadMode() {}\n  }, {\n    key: \"_viewerElement\",\n    get: function get() {\n      return (0, _pdfjsLib.shadow)(this, \"_viewerElement\", this._shadowViewer);\n    }\n  }, {\n    key: \"_isScrollModeHorizontal\",\n    get: function get() {\n      return (0, _pdfjsLib.shadow)(this, \"_isScrollModeHorizontal\", false);\n    }\n  }]);\n\n  return PDFSinglePageViewer;\n}(_base_viewer.BaseViewer);\n\nexports.PDFSinglePageViewer = PDFSinglePageViewer;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseViewer = void 0;\n\nvar _ui_utils = __w_pdfjs_require__(3);\n\nvar _pdf_rendering_queue = __w_pdfjs_require__(17);\n\nvar _annotation_layer_builder = __w_pdfjs_require__(1);\n\nvar _pdfjsLib = __w_pdfjs_require__(2);\n\nvar _pdf_page_view = __w_pdfjs_require__(16);\n\nvar _pdf_link_service = __w_pdfjs_require__(7);\n\nvar _text_layer_builder = __w_pdfjs_require__(8);\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DEFAULT_CACHE_SIZE = 10;\n\nfunction PDFPageViewBuffer(size) {\n  var data = [];\n\n  this.push = function (view) {\n    var i = data.indexOf(view);\n\n    if (i >= 0) {\n      data.splice(i, 1);\n    }\n\n    data.push(view);\n\n    if (data.length > size) {\n      data.shift().destroy();\n    }\n  };\n\n  this.resize = function (newSize, pagesToKeep) {\n    size = newSize;\n\n    if (pagesToKeep) {\n      var pageIdsToKeep = new Set();\n\n      for (var i = 0, iMax = pagesToKeep.length; i < iMax; ++i) {\n        pageIdsToKeep.add(pagesToKeep[i].id);\n      }\n\n      (0, _ui_utils.moveToEndOfArray)(data, function (page) {\n        return pageIdsToKeep.has(page.id);\n      });\n    }\n\n    while (data.length > size) {\n      data.shift().destroy();\n    }\n  };\n}\n\nfunction isSameScale(oldScale, newScale) {\n  if (newScale === oldScale) {\n    return true;\n  }\n\n  if (Math.abs(newScale - oldScale) < 1e-15) {\n    return true;\n  }\n\n  return false;\n}\n\nvar BaseViewer = /*#__PURE__*/function () {\n  function BaseViewer(options) {\n    var _this = this;\n\n    _classCallCheck(this, BaseViewer);\n\n    if (this.constructor === BaseViewer) {\n      throw new Error(\"Cannot initialize BaseViewer.\");\n    }\n\n    this._name = this.constructor.name;\n    this.container = options.container;\n    this.viewer = options.viewer || options.container.firstElementChild;\n\n    if (!(this.container instanceof HTMLDivElement && this.viewer instanceof HTMLDivElement)) {\n      throw new Error(\"Invalid `container` and/or `viewer` option.\");\n    }\n\n    this.eventBus = options.eventBus;\n    this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService();\n    this.downloadManager = options.downloadManager || null;\n    this.findController = options.findController || null;\n    this.removePageBorders = options.removePageBorders || false;\n    this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE;\n    this.imageResourcesPath = options.imageResourcesPath || \"\";\n    this.renderInteractiveForms = typeof options.renderInteractiveForms === \"boolean\" ? options.renderInteractiveForms : true;\n    this.enablePrintAutoRotate = options.enablePrintAutoRotate || false;\n    this.renderer = options.renderer || _ui_utils.RendererType.CANVAS;\n    this.enableWebGL = options.enableWebGL || false;\n    this.useOnlyCssZoom = options.useOnlyCssZoom || false;\n    this.maxCanvasPixels = options.maxCanvasPixels;\n    this.l10n = options.l10n || _ui_utils.NullL10n;\n    this.defaultRenderingQueue = !options.renderingQueue;\n\n    if (this.defaultRenderingQueue) {\n      this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue();\n      this.renderingQueue.setViewer(this);\n    } else {\n      this.renderingQueue = options.renderingQueue;\n    }\n\n    this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this));\n    this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN;\n    this._onBeforeDraw = this._onAfterDraw = null;\n\n    this._resetView();\n\n    if (this.removePageBorders) {\n      this.viewer.classList.add(\"removePageBorders\");\n    }\n\n    Promise.resolve().then(function () {\n      _this.eventBus.dispatch(\"baseviewerinit\", {\n        source: _this\n      });\n    });\n  }\n\n  _createClass(BaseViewer, [{\n    key: \"getPageView\",\n    value: function getPageView(index) {\n      return this._pages[index];\n    }\n  }, {\n    key: \"_setCurrentPageNumber\",\n    value: function _setCurrentPageNumber(val) {\n      var resetCurrentPageView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (this._currentPageNumber === val) {\n        if (resetCurrentPageView) {\n          this._resetCurrentPageView();\n        }\n\n        return true;\n      }\n\n      if (!(0 < val && val <= this.pagesCount)) {\n        return false;\n      }\n\n      this._currentPageNumber = val;\n      this.eventBus.dispatch(\"pagechanging\", {\n        source: this,\n        pageNumber: val,\n        pageLabel: this._pageLabels && this._pageLabels[val - 1]\n      });\n\n      if (resetCurrentPageView) {\n        this._resetCurrentPageView();\n      }\n\n      return true;\n    }\n  }, {\n    key: \"_onePageRenderedOrForceFetch\",\n    value: function _onePageRenderedOrForceFetch() {\n      if (!this.container.offsetParent || this._getVisiblePages().views.length === 0) {\n        return Promise.resolve();\n      }\n\n      return this._onePageRenderedCapability.promise;\n    }\n  }, {\n    key: \"setDocument\",\n    value: function setDocument(pdfDocument) {\n      var _this2 = this;\n\n      if (this.pdfDocument) {\n        this._cancelRendering();\n\n        this._resetView();\n\n        if (this.findController) {\n          this.findController.setDocument(null);\n        }\n      }\n\n      this.pdfDocument = pdfDocument;\n\n      if (!pdfDocument) {\n        return;\n      }\n\n      var pagesCount = pdfDocument.numPages;\n      var firstPagePromise = pdfDocument.getPage(1);\n      var annotationStorage = pdfDocument.annotationStorage;\n      var optionalContentConfigPromise = pdfDocument.getOptionalContentConfig();\n\n      this._pagesCapability.promise.then(function () {\n        _this2.eventBus.dispatch(\"pagesloaded\", {\n          source: _this2,\n          pagesCount: pagesCount\n        });\n      });\n\n      this._onBeforeDraw = function (evt) {\n        var pageView = _this2._pages[evt.pageNumber - 1];\n\n        if (!pageView) {\n          return;\n        }\n\n        _this2._buffer.push(pageView);\n      };\n\n      this.eventBus._on(\"pagerender\", this._onBeforeDraw);\n\n      this._onAfterDraw = function (evt) {\n        if (evt.cssTransform || _this2._onePageRenderedCapability.settled) {\n          return;\n        }\n\n        _this2._onePageRenderedCapability.resolve();\n\n        _this2.eventBus._off(\"pagerendered\", _this2._onAfterDraw);\n\n        _this2._onAfterDraw = null;\n      };\n\n      this.eventBus._on(\"pagerendered\", this._onAfterDraw);\n\n      firstPagePromise.then(function (firstPdfPage) {\n        _this2._firstPageCapability.resolve(firstPdfPage);\n\n        _this2._optionalContentConfigPromise = optionalContentConfigPromise;\n        var scale = _this2.currentScale;\n        var viewport = firstPdfPage.getViewport({\n          scale: scale * _ui_utils.CSS_UNITS\n        });\n        var textLayerFactory = _this2.textLayerMode !== _ui_utils.TextLayerMode.DISABLE ? _this2 : null;\n\n        for (var pageNum = 1; pageNum <= pagesCount; ++pageNum) {\n          var pageView = new _pdf_page_view.PDFPageView({\n            container: _this2._viewerElement,\n            eventBus: _this2.eventBus,\n            id: pageNum,\n            scale: scale,\n            defaultViewport: viewport.clone(),\n            annotationStorage: annotationStorage,\n            optionalContentConfigPromise: optionalContentConfigPromise,\n            renderingQueue: _this2.renderingQueue,\n            textLayerFactory: textLayerFactory,\n            textLayerMode: _this2.textLayerMode,\n            annotationLayerFactory: _this2,\n            imageResourcesPath: _this2.imageResourcesPath,\n            renderInteractiveForms: _this2.renderInteractiveForms,\n            renderer: _this2.renderer,\n            enableWebGL: _this2.enableWebGL,\n            useOnlyCssZoom: _this2.useOnlyCssZoom,\n            maxCanvasPixels: _this2.maxCanvasPixels,\n            l10n: _this2.l10n\n          });\n\n          _this2._pages.push(pageView);\n        }\n\n        var firstPageView = _this2._pages[0];\n\n        if (firstPageView) {\n          firstPageView.setPdfPage(firstPdfPage);\n\n          _this2.linkService.cachePageRef(1, firstPdfPage.ref);\n        }\n\n        if (_this2._spreadMode !== _ui_utils.SpreadMode.NONE) {\n          _this2._updateSpreadMode();\n        }\n\n        _this2._onePageRenderedOrForceFetch().then(function () {\n          if (_this2.findController) {\n            _this2.findController.setDocument(pdfDocument);\n          }\n\n          if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > 7500) {\n            _this2._pagesCapability.resolve();\n\n            return;\n          }\n\n          var getPagesLeft = pagesCount - 1;\n\n          if (getPagesLeft <= 0) {\n            _this2._pagesCapability.resolve();\n\n            return;\n          }\n\n          var _loop = function _loop(_pageNum) {\n            pdfDocument.getPage(_pageNum).then(function (pdfPage) {\n              var pageView = _this2._pages[_pageNum - 1];\n\n              if (!pageView.pdfPage) {\n                pageView.setPdfPage(pdfPage);\n              }\n\n              _this2.linkService.cachePageRef(_pageNum, pdfPage.ref);\n\n              if (--getPagesLeft === 0) {\n                _this2._pagesCapability.resolve();\n              }\n            }, function (reason) {\n              console.error(\"Unable to get page \".concat(_pageNum, \" to initialize viewer\"), reason);\n\n              if (--getPagesLeft === 0) {\n                _this2._pagesCapability.resolve();\n              }\n            });\n          };\n\n          for (var _pageNum = 2; _pageNum <= pagesCount; ++_pageNum) {\n            _loop(_pageNum);\n          }\n        });\n\n        _this2.eventBus.dispatch(\"pagesinit\", {\n          source: _this2\n        });\n\n        if (_this2.defaultRenderingQueue) {\n          _this2.update();\n        }\n      })[\"catch\"](function (reason) {\n        console.error(\"Unable to initialize viewer\", reason);\n      });\n    }\n  }, {\n    key: \"setPageLabels\",\n    value: function setPageLabels(labels) {\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      if (!labels) {\n        this._pageLabels = null;\n      } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) {\n        this._pageLabels = null;\n        console.error(\"\".concat(this._name, \".setPageLabels: Invalid page labels.\"));\n      } else {\n        this._pageLabels = labels;\n      }\n\n      for (var i = 0, ii = this._pages.length; i < ii; i++) {\n        var pageView = this._pages[i];\n        var label = this._pageLabels && this._pageLabels[i];\n        pageView.setPageLabel(label);\n      }\n    }\n  }, {\n    key: \"_resetView\",\n    value: function _resetView() {\n      this._pages = [];\n      this._currentPageNumber = 1;\n      this._currentScale = _ui_utils.UNKNOWN_SCALE;\n      this._currentScaleValue = null;\n      this._pageLabels = null;\n      this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE);\n      this._location = null;\n      this._pagesRotation = 0;\n      this._optionalContentConfigPromise = null;\n      this._pagesRequests = new WeakMap();\n      this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)();\n      this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)();\n      this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)();\n      this._scrollMode = _ui_utils.ScrollMode.VERTICAL;\n      this._spreadMode = _ui_utils.SpreadMode.NONE;\n\n      if (this._onBeforeDraw) {\n        this.eventBus._off(\"pagerender\", this._onBeforeDraw);\n\n        this._onBeforeDraw = null;\n      }\n\n      if (this._onAfterDraw) {\n        this.eventBus._off(\"pagerendered\", this._onAfterDraw);\n\n        this._onAfterDraw = null;\n      }\n\n      this.viewer.textContent = \"\";\n\n      this._updateScrollMode();\n    }\n  }, {\n    key: \"_scrollUpdate\",\n    value: function _scrollUpdate() {\n      if (this.pagesCount === 0) {\n        return;\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"_scrollIntoView\",\n    value: function _scrollIntoView(_ref) {\n      var pageDiv = _ref.pageDiv,\n          _ref$pageSpot = _ref.pageSpot,\n          pageSpot = _ref$pageSpot === void 0 ? null : _ref$pageSpot,\n          _ref$pageNumber = _ref.pageNumber,\n          pageNumber = _ref$pageNumber === void 0 ? null : _ref$pageNumber;\n      (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot);\n    }\n  }, {\n    key: \"_setScaleUpdatePages\",\n    value: function _setScaleUpdatePages(newScale, newValue) {\n      var noScroll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var preset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      this._currentScaleValue = newValue.toString();\n\n      if (isSameScale(this._currentScale, newScale)) {\n        if (preset) {\n          this.eventBus.dispatch(\"scalechanging\", {\n            source: this,\n            scale: newScale,\n            presetValue: newValue\n          });\n        }\n\n        return;\n      }\n\n      for (var i = 0, ii = this._pages.length; i < ii; i++) {\n        this._pages[i].update(newScale);\n      }\n\n      this._currentScale = newScale;\n\n      if (!noScroll) {\n        var page = this._currentPageNumber,\n            dest;\n\n        if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) {\n          page = this._location.pageNumber;\n          dest = [null, {\n            name: \"XYZ\"\n          }, this._location.left, this._location.top, null];\n        }\n\n        this.scrollPageIntoView({\n          pageNumber: page,\n          destArray: dest,\n          allowNegativeOffset: true\n        });\n      }\n\n      this.eventBus.dispatch(\"scalechanging\", {\n        source: this,\n        scale: newScale,\n        presetValue: preset ? newValue : undefined\n      });\n\n      if (this.defaultRenderingQueue) {\n        this.update();\n      }\n    }\n  }, {\n    key: \"_setScale\",\n    value: function _setScale(value) {\n      var noScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var scale = parseFloat(value);\n\n      if (scale > 0) {\n        this._setScaleUpdatePages(scale, value, noScroll, false);\n      } else {\n        var currentPage = this._pages[this._currentPageNumber - 1];\n\n        if (!currentPage) {\n          return;\n        }\n\n        var noPadding = this.isInPresentationMode || this.removePageBorders;\n        var hPadding = noPadding ? 0 : _ui_utils.SCROLLBAR_PADDING;\n        var vPadding = noPadding ? 0 : _ui_utils.VERTICAL_PADDING;\n\n        if (!noPadding && this._isScrollModeHorizontal) {\n          var _ref2 = [vPadding, hPadding];\n          hPadding = _ref2[0];\n          vPadding = _ref2[1];\n        }\n\n        var pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale;\n        var pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale;\n\n        switch (value) {\n          case \"page-actual\":\n            scale = 1;\n            break;\n\n          case \"page-width\":\n            scale = pageWidthScale;\n            break;\n\n          case \"page-height\":\n            scale = pageHeightScale;\n            break;\n\n          case \"page-fit\":\n            scale = Math.min(pageWidthScale, pageHeightScale);\n            break;\n\n          case \"auto\":\n            var horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale);\n            scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale);\n            break;\n\n          default:\n            console.error(\"\".concat(this._name, \"._setScale: \\\"\").concat(value, \"\\\" is an unknown zoom value.\"));\n            return;\n        }\n\n        this._setScaleUpdatePages(scale, value, noScroll, true);\n      }\n    }\n  }, {\n    key: \"_resetCurrentPageView\",\n    value: function _resetCurrentPageView() {\n      if (this.isInPresentationMode) {\n        this._setScale(this._currentScaleValue, true);\n      }\n\n      var pageView = this._pages[this._currentPageNumber - 1];\n\n      this._scrollIntoView({\n        pageDiv: pageView.div\n      });\n    }\n  }, {\n    key: \"scrollPageIntoView\",\n    value: function scrollPageIntoView(_ref3) {\n      var pageNumber = _ref3.pageNumber,\n          _ref3$destArray = _ref3.destArray,\n          destArray = _ref3$destArray === void 0 ? null : _ref3$destArray,\n          _ref3$allowNegativeOf = _ref3.allowNegativeOffset,\n          allowNegativeOffset = _ref3$allowNegativeOf === void 0 ? false : _ref3$allowNegativeOf,\n          _ref3$ignoreDestinati = _ref3.ignoreDestinationZoom,\n          ignoreDestinationZoom = _ref3$ignoreDestinati === void 0 ? false : _ref3$ignoreDestinati;\n\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      var pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1];\n\n      if (!pageView) {\n        console.error(\"\".concat(this._name, \".scrollPageIntoView: \") + \"\\\"\".concat(pageNumber, \"\\\" is not a valid pageNumber parameter.\"));\n        return;\n      }\n\n      if (this.isInPresentationMode || !destArray) {\n        this._setCurrentPageNumber(pageNumber, true);\n\n        return;\n      }\n\n      var x = 0,\n          y = 0;\n      var width = 0,\n          height = 0,\n          widthScale,\n          heightScale;\n      var changeOrientation = pageView.rotation % 180 !== 0;\n      var pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _ui_utils.CSS_UNITS;\n      var pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _ui_utils.CSS_UNITS;\n      var scale = 0;\n\n      switch (destArray[1].name) {\n        case \"XYZ\":\n          x = destArray[2];\n          y = destArray[3];\n          scale = destArray[4];\n          x = x !== null ? x : 0;\n          y = y !== null ? y : pageHeight;\n          break;\n\n        case \"Fit\":\n        case \"FitB\":\n          scale = \"page-fit\";\n          break;\n\n        case \"FitH\":\n        case \"FitBH\":\n          y = destArray[2];\n          scale = \"page-width\";\n\n          if (y === null && this._location) {\n            x = this._location.left;\n            y = this._location.top;\n          }\n\n          break;\n\n        case \"FitV\":\n        case \"FitBV\":\n          x = destArray[2];\n          width = pageWidth;\n          height = pageHeight;\n          scale = \"page-height\";\n          break;\n\n        case \"FitR\":\n          x = destArray[2];\n          y = destArray[3];\n          width = destArray[4] - x;\n          height = destArray[5] - y;\n          var hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING;\n          var vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING;\n          widthScale = (this.container.clientWidth - hPadding) / width / _ui_utils.CSS_UNITS;\n          heightScale = (this.container.clientHeight - vPadding) / height / _ui_utils.CSS_UNITS;\n          scale = Math.min(Math.abs(widthScale), Math.abs(heightScale));\n          break;\n\n        default:\n          console.error(\"\".concat(this._name, \".scrollPageIntoView: \") + \"\\\"\".concat(destArray[1].name, \"\\\" is not a valid destination type.\"));\n          return;\n      }\n\n      if (!ignoreDestinationZoom) {\n        if (scale && scale !== this._currentScale) {\n          this.currentScaleValue = scale;\n        } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) {\n          this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE;\n        }\n      }\n\n      if (scale === \"page-fit\" && !destArray[4]) {\n        this._scrollIntoView({\n          pageDiv: pageView.div,\n          pageNumber: pageNumber\n        });\n\n        return;\n      }\n\n      var boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)];\n      var left = Math.min(boundingRect[0][0], boundingRect[1][0]);\n      var top = Math.min(boundingRect[0][1], boundingRect[1][1]);\n\n      if (!allowNegativeOffset) {\n        left = Math.max(left, 0);\n        top = Math.max(top, 0);\n      }\n\n      this._scrollIntoView({\n        pageDiv: pageView.div,\n        pageSpot: {\n          left: left,\n          top: top\n        },\n        pageNumber: pageNumber\n      });\n    }\n  }, {\n    key: \"_updateLocation\",\n    value: function _updateLocation(firstPage) {\n      var currentScale = this._currentScale;\n      var currentScaleValue = this._currentScaleValue;\n      var normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue;\n      var pageNumber = firstPage.id;\n      var pdfOpenParams = \"#page=\" + pageNumber;\n      pdfOpenParams += \"&zoom=\" + normalizedScaleValue;\n      var currentPageView = this._pages[pageNumber - 1];\n      var container = this.container;\n      var topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y);\n      var intLeft = Math.round(topLeft[0]);\n      var intTop = Math.round(topLeft[1]);\n      pdfOpenParams += \",\" + intLeft + \",\" + intTop;\n      this._location = {\n        pageNumber: pageNumber,\n        scale: normalizedScaleValue,\n        top: intTop,\n        left: intLeft,\n        rotation: this._pagesRotation,\n        pdfOpenParams: pdfOpenParams\n      };\n    }\n  }, {\n    key: \"_updateHelper\",\n    value: function _updateHelper(visiblePages) {\n      throw new Error(\"Not implemented: _updateHelper\");\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var visible = this._getVisiblePages();\n\n      var visiblePages = visible.views,\n          numVisiblePages = visiblePages.length;\n\n      if (numVisiblePages === 0) {\n        return;\n      }\n\n      var newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1);\n\n      this._buffer.resize(newCacheSize, visiblePages);\n\n      this.renderingQueue.renderHighestPriority(visible);\n\n      this._updateHelper(visiblePages);\n\n      this._updateLocation(visible.first);\n\n      this.eventBus.dispatch(\"updateviewarea\", {\n        source: this,\n        location: this._location\n      });\n    }\n  }, {\n    key: \"containsElement\",\n    value: function containsElement(element) {\n      return this.container.contains(element);\n    }\n  }, {\n    key: \"focus\",\n    value: function focus() {\n      this.container.focus();\n    }\n  }, {\n    key: \"_getCurrentVisiblePage\",\n    value: function _getCurrentVisiblePage() {\n      if (!this.pagesCount) {\n        return {\n          views: []\n        };\n      }\n\n      var pageView = this._pages[this._currentPageNumber - 1];\n      var element = pageView.div;\n      var view = {\n        id: pageView.id,\n        x: element.offsetLeft + element.clientLeft,\n        y: element.offsetTop + element.clientTop,\n        view: pageView\n      };\n      return {\n        first: view,\n        last: view,\n        views: [view]\n      };\n    }\n  }, {\n    key: \"_getVisiblePages\",\n    value: function _getVisiblePages() {\n      return (0, _ui_utils.getVisibleElements)(this.container, this._pages, true, this._isScrollModeHorizontal);\n    }\n  }, {\n    key: \"isPageVisible\",\n    value: function isPageVisible(pageNumber) {\n      if (!this.pdfDocument) {\n        return false;\n      }\n\n      if (pageNumber < 1 || pageNumber > this.pagesCount) {\n        console.error(\"\".concat(this._name, \".isPageVisible: \\\"\").concat(pageNumber, \"\\\" is out of bounds.\"));\n        return false;\n      }\n\n      return this._getVisiblePages().views.some(function (view) {\n        return view.id === pageNumber;\n      });\n    }\n  }, {\n    key: \"cleanup\",\n    value: function cleanup() {\n      for (var i = 0, ii = this._pages.length; i < ii; i++) {\n        if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) {\n          this._pages[i].reset();\n        }\n      }\n    }\n  }, {\n    key: \"_cancelRendering\",\n    value: function _cancelRendering() {\n      for (var i = 0, ii = this._pages.length; i < ii; i++) {\n        if (this._pages[i]) {\n          this._pages[i].cancelRendering();\n        }\n      }\n    }\n  }, {\n    key: \"_ensurePdfPageLoaded\",\n    value: function _ensurePdfPageLoaded(pageView) {\n      var _this3 = this;\n\n      if (pageView.pdfPage) {\n        return Promise.resolve(pageView.pdfPage);\n      }\n\n      if (this._pagesRequests.has(pageView)) {\n        return this._pagesRequests.get(pageView);\n      }\n\n      var promise = this.pdfDocument.getPage(pageView.id).then(function (pdfPage) {\n        if (!pageView.pdfPage) {\n          pageView.setPdfPage(pdfPage);\n        }\n\n        _this3._pagesRequests[\"delete\"](pageView);\n\n        return pdfPage;\n      })[\"catch\"](function (reason) {\n        console.error(\"Unable to get page for page view\", reason);\n\n        _this3._pagesRequests[\"delete\"](pageView);\n      });\n\n      this._pagesRequests.set(pageView, promise);\n\n      return promise;\n    }\n  }, {\n    key: \"forceRendering\",\n    value: function forceRendering(currentlyVisiblePages) {\n      var _this4 = this;\n\n      var visiblePages = currentlyVisiblePages || this._getVisiblePages();\n\n      var scrollAhead = this._isScrollModeHorizontal ? this.scroll.right : this.scroll.down;\n      var pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead);\n\n      if (pageView) {\n        this._ensurePdfPageLoaded(pageView).then(function () {\n          _this4.renderingQueue.renderView(pageView);\n        });\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"createTextLayerBuilder\",\n    value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) {\n      var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var eventBus = arguments.length > 4 ? arguments[4] : undefined;\n      return new _text_layer_builder.TextLayerBuilder({\n        textLayerDiv: textLayerDiv,\n        eventBus: eventBus,\n        pageIndex: pageIndex,\n        viewport: viewport,\n        findController: this.isInPresentationMode ? null : this.findController,\n        enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection\n      });\n    }\n  }, {\n    key: \"createAnnotationLayerBuilder\",\n    value: function createAnnotationLayerBuilder(pageDiv, pdfPage) {\n      var annotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      var imageResourcesPath = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n      var renderInteractiveForms = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n      var l10n = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _ui_utils.NullL10n;\n      return new _annotation_layer_builder.AnnotationLayerBuilder({\n        pageDiv: pageDiv,\n        pdfPage: pdfPage,\n        annotationStorage: annotationStorage,\n        imageResourcesPath: imageResourcesPath,\n        renderInteractiveForms: renderInteractiveForms,\n        linkService: this.linkService,\n        downloadManager: this.downloadManager,\n        l10n: l10n\n      });\n    }\n  }, {\n    key: \"getPagesOverview\",\n    value: function getPagesOverview() {\n      var pagesOverview = this._pages.map(function (pageView) {\n        var viewport = pageView.pdfPage.getViewport({\n          scale: 1\n        });\n        return {\n          width: viewport.width,\n          height: viewport.height,\n          rotation: viewport.rotation\n        };\n      });\n\n      if (!this.enablePrintAutoRotate) {\n        return pagesOverview;\n      }\n\n      return pagesOverview.map(function (size) {\n        if ((0, _ui_utils.isPortraitOrientation)(size)) {\n          return size;\n        }\n\n        return {\n          width: size.height,\n          height: size.width,\n          rotation: (size.rotation + 90) % 360\n        };\n      });\n    }\n  }, {\n    key: \"_updateScrollMode\",\n    value: function _updateScrollMode() {\n      var pageNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n      var scrollMode = this._scrollMode,\n          viewer = this.viewer;\n      viewer.classList.toggle(\"scrollHorizontal\", scrollMode === _ui_utils.ScrollMode.HORIZONTAL);\n      viewer.classList.toggle(\"scrollWrapped\", scrollMode === _ui_utils.ScrollMode.WRAPPED);\n\n      if (!this.pdfDocument || !pageNumber) {\n        return;\n      }\n\n      if (this._currentScaleValue && isNaN(this._currentScaleValue)) {\n        this._setScale(this._currentScaleValue, true);\n      }\n\n      this._setCurrentPageNumber(pageNumber, true);\n\n      this.update();\n    }\n  }, {\n    key: \"_updateSpreadMode\",\n    value: function _updateSpreadMode() {\n      var pageNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      var viewer = this.viewer,\n          pages = this._pages;\n      viewer.textContent = \"\";\n\n      if (this._spreadMode === _ui_utils.SpreadMode.NONE) {\n        for (var i = 0, iMax = pages.length; i < iMax; ++i) {\n          viewer.appendChild(pages[i].div);\n        }\n      } else {\n        var parity = this._spreadMode - 1;\n        var spread = null;\n\n        for (var _i = 0, _iMax = pages.length; _i < _iMax; ++_i) {\n          if (spread === null) {\n            spread = document.createElement(\"div\");\n            spread.className = \"spread\";\n            viewer.appendChild(spread);\n          } else if (_i % 2 === parity) {\n            spread = spread.cloneNode(false);\n            viewer.appendChild(spread);\n          }\n\n          spread.appendChild(pages[_i].div);\n        }\n      }\n\n      if (!pageNumber) {\n        return;\n      }\n\n      this._setCurrentPageNumber(pageNumber, true);\n\n      this.update();\n    }\n  }, {\n    key: \"pagesCount\",\n    get: function get() {\n      return this._pages.length;\n    }\n  }, {\n    key: \"pageViewsReady\",\n    get: function get() {\n      if (!this._pagesCapability.settled) {\n        return false;\n      }\n\n      return this._pages.every(function (pageView) {\n        return pageView && pageView.pdfPage;\n      });\n    }\n  }, {\n    key: \"currentPageNumber\",\n    get: function get() {\n      return this._currentPageNumber;\n    },\n    set: function set(val) {\n      if (!Number.isInteger(val)) {\n        throw new Error(\"Invalid page number.\");\n      }\n\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      if (!this._setCurrentPageNumber(val, true)) {\n        console.error(\"\".concat(this._name, \".currentPageNumber: \\\"\").concat(val, \"\\\" is not a valid page.\"));\n      }\n    }\n  }, {\n    key: \"currentPageLabel\",\n    get: function get() {\n      return this._pageLabels && this._pageLabels[this._currentPageNumber - 1];\n    },\n    set: function set(val) {\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      var page = val | 0;\n\n      if (this._pageLabels) {\n        var i = this._pageLabels.indexOf(val);\n\n        if (i >= 0) {\n          page = i + 1;\n        }\n      }\n\n      if (!this._setCurrentPageNumber(page, true)) {\n        console.error(\"\".concat(this._name, \".currentPageLabel: \\\"\").concat(val, \"\\\" is not a valid page.\"));\n      }\n    }\n  }, {\n    key: \"currentScale\",\n    get: function get() {\n      return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE;\n    },\n    set: function set(val) {\n      if (isNaN(val)) {\n        throw new Error(\"Invalid numeric scale.\");\n      }\n\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      this._setScale(val, false);\n    }\n  }, {\n    key: \"currentScaleValue\",\n    get: function get() {\n      return this._currentScaleValue;\n    },\n    set: function set(val) {\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      this._setScale(val, false);\n    }\n  }, {\n    key: \"pagesRotation\",\n    get: function get() {\n      return this._pagesRotation;\n    },\n    set: function set(rotation) {\n      if (!(0, _ui_utils.isValidRotation)(rotation)) {\n        throw new Error(\"Invalid pages rotation angle.\");\n      }\n\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      if (this._pagesRotation === rotation) {\n        return;\n      }\n\n      this._pagesRotation = rotation;\n      var pageNumber = this._currentPageNumber;\n\n      for (var i = 0, ii = this._pages.length; i < ii; i++) {\n        var pageView = this._pages[i];\n        pageView.update(pageView.scale, rotation);\n      }\n\n      if (this._currentScaleValue) {\n        this._setScale(this._currentScaleValue, true);\n      }\n\n      this.eventBus.dispatch(\"rotationchanging\", {\n        source: this,\n        pagesRotation: rotation,\n        pageNumber: pageNumber\n      });\n\n      if (this.defaultRenderingQueue) {\n        this.update();\n      }\n    }\n  }, {\n    key: \"firstPagePromise\",\n    get: function get() {\n      return this.pdfDocument ? this._firstPageCapability.promise : null;\n    }\n  }, {\n    key: \"onePageRendered\",\n    get: function get() {\n      return this.pdfDocument ? this._onePageRenderedCapability.promise : null;\n    }\n  }, {\n    key: \"pagesPromise\",\n    get: function get() {\n      return this.pdfDocument ? this._pagesCapability.promise : null;\n    }\n  }, {\n    key: \"_viewerElement\",\n    get: function get() {\n      throw new Error(\"Not implemented: _viewerElement\");\n    }\n  }, {\n    key: \"_isScrollModeHorizontal\",\n    get: function get() {\n      return this.isInPresentationMode ? false : this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL;\n    }\n  }, {\n    key: \"isInPresentationMode\",\n    get: function get() {\n      return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN;\n    }\n  }, {\n    key: \"isChangingPresentationMode\",\n    get: function get() {\n      return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING;\n    }\n  }, {\n    key: \"isHorizontalScrollbarEnabled\",\n    get: function get() {\n      return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth;\n    }\n  }, {\n    key: \"isVerticalScrollbarEnabled\",\n    get: function get() {\n      return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight;\n    }\n  }, {\n    key: \"hasEqualPageSizes\",\n    get: function get() {\n      var firstPageView = this._pages[0];\n\n      for (var i = 1, ii = this._pages.length; i < ii; ++i) {\n        var pageView = this._pages[i];\n\n        if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"optionalContentConfigPromise\",\n    get: function get() {\n      if (!this.pdfDocument) {\n        return Promise.resolve(null);\n      }\n\n      if (!this._optionalContentConfigPromise) {\n        return this.pdfDocument.getOptionalContentConfig();\n      }\n\n      return this._optionalContentConfigPromise;\n    },\n    set: function set(promise) {\n      if (!(promise instanceof Promise)) {\n        throw new Error(\"Invalid optionalContentConfigPromise: \".concat(promise));\n      }\n\n      if (!this.pdfDocument) {\n        return;\n      }\n\n      if (!this._optionalContentConfigPromise) {\n        return;\n      }\n\n      this._optionalContentConfigPromise = promise;\n\n      var _iterator = _createForOfIteratorHelper(this._pages),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var pageView = _step.value;\n          pageView.update(pageView.scale, pageView.rotation, promise);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      this.update();\n      this.eventBus.dispatch(\"optionalcontentconfigchanged\", {\n        source: this,\n        promise: promise\n      });\n    }\n  }, {\n    key: \"scrollMode\",\n    get: function get() {\n      return this._scrollMode;\n    },\n    set: function set(mode) {\n      if (this._scrollMode === mode) {\n        return;\n      }\n\n      if (!(0, _ui_utils.isValidScrollMode)(mode)) {\n        throw new Error(\"Invalid scroll mode: \".concat(mode));\n      }\n\n      this._scrollMode = mode;\n      this.eventBus.dispatch(\"scrollmodechanged\", {\n        source: this,\n        mode: mode\n      });\n\n      this._updateScrollMode(this._currentPageNumber);\n    }\n  }, {\n    key: \"spreadMode\",\n    get: function get() {\n      return this._spreadMode;\n    },\n    set: function set(mode) {\n      if (this._spreadMode === mode) {\n        return;\n      }\n\n      if (!(0, _ui_utils.isValidSpreadMode)(mode)) {\n        throw new Error(\"Invalid spread mode: \".concat(mode));\n      }\n\n      this._spreadMode = mode;\n      this.eventBus.dispatch(\"spreadmodechanged\", {\n        source: this,\n        mode: mode\n      });\n\n      this._updateSpreadMode(this._currentPageNumber);\n    }\n  }]);\n\n  return BaseViewer;\n}();\n\nexports.BaseViewer = BaseViewer;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __w_pdfjs_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PDFViewer = void 0;\n\nvar _base_viewer = __w_pdfjs_require__(19);\n\nvar _pdfjsLib = __w_pdfjs_require__(2);\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar PDFViewer = /*#__PURE__*/function (_BaseViewer) {\n  _inherits(PDFViewer, _BaseViewer);\n\n  var _super = _createSuper(PDFViewer);\n\n  function PDFViewer() {\n    _classCallCheck(this, PDFViewer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(PDFViewer, [{\n    key: \"_scrollIntoView\",\n    value: function _scrollIntoView(_ref) {\n      var pageDiv = _ref.pageDiv,\n          _ref$pageSpot = _ref.pageSpot,\n          pageSpot = _ref$pageSpot === void 0 ? null : _ref$pageSpot,\n          _ref$pageNumber = _ref.pageNumber,\n          pageNumber = _ref$pageNumber === void 0 ? null : _ref$pageNumber;\n\n      if (!pageSpot && !this.isInPresentationMode) {\n        var left = pageDiv.offsetLeft + pageDiv.clientLeft;\n        var right = left + pageDiv.clientWidth;\n        var _this$container = this.container,\n            scrollLeft = _this$container.scrollLeft,\n            clientWidth = _this$container.clientWidth;\n\n        if (this._isScrollModeHorizontal || left < scrollLeft || right > scrollLeft + clientWidth) {\n          pageSpot = {\n            left: 0,\n            top: 0\n          };\n        }\n      }\n\n      _get(_getPrototypeOf(PDFViewer.prototype), \"_scrollIntoView\", this).call(this, {\n        pageDiv: pageDiv,\n        pageSpot: pageSpot,\n        pageNumber: pageNumber\n      });\n    }\n  }, {\n    key: \"_getVisiblePages\",\n    value: function _getVisiblePages() {\n      if (this.isInPresentationMode) {\n        return this._getCurrentVisiblePage();\n      }\n\n      return _get(_getPrototypeOf(PDFViewer.prototype), \"_getVisiblePages\", this).call(this);\n    }\n  }, {\n    key: \"_updateHelper\",\n    value: function _updateHelper(visiblePages) {\n      if (this.isInPresentationMode) {\n        return;\n      }\n\n      var currentId = this._currentPageNumber;\n      var stillFullyVisible = false;\n\n      var _iterator = _createForOfIteratorHelper(visiblePages),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var page = _step.value;\n\n          if (page.percent < 100) {\n            break;\n          }\n\n          if (page.id === currentId) {\n            stillFullyVisible = true;\n            break;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (!stillFullyVisible) {\n        currentId = visiblePages[0].id;\n      }\n\n      this._setCurrentPageNumber(currentId);\n    }\n  }, {\n    key: \"_viewerElement\",\n    get: function get() {\n      return (0, _pdfjsLib.shadow)(this, \"_viewerElement\", this.viewer);\n    }\n  }]);\n\n  return PDFViewer;\n}(_base_viewer.BaseViewer);\n\nexports.PDFViewer = PDFViewer;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=pdf_viewer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC1zaWcvZXM1L3dlYi9wZGZfdmlld2VyLmpzPzVmMmIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLNkQ7QUFDbkUsQ0FBQztBQUNELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxnQ0FBZ0M7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLGtCQUFrQjtBQUNsRjtBQUNBLHlEQUF5RCxjQUFjO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGlDQUFpQztBQUNsRix3SEFBd0gsbUJBQW1CLEVBQUU7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDBCQUEwQixFQUFFO0FBQy9ELHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsK0RBQStEO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsYUFBYSxtQkFBTyxDQUFDLHVFQUFpQjtBQUN0Qzs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsdUNBQXVDLGtCQUFrQjs7QUFFL0YsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck4sdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLGlDQUFpQywySEFBMkg7O0FBRTVKLDZCQUE2QixrS0FBa0s7O0FBRS9MLGlEQUFpRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNELGtIQUFrSDs7QUFFOVosc0NBQXNDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLGtCQUFrQixFQUFFLGFBQWE7O0FBRXJMLHdDQUF3QyxnRkFBZ0YsZUFBZSxlQUFlLGdCQUFnQixvQkFBb0IsTUFBTSwwQ0FBMEMsK0JBQStCLGFBQWEscUJBQXFCLG1DQUFtQyxFQUFFLEVBQUUsY0FBYyxXQUFXLFVBQVUsRUFBRSxVQUFVLE1BQU0saURBQWlELEVBQUUsVUFBVSxrQkFBa0IsRUFBRSxFQUFFLGFBQWE7O0FBRXZlLCtCQUErQixvQ0FBb0M7O0FBRW5FLDRFQUE0RSxNQUFNLDBCQUEwQix3QkFBd0IsRUFBRSxnQkFBZ0IsZUFBZSxRQUFRLEVBQUUsaUJBQWlCLGdCQUFnQixFQUFFLE9BQU8sNENBQTRDLEVBQUU7O0FBRXZRLGdDQUFnQyxxQkFBcUIsbUNBQW1DLGdEQUFnRCxnQ0FBZ0Msd0JBQXdCLHdFQUF3RSxFQUFFLHVCQUF1Qix1RUFBdUUsRUFBRSxrQkFBa0IsRUFBRSxFQUFFLEdBQUc7O0FBRW5ZO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QixFQUFFLGFBQWEsRUFBRTtBQUMxQywwQ0FBMEMsY0FBYztBQUN4RCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCLFFBQVE7QUFDakM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlEQUFpRCxRQUFRO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0ZBQXNGO0FBQ3RGO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGFBQWE7QUFDbEM7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVCQUF1QiwyQkFBMkIsMkVBQTJFLGtDQUFrQyxtQkFBbUIsR0FBRyxFQUFFLE9BQU8sa0NBQWtDLDhIQUE4SCxHQUFHLEVBQUUscUJBQXFCOztBQUV4WDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDhDQUE4QyxRQUFRO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEdBQUcsTUFBSyxHQUFHLENBQVMsc0RBQXNEOztBQUUzRTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUEsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOO0FBQ0E7QUFDQSxxRkFBcUY7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsYUFBYTtBQUNiO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU8sc0JBQXNCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsUUFBUTtBQUNsRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLDBEQUEwRCxTQUFTO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxRQUFRO0FBQ2xEO0FBQ0E7O0FBRUEsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUEsc0NBQXNDLHVDQUF1QyxrQkFBa0I7O0FBRS9GLDRFQUE0RSxNQUFNLDBCQUEwQix3QkFBd0IsRUFBRSxnQkFBZ0IsZUFBZSxRQUFRLEVBQUUsaUJBQWlCLGdCQUFnQixFQUFFLE9BQU8sNENBQTRDLEVBQUU7O0FBRXZRLGdDQUFnQyxxQkFBcUIsbUNBQW1DLGdEQUFnRCxnQ0FBZ0Msd0JBQXdCLHdFQUF3RSxFQUFFLHVCQUF1Qix1RUFBdUUsRUFBRSxrQkFBa0IsRUFBRSxFQUFFLEdBQUc7O0FBRW5ZLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1LQUFtSyxNQUFNLGVBQWUsTUFBTTtBQUM5TDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLHNDQUFzQztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLEVBQUUsYUFBYSxFQUFFO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsYUFBYTtBQUMzQztBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQiwrQkFBK0I7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsYUFBYTtBQUM3QixLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQyxRQUFRO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDLFNBQVM7QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBOztBQUVBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBLHdEQUF3RCxRQUFRO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsY0FBYztBQUNyQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSx1QkFBdUIsMkJBQTJCLDJFQUEyRSxrQ0FBa0MsbUJBQW1CLEdBQUcsRUFBRSxPQUFPLGtDQUFrQyw4SEFBOEgsR0FBRyxFQUFFLHFCQUFxQjs7QUFFeFgsaUNBQWlDLDJIQUEySDs7QUFFNUosNkJBQTZCLGtLQUFrSzs7QUFFL0wsaURBQWlELGdCQUFnQixnRUFBZ0Usd0RBQXdELDZEQUE2RCxzREFBc0Qsa0hBQWtIOztBQUU5WixzQ0FBc0MsdURBQXVELHVDQUF1QyxTQUFTLE9BQU8sa0JBQWtCLEVBQUUsYUFBYTs7QUFFckwsd0NBQXdDLGdGQUFnRixlQUFlLGVBQWUsZ0JBQWdCLG9CQUFvQixNQUFNLDBDQUEwQywrQkFBK0IsYUFBYSxxQkFBcUIsbUNBQW1DLEVBQUUsRUFBRSxjQUFjLFdBQVcsVUFBVSxFQUFFLFVBQVUsTUFBTSxpREFBaUQsRUFBRSxVQUFVLGtCQUFrQixFQUFFLEVBQUUsYUFBYTs7QUFFdmUsK0JBQStCLG9DQUFvQzs7QUFFbkUsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUU7O0FBRTNULDZEQUE2RCxzRUFBc0UsOERBQThELG9CQUFvQjs7QUFFck47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsUUFBUTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBLHNDQUFzQyx1Q0FBdUMsa0JBQWtCOztBQUUvRiw0RUFBNEUsTUFBTSwwQkFBMEIsd0JBQXdCLEVBQUUsZ0JBQWdCLGVBQWUsUUFBUSxFQUFFLGlCQUFpQixnQkFBZ0IsRUFBRSxPQUFPLDRDQUE0QyxFQUFFOztBQUV2USxnQ0FBZ0MscUJBQXFCLG1DQUFtQyxnREFBZ0QsZ0NBQWdDLHdCQUF3Qix3RUFBd0UsRUFBRSx1QkFBdUIsdUVBQXVFLEVBQUUsa0JBQWtCLEVBQUUsRUFBRSxHQUFHOztBQUVuWSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUMsUUFBUTtBQUNqRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxVQUFVLE1BQU07QUFDdkI7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQSxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLGdCQUFnQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBOztBQUVBOztBQUVBLHVCQUF1QiwyQkFBMkIsMkVBQTJFLGtDQUFrQyxtQkFBbUIsR0FBRyxFQUFFLE9BQU8sa0NBQWtDLDhIQUE4SCxHQUFHLEVBQUUscUJBQXFCOztBQUV4WCxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTiwyQ0FBMkMscURBQXFELG9CQUFvQixFQUFFLE9BQU8sbURBQW1ELDZDQUE2QyxtQkFBbUIsNERBQTRELGdCQUFnQixnQ0FBZ0MsRUFBRSxtQkFBbUIsR0FBRyxFQUFFLG1EQUFtRDs7QUFFemEsMkNBQTJDLGtFQUFrRSxrQ0FBa0MsNEJBQTRCLEVBQUUsZUFBZTs7QUFFNUwsMENBQTBDLCtEQUErRCwyRUFBMkUsRUFBRSx5RUFBeUUsZUFBZSxzREFBc0QsRUFBRSxFQUFFLHVEQUF1RDs7QUFFL1gsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssZ0NBQWdDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQseURBQXlELEVBQUUsT0FBTyx1Q0FBdUMsRUFBRSxpREFBaUQsR0FBRzs7QUFFdmEsaURBQWlELDBFQUEwRSxhQUFhLEVBQUUscUNBQXFDOztBQUUvSyx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLHNDQUFzQyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLHdFQUF3RSxHQUFHLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRTs7QUFFbFUsNkJBQTZCLGdHQUFnRyxnREFBZ0QsR0FBRywyQkFBMkI7O0FBRTNNO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0RBQXdELFFBQVEsbUVBQW1FLHdIQUF3SCxnQkFBZ0IsV0FBVyx5QkFBeUIsU0FBUyx3QkFBd0IsNEJBQTRCLGNBQWMsU0FBUyw4QkFBOEIsRUFBRSxxQkFBcUIsVUFBVSxFQUFFLFNBQVMsRUFBRSw4SkFBOEosRUFBRSxrREFBa0QsU0FBUyxrQkFBa0IsMkJBQTJCLEVBQUUsbUJBQW1CLHNCQUFzQiw4QkFBOEIsYUFBYSxFQUFFLHNCQUFzQixlQUFlLFdBQVcsRUFBRSxtQkFBbUIsTUFBTSwrREFBK0QsRUFBRSxVQUFVLHVCQUF1QixFQUFFLEVBQUUsR0FBRzs7QUFFbitCLGlEQUFpRCxnQkFBZ0IsZ0VBQWdFLHdEQUF3RCw2REFBNkQsc0RBQXNELGtIQUFrSDs7QUFFOVosc0NBQXNDLHVEQUF1RCx1Q0FBdUMsU0FBUyxPQUFPLGtCQUFrQixFQUFFLGFBQWE7O0FBRXJMLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFOztBQUUzVCw2REFBNkQsc0VBQXNFLDhEQUE4RCxvQkFBb0I7O0FBRXJOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxVQUFVO0FBQzFEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSw2QkFBNkIsdUJBQXVCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUEsZ0NBQWdDLHdCQUF3QjtBQUN4RDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSw4Q0FBOEMsWUFBWTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDhDQUE4QyxRQUFRO0FBQ3REO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSw4Q0FBOEMsUUFBUTtBQUN0RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwrQkFBK0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7O0FBRUEsdUJBQXVCLDJCQUEyQiwyRUFBMkUsa0NBQWtDLG1CQUFtQixHQUFHLEVBQUUsT0FBTyxrQ0FBa0MsOEhBQThILEdBQUcsRUFBRSxxQkFBcUI7O0FBRXhYLHdEQUF3RCxRQUFRLG1FQUFtRSx3SEFBd0gsZ0JBQWdCLFdBQVcseUJBQXlCLFNBQVMsd0JBQXdCLDRCQUE0QixjQUFjLFNBQVMsOEJBQThCLEVBQUUscUJBQXFCLFVBQVUsRUFBRSxTQUFTLEVBQUUsOEpBQThKLEVBQUUsa0RBQWtELFNBQVMsa0JBQWtCLDJCQUEyQixFQUFFLG1CQUFtQixzQkFBc0IsOEJBQThCLGFBQWEsRUFBRSxzQkFBc0IsZUFBZSxXQUFXLEVBQUUsbUJBQW1CLE1BQU0sK0RBQStELEVBQUUsVUFBVSx1QkFBdUIsRUFBRSxFQUFFLEdBQUc7O0FBRW4rQixpREFBaUQsZ0JBQWdCLGdFQUFnRSx3REFBd0QsNkRBQTZELHNEQUFzRCxrSEFBa0g7O0FBRTlaLHNDQUFzQyx1REFBdUQsdUNBQXVDLFNBQVMsT0FBTyxrQkFBa0IsRUFBRSxhQUFhOztBQUVyTCxpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SiwyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRTs7QUFFM1QsNkRBQTZELHNFQUFzRSw4REFBOEQsb0JBQW9COztBQUVyTiwyQ0FBMkMscURBQXFELG9CQUFvQixFQUFFLE9BQU8sbURBQW1ELDZDQUE2QyxtQkFBbUIsNERBQTRELGdCQUFnQixnQ0FBZ0MsRUFBRSxtQkFBbUIsR0FBRyxFQUFFLG1EQUFtRDs7QUFFemEsMkNBQTJDLGtFQUFrRSxrQ0FBa0MsNEJBQTRCLEVBQUUsZUFBZTs7QUFFNUwsMENBQTBDLCtEQUErRCwyRUFBMkUsRUFBRSx5RUFBeUUsZUFBZSxzREFBc0QsRUFBRSxFQUFFLHVEQUF1RDs7QUFFL1gsZ0NBQWdDLDRFQUE0RSxpQkFBaUIsVUFBVSxHQUFHLDhCQUE4Qjs7QUFFeEssZ0NBQWdDLDZEQUE2RCx5Q0FBeUMsOENBQThDLGlDQUFpQyxtREFBbUQseURBQXlELEVBQUUsT0FBTyx1Q0FBdUMsRUFBRSxpREFBaUQsR0FBRzs7QUFFdmEsaURBQWlELDBFQUEwRSxhQUFhLEVBQUUscUNBQXFDOztBQUUvSyx1Q0FBdUMsdUJBQXVCLHVGQUF1RixFQUFFLGFBQWE7O0FBRXBLLHNDQUFzQyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLHdFQUF3RSxHQUFHLGFBQWEsRUFBRSxZQUFZLGNBQWMsRUFBRTs7QUFFbFUsNkJBQTZCLGdHQUFnRyxnREFBZ0QsR0FBRywyQkFBMkI7O0FBRTNNO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQiwrQkFBK0I7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBLENBQUM7QUFDRCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0LXNpZy9lczUvd2ViL3BkZl92aWV3ZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNzdGFydCBUaGUgZm9sbG93aW5nIGlzIHRoZSBlbnRpcmUgbGljZW5zZSBub3RpY2UgZm9yIHRoZVxuICogSmF2YXNjcmlwdCBjb2RlIGluIHRoaXMgcGFnZVxuICpcbiAqIENvcHlyaWdodCAyMDIwIE1vemlsbGEgRm91bmRhdGlvblxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqXG4gKiBAbGljZW5kIFRoZSBhYm92ZSBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFzY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqL1xuXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShcInBkZmpzLWRpc3Qvd2ViL3BkZl92aWV3ZXJcIiwgW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wicGRmanMtZGlzdC93ZWIvcGRmX3ZpZXdlclwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJwZGZqcy1kaXN0L3dlYi9wZGZfdmlld2VyXCJdID0gcm9vdC5wZGZqc1ZpZXdlciA9IGZhY3RvcnkoKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKCkge1xucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193X3BkZmpzX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsOiBmYWxzZSxcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXyk7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdF9fd19wZGZqc19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4vKioqKioqLyBcdFx0aWYoIV9fd19wZGZqc19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dfcGRmanNfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4vKioqKioqLyBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4vKioqKioqLyBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4vKioqKioqLyBcdF9fd19wZGZqc19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193X3BkZmpzX3JlcXVpcmVfXyh2YWx1ZSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKioqKioqLyBcdFx0X193X3BkZmpzX3JlcXVpcmVfXy5yKG5zKTtcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4vKioqKioqLyBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193X3BkZmpzX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuLyoqKioqKi8gXHRcdHJldHVybiBucztcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4vKioqKioqLyBcdF9fd19wZGZqc19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuLyoqKioqKi8gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4vKioqKioqLyBcdFx0X193X3BkZmpzX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuLyoqKioqKi8gXHRcdHJldHVybiBnZXR0ZXI7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbi8qKioqKiovIFx0X193X3BkZmpzX3JlcXVpcmVfXy5wID0gXCJcIjtcbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd19wZGZqc19yZXF1aXJlX18oX193X3BkZmpzX3JlcXVpcmVfXy5zID0gMCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uTGF5ZXJCdWlsZGVyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9hbm5vdGF0aW9uX2xheWVyX2J1aWxkZXIuQW5ub3RhdGlvbkxheWVyQnVpbGRlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJEZWZhdWx0QW5ub3RhdGlvbkxheWVyRmFjdG9yeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfYW5ub3RhdGlvbl9sYXllcl9idWlsZGVyLkRlZmF1bHRBbm5vdGF0aW9uTGF5ZXJGYWN0b3J5O1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRlZmF1bHRUZXh0TGF5ZXJGYWN0b3J5XCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF90ZXh0X2xheWVyX2J1aWxkZXIuRGVmYXVsdFRleHRMYXllckZhY3Rvcnk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVGV4dExheWVyQnVpbGRlclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdGV4dF9sYXllcl9idWlsZGVyLlRleHRMYXllckJ1aWxkZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRCdXNcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3VpX3V0aWxzLkV2ZW50QnVzO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk51bGxMMTBuXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF91aV91dGlscy5OdWxsTDEwbjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQcm9ncmVzc0JhclwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfdWlfdXRpbHMuUHJvZ3Jlc3NCYXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGTGlua1NlcnZpY2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BkZl9saW5rX3NlcnZpY2UuUERGTGlua1NlcnZpY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2ltcGxlTGlua1NlcnZpY2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BkZl9saW5rX3NlcnZpY2UuU2ltcGxlTGlua1NlcnZpY2U7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRG93bmxvYWRNYW5hZ2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9kb3dubG9hZF9tYW5hZ2VyLkRvd25sb2FkTWFuYWdlcjtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJHZW5lcmljTDEwblwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZ2VuZXJpY2wxMG4uR2VuZXJpY0wxMG47XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGRmluZENvbnRyb2xsZXJcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BkZl9maW5kX2NvbnRyb2xsZXIuUERGRmluZENvbnRyb2xsZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGSGlzdG9yeVwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGRmX2hpc3RvcnkuUERGSGlzdG9yeTtcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZQYWdlVmlld1wiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfcGRmX3BhZ2Vfdmlldy5QREZQYWdlVmlldztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQREZTaW5nbGVQYWdlVmlld2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wZGZfc2luZ2xlX3BhZ2Vfdmlld2VyLlBERlNpbmdsZVBhZ2VWaWV3ZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGVmlld2VyXCIsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIF9wZGZfdmlld2VyLlBERlZpZXdlcjtcbiAgfVxufSk7XG5cbnZhciBfYW5ub3RhdGlvbl9sYXllcl9idWlsZGVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcblxudmFyIF90ZXh0X2xheWVyX2J1aWxkZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xuXG52YXIgX3VpX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcblxudmFyIF9wZGZfbGlua19zZXJ2aWNlID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcblxudmFyIF9kb3dubG9hZF9tYW5hZ2VyID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcblxudmFyIF9nZW5lcmljbDEwbiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xuXG52YXIgX3BkZl9maW5kX2NvbnRyb2xsZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcblxudmFyIF9wZGZfaGlzdG9yeSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUpO1xuXG52YXIgX3BkZl9wYWdlX3ZpZXcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2KTtcblxudmFyIF9wZGZfc2luZ2xlX3BhZ2Vfdmlld2VyID0gX193X3BkZmpzX3JlcXVpcmVfXygxOCk7XG5cbnZhciBfcGRmX3ZpZXdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xuXG52YXIgcGRmanNWZXJzaW9uID0gJzIuNi4zNDcnO1xudmFyIHBkZmpzQnVpbGQgPSAnM2JlOWM2NWYnO1xuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRGVmYXVsdEFubm90YXRpb25MYXllckZhY3RvcnkgPSBleHBvcnRzLkFubm90YXRpb25MYXllckJ1aWxkZXIgPSB2b2lkIDA7XG5cbnZhciBfcGRmanNMaWIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuXG52YXIgX3VpX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcblxudmFyIF9wZGZfbGlua19zZXJ2aWNlID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgQW5ub3RhdGlvbkxheWVyQnVpbGRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb25MYXllckJ1aWxkZXIoX3JlZikge1xuICAgIHZhciBwYWdlRGl2ID0gX3JlZi5wYWdlRGl2LFxuICAgICAgICBwZGZQYWdlID0gX3JlZi5wZGZQYWdlLFxuICAgICAgICBsaW5rU2VydmljZSA9IF9yZWYubGlua1NlcnZpY2UsXG4gICAgICAgIGRvd25sb2FkTWFuYWdlciA9IF9yZWYuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgICBfcmVmJGFubm90YXRpb25TdG9yYWcgPSBfcmVmLmFubm90YXRpb25TdG9yYWdlLFxuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZSA9IF9yZWYkYW5ub3RhdGlvblN0b3JhZyA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkYW5ub3RhdGlvblN0b3JhZyxcbiAgICAgICAgX3JlZiRpbWFnZVJlc291cmNlc1BhID0gX3JlZi5pbWFnZVJlc291cmNlc1BhdGgsXG4gICAgICAgIGltYWdlUmVzb3VyY2VzUGF0aCA9IF9yZWYkaW1hZ2VSZXNvdXJjZXNQYSA9PT0gdm9pZCAwID8gXCJcIiA6IF9yZWYkaW1hZ2VSZXNvdXJjZXNQYSxcbiAgICAgICAgX3JlZiRyZW5kZXJJbnRlcmFjdGl2ID0gX3JlZi5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zLFxuICAgICAgICByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID0gX3JlZiRyZW5kZXJJbnRlcmFjdGl2ID09PSB2b2lkIDAgPyB0cnVlIDogX3JlZiRyZW5kZXJJbnRlcmFjdGl2LFxuICAgICAgICBfcmVmJGwxMG4gPSBfcmVmLmwxMG4sXG4gICAgICAgIGwxMG4gPSBfcmVmJGwxMG4gPT09IHZvaWQgMCA/IF91aV91dGlscy5OdWxsTDEwbiA6IF9yZWYkbDEwbjtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBbm5vdGF0aW9uTGF5ZXJCdWlsZGVyKTtcblxuICAgIHRoaXMucGFnZURpdiA9IHBhZ2VEaXY7XG4gICAgdGhpcy5wZGZQYWdlID0gcGRmUGFnZTtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlID0gbGlua1NlcnZpY2U7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBkb3dubG9hZE1hbmFnZXI7XG4gICAgdGhpcy5pbWFnZVJlc291cmNlc1BhdGggPSBpbWFnZVJlc291cmNlc1BhdGg7XG4gICAgdGhpcy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID0gcmVuZGVySW50ZXJhY3RpdmVGb3JtcztcbiAgICB0aGlzLmwxMG4gPSBsMTBuO1xuICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UgPSBhbm5vdGF0aW9uU3RvcmFnZTtcbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy5fY2FuY2VsbGVkID0gZmFsc2U7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQW5ub3RhdGlvbkxheWVyQnVpbGRlciwgW3tcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcih2aWV3cG9ydCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGludGVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogXCJkaXNwbGF5XCI7XG4gICAgICByZXR1cm4gdGhpcy5wZGZQYWdlLmdldEFubm90YXRpb25zKHtcbiAgICAgICAgaW50ZW50OiBpbnRlbnRcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGFubm90YXRpb25zKSB7XG4gICAgICAgIGlmIChfdGhpcy5fY2FuY2VsbGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFubm90YXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJhbWV0ZXJzID0ge1xuICAgICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydC5jbG9uZSh7XG4gICAgICAgICAgICBkb250RmxpcDogdHJ1ZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGRpdjogX3RoaXMuZGl2LFxuICAgICAgICAgIGFubm90YXRpb25zOiBhbm5vdGF0aW9ucyxcbiAgICAgICAgICBwYWdlOiBfdGhpcy5wZGZQYWdlLFxuICAgICAgICAgIGltYWdlUmVzb3VyY2VzUGF0aDogX3RoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoLFxuICAgICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IF90aGlzLnJlbmRlckludGVyYWN0aXZlRm9ybXMsXG4gICAgICAgICAgbGlua1NlcnZpY2U6IF90aGlzLmxpbmtTZXJ2aWNlLFxuICAgICAgICAgIGRvd25sb2FkTWFuYWdlcjogX3RoaXMuZG93bmxvYWRNYW5hZ2VyLFxuICAgICAgICAgIGFubm90YXRpb25TdG9yYWdlOiBfdGhpcy5hbm5vdGF0aW9uU3RvcmFnZVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChfdGhpcy5kaXYpIHtcbiAgICAgICAgICBfcGRmanNMaWIuQW5ub3RhdGlvbkxheWVyLnVwZGF0ZShwYXJhbWV0ZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5kaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIF90aGlzLmRpdi5jbGFzc05hbWUgPSBcImFubm90YXRpb25MYXllclwiO1xuXG4gICAgICAgICAgX3RoaXMucGFnZURpdi5hcHBlbmRDaGlsZChfdGhpcy5kaXYpO1xuXG4gICAgICAgICAgcGFyYW1ldGVycy5kaXYgPSBfdGhpcy5kaXY7XG5cbiAgICAgICAgICBfcGRmanNMaWIuQW5ub3RhdGlvbkxheWVyLnJlbmRlcihwYXJhbWV0ZXJzKTtcblxuICAgICAgICAgIF90aGlzLmwxMG4udHJhbnNsYXRlKF90aGlzLmRpdik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgdGhpcy5fY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgaWYgKCF0aGlzLmRpdikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcInRydWVcIik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEFubm90YXRpb25MYXllckJ1aWxkZXI7XG59KCk7XG5cbmV4cG9ydHMuQW5ub3RhdGlvbkxheWVyQnVpbGRlciA9IEFubm90YXRpb25MYXllckJ1aWxkZXI7XG5cbnZhciBEZWZhdWx0QW5ub3RhdGlvbkxheWVyRmFjdG9yeSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIERlZmF1bHRBbm5vdGF0aW9uTGF5ZXJGYWN0b3J5KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEZWZhdWx0QW5ub3RhdGlvbkxheWVyRmFjdG9yeSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRGVmYXVsdEFubm90YXRpb25MYXllckZhY3RvcnksIFt7XG4gICAga2V5OiBcImNyZWF0ZUFubm90YXRpb25MYXllckJ1aWxkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQW5ub3RhdGlvbkxheWVyQnVpbGRlcihwYWdlRGl2LCBwZGZQYWdlKSB7XG4gICAgICB2YXIgYW5ub3RhdGlvblN0b3JhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG4gICAgICB2YXIgaW1hZ2VSZXNvdXJjZXNQYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBcIlwiO1xuICAgICAgdmFyIHJlbmRlckludGVyYWN0aXZlRm9ybXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCAmJiBhcmd1bWVudHNbNF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s0XSA6IHRydWU7XG4gICAgICB2YXIgbDEwbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogX3VpX3V0aWxzLk51bGxMMTBuO1xuICAgICAgcmV0dXJuIG5ldyBBbm5vdGF0aW9uTGF5ZXJCdWlsZGVyKHtcbiAgICAgICAgcGFnZURpdjogcGFnZURpdixcbiAgICAgICAgcGRmUGFnZTogcGRmUGFnZSxcbiAgICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBpbWFnZVJlc291cmNlc1BhdGgsXG4gICAgICAgIHJlbmRlckludGVyYWN0aXZlRm9ybXM6IHJlbmRlckludGVyYWN0aXZlRm9ybXMsXG4gICAgICAgIGxpbmtTZXJ2aWNlOiBuZXcgX3BkZl9saW5rX3NlcnZpY2UuU2ltcGxlTGlua1NlcnZpY2UoKSxcbiAgICAgICAgbDEwbjogbDEwbixcbiAgICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IGFubm90YXRpb25TdG9yYWdlXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRGVmYXVsdEFubm90YXRpb25MYXllckZhY3Rvcnk7XG59KCk7XG5cbmV4cG9ydHMuRGVmYXVsdEFubm90YXRpb25MYXllckZhY3RvcnkgPSBEZWZhdWx0QW5ub3RhdGlvbkxheWVyRmFjdG9yeTtcblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBwZGZqc0xpYjtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93W1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0pIHtcbiAgcGRmanNMaWIgPSB3aW5kb3dbXCJwZGZqcy1kaXN0L2J1aWxkL3BkZlwiXTtcbn0gZWxzZSB7XG4gIHBkZmpzTGliID0gcmVxdWlyZShcIi4uL2J1aWxkL3BkZi5qc1wiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZGZqc0xpYjtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzVmFsaWRSb3RhdGlvbiA9IGlzVmFsaWRSb3RhdGlvbjtcbmV4cG9ydHMuaXNWYWxpZFNjcm9sbE1vZGUgPSBpc1ZhbGlkU2Nyb2xsTW9kZTtcbmV4cG9ydHMuaXNWYWxpZFNwcmVhZE1vZGUgPSBpc1ZhbGlkU3ByZWFkTW9kZTtcbmV4cG9ydHMuaXNQb3J0cmFpdE9yaWVudGF0aW9uID0gaXNQb3J0cmFpdE9yaWVudGF0aW9uO1xuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZXhwb3J0cy5nZXRQREZGaWxlTmFtZUZyb21VUkwgPSBnZXRQREZGaWxlTmFtZUZyb21VUkw7XG5leHBvcnRzLm5vQ29udGV4dE1lbnVIYW5kbGVyID0gbm9Db250ZXh0TWVudUhhbmRsZXI7XG5leHBvcnRzLnBhcnNlUXVlcnlTdHJpbmcgPSBwYXJzZVF1ZXJ5U3RyaW5nO1xuZXhwb3J0cy5iYWNrdHJhY2tCZWZvcmVBbGxWaXNpYmxlRWxlbWVudHMgPSBiYWNrdHJhY2tCZWZvcmVBbGxWaXNpYmxlRWxlbWVudHM7XG5leHBvcnRzLmdldFZpc2libGVFbGVtZW50cyA9IGdldFZpc2libGVFbGVtZW50cztcbmV4cG9ydHMucm91bmRUb0RpdmlkZSA9IHJvdW5kVG9EaXZpZGU7XG5leHBvcnRzLmdldFBhZ2VTaXplSW5jaGVzID0gZ2V0UGFnZVNpemVJbmNoZXM7XG5leHBvcnRzLmFwcHJveGltYXRlRnJhY3Rpb24gPSBhcHByb3hpbWF0ZUZyYWN0aW9uO1xuZXhwb3J0cy5nZXRPdXRwdXRTY2FsZSA9IGdldE91dHB1dFNjYWxlO1xuZXhwb3J0cy5zY3JvbGxJbnRvVmlldyA9IHNjcm9sbEludG9WaWV3O1xuZXhwb3J0cy53YXRjaFNjcm9sbCA9IHdhdGNoU2Nyb2xsO1xuZXhwb3J0cy5iaW5hcnlTZWFyY2hGaXJzdEl0ZW0gPSBiaW5hcnlTZWFyY2hGaXJzdEl0ZW07XG5leHBvcnRzLm5vcm1hbGl6ZVdoZWVsRXZlbnREaXJlY3Rpb24gPSBub3JtYWxpemVXaGVlbEV2ZW50RGlyZWN0aW9uO1xuZXhwb3J0cy5ub3JtYWxpemVXaGVlbEV2ZW50RGVsdGEgPSBub3JtYWxpemVXaGVlbEV2ZW50RGVsdGE7XG5leHBvcnRzLndhaXRPbkV2ZW50T3JUaW1lb3V0ID0gd2FpdE9uRXZlbnRPclRpbWVvdXQ7XG5leHBvcnRzLm1vdmVUb0VuZE9mQXJyYXkgPSBtb3ZlVG9FbmRPZkFycmF5O1xuZXhwb3J0cy5XYWl0T25UeXBlID0gZXhwb3J0cy5hbmltYXRpb25TdGFydGVkID0gZXhwb3J0cy5Qcm9ncmVzc0JhciA9IGV4cG9ydHMuRXZlbnRCdXMgPSBleHBvcnRzLk51bGxMMTBuID0gZXhwb3J0cy5TcHJlYWRNb2RlID0gZXhwb3J0cy5TY3JvbGxNb2RlID0gZXhwb3J0cy5UZXh0TGF5ZXJNb2RlID0gZXhwb3J0cy5SZW5kZXJlclR5cGUgPSBleHBvcnRzLlByZXNlbnRhdGlvbk1vZGVTdGF0ZSA9IGV4cG9ydHMuVkVSVElDQUxfUEFERElORyA9IGV4cG9ydHMuU0NST0xMQkFSX1BBRERJTkcgPSBleHBvcnRzLk1BWF9BVVRPX1NDQUxFID0gZXhwb3J0cy5VTktOT1dOX1NDQUxFID0gZXhwb3J0cy5NQVhfU0NBTEUgPSBleHBvcnRzLk1JTl9TQ0FMRSA9IGV4cG9ydHMuREVGQVVMVF9TQ0FMRSA9IGV4cG9ydHMuREVGQVVMVF9TQ0FMRV9WQUxVRSA9IGV4cG9ydHMuQ1NTX1VOSVRTID0gZXhwb3J0cy5BdXRvUHJpbnRSZWdFeHAgPSB2b2lkIDA7XG5cbnZhciBfcmVnZW5lcmF0b3IgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd19wZGZqc19yZXF1aXJlX18oNCkpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbnZhciBDU1NfVU5JVFMgPSA5Ni4wIC8gNzIuMDtcbmV4cG9ydHMuQ1NTX1VOSVRTID0gQ1NTX1VOSVRTO1xudmFyIERFRkFVTFRfU0NBTEVfVkFMVUUgPSBcImF1dG9cIjtcbmV4cG9ydHMuREVGQVVMVF9TQ0FMRV9WQUxVRSA9IERFRkFVTFRfU0NBTEVfVkFMVUU7XG52YXIgREVGQVVMVF9TQ0FMRSA9IDEuMDtcbmV4cG9ydHMuREVGQVVMVF9TQ0FMRSA9IERFRkFVTFRfU0NBTEU7XG52YXIgTUlOX1NDQUxFID0gMC4xO1xuZXhwb3J0cy5NSU5fU0NBTEUgPSBNSU5fU0NBTEU7XG52YXIgTUFYX1NDQUxFID0gMTAuMDtcbmV4cG9ydHMuTUFYX1NDQUxFID0gTUFYX1NDQUxFO1xudmFyIFVOS05PV05fU0NBTEUgPSAwO1xuZXhwb3J0cy5VTktOT1dOX1NDQUxFID0gVU5LTk9XTl9TQ0FMRTtcbnZhciBNQVhfQVVUT19TQ0FMRSA9IDEuMjU7XG5leHBvcnRzLk1BWF9BVVRPX1NDQUxFID0gTUFYX0FVVE9fU0NBTEU7XG52YXIgU0NST0xMQkFSX1BBRERJTkcgPSA0MDtcbmV4cG9ydHMuU0NST0xMQkFSX1BBRERJTkcgPSBTQ1JPTExCQVJfUEFERElORztcbnZhciBWRVJUSUNBTF9QQURESU5HID0gNTtcbmV4cG9ydHMuVkVSVElDQUxfUEFERElORyA9IFZFUlRJQ0FMX1BBRERJTkc7XG52YXIgUHJlc2VudGF0aW9uTW9kZVN0YXRlID0ge1xuICBVTktOT1dOOiAwLFxuICBOT1JNQUw6IDEsXG4gIENIQU5HSU5HOiAyLFxuICBGVUxMU0NSRUVOOiAzXG59O1xuZXhwb3J0cy5QcmVzZW50YXRpb25Nb2RlU3RhdGUgPSBQcmVzZW50YXRpb25Nb2RlU3RhdGU7XG52YXIgUmVuZGVyZXJUeXBlID0ge1xuICBDQU5WQVM6IFwiY2FudmFzXCIsXG4gIFNWRzogXCJzdmdcIlxufTtcbmV4cG9ydHMuUmVuZGVyZXJUeXBlID0gUmVuZGVyZXJUeXBlO1xudmFyIFRleHRMYXllck1vZGUgPSB7XG4gIERJU0FCTEU6IDAsXG4gIEVOQUJMRTogMSxcbiAgRU5BQkxFX0VOSEFOQ0U6IDJcbn07XG5leHBvcnRzLlRleHRMYXllck1vZGUgPSBUZXh0TGF5ZXJNb2RlO1xudmFyIFNjcm9sbE1vZGUgPSB7XG4gIFVOS05PV046IC0xLFxuICBWRVJUSUNBTDogMCxcbiAgSE9SSVpPTlRBTDogMSxcbiAgV1JBUFBFRDogMlxufTtcbmV4cG9ydHMuU2Nyb2xsTW9kZSA9IFNjcm9sbE1vZGU7XG52YXIgU3ByZWFkTW9kZSA9IHtcbiAgVU5LTk9XTjogLTEsXG4gIE5PTkU6IDAsXG4gIE9ERDogMSxcbiAgRVZFTjogMlxufTtcbmV4cG9ydHMuU3ByZWFkTW9kZSA9IFNwcmVhZE1vZGU7XG52YXIgQXV0b1ByaW50UmVnRXhwID0gL1xcYnByaW50XFxzKlxcKC87XG5leHBvcnRzLkF1dG9QcmludFJlZ0V4cCA9IEF1dG9QcmludFJlZ0V4cDtcblxuZnVuY3Rpb24gZm9ybWF0TDEwblZhbHVlKHRleHQsIGFyZ3MpIHtcbiAgaWYgKCFhcmdzKSB7XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICByZXR1cm4gdGV4dC5yZXBsYWNlKC9cXHtcXHtcXHMqKFxcdyspXFxzKlxcfVxcfS9nLCBmdW5jdGlvbiAoYWxsLCBuYW1lKSB7XG4gICAgcmV0dXJuIG5hbWUgaW4gYXJncyA/IGFyZ3NbbmFtZV0gOiBcInt7XCIgKyBuYW1lICsgXCJ9fVwiO1xuICB9KTtcbn1cblxudmFyIE51bGxMMTBuID0ge1xuICBnZXRMYW5ndWFnZTogZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIFwiZW4tdXNcIik7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUpO1xuICAgIH0pKSgpO1xuICB9LFxuICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbigpIHtcbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgXCJsdHJcIik7XG5cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCBfY2FsbGVlMik7XG4gICAgfSkpKCk7XG4gIH0sXG4gIGdldDogZnVuY3Rpb24gZ2V0KHByb3BlcnR5LCBhcmdzLCBmYWxsYmFjaykge1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBmb3JtYXRMMTBuVmFsdWUoZmFsbGJhY2ssIGFyZ3MpKTtcblxuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUzKTtcbiAgICB9KSkoKTtcbiAgfSxcbiAgdHJhbnNsYXRlOiBmdW5jdGlvbiB0cmFuc2xhdGUoZWxlbWVudCkge1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlNCgpIHtcbiAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWU0KTtcbiAgICB9KSkoKTtcbiAgfVxufTtcbmV4cG9ydHMuTnVsbEwxMG4gPSBOdWxsTDEwbjtcblxuZnVuY3Rpb24gZ2V0T3V0cHV0U2NhbGUoY3R4KSB7XG4gIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgdmFyIGJhY2tpbmdTdG9yZVJhdGlvID0gY3R4LndlYmtpdEJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4Lm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCBjdHgub0JhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcbiAgdmFyIHBpeGVsUmF0aW8gPSBkZXZpY2VQaXhlbFJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG4gIHJldHVybiB7XG4gICAgc3g6IHBpeGVsUmF0aW8sXG4gICAgc3k6IHBpeGVsUmF0aW8sXG4gICAgc2NhbGVkOiBwaXhlbFJhdGlvICE9PSAxXG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjcm9sbEludG9WaWV3KGVsZW1lbnQsIHNwb3QpIHtcbiAgdmFyIHNraXBPdmVyZmxvd0hpZGRlbkVsZW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgdmFyIHBhcmVudCA9IGVsZW1lbnQub2Zmc2V0UGFyZW50O1xuXG4gIGlmICghcGFyZW50KSB7XG4gICAgY29uc29sZS5lcnJvcihcIm9mZnNldFBhcmVudCBpcyBub3Qgc2V0IC0tIGNhbm5vdCBzY3JvbGxcIik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG9mZnNldFkgPSBlbGVtZW50Lm9mZnNldFRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICB2YXIgb2Zmc2V0WCA9IGVsZW1lbnQub2Zmc2V0TGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcblxuICB3aGlsZSAocGFyZW50LmNsaWVudEhlaWdodCA9PT0gcGFyZW50LnNjcm9sbEhlaWdodCAmJiBwYXJlbnQuY2xpZW50V2lkdGggPT09IHBhcmVudC5zY3JvbGxXaWR0aCB8fCBza2lwT3ZlcmZsb3dIaWRkZW5FbGVtZW50cyAmJiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkub3ZlcmZsb3cgPT09IFwiaGlkZGVuXCIpIHtcbiAgICBpZiAocGFyZW50LmRhdGFzZXQuX3NjYWxlWSkge1xuICAgICAgb2Zmc2V0WSAvPSBwYXJlbnQuZGF0YXNldC5fc2NhbGVZO1xuICAgICAgb2Zmc2V0WCAvPSBwYXJlbnQuZGF0YXNldC5fc2NhbGVYO1xuICAgIH1cblxuICAgIG9mZnNldFkgKz0gcGFyZW50Lm9mZnNldFRvcDtcbiAgICBvZmZzZXRYICs9IHBhcmVudC5vZmZzZXRMZWZ0O1xuICAgIHBhcmVudCA9IHBhcmVudC5vZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAoIXBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzcG90KSB7XG4gICAgaWYgKHNwb3QudG9wICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG9mZnNldFkgKz0gc3BvdC50b3A7XG4gICAgfVxuXG4gICAgaWYgKHNwb3QubGVmdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvZmZzZXRYICs9IHNwb3QubGVmdDtcbiAgICAgIHBhcmVudC5zY3JvbGxMZWZ0ID0gb2Zmc2V0WDtcbiAgICB9XG4gIH1cblxuICBwYXJlbnQuc2Nyb2xsVG9wID0gb2Zmc2V0WTtcbn1cblxuZnVuY3Rpb24gd2F0Y2hTY3JvbGwodmlld0FyZWFFbGVtZW50LCBjYWxsYmFjaykge1xuICB2YXIgZGVib3VuY2VTY3JvbGwgPSBmdW5jdGlvbiBkZWJvdW5jZVNjcm9sbChldnQpIHtcbiAgICBpZiAockFGKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgckFGID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiB2aWV3QXJlYUVsZW1lbnRTY3JvbGxlZCgpIHtcbiAgICAgIHJBRiA9IG51bGw7XG4gICAgICB2YXIgY3VycmVudFggPSB2aWV3QXJlYUVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgIHZhciBsYXN0WCA9IHN0YXRlLmxhc3RYO1xuXG4gICAgICBpZiAoY3VycmVudFggIT09IGxhc3RYKSB7XG4gICAgICAgIHN0YXRlLnJpZ2h0ID0gY3VycmVudFggPiBsYXN0WDtcbiAgICAgIH1cblxuICAgICAgc3RhdGUubGFzdFggPSBjdXJyZW50WDtcbiAgICAgIHZhciBjdXJyZW50WSA9IHZpZXdBcmVhRWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICB2YXIgbGFzdFkgPSBzdGF0ZS5sYXN0WTtcblxuICAgICAgaWYgKGN1cnJlbnRZICE9PSBsYXN0WSkge1xuICAgICAgICBzdGF0ZS5kb3duID0gY3VycmVudFkgPiBsYXN0WTtcbiAgICAgIH1cblxuICAgICAgc3RhdGUubGFzdFkgPSBjdXJyZW50WTtcbiAgICAgIGNhbGxiYWNrKHN0YXRlKTtcbiAgICB9KTtcbiAgfTtcblxuICB2YXIgc3RhdGUgPSB7XG4gICAgcmlnaHQ6IHRydWUsXG4gICAgZG93bjogdHJ1ZSxcbiAgICBsYXN0WDogdmlld0FyZWFFbGVtZW50LnNjcm9sbExlZnQsXG4gICAgbGFzdFk6IHZpZXdBcmVhRWxlbWVudC5zY3JvbGxUb3AsXG4gICAgX2V2ZW50SGFuZGxlcjogZGVib3VuY2VTY3JvbGxcbiAgfTtcbiAgdmFyIHJBRiA9IG51bGw7XG4gIHZpZXdBcmVhRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGRlYm91bmNlU2Nyb2xsLCB0cnVlKTtcbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBwYXJzZVF1ZXJ5U3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJ0cyA9IHF1ZXJ5LnNwbGl0KFwiJlwiKTtcbiAgdmFyIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGlpID0gcGFydHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgIHZhciBwYXJhbSA9IHBhcnRzW2ldLnNwbGl0KFwiPVwiKTtcbiAgICB2YXIga2V5ID0gcGFyYW1bMF0udG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgdmFsdWUgPSBwYXJhbS5sZW5ndGggPiAxID8gcGFyYW1bMV0gOiBudWxsO1xuICAgIHBhcmFtc1tkZWNvZGVVUklDb21wb25lbnQoa2V5KV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2VhcmNoRmlyc3RJdGVtKGl0ZW1zLCBjb25kaXRpb24pIHtcbiAgdmFyIG1pbkluZGV4ID0gMDtcbiAgdmFyIG1heEluZGV4ID0gaXRlbXMubGVuZ3RoIC0gMTtcblxuICBpZiAobWF4SW5kZXggPCAwIHx8ICFjb25kaXRpb24oaXRlbXNbbWF4SW5kZXhdKSkge1xuICAgIHJldHVybiBpdGVtcy5sZW5ndGg7XG4gIH1cblxuICBpZiAoY29uZGl0aW9uKGl0ZW1zW21pbkluZGV4XSkpIHtcbiAgICByZXR1cm4gbWluSW5kZXg7XG4gIH1cblxuICB3aGlsZSAobWluSW5kZXggPCBtYXhJbmRleCkge1xuICAgIHZhciBjdXJyZW50SW5kZXggPSBtaW5JbmRleCArIG1heEluZGV4ID4+IDE7XG4gICAgdmFyIGN1cnJlbnRJdGVtID0gaXRlbXNbY3VycmVudEluZGV4XTtcblxuICAgIGlmIChjb25kaXRpb24oY3VycmVudEl0ZW0pKSB7XG4gICAgICBtYXhJbmRleCA9IGN1cnJlbnRJbmRleDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluSW5kZXggPSBjdXJyZW50SW5kZXggKyAxO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtaW5JbmRleDtcbn1cblxuZnVuY3Rpb24gYXBwcm94aW1hdGVGcmFjdGlvbih4KSB7XG4gIGlmIChNYXRoLmZsb29yKHgpID09PSB4KSB7XG4gICAgcmV0dXJuIFt4LCAxXTtcbiAgfVxuXG4gIHZhciB4aW52ID0gMSAvIHg7XG4gIHZhciBsaW1pdCA9IDg7XG5cbiAgaWYgKHhpbnYgPiBsaW1pdCkge1xuICAgIHJldHVybiBbMSwgbGltaXRdO1xuICB9IGVsc2UgaWYgKE1hdGguZmxvb3IoeGludikgPT09IHhpbnYpIHtcbiAgICByZXR1cm4gWzEsIHhpbnZdO1xuICB9XG5cbiAgdmFyIHhfID0geCA+IDEgPyB4aW52IDogeDtcbiAgdmFyIGEgPSAwLFxuICAgICAgYiA9IDEsXG4gICAgICBjID0gMSxcbiAgICAgIGQgPSAxO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHAgPSBhICsgYyxcbiAgICAgICAgcSA9IGIgKyBkO1xuXG4gICAgaWYgKHEgPiBsaW1pdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHhfIDw9IHAgLyBxKSB7XG4gICAgICBjID0gcDtcbiAgICAgIGQgPSBxO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gcDtcbiAgICAgIGIgPSBxO1xuICAgIH1cbiAgfVxuXG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKHhfIC0gYSAvIGIgPCBjIC8gZCAtIHhfKSB7XG4gICAgcmVzdWx0ID0geF8gPT09IHggPyBbYSwgYl0gOiBbYiwgYV07XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0geF8gPT09IHggPyBbYywgZF0gOiBbZCwgY107XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByb3VuZFRvRGl2aWRlKHgsIGRpdikge1xuICB2YXIgciA9IHggJSBkaXY7XG4gIHJldHVybiByID09PSAwID8geCA6IE1hdGgucm91bmQoeCAtIHIgKyBkaXYpO1xufVxuXG5mdW5jdGlvbiBnZXRQYWdlU2l6ZUluY2hlcyhfcmVmKSB7XG4gIHZhciB2aWV3ID0gX3JlZi52aWV3LFxuICAgICAgdXNlclVuaXQgPSBfcmVmLnVzZXJVbml0LFxuICAgICAgcm90YXRlID0gX3JlZi5yb3RhdGU7XG5cbiAgdmFyIF92aWV3ID0gX3NsaWNlZFRvQXJyYXkodmlldywgNCksXG4gICAgICB4MSA9IF92aWV3WzBdLFxuICAgICAgeTEgPSBfdmlld1sxXSxcbiAgICAgIHgyID0gX3ZpZXdbMl0sXG4gICAgICB5MiA9IF92aWV3WzNdO1xuXG4gIHZhciBjaGFuZ2VPcmllbnRhdGlvbiA9IHJvdGF0ZSAlIDE4MCAhPT0gMDtcbiAgdmFyIHdpZHRoID0gKHgyIC0geDEpIC8gNzIgKiB1c2VyVW5pdDtcbiAgdmFyIGhlaWdodCA9ICh5MiAtIHkxKSAvIDcyICogdXNlclVuaXQ7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGNoYW5nZU9yaWVudGF0aW9uID8gaGVpZ2h0IDogd2lkdGgsXG4gICAgaGVpZ2h0OiBjaGFuZ2VPcmllbnRhdGlvbiA/IHdpZHRoIDogaGVpZ2h0XG4gIH07XG59XG5cbmZ1bmN0aW9uIGJhY2t0cmFja0JlZm9yZUFsbFZpc2libGVFbGVtZW50cyhpbmRleCwgdmlld3MsIHRvcCkge1xuICBpZiAoaW5kZXggPCAyKSB7XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgdmFyIGVsdCA9IHZpZXdzW2luZGV4XS5kaXY7XG4gIHZhciBwYWdlVG9wID0gZWx0Lm9mZnNldFRvcCArIGVsdC5jbGllbnRUb3A7XG5cbiAgaWYgKHBhZ2VUb3AgPj0gdG9wKSB7XG4gICAgZWx0ID0gdmlld3NbaW5kZXggLSAxXS5kaXY7XG4gICAgcGFnZVRvcCA9IGVsdC5vZmZzZXRUb3AgKyBlbHQuY2xpZW50VG9wO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IGluZGV4IC0gMjsgaSA+PSAwOyAtLWkpIHtcbiAgICBlbHQgPSB2aWV3c1tpXS5kaXY7XG5cbiAgICBpZiAoZWx0Lm9mZnNldFRvcCArIGVsdC5jbGllbnRUb3AgKyBlbHQuY2xpZW50SGVpZ2h0IDw9IHBhZ2VUb3ApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGluZGV4ID0gaTtcbiAgfVxuXG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gZ2V0VmlzaWJsZUVsZW1lbnRzKHNjcm9sbEVsLCB2aWV3cykge1xuICB2YXIgc29ydEJ5VmlzaWJpbGl0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gIHZhciBob3Jpem9udGFsID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgdmFyIHRvcCA9IHNjcm9sbEVsLnNjcm9sbFRvcCxcbiAgICAgIGJvdHRvbSA9IHRvcCArIHNjcm9sbEVsLmNsaWVudEhlaWdodDtcbiAgdmFyIGxlZnQgPSBzY3JvbGxFbC5zY3JvbGxMZWZ0LFxuICAgICAgcmlnaHQgPSBsZWZ0ICsgc2Nyb2xsRWwuY2xpZW50V2lkdGg7XG5cbiAgZnVuY3Rpb24gaXNFbGVtZW50Qm90dG9tQWZ0ZXJWaWV3VG9wKHZpZXcpIHtcbiAgICB2YXIgZWxlbWVudCA9IHZpZXcuZGl2O1xuICAgIHZhciBlbGVtZW50Qm90dG9tID0gZWxlbWVudC5vZmZzZXRUb3AgKyBlbGVtZW50LmNsaWVudFRvcCArIGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIHJldHVybiBlbGVtZW50Qm90dG9tID4gdG9wO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFbGVtZW50UmlnaHRBZnRlclZpZXdMZWZ0KHZpZXcpIHtcbiAgICB2YXIgZWxlbWVudCA9IHZpZXcuZGl2O1xuICAgIHZhciBlbGVtZW50UmlnaHQgPSBlbGVtZW50Lm9mZnNldExlZnQgKyBlbGVtZW50LmNsaWVudExlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIHJldHVybiBlbGVtZW50UmlnaHQgPiBsZWZ0O1xuICB9XG5cbiAgdmFyIHZpc2libGUgPSBbXSxcbiAgICAgIG51bVZpZXdzID0gdmlld3MubGVuZ3RoO1xuICB2YXIgZmlyc3RWaXNpYmxlRWxlbWVudEluZCA9IG51bVZpZXdzID09PSAwID8gMCA6IGJpbmFyeVNlYXJjaEZpcnN0SXRlbSh2aWV3cywgaG9yaXpvbnRhbCA/IGlzRWxlbWVudFJpZ2h0QWZ0ZXJWaWV3TGVmdCA6IGlzRWxlbWVudEJvdHRvbUFmdGVyVmlld1RvcCk7XG5cbiAgaWYgKGZpcnN0VmlzaWJsZUVsZW1lbnRJbmQgPiAwICYmIGZpcnN0VmlzaWJsZUVsZW1lbnRJbmQgPCBudW1WaWV3cyAmJiAhaG9yaXpvbnRhbCkge1xuICAgIGZpcnN0VmlzaWJsZUVsZW1lbnRJbmQgPSBiYWNrdHJhY2tCZWZvcmVBbGxWaXNpYmxlRWxlbWVudHMoZmlyc3RWaXNpYmxlRWxlbWVudEluZCwgdmlld3MsIHRvcCk7XG4gIH1cblxuICB2YXIgbGFzdEVkZ2UgPSBob3Jpem9udGFsID8gcmlnaHQgOiAtMTtcblxuICBmb3IgKHZhciBpID0gZmlyc3RWaXNpYmxlRWxlbWVudEluZDsgaSA8IG51bVZpZXdzOyBpKyspIHtcbiAgICB2YXIgdmlldyA9IHZpZXdzW2ldLFxuICAgICAgICBlbGVtZW50ID0gdmlldy5kaXY7XG4gICAgdmFyIGN1cnJlbnRXaWR0aCA9IGVsZW1lbnQub2Zmc2V0TGVmdCArIGVsZW1lbnQuY2xpZW50TGVmdDtcbiAgICB2YXIgY3VycmVudEhlaWdodCA9IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gICAgdmFyIHZpZXdXaWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGgsXG4gICAgICAgIHZpZXdIZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICB2YXIgdmlld1JpZ2h0ID0gY3VycmVudFdpZHRoICsgdmlld1dpZHRoO1xuICAgIHZhciB2aWV3Qm90dG9tID0gY3VycmVudEhlaWdodCArIHZpZXdIZWlnaHQ7XG5cbiAgICBpZiAobGFzdEVkZ2UgPT09IC0xKSB7XG4gICAgICBpZiAodmlld0JvdHRvbSA+PSBib3R0b20pIHtcbiAgICAgICAgbGFzdEVkZ2UgPSB2aWV3Qm90dG9tO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKGhvcml6b250YWwgPyBjdXJyZW50V2lkdGggOiBjdXJyZW50SGVpZ2h0KSA+IGxhc3RFZGdlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAodmlld0JvdHRvbSA8PSB0b3AgfHwgY3VycmVudEhlaWdodCA+PSBib3R0b20gfHwgdmlld1JpZ2h0IDw9IGxlZnQgfHwgY3VycmVudFdpZHRoID49IHJpZ2h0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaGlkZGVuSGVpZ2h0ID0gTWF0aC5tYXgoMCwgdG9wIC0gY3VycmVudEhlaWdodCkgKyBNYXRoLm1heCgwLCB2aWV3Qm90dG9tIC0gYm90dG9tKTtcbiAgICB2YXIgaGlkZGVuV2lkdGggPSBNYXRoLm1heCgwLCBsZWZ0IC0gY3VycmVudFdpZHRoKSArIE1hdGgubWF4KDAsIHZpZXdSaWdodCAtIHJpZ2h0KTtcbiAgICB2YXIgcGVyY2VudCA9ICh2aWV3SGVpZ2h0IC0gaGlkZGVuSGVpZ2h0KSAqICh2aWV3V2lkdGggLSBoaWRkZW5XaWR0aCkgKiAxMDAgLyB2aWV3SGVpZ2h0IC8gdmlld1dpZHRoIHwgMDtcbiAgICB2aXNpYmxlLnB1c2goe1xuICAgICAgaWQ6IHZpZXcuaWQsXG4gICAgICB4OiBjdXJyZW50V2lkdGgsXG4gICAgICB5OiBjdXJyZW50SGVpZ2h0LFxuICAgICAgdmlldzogdmlldyxcbiAgICAgIHBlcmNlbnQ6IHBlcmNlbnRcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBmaXJzdCA9IHZpc2libGVbMF0sXG4gICAgICBsYXN0ID0gdmlzaWJsZVt2aXNpYmxlLmxlbmd0aCAtIDFdO1xuXG4gIGlmIChzb3J0QnlWaXNpYmlsaXR5KSB7XG4gICAgdmlzaWJsZS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgcGMgPSBhLnBlcmNlbnQgLSBiLnBlcmNlbnQ7XG5cbiAgICAgIGlmIChNYXRoLmFicyhwYykgPiAwLjAwMSkge1xuICAgICAgICByZXR1cm4gLXBjO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYS5pZCAtIGIuaWQ7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGZpcnN0OiBmaXJzdCxcbiAgICBsYXN0OiBsYXN0LFxuICAgIHZpZXdzOiB2aXNpYmxlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vQ29udGV4dE1lbnVIYW5kbGVyKGV2dCkge1xuICBldnQucHJldmVudERlZmF1bHQoKTtcbn1cblxuZnVuY3Rpb24gaXNEYXRhU2NoZW1hKHVybCkge1xuICB2YXIgaSA9IDA7XG4gIHZhciBpaSA9IHVybC5sZW5ndGg7XG5cbiAgd2hpbGUgKGkgPCBpaSAmJiB1cmxbaV0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgaSsrO1xuICB9XG5cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoaSwgaSArIDUpLnRvTG93ZXJDYXNlKCkgPT09IFwiZGF0YTpcIjtcbn1cblxuZnVuY3Rpb24gZ2V0UERGRmlsZU5hbWVGcm9tVVJMKHVybCkge1xuICB2YXIgZGVmYXVsdEZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImRvY3VtZW50LnBkZlwiO1xuXG4gIGlmICh0eXBlb2YgdXJsICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRGaWxlbmFtZTtcbiAgfVxuXG4gIGlmIChpc0RhdGFTY2hlbWEodXJsKSkge1xuICAgIGNvbnNvbGUud2FybihcImdldFBERkZpbGVOYW1lRnJvbVVSTDogXCIgKyAnaWdub3JpbmcgXCJkYXRhOlwiIFVSTCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4nKTtcbiAgICByZXR1cm4gZGVmYXVsdEZpbGVuYW1lO1xuICB9XG5cbiAgdmFyIHJlVVJJID0gL14oPzooPzpbXjpdKzopP1xcL1xcL1teXFwvXSspPyhbXj8jXSopKFxcP1teI10qKT8oIy4qKT8kLztcbiAgdmFyIHJlRmlsZW5hbWUgPSAvW15cXC8/Iz1dK1xcLnBkZlxcYig/IS4qXFwucGRmXFxiKS9pO1xuICB2YXIgc3BsaXRVUkkgPSByZVVSSS5leGVjKHVybCk7XG4gIHZhciBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVsxXSkgfHwgcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzJdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbM10pO1xuXG4gIGlmIChzdWdnZXN0ZWRGaWxlbmFtZSkge1xuICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gc3VnZ2VzdGVkRmlsZW5hbWVbMF07XG5cbiAgICBpZiAoc3VnZ2VzdGVkRmlsZW5hbWUuaW5jbHVkZXMoXCIlXCIpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdWdnZXN0ZWRGaWxlbmFtZSA9IHJlRmlsZW5hbWUuZXhlYyhkZWNvZGVVUklDb21wb25lbnQoc3VnZ2VzdGVkRmlsZW5hbWUpKVswXTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzdWdnZXN0ZWRGaWxlbmFtZSB8fCBkZWZhdWx0RmlsZW5hbWU7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZVdoZWVsRXZlbnREaXJlY3Rpb24oZXZ0KSB7XG4gIHZhciBkZWx0YSA9IE1hdGguc3FydChldnQuZGVsdGFYICogZXZ0LmRlbHRhWCArIGV2dC5kZWx0YVkgKiBldnQuZGVsdGFZKTtcbiAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihldnQuZGVsdGFZLCBldnQuZGVsdGFYKTtcblxuICBpZiAoLTAuMjUgKiBNYXRoLlBJIDwgYW5nbGUgJiYgYW5nbGUgPCAwLjc1ICogTWF0aC5QSSkge1xuICAgIGRlbHRhID0gLWRlbHRhO1xuICB9XG5cbiAgcmV0dXJuIGRlbHRhO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVXaGVlbEV2ZW50RGVsdGEoZXZ0KSB7XG4gIHZhciBkZWx0YSA9IG5vcm1hbGl6ZVdoZWVsRXZlbnREaXJlY3Rpb24oZXZ0KTtcbiAgdmFyIE1PVVNFX0RPTV9ERUxUQV9QSVhFTF9NT0RFID0gMDtcbiAgdmFyIE1PVVNFX0RPTV9ERUxUQV9MSU5FX01PREUgPSAxO1xuICB2YXIgTU9VU0VfUElYRUxTX1BFUl9MSU5FID0gMzA7XG4gIHZhciBNT1VTRV9MSU5FU19QRVJfUEFHRSA9IDMwO1xuXG4gIGlmIChldnQuZGVsdGFNb2RlID09PSBNT1VTRV9ET01fREVMVEFfUElYRUxfTU9ERSkge1xuICAgIGRlbHRhIC89IE1PVVNFX1BJWEVMU19QRVJfTElORSAqIE1PVVNFX0xJTkVTX1BFUl9QQUdFO1xuICB9IGVsc2UgaWYgKGV2dC5kZWx0YU1vZGUgPT09IE1PVVNFX0RPTV9ERUxUQV9MSU5FX01PREUpIHtcbiAgICBkZWx0YSAvPSBNT1VTRV9MSU5FU19QRVJfUEFHRTtcbiAgfVxuXG4gIHJldHVybiBkZWx0YTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFJvdGF0aW9uKGFuZ2xlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGFuZ2xlKSAmJiBhbmdsZSAlIDkwID09PSAwO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkU2Nyb2xsTW9kZShtb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKG1vZGUpICYmIE9iamVjdC52YWx1ZXMoU2Nyb2xsTW9kZSkuaW5jbHVkZXMobW9kZSkgJiYgbW9kZSAhPT0gU2Nyb2xsTW9kZS5VTktOT1dOO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkU3ByZWFkTW9kZShtb2RlKSB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKG1vZGUpICYmIE9iamVjdC52YWx1ZXMoU3ByZWFkTW9kZSkuaW5jbHVkZXMobW9kZSkgJiYgbW9kZSAhPT0gU3ByZWFkTW9kZS5VTktOT1dOO1xufVxuXG5mdW5jdGlvbiBpc1BvcnRyYWl0T3JpZW50YXRpb24oc2l6ZSkge1xuICByZXR1cm4gc2l6ZS53aWR0aCA8PSBzaXplLmhlaWdodDtcbn1cblxudmFyIFdhaXRPblR5cGUgPSB7XG4gIEVWRU5UOiBcImV2ZW50XCIsXG4gIFRJTUVPVVQ6IFwidGltZW91dFwiXG59O1xuZXhwb3J0cy5XYWl0T25UeXBlID0gV2FpdE9uVHlwZTtcblxuZnVuY3Rpb24gd2FpdE9uRXZlbnRPclRpbWVvdXQoX3JlZjIpIHtcbiAgdmFyIHRhcmdldCA9IF9yZWYyLnRhcmdldCxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lLFxuICAgICAgX3JlZjIkZGVsYXkgPSBfcmVmMi5kZWxheSxcbiAgICAgIGRlbGF5ID0gX3JlZjIkZGVsYXkgPT09IHZvaWQgMCA/IDAgOiBfcmVmMiRkZWxheTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoX3R5cGVvZih0YXJnZXQpICE9PSBcIm9iamVjdFwiIHx8ICEobmFtZSAmJiB0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikgfHwgIShOdW1iZXIuaXNJbnRlZ2VyKGRlbGF5KSAmJiBkZWxheSA+PSAwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwid2FpdE9uRXZlbnRPclRpbWVvdXQgLSBpbnZhbGlkIHBhcmFtZXRlcnMuXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZXIodHlwZSkge1xuICAgICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIEV2ZW50QnVzKSB7XG4gICAgICAgIHRhcmdldC5fb2ZmKG5hbWUsIGV2ZW50SGFuZGxlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudEhhbmRsZXIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUodHlwZSk7XG4gICAgfVxuXG4gICAgdmFyIGV2ZW50SGFuZGxlciA9IGhhbmRsZXIuYmluZChudWxsLCBXYWl0T25UeXBlLkVWRU5UKTtcblxuICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBFdmVudEJ1cykge1xuICAgICAgdGFyZ2V0Ll9vbihuYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH1cblxuICAgIHZhciB0aW1lb3V0SGFuZGxlciA9IGhhbmRsZXIuYmluZChudWxsLCBXYWl0T25UeXBlLlRJTUVPVVQpO1xuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dCh0aW1lb3V0SGFuZGxlciwgZGVsYXkpO1xuICB9KTtcbn1cblxudmFyIGFuaW1hdGlvblN0YXJ0ZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc29sdmUpO1xufSk7XG5leHBvcnRzLmFuaW1hdGlvblN0YXJ0ZWQgPSBhbmltYXRpb25TdGFydGVkO1xuXG5mdW5jdGlvbiBkaXNwYXRjaERPTUV2ZW50KGV2ZW50TmFtZSkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkOiBkaXNwYXRjaERPTUV2ZW50XCIpO1xufVxuXG52YXIgRXZlbnRCdXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFdmVudEJ1cyhvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEV2ZW50QnVzKTtcblxuICAgIHRoaXMuX2xpc3RlbmVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoRXZlbnRCdXMsIFt7XG4gICAga2V5OiBcIm9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX29uKGV2ZW50TmFtZSwgbGlzdGVuZXIsIHtcbiAgICAgICAgZXh0ZXJuYWw6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvZmZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHRoaXMuX29mZihldmVudE5hbWUsIGxpc3RlbmVyLCB7XG4gICAgICAgIGV4dGVybmFsOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzcGF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcGF0Y2goZXZlbnROYW1lKSB7XG4gICAgICB2YXIgZXZlbnRMaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnROYW1lXTtcblxuICAgICAgaWYgKCFldmVudExpc3RlbmVycyB8fCBldmVudExpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgZXh0ZXJuYWxMaXN0ZW5lcnM7XG4gICAgICBldmVudExpc3RlbmVycy5zbGljZSgwKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgbGlzdGVuZXIgPSBfcmVmMy5saXN0ZW5lcixcbiAgICAgICAgICAgIGV4dGVybmFsID0gX3JlZjMuZXh0ZXJuYWw7XG5cbiAgICAgICAgaWYgKGV4dGVybmFsKSB7XG4gICAgICAgICAgaWYgKCFleHRlcm5hbExpc3RlbmVycykge1xuICAgICAgICAgICAgZXh0ZXJuYWxMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBleHRlcm5hbExpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoZXh0ZXJuYWxMaXN0ZW5lcnMpIHtcbiAgICAgICAgZXh0ZXJuYWxMaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgICBsaXN0ZW5lci5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGV4dGVybmFsTGlzdGVuZXJzID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vbihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciBldmVudExpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdO1xuXG4gICAgICBpZiAoIWV2ZW50TGlzdGVuZXJzKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudE5hbWVdID0gZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRMaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIGxpc3RlbmVyOiBsaXN0ZW5lcixcbiAgICAgICAgZXh0ZXJuYWw6IChvcHRpb25zICYmIG9wdGlvbnMuZXh0ZXJuYWwpID09PSB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX29mZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdmFyIGV2ZW50TGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50TmFtZV07XG5cbiAgICAgIGlmICghZXZlbnRMaXN0ZW5lcnMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBldmVudExpc3RlbmVycy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmIChldmVudExpc3RlbmVyc1tpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICBldmVudExpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEV2ZW50QnVzO1xufSgpO1xuXG5leHBvcnRzLkV2ZW50QnVzID0gRXZlbnRCdXM7XG5cbmZ1bmN0aW9uIGNsYW1wKHYsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xufVxuXG52YXIgUHJvZ3Jlc3NCYXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9ncmVzc0JhcihpZCkge1xuICAgIHZhciBfcmVmNCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIGhlaWdodCA9IF9yZWY0LmhlaWdodCxcbiAgICAgICAgd2lkdGggPSBfcmVmNC53aWR0aCxcbiAgICAgICAgdW5pdHMgPSBfcmVmNC51bml0cztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmVzc0Jhcik7XG5cbiAgICB0aGlzLnZpc2libGUgPSB0cnVlO1xuICAgIHRoaXMuZGl2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihpZCArIFwiIC5wcm9ncmVzc1wiKTtcbiAgICB0aGlzLmJhciA9IHRoaXMuZGl2LnBhcmVudE5vZGU7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgfHwgMTAwO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aCB8fCAxMDA7XG4gICAgdGhpcy51bml0cyA9IHVuaXRzIHx8IFwiJVwiO1xuICAgIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgdGhpcy51bml0cztcbiAgICB0aGlzLnBlcmNlbnQgPSAwO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFByb2dyZXNzQmFyLCBbe1xuICAgIGtleTogXCJfdXBkYXRlQmFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCYXIoKSB7XG4gICAgICBpZiAodGhpcy5faW5kZXRlcm1pbmF0ZSkge1xuICAgICAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwiaW5kZXRlcm1pbmF0ZVwiKTtcbiAgICAgICAgdGhpcy5kaXYuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgdGhpcy51bml0cztcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiaW5kZXRlcm1pbmF0ZVwiKTtcbiAgICAgIHZhciBwcm9ncmVzc1NpemUgPSB0aGlzLndpZHRoICogdGhpcy5fcGVyY2VudCAvIDEwMDtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gcHJvZ3Jlc3NTaXplICsgdGhpcy51bml0cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0V2lkdGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0V2lkdGgodmlld2VyKSB7XG4gICAgICBpZiAoIXZpZXdlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250YWluZXIgPSB2aWV3ZXIucGFyZW50Tm9kZTtcbiAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IGNvbnRhaW5lci5vZmZzZXRXaWR0aCAtIHZpZXdlci5vZmZzZXRXaWR0aDtcblxuICAgICAgaWYgKHNjcm9sbGJhcldpZHRoID4gMCkge1xuICAgICAgICB0aGlzLmJhci5zdHlsZS53aWR0aCA9IFwiY2FsYygxMDAlIC0gXCIuY29uY2F0KHNjcm9sbGJhcldpZHRoLCBcInB4KVwiKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGlkZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgaWYgKCF0aGlzLnZpc2libGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5hZGQoXCJoaWRkZW5cIik7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoXCJsb2FkaW5nSW5Qcm9ncmVzc1wiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaG93KCkge1xuICAgICAgaWYgKHRoaXMudmlzaWJsZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJsb2FkaW5nSW5Qcm9ncmVzc1wiKTtcbiAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBlcmNlbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wZXJjZW50O1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICB0aGlzLl9pbmRldGVybWluYXRlID0gaXNOYU4odmFsKTtcbiAgICAgIHRoaXMuX3BlcmNlbnQgPSBjbGFtcCh2YWwsIDAsIDEwMCk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUJhcigpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQcm9ncmVzc0Jhcjtcbn0oKTtcblxuZXhwb3J0cy5Qcm9ncmVzc0JhciA9IFByb2dyZXNzQmFyO1xuXG5mdW5jdGlvbiBtb3ZlVG9FbmRPZkFycmF5KGFyciwgY29uZGl0aW9uKSB7XG4gIHZhciBtb3ZlZCA9IFtdLFxuICAgICAgbGVuID0gYXJyLmxlbmd0aDtcbiAgdmFyIHdyaXRlID0gMDtcblxuICBmb3IgKHZhciByZWFkID0gMDsgcmVhZCA8IGxlbjsgKytyZWFkKSB7XG4gICAgaWYgKGNvbmRpdGlvbihhcnJbcmVhZF0pKSB7XG4gICAgICBtb3ZlZC5wdXNoKGFycltyZWFkXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFyclt3cml0ZV0gPSBhcnJbcmVhZF07XG4gICAgICArK3dyaXRlO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9yZWFkID0gMDsgd3JpdGUgPCBsZW47ICsrX3JlYWQsICsrd3JpdGUpIHtcbiAgICBhcnJbd3JpdGVdID0gbW92ZWRbX3JlYWRdO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihtb2R1bGUpIHtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG52YXIgcnVudGltZSA9IGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDtcbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cblxuICB0cnkge1xuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuXG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwibm9ybWFsXCIsXG4gICAgICAgIGFyZzogZm4uY2FsbChvYmosIGFyZylcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcInRocm93XCIsXG4gICAgICAgIGFyZzogZXJyXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cblxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbiAgSXRlcmF0b3JQcm90b3R5cGVbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbiAgdmFyIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpO1xuXG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSkge1xuICAgIEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGU7XG4gIH1cblxuICB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7XG4gIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdwLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLmNvbnN0cnVjdG9yID0gR2VuZXJhdG9yRnVuY3Rpb247XG4gIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcblxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yID8gY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuXG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19hd2FpdDogYXJnXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG5cbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG5cbiAgICAgICAgaWYgKHZhbHVlICYmIF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7XG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnZva2UgPSBlbnF1ZXVlO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKTtcblxuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcbiAgICB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7XG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZykge1xuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUV4ZWN1dGluZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlQ29tcGxldGVkKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIHRocm93IGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG5cbiAgICAgICAgaWYgKGRlbGVnYXRlKSB7XG4gICAgICAgICAgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuICAgICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBHZW5TdGF0ZUNvbXBsZXRlZCA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkge1xuICAgIHZhciBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF07XG5cbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7XG5cbiAgICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ3Rocm93JyBtZXRob2RcIik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7XG5cbiAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cblxuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcblxuICAgIGlmICghaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWU7XG4gICAgICBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgIT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcbiAgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIik7XG5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7XG4gICAgdmFyIGVudHJ5ID0ge1xuICAgICAgdHJ5TG9jOiBsb2NzWzBdXG4gICAgfTtcblxuICAgIGlmICgxIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXTtcbiAgICB9XG5cbiAgICBpZiAoMiBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXTtcbiAgICAgIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXTtcbiAgICB9XG5cbiAgICB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7XG4gICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307XG4gICAgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiO1xuICAgIGRlbGV0ZSByZWNvcmQuYXJnO1xuICAgIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cblxuICBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7XG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3tcbiAgICAgIHRyeUxvYzogXCJyb290XCJcbiAgICB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuXG4gICAga2V5cy5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICB3aGlsZSAoa2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IGtleXMucG9wKCk7XG5cbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkge1xuICAgIGlmIChpdGVyYWJsZSkge1xuICAgICAgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdO1xuXG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgICAgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICAgICAgd2hpbGUgKCsraSA8IGl0ZXJhYmxlLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkge1xuICAgICAgICAgICAgICBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV07XG4gICAgICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBuZXh0LnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIG5leHQuZG9uZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6IGRvbmVSZXN1bHRcbiAgICB9O1xuICB9XG5cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6IHRydWVcbiAgICB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG4gICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhY2F1Z2h0O1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gXCJyb290XCIpIHtcbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmICh0eXBlID09PSBcImJyZWFrXCIgfHwgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgZmluYWxseUVudHJ5ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZWNvcmQudHlwZSA9IHR5cGU7XG4gICAgICByZWNvcmQuYXJnID0gYXJnO1xuXG4gICAgICBpZiAoZmluYWxseUVudHJ5KSB7XG4gICAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jO1xuICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuY29tcGxldGUocmVjb3JkKTtcbiAgICB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fCByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcblxuICAgICAgICBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykge1xuICAgICAgICAgIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpO1xuICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7XG4gICAgfSxcbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZXhwb3J0cztcbn0oKCBmYWxzZSA/IHVuZGVmaW5lZCA6IF90eXBlb2YobW9kdWxlKSkgPT09IFwib2JqZWN0XCIgPyBtb2R1bGUuZXhwb3J0cyA6IHt9KTtcblxudHJ5IHtcbiAgcmVnZW5lcmF0b3JSdW50aW1lID0gcnVudGltZTtcbn0gY2F0Y2ggKGFjY2lkZW50YWxTdHJpY3RNb2RlKSB7XG4gIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG59XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193X3BkZmpzX3JlcXVpcmVfXyg2KShtb2R1bGUpKSlcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1vZHVsZSkge1xuICBpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcbiAgICBtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgICBtb2R1bGUucGF0aHMgPSBbXTtcbiAgICBpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICByZXR1cm4gbW9kdWxlLmw7XG4gICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtb2R1bGUuaTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcbiAgfVxuXG4gIHJldHVybiBtb2R1bGU7XG59O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuU2ltcGxlTGlua1NlcnZpY2UgPSBleHBvcnRzLlBERkxpbmtTZXJ2aWNlID0gdm9pZCAwO1xuXG52YXIgX3VpX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBQREZMaW5rU2VydmljZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERkxpbmtTZXJ2aWNlKCkge1xuICAgIHZhciBfcmVmID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fSxcbiAgICAgICAgZXZlbnRCdXMgPSBfcmVmLmV2ZW50QnVzLFxuICAgICAgICBfcmVmJGV4dGVybmFsTGlua1RhcmcgPSBfcmVmLmV4dGVybmFsTGlua1RhcmdldCxcbiAgICAgICAgZXh0ZXJuYWxMaW5rVGFyZ2V0ID0gX3JlZiRleHRlcm5hbExpbmtUYXJnID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRleHRlcm5hbExpbmtUYXJnLFxuICAgICAgICBfcmVmJGV4dGVybmFsTGlua1JlbCA9IF9yZWYuZXh0ZXJuYWxMaW5rUmVsLFxuICAgICAgICBleHRlcm5hbExpbmtSZWwgPSBfcmVmJGV4dGVybmFsTGlua1JlbCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkZXh0ZXJuYWxMaW5rUmVsLFxuICAgICAgICBfcmVmJGV4dGVybmFsTGlua0VuYWIgPSBfcmVmLmV4dGVybmFsTGlua0VuYWJsZWQsXG4gICAgICAgIGV4dGVybmFsTGlua0VuYWJsZWQgPSBfcmVmJGV4dGVybmFsTGlua0VuYWIgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJGV4dGVybmFsTGlua0VuYWIsXG4gICAgICAgIF9yZWYkaWdub3JlRGVzdGluYXRpbyA9IF9yZWYuaWdub3JlRGVzdGluYXRpb25ab29tLFxuICAgICAgICBpZ25vcmVEZXN0aW5hdGlvblpvb20gPSBfcmVmJGlnbm9yZURlc3RpbmF0aW8gPT09IHZvaWQgMCA/IGZhbHNlIDogX3JlZiRpZ25vcmVEZXN0aW5hdGlvO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkxpbmtTZXJ2aWNlKTtcblxuICAgIHRoaXMuZXZlbnRCdXMgPSBldmVudEJ1cztcbiAgICB0aGlzLmV4dGVybmFsTGlua1RhcmdldCA9IGV4dGVybmFsTGlua1RhcmdldDtcbiAgICB0aGlzLmV4dGVybmFsTGlua1JlbCA9IGV4dGVybmFsTGlua1JlbDtcbiAgICB0aGlzLmV4dGVybmFsTGlua0VuYWJsZWQgPSBleHRlcm5hbExpbmtFbmFibGVkO1xuICAgIHRoaXMuX2lnbm9yZURlc3RpbmF0aW9uWm9vbSA9IGlnbm9yZURlc3RpbmF0aW9uWm9vbTtcbiAgICB0aGlzLmJhc2VVcmwgPSBudWxsO1xuICAgIHRoaXMucGRmRG9jdW1lbnQgPSBudWxsO1xuICAgIHRoaXMucGRmVmlld2VyID0gbnVsbDtcbiAgICB0aGlzLnBkZkhpc3RvcnkgPSBudWxsO1xuICAgIHRoaXMuX3BhZ2VzUmVmQ2FjaGUgPSBudWxsO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBERkxpbmtTZXJ2aWNlLCBbe1xuICAgIGtleTogXCJzZXREb2N1bWVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXREb2N1bWVudChwZGZEb2N1bWVudCkge1xuICAgICAgdmFyIGJhc2VVcmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgICAgdGhpcy5wZGZEb2N1bWVudCA9IHBkZkRvY3VtZW50O1xuICAgICAgdGhpcy5fcGFnZXNSZWZDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFZpZXdlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRWaWV3ZXIocGRmVmlld2VyKSB7XG4gICAgICB0aGlzLnBkZlZpZXdlciA9IHBkZlZpZXdlcjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0SGlzdG9yeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRIaXN0b3J5KHBkZkhpc3RvcnkpIHtcbiAgICAgIHRoaXMucGRmSGlzdG9yeSA9IHBkZkhpc3Rvcnk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm5hdmlnYXRlVG9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbmF2aWdhdGVUbyhkZXN0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgZ29Ub0Rlc3RpbmF0aW9uID0gZnVuY3Rpb24gZ29Ub0Rlc3RpbmF0aW9uKF9yZWYyKSB7XG4gICAgICAgIHZhciBuYW1lZERlc3QgPSBfcmVmMi5uYW1lZERlc3QsXG4gICAgICAgICAgICBleHBsaWNpdERlc3QgPSBfcmVmMi5leHBsaWNpdERlc3Q7XG4gICAgICAgIHZhciBkZXN0UmVmID0gZXhwbGljaXREZXN0WzBdO1xuICAgICAgICB2YXIgcGFnZU51bWJlcjtcblxuICAgICAgICBpZiAoZGVzdFJlZiBpbnN0YW5jZW9mIE9iamVjdCkge1xuICAgICAgICAgIHBhZ2VOdW1iZXIgPSBfdGhpcy5fY2FjaGVkUGFnZU51bWJlcihkZXN0UmVmKTtcblxuICAgICAgICAgIGlmIChwYWdlTnVtYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICBfdGhpcy5wZGZEb2N1bWVudC5nZXRQYWdlSW5kZXgoZGVzdFJlZikudGhlbihmdW5jdGlvbiAocGFnZUluZGV4KSB7XG4gICAgICAgICAgICAgIF90aGlzLmNhY2hlUGFnZVJlZihwYWdlSW5kZXggKyAxLCBkZXN0UmVmKTtcblxuICAgICAgICAgICAgICBnb1RvRGVzdGluYXRpb24oe1xuICAgICAgICAgICAgICAgIG5hbWVkRGVzdDogbmFtZWREZXN0LFxuICAgICAgICAgICAgICAgIGV4cGxpY2l0RGVzdDogZXhwbGljaXREZXN0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQREZMaW5rU2VydmljZS5uYXZpZ2F0ZVRvOiBcXFwiXCIuY29uY2F0KGRlc3RSZWYsIFwiXFxcIiBpcyBub3QgXCIpICsgXCJhIHZhbGlkIHBhZ2UgcmVmZXJlbmNlLCBmb3IgZGVzdD1cXFwiXCIuY29uY2F0KGRlc3QsIFwiXFxcIi5cIikpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoTnVtYmVyLmlzSW50ZWdlcihkZXN0UmVmKSkge1xuICAgICAgICAgIHBhZ2VOdW1iZXIgPSBkZXN0UmVmICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUERGTGlua1NlcnZpY2UubmF2aWdhdGVUbzogXFxcIlwiLmNvbmNhdChkZXN0UmVmLCBcIlxcXCIgaXMgbm90IFwiKSArIFwiYSB2YWxpZCBkZXN0aW5hdGlvbiByZWZlcmVuY2UsIGZvciBkZXN0PVxcXCJcIi5jb25jYXQoZGVzdCwgXCJcXFwiLlwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFwYWdlTnVtYmVyIHx8IHBhZ2VOdW1iZXIgPCAxIHx8IHBhZ2VOdW1iZXIgPiBfdGhpcy5wYWdlc0NvdW50KSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlBERkxpbmtTZXJ2aWNlLm5hdmlnYXRlVG86IFxcXCJcIi5jb25jYXQocGFnZU51bWJlciwgXCJcXFwiIGlzIG5vdCBcIikgKyBcImEgdmFsaWQgcGFnZSBudW1iZXIsIGZvciBkZXN0PVxcXCJcIi5jb25jYXQoZGVzdCwgXCJcXFwiLlwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzLnBkZkhpc3RvcnkpIHtcbiAgICAgICAgICBfdGhpcy5wZGZIaXN0b3J5LnB1c2hDdXJyZW50UG9zaXRpb24oKTtcblxuICAgICAgICAgIF90aGlzLnBkZkhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICBuYW1lZERlc3Q6IG5hbWVkRGVzdCxcbiAgICAgICAgICAgIGV4cGxpY2l0RGVzdDogZXhwbGljaXREZXN0LFxuICAgICAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bWJlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMucGRmVmlld2VyLnNjcm9sbFBhZ2VJbnRvVmlldyh7XG4gICAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bWJlcixcbiAgICAgICAgICBkZXN0QXJyYXk6IGV4cGxpY2l0RGVzdCxcbiAgICAgICAgICBpZ25vcmVEZXN0aW5hdGlvblpvb206IF90aGlzLl9pZ25vcmVEZXN0aW5hdGlvblpvb21cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIF90aGlzLnBkZkRvY3VtZW50LmdldERlc3RpbmF0aW9uKGRlc3QpLnRoZW4oZnVuY3Rpb24gKGRlc3RBcnJheSkge1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIG5hbWVkRGVzdDogZGVzdCxcbiAgICAgICAgICAgICAgZXhwbGljaXREZXN0OiBkZXN0QXJyYXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgbmFtZWREZXN0OiBcIlwiLFxuICAgICAgICAgIGV4cGxpY2l0RGVzdDogZGVzdFxuICAgICAgICB9KTtcbiAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEuZXhwbGljaXREZXN0KSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQREZMaW5rU2VydmljZS5uYXZpZ2F0ZVRvOiBcXFwiXCIuY29uY2F0KGRhdGEuZXhwbGljaXREZXN0LCBcIlxcXCIgaXNcIikgKyBcIiBub3QgYSB2YWxpZCBkZXN0aW5hdGlvbiBhcnJheSwgZm9yIGRlc3Q9XFxcIlwiLmNvbmNhdChkZXN0LCBcIlxcXCIuXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnb1RvRGVzdGluYXRpb24oZGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGVzdGluYXRpb25IYXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlc3RpbmF0aW9uSGFzaChkZXN0KSB7XG4gICAgICBpZiAodHlwZW9mIGRlc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QW5jaG9yVXJsKFwiI1wiICsgZXNjYXBlKGRlc3QpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGVzdCkpIHtcbiAgICAgICAgdmFyIHN0ciA9IEpTT04uc3RyaW5naWZ5KGRlc3QpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbmNob3JVcmwoXCIjXCIgKyBlc2NhcGUoc3RyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmdldEFuY2hvclVybChcIlwiKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QW5jaG9yVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFuY2hvclVybChhbmNob3IpIHtcbiAgICAgIHJldHVybiAodGhpcy5iYXNlVXJsIHx8IFwiXCIpICsgYW5jaG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRIYXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEhhc2goaGFzaCkge1xuICAgICAgdmFyIHBhZ2VOdW1iZXIsIGRlc3Q7XG5cbiAgICAgIGlmIChoYXNoLmluY2x1ZGVzKFwiPVwiKSkge1xuICAgICAgICB2YXIgcGFyYW1zID0gKDAsIF91aV91dGlscy5wYXJzZVF1ZXJ5U3RyaW5nKShoYXNoKTtcblxuICAgICAgICBpZiAoXCJzZWFyY2hcIiBpbiBwYXJhbXMpIHtcbiAgICAgICAgICB0aGlzLmV2ZW50QnVzLmRpc3BhdGNoKFwiZmluZGZyb211cmxoYXNoXCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIHF1ZXJ5OiBwYXJhbXMuc2VhcmNoLnJlcGxhY2UoL1wiL2csIFwiXCIpLFxuICAgICAgICAgICAgcGhyYXNlU2VhcmNoOiBwYXJhbXMucGhyYXNlID09PSBcInRydWVcIlxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwicGFnZVwiIGluIHBhcmFtcykge1xuICAgICAgICAgIHBhZ2VOdW1iZXIgPSBwYXJhbXMucGFnZSB8IDAgfHwgMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChcInpvb21cIiBpbiBwYXJhbXMpIHtcbiAgICAgICAgICB2YXIgem9vbUFyZ3MgPSBwYXJhbXMuem9vbS5zcGxpdChcIixcIik7XG4gICAgICAgICAgdmFyIHpvb21BcmcgPSB6b29tQXJnc1swXTtcbiAgICAgICAgICB2YXIgem9vbUFyZ051bWJlciA9IHBhcnNlRmxvYXQoem9vbUFyZyk7XG5cbiAgICAgICAgICBpZiAoIXpvb21BcmcuaW5jbHVkZXMoXCJGaXRcIikpIHtcbiAgICAgICAgICAgIGRlc3QgPSBbbnVsbCwge1xuICAgICAgICAgICAgICBuYW1lOiBcIlhZWlwiXG4gICAgICAgICAgICB9LCB6b29tQXJncy5sZW5ndGggPiAxID8gem9vbUFyZ3NbMV0gfCAwIDogbnVsbCwgem9vbUFyZ3MubGVuZ3RoID4gMiA/IHpvb21BcmdzWzJdIHwgMCA6IG51bGwsIHpvb21BcmdOdW1iZXIgPyB6b29tQXJnTnVtYmVyIC8gMTAwIDogem9vbUFyZ107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh6b29tQXJnID09PSBcIkZpdFwiIHx8IHpvb21BcmcgPT09IFwiRml0QlwiKSB7XG4gICAgICAgICAgICAgIGRlc3QgPSBbbnVsbCwge1xuICAgICAgICAgICAgICAgIG5hbWU6IHpvb21BcmdcbiAgICAgICAgICAgICAgfV07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHpvb21BcmcgPT09IFwiRml0SFwiIHx8IHpvb21BcmcgPT09IFwiRml0QkhcIiB8fCB6b29tQXJnID09PSBcIkZpdFZcIiB8fCB6b29tQXJnID09PSBcIkZpdEJWXCIpIHtcbiAgICAgICAgICAgICAgZGVzdCA9IFtudWxsLCB7XG4gICAgICAgICAgICAgICAgbmFtZTogem9vbUFyZ1xuICAgICAgICAgICAgICB9LCB6b29tQXJncy5sZW5ndGggPiAxID8gem9vbUFyZ3NbMV0gfCAwIDogbnVsbF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHpvb21BcmcgPT09IFwiRml0UlwiKSB7XG4gICAgICAgICAgICAgIGlmICh6b29tQXJncy5sZW5ndGggIT09IDUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQREZMaW5rU2VydmljZS5zZXRIYXNoOiBOb3QgZW5vdWdoIHBhcmFtZXRlcnMgZm9yIFwiRml0UlwiLicpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlc3QgPSBbbnVsbCwge1xuICAgICAgICAgICAgICAgICAgbmFtZTogem9vbUFyZ1xuICAgICAgICAgICAgICAgIH0sIHpvb21BcmdzWzFdIHwgMCwgem9vbUFyZ3NbMl0gfCAwLCB6b29tQXJnc1szXSB8IDAsIHpvb21BcmdzWzRdIHwgMF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQREZMaW5rU2VydmljZS5zZXRIYXNoOiBcXFwiXCIuY29uY2F0KHpvb21BcmcsIFwiXFxcIiBpcyBub3QgXCIpICsgXCJhIHZhbGlkIHpvb20gdmFsdWUuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZXN0KSB7XG4gICAgICAgICAgdGhpcy5wZGZWaWV3ZXIuc2Nyb2xsUGFnZUludG9WaWV3KHtcbiAgICAgICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXIgfHwgdGhpcy5wYWdlLFxuICAgICAgICAgICAgZGVzdEFycmF5OiBkZXN0LFxuICAgICAgICAgICAgYWxsb3dOZWdhdGl2ZU9mZnNldDogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHBhZ2VOdW1iZXIpIHtcbiAgICAgICAgICB0aGlzLnBhZ2UgPSBwYWdlTnVtYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwicGFnZW1vZGVcIiBpbiBwYXJhbXMpIHtcbiAgICAgICAgICB0aGlzLmV2ZW50QnVzLmRpc3BhdGNoKFwicGFnZW1vZGVcIiwge1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgbW9kZTogcGFyYW1zLnBhZ2Vtb2RlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoXCJuYW1lZGRlc3RcIiBpbiBwYXJhbXMpIHtcbiAgICAgICAgICB0aGlzLm5hdmlnYXRlVG8ocGFyYW1zLm5hbWVkZGVzdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlc3QgPSB1bmVzY2FwZShoYXNoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRlc3QgPSBKU09OLnBhcnNlKGRlc3QpO1xuXG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRlc3QpKSB7XG4gICAgICAgICAgICBkZXN0ID0gZGVzdC50b1N0cmluZygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXgpIHt9XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkZXN0ID09PSBcInN0cmluZ1wiIHx8IGlzVmFsaWRFeHBsaWNpdERlc3RpbmF0aW9uKGRlc3QpKSB7XG4gICAgICAgICAgdGhpcy5uYXZpZ2F0ZVRvKGRlc3QpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQREZMaW5rU2VydmljZS5zZXRIYXNoOiBcXFwiXCIuY29uY2F0KHVuZXNjYXBlKGhhc2gpLCBcIlxcXCIgaXMgbm90IFwiKSArIFwiYSB2YWxpZCBkZXN0aW5hdGlvbi5cIik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4ZWN1dGVOYW1lZEFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKSB7XG4gICAgICBzd2l0Y2ggKGFjdGlvbikge1xuICAgICAgICBjYXNlIFwiR29CYWNrXCI6XG4gICAgICAgICAgaWYgKHRoaXMucGRmSGlzdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5wZGZIaXN0b3J5LmJhY2soKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiR29Gb3J3YXJkXCI6XG4gICAgICAgICAgaWYgKHRoaXMucGRmSGlzdG9yeSkge1xuICAgICAgICAgICAgdGhpcy5wZGZIaXN0b3J5LmZvcndhcmQoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiTmV4dFBhZ2VcIjpcbiAgICAgICAgICBpZiAodGhpcy5wYWdlIDwgdGhpcy5wYWdlc0NvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhZ2UrKztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiUHJldlBhZ2VcIjpcbiAgICAgICAgICBpZiAodGhpcy5wYWdlID4gMSkge1xuICAgICAgICAgICAgdGhpcy5wYWdlLS07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBcIkxhc3RQYWdlXCI6XG4gICAgICAgICAgdGhpcy5wYWdlID0gdGhpcy5wYWdlc0NvdW50O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJGaXJzdFBhZ2VcIjpcbiAgICAgICAgICB0aGlzLnBhZ2UgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXZlbnRCdXMuZGlzcGF0Y2goXCJuYW1lZGFjdGlvblwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWNoZVBhZ2VSZWZcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FjaGVQYWdlUmVmKHBhZ2VOdW0sIHBhZ2VSZWYpIHtcbiAgICAgIGlmICghcGFnZVJlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZWZTdHIgPSBwYWdlUmVmLmdlbiA9PT0gMCA/IFwiXCIuY29uY2F0KHBhZ2VSZWYubnVtLCBcIlJcIikgOiBcIlwiLmNvbmNhdChwYWdlUmVmLm51bSwgXCJSXCIpLmNvbmNhdChwYWdlUmVmLmdlbik7XG4gICAgICB0aGlzLl9wYWdlc1JlZkNhY2hlW3JlZlN0cl0gPSBwYWdlTnVtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FjaGVkUGFnZU51bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FjaGVkUGFnZU51bWJlcihwYWdlUmVmKSB7XG4gICAgICB2YXIgcmVmU3RyID0gcGFnZVJlZi5nZW4gPT09IDAgPyBcIlwiLmNvbmNhdChwYWdlUmVmLm51bSwgXCJSXCIpIDogXCJcIi5jb25jYXQocGFnZVJlZi5udW0sIFwiUlwiKS5jb25jYXQocGFnZVJlZi5nZW4pO1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VzUmVmQ2FjaGUgJiYgdGhpcy5fcGFnZXNSZWZDYWNoZVtyZWZTdHJdIHx8IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUGFnZVZpc2libGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNQYWdlVmlzaWJsZShwYWdlTnVtYmVyKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZGZWaWV3ZXIuaXNQYWdlVmlzaWJsZShwYWdlTnVtYmVyKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZXNDb3VudFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGRmRG9jdW1lbnQgPyB0aGlzLnBkZkRvY3VtZW50Lm51bVBhZ2VzIDogMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGRmVmlld2VyLmN1cnJlbnRQYWdlTnVtYmVyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAgIHRoaXMucGRmVmlld2VyLmN1cnJlbnRQYWdlTnVtYmVyID0gdmFsdWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZGZWaWV3ZXIucGFnZXNSb3RhdGlvbjtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLnBkZlZpZXdlci5wYWdlc1JvdGF0aW9uID0gdmFsdWU7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkxpbmtTZXJ2aWNlO1xufSgpO1xuXG5leHBvcnRzLlBERkxpbmtTZXJ2aWNlID0gUERGTGlua1NlcnZpY2U7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFeHBsaWNpdERlc3RpbmF0aW9uKGRlc3QpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRlc3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGRlc3RMZW5ndGggPSBkZXN0Lmxlbmd0aDtcblxuICBpZiAoZGVzdExlbmd0aCA8IDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgcGFnZSA9IGRlc3RbMF07XG5cbiAgaWYgKCEoX3R5cGVvZihwYWdlKSA9PT0gXCJvYmplY3RcIiAmJiBOdW1iZXIuaXNJbnRlZ2VyKHBhZ2UubnVtKSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHBhZ2UuZ2VuKSkgJiYgIShOdW1iZXIuaXNJbnRlZ2VyKHBhZ2UpICYmIHBhZ2UgPj0gMCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgem9vbSA9IGRlc3RbMV07XG5cbiAgaWYgKCEoX3R5cGVvZih6b29tKSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygem9vbS5uYW1lID09PSBcInN0cmluZ1wiKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBhbGxvd051bGwgPSB0cnVlO1xuXG4gIHN3aXRjaCAoem9vbS5uYW1lKSB7XG4gICAgY2FzZSBcIlhZWlwiOlxuICAgICAgaWYgKGRlc3RMZW5ndGggIT09IDUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgXCJGaXRcIjpcbiAgICBjYXNlIFwiRml0QlwiOlxuICAgICAgcmV0dXJuIGRlc3RMZW5ndGggPT09IDI7XG5cbiAgICBjYXNlIFwiRml0SFwiOlxuICAgIGNhc2UgXCJGaXRCSFwiOlxuICAgIGNhc2UgXCJGaXRWXCI6XG4gICAgY2FzZSBcIkZpdEJWXCI6XG4gICAgICBpZiAoZGVzdExlbmd0aCAhPT0gMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBcIkZpdFJcIjpcbiAgICAgIGlmIChkZXN0TGVuZ3RoICE9PSA2KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgYWxsb3dOdWxsID0gZmFsc2U7XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMjsgaSA8IGRlc3RMZW5ndGg7IGkrKykge1xuICAgIHZhciBwYXJhbSA9IGRlc3RbaV07XG5cbiAgICBpZiAoISh0eXBlb2YgcGFyYW0gPT09IFwibnVtYmVyXCIgfHwgYWxsb3dOdWxsICYmIHBhcmFtID09PSBudWxsKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgU2ltcGxlTGlua1NlcnZpY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTaW1wbGVMaW5rU2VydmljZSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2ltcGxlTGlua1NlcnZpY2UpO1xuXG4gICAgdGhpcy5leHRlcm5hbExpbmtUYXJnZXQgPSBudWxsO1xuICAgIHRoaXMuZXh0ZXJuYWxMaW5rUmVsID0gbnVsbDtcbiAgICB0aGlzLmV4dGVybmFsTGlua0VuYWJsZWQgPSB0cnVlO1xuICAgIHRoaXMuX2lnbm9yZURlc3RpbmF0aW9uWm9vbSA9IGZhbHNlO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFNpbXBsZUxpbmtTZXJ2aWNlLCBbe1xuICAgIGtleTogXCJuYXZpZ2F0ZVRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5hdmlnYXRlVG8oZGVzdCkge31cbiAgfSwge1xuICAgIGtleTogXCJnZXREZXN0aW5hdGlvbkhhc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVzdGluYXRpb25IYXNoKGRlc3QpIHtcbiAgICAgIHJldHVybiBcIiNcIjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QW5jaG9yVXJsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFuY2hvclVybChoYXNoKSB7XG4gICAgICByZXR1cm4gXCIjXCI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldEhhc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SGFzaChoYXNoKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImV4ZWN1dGVOYW1lZEFjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKSB7fVxuICB9LCB7XG4gICAga2V5OiBcImNhY2hlUGFnZVJlZlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWNoZVBhZ2VSZWYocGFnZU51bSwgcGFnZVJlZikge31cbiAgfSwge1xuICAgIGtleTogXCJpc1BhZ2VWaXNpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUGFnZVZpc2libGUocGFnZU51bWJlcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VzQ291bnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwYWdlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7fVxuICB9LCB7XG4gICAga2V5OiBcInJvdGF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7fVxuICB9XSk7XG5cbiAgcmV0dXJuIFNpbXBsZUxpbmtTZXJ2aWNlO1xufSgpO1xuXG5leHBvcnRzLlNpbXBsZUxpbmtTZXJ2aWNlID0gU2ltcGxlTGlua1NlcnZpY2U7XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5EZWZhdWx0VGV4dExheWVyRmFjdG9yeSA9IGV4cG9ydHMuVGV4dExheWVyQnVpbGRlciA9IHZvaWQgMDtcblxudmFyIF9wZGZqc0xpYiA9IF9fd19wZGZqc19yZXF1aXJlX18oMik7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEVYUEFORF9ESVZTX1RJTUVPVVQgPSAzMDA7XG5cbnZhciBUZXh0TGF5ZXJCdWlsZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVGV4dExheWVyQnVpbGRlcihfcmVmKSB7XG4gICAgdmFyIHRleHRMYXllckRpdiA9IF9yZWYudGV4dExheWVyRGl2LFxuICAgICAgICBldmVudEJ1cyA9IF9yZWYuZXZlbnRCdXMsXG4gICAgICAgIHBhZ2VJbmRleCA9IF9yZWYucGFnZUluZGV4LFxuICAgICAgICB2aWV3cG9ydCA9IF9yZWYudmlld3BvcnQsXG4gICAgICAgIF9yZWYkZmluZENvbnRyb2xsZXIgPSBfcmVmLmZpbmRDb250cm9sbGVyLFxuICAgICAgICBmaW5kQ29udHJvbGxlciA9IF9yZWYkZmluZENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJGZpbmRDb250cm9sbGVyLFxuICAgICAgICBfcmVmJGVuaGFuY2VUZXh0U2VsZWMgPSBfcmVmLmVuaGFuY2VUZXh0U2VsZWN0aW9uLFxuICAgICAgICBlbmhhbmNlVGV4dFNlbGVjdGlvbiA9IF9yZWYkZW5oYW5jZVRleHRTZWxlYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmJGVuaGFuY2VUZXh0U2VsZWM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGV4dExheWVyQnVpbGRlcik7XG5cbiAgICB0aGlzLnRleHRMYXllckRpdiA9IHRleHRMYXllckRpdjtcbiAgICB0aGlzLmV2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IG51bGw7XG4gICAgdGhpcy50ZXh0Q29udGVudEl0ZW1zU3RyID0gW107XG4gICAgdGhpcy50ZXh0Q29udGVudFN0cmVhbSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJpbmdEb25lID0gZmFsc2U7XG4gICAgdGhpcy5wYWdlSWR4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMucGFnZU51bWJlciA9IHRoaXMucGFnZUlkeCArIDE7XG4gICAgdGhpcy5tYXRjaGVzID0gW107XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMudGV4dERpdnMgPSBbXTtcbiAgICB0aGlzLmZpbmRDb250cm9sbGVyID0gZmluZENvbnRyb2xsZXI7XG4gICAgdGhpcy50ZXh0TGF5ZXJSZW5kZXJUYXNrID0gbnVsbDtcbiAgICB0aGlzLmVuaGFuY2VUZXh0U2VsZWN0aW9uID0gZW5oYW5jZVRleHRTZWxlY3Rpb247XG4gICAgdGhpcy5fb25VcGRhdGVUZXh0TGF5ZXJNYXRjaGVzID0gbnVsbDtcblxuICAgIHRoaXMuX2JpbmRNb3VzZSgpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFRleHRMYXllckJ1aWxkZXIsIFt7XG4gICAga2V5OiBcIl9maW5pc2hSZW5kZXJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2ZpbmlzaFJlbmRlcmluZygpIHtcbiAgICAgIHRoaXMucmVuZGVyaW5nRG9uZSA9IHRydWU7XG5cbiAgICAgIGlmICghdGhpcy5lbmhhbmNlVGV4dFNlbGVjdGlvbikge1xuICAgICAgICB2YXIgZW5kT2ZDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZW5kT2ZDb250ZW50LmNsYXNzTmFtZSA9IFwiZW5kT2ZDb250ZW50XCI7XG4gICAgICAgIHRoaXMudGV4dExheWVyRGl2LmFwcGVuZENoaWxkKGVuZE9mQ29udGVudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZXZlbnRCdXMuZGlzcGF0Y2goXCJ0ZXh0bGF5ZXJyZW5kZXJlZFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgcGFnZU51bWJlcjogdGhpcy5wYWdlTnVtYmVyLFxuICAgICAgICBudW1UZXh0RGl2czogdGhpcy50ZXh0RGl2cy5sZW5ndGhcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHRpbWVvdXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG5cbiAgICAgIGlmICghKHRoaXMudGV4dENvbnRlbnQgfHwgdGhpcy50ZXh0Q29udGVudFN0cmVhbSkgfHwgdGhpcy5yZW5kZXJpbmdEb25lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgIHRoaXMudGV4dERpdnMgPSBbXTtcbiAgICAgIHZhciB0ZXh0TGF5ZXJGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgdGhpcy50ZXh0TGF5ZXJSZW5kZXJUYXNrID0gKDAsIF9wZGZqc0xpYi5yZW5kZXJUZXh0TGF5ZXIpKHtcbiAgICAgICAgdGV4dENvbnRlbnQ6IHRoaXMudGV4dENvbnRlbnQsXG4gICAgICAgIHRleHRDb250ZW50U3RyZWFtOiB0aGlzLnRleHRDb250ZW50U3RyZWFtLFxuICAgICAgICBjb250YWluZXI6IHRleHRMYXllckZyYWcsXG4gICAgICAgIHZpZXdwb3J0OiB0aGlzLnZpZXdwb3J0LFxuICAgICAgICB0ZXh0RGl2czogdGhpcy50ZXh0RGl2cyxcbiAgICAgICAgdGV4dENvbnRlbnRJdGVtc1N0cjogdGhpcy50ZXh0Q29udGVudEl0ZW1zU3RyLFxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICBlbmhhbmNlVGV4dFNlbGVjdGlvbjogdGhpcy5lbmhhbmNlVGV4dFNlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICB0aGlzLnRleHRMYXllclJlbmRlclRhc2sucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMudGV4dExheWVyRGl2LmFwcGVuZENoaWxkKHRleHRMYXllckZyYWcpO1xuXG4gICAgICAgIF90aGlzLl9maW5pc2hSZW5kZXJpbmcoKTtcblxuICAgICAgICBfdGhpcy5fdXBkYXRlTWF0Y2hlcygpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge30pO1xuXG4gICAgICBpZiAoIXRoaXMuX29uVXBkYXRlVGV4dExheWVyTWF0Y2hlcykge1xuICAgICAgICB0aGlzLl9vblVwZGF0ZVRleHRMYXllck1hdGNoZXMgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgICAgaWYgKGV2dC5wYWdlSW5kZXggPT09IF90aGlzLnBhZ2VJZHggfHwgZXZ0LnBhZ2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVNYXRjaGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZXZlbnRCdXMuX29uKFwidXBkYXRldGV4dGxheWVybWF0Y2hlc1wiLCB0aGlzLl9vblVwZGF0ZVRleHRMYXllck1hdGNoZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsKCkge1xuICAgICAgaWYgKHRoaXMudGV4dExheWVyUmVuZGVyVGFzaykge1xuICAgICAgICB0aGlzLnRleHRMYXllclJlbmRlclRhc2suY2FuY2VsKCk7XG4gICAgICAgIHRoaXMudGV4dExheWVyUmVuZGVyVGFzayA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9vblVwZGF0ZVRleHRMYXllck1hdGNoZXMpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5fb2ZmKFwidXBkYXRldGV4dGxheWVybWF0Y2hlc1wiLCB0aGlzLl9vblVwZGF0ZVRleHRMYXllck1hdGNoZXMpO1xuXG4gICAgICAgIHRoaXMuX29uVXBkYXRlVGV4dExheWVyTWF0Y2hlcyA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFRleHRDb250ZW50U3RyZWFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFRleHRDb250ZW50U3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgdGhpcy50ZXh0Q29udGVudFN0cmVhbSA9IHJlYWRhYmxlU3RyZWFtO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRUZXh0Q29udGVudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRUZXh0Q29udGVudCh0ZXh0Q29udGVudCkge1xuICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgIHRoaXMudGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2NvbnZlcnRNYXRjaGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jb252ZXJ0TWF0Y2hlcyhtYXRjaGVzLCBtYXRjaGVzTGVuZ3RoKSB7XG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmluZENvbnRyb2xsZXIgPSB0aGlzLmZpbmRDb250cm9sbGVyLFxuICAgICAgICAgIHRleHRDb250ZW50SXRlbXNTdHIgPSB0aGlzLnRleHRDb250ZW50SXRlbXNTdHI7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgaUluZGV4ID0gMDtcbiAgICAgIHZhciBlbmQgPSB0ZXh0Q29udGVudEl0ZW1zU3RyLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgcXVlcnlMZW4gPSBmaW5kQ29udHJvbGxlci5zdGF0ZS5xdWVyeS5sZW5ndGg7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIG0gPSAwLCBtbSA9IG1hdGNoZXMubGVuZ3RoOyBtIDwgbW07IG0rKykge1xuICAgICAgICB2YXIgbWF0Y2hJZHggPSBtYXRjaGVzW21dO1xuXG4gICAgICAgIHdoaWxlIChpICE9PSBlbmQgJiYgbWF0Y2hJZHggPj0gaUluZGV4ICsgdGV4dENvbnRlbnRJdGVtc1N0cltpXS5sZW5ndGgpIHtcbiAgICAgICAgICBpSW5kZXggKz0gdGV4dENvbnRlbnRJdGVtc1N0cltpXS5sZW5ndGg7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPT09IHRleHRDb250ZW50SXRlbXNTdHIubGVuZ3RoKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBmaW5kIGEgbWF0Y2hpbmcgbWFwcGluZ1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtYXRjaCA9IHtcbiAgICAgICAgICBiZWdpbjoge1xuICAgICAgICAgICAgZGl2SWR4OiBpLFxuICAgICAgICAgICAgb2Zmc2V0OiBtYXRjaElkeCAtIGlJbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobWF0Y2hlc0xlbmd0aCkge1xuICAgICAgICAgIG1hdGNoSWR4ICs9IG1hdGNoZXNMZW5ndGhbbV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0Y2hJZHggKz0gcXVlcnlMZW47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoaSAhPT0gZW5kICYmIG1hdGNoSWR4ID4gaUluZGV4ICsgdGV4dENvbnRlbnRJdGVtc1N0cltpXS5sZW5ndGgpIHtcbiAgICAgICAgICBpSW5kZXggKz0gdGV4dENvbnRlbnRJdGVtc1N0cltpXS5sZW5ndGg7XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2guZW5kID0ge1xuICAgICAgICAgIGRpdklkeDogaSxcbiAgICAgICAgICBvZmZzZXQ6IG1hdGNoSWR4IC0gaUluZGV4XG4gICAgICAgIH07XG4gICAgICAgIHJlc3VsdC5wdXNoKG1hdGNoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3JlbmRlck1hdGNoZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3JlbmRlck1hdGNoZXMobWF0Y2hlcykge1xuICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpbmRDb250cm9sbGVyID0gdGhpcy5maW5kQ29udHJvbGxlcixcbiAgICAgICAgICBwYWdlSWR4ID0gdGhpcy5wYWdlSWR4LFxuICAgICAgICAgIHRleHRDb250ZW50SXRlbXNTdHIgPSB0aGlzLnRleHRDb250ZW50SXRlbXNTdHIsXG4gICAgICAgICAgdGV4dERpdnMgPSB0aGlzLnRleHREaXZzO1xuICAgICAgdmFyIGlzU2VsZWN0ZWRQYWdlID0gcGFnZUlkeCA9PT0gZmluZENvbnRyb2xsZXIuc2VsZWN0ZWQucGFnZUlkeDtcbiAgICAgIHZhciBzZWxlY3RlZE1hdGNoSWR4ID0gZmluZENvbnRyb2xsZXIuc2VsZWN0ZWQubWF0Y2hJZHg7XG4gICAgICB2YXIgaGlnaGxpZ2h0QWxsID0gZmluZENvbnRyb2xsZXIuc3RhdGUuaGlnaGxpZ2h0QWxsO1xuICAgICAgdmFyIHByZXZFbmQgPSBudWxsO1xuICAgICAgdmFyIGluZmluaXR5ID0ge1xuICAgICAgICBkaXZJZHg6IC0xLFxuICAgICAgICBvZmZzZXQ6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgZnVuY3Rpb24gYmVnaW5UZXh0KGJlZ2luLCBjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIGRpdklkeCA9IGJlZ2luLmRpdklkeDtcbiAgICAgICAgdGV4dERpdnNbZGl2SWR4XS50ZXh0Q29udGVudCA9IFwiXCI7XG4gICAgICAgIGFwcGVuZFRleHRUb0RpdihkaXZJZHgsIDAsIGJlZ2luLm9mZnNldCwgY2xhc3NOYW1lKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYXBwZW5kVGV4dFRvRGl2KGRpdklkeCwgZnJvbU9mZnNldCwgdG9PZmZzZXQsIGNsYXNzTmFtZSkge1xuICAgICAgICB2YXIgZGl2ID0gdGV4dERpdnNbZGl2SWR4XTtcbiAgICAgICAgdmFyIGNvbnRlbnQgPSB0ZXh0Q29udGVudEl0ZW1zU3RyW2RpdklkeF0uc3Vic3RyaW5nKGZyb21PZmZzZXQsIHRvT2Zmc2V0KTtcbiAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjb250ZW50KTtcblxuICAgICAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICAgIGRpdi5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBpMCA9IHNlbGVjdGVkTWF0Y2hJZHgsXG4gICAgICAgICAgaTEgPSBpMCArIDE7XG5cbiAgICAgIGlmIChoaWdobGlnaHRBbGwpIHtcbiAgICAgICAgaTAgPSAwO1xuICAgICAgICBpMSA9IG1hdGNoZXMubGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICghaXNTZWxlY3RlZFBhZ2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gaTA7IGkgPCBpMTsgaSsrKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IG1hdGNoZXNbaV07XG4gICAgICAgIHZhciBiZWdpbiA9IG1hdGNoLmJlZ2luO1xuICAgICAgICB2YXIgZW5kID0gbWF0Y2guZW5kO1xuICAgICAgICB2YXIgaXNTZWxlY3RlZCA9IGlzU2VsZWN0ZWRQYWdlICYmIGkgPT09IHNlbGVjdGVkTWF0Y2hJZHg7XG4gICAgICAgIHZhciBoaWdobGlnaHRTdWZmaXggPSBpc1NlbGVjdGVkID8gXCIgc2VsZWN0ZWRcIiA6IFwiXCI7XG5cbiAgICAgICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICBmaW5kQ29udHJvbGxlci5zY3JvbGxNYXRjaEludG9WaWV3KHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IHRleHREaXZzW2JlZ2luLmRpdklkeF0sXG4gICAgICAgICAgICBwYWdlSW5kZXg6IHBhZ2VJZHgsXG4gICAgICAgICAgICBtYXRjaEluZGV4OiBzZWxlY3RlZE1hdGNoSWR4XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXByZXZFbmQgfHwgYmVnaW4uZGl2SWR4ICE9PSBwcmV2RW5kLmRpdklkeCkge1xuICAgICAgICAgIGlmIChwcmV2RW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhcHBlbmRUZXh0VG9EaXYocHJldkVuZC5kaXZJZHgsIHByZXZFbmQub2Zmc2V0LCBpbmZpbml0eS5vZmZzZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJlZ2luVGV4dChiZWdpbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwZW5kVGV4dFRvRGl2KHByZXZFbmQuZGl2SWR4LCBwcmV2RW5kLm9mZnNldCwgYmVnaW4ub2Zmc2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiZWdpbi5kaXZJZHggPT09IGVuZC5kaXZJZHgpIHtcbiAgICAgICAgICBhcHBlbmRUZXh0VG9EaXYoYmVnaW4uZGl2SWR4LCBiZWdpbi5vZmZzZXQsIGVuZC5vZmZzZXQsIFwiaGlnaGxpZ2h0XCIgKyBoaWdobGlnaHRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGVuZFRleHRUb0RpdihiZWdpbi5kaXZJZHgsIGJlZ2luLm9mZnNldCwgaW5maW5pdHkub2Zmc2V0LCBcImhpZ2hsaWdodCBiZWdpblwiICsgaGlnaGxpZ2h0U3VmZml4KTtcblxuICAgICAgICAgIGZvciAodmFyIG4wID0gYmVnaW4uZGl2SWR4ICsgMSwgbjEgPSBlbmQuZGl2SWR4OyBuMCA8IG4xOyBuMCsrKSB7XG4gICAgICAgICAgICB0ZXh0RGl2c1tuMF0uY2xhc3NOYW1lID0gXCJoaWdobGlnaHQgbWlkZGxlXCIgKyBoaWdobGlnaHRTdWZmaXg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYmVnaW5UZXh0KGVuZCwgXCJoaWdobGlnaHQgZW5kXCIgKyBoaWdobGlnaHRTdWZmaXgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldkVuZCA9IGVuZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZFbmQpIHtcbiAgICAgICAgYXBwZW5kVGV4dFRvRGl2KHByZXZFbmQuZGl2SWR4LCBwcmV2RW5kLm9mZnNldCwgaW5maW5pdHkub2Zmc2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZU1hdGNoZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1hdGNoZXMoKSB7XG4gICAgICBpZiAoIXRoaXMucmVuZGVyaW5nRG9uZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5kQ29udHJvbGxlciA9IHRoaXMuZmluZENvbnRyb2xsZXIsXG4gICAgICAgICAgbWF0Y2hlcyA9IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICBwYWdlSWR4ID0gdGhpcy5wYWdlSWR4LFxuICAgICAgICAgIHRleHRDb250ZW50SXRlbXNTdHIgPSB0aGlzLnRleHRDb250ZW50SXRlbXNTdHIsXG4gICAgICAgICAgdGV4dERpdnMgPSB0aGlzLnRleHREaXZzO1xuICAgICAgdmFyIGNsZWFyZWRVbnRpbERpdklkeCA9IC0xO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBtYXRjaGVzLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgdmFyIG1hdGNoID0gbWF0Y2hlc1tpXTtcbiAgICAgICAgdmFyIGJlZ2luID0gTWF0aC5tYXgoY2xlYXJlZFVudGlsRGl2SWR4LCBtYXRjaC5iZWdpbi5kaXZJZHgpO1xuXG4gICAgICAgIGZvciAodmFyIG4gPSBiZWdpbiwgZW5kID0gbWF0Y2guZW5kLmRpdklkeDsgbiA8PSBlbmQ7IG4rKykge1xuICAgICAgICAgIHZhciBkaXYgPSB0ZXh0RGl2c1tuXTtcbiAgICAgICAgICBkaXYudGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudEl0ZW1zU3RyW25dO1xuICAgICAgICAgIGRpdi5jbGFzc05hbWUgPSBcIlwiO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xlYXJlZFVudGlsRGl2SWR4ID0gbWF0Y2guZW5kLmRpdklkeCArIDE7XG4gICAgICB9XG5cbiAgICAgIGlmICghZmluZENvbnRyb2xsZXIgfHwgIWZpbmRDb250cm9sbGVyLmhpZ2hsaWdodE1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFnZU1hdGNoZXMgPSBmaW5kQ29udHJvbGxlci5wYWdlTWF0Y2hlc1twYWdlSWR4XSB8fCBudWxsO1xuICAgICAgdmFyIHBhZ2VNYXRjaGVzTGVuZ3RoID0gZmluZENvbnRyb2xsZXIucGFnZU1hdGNoZXNMZW5ndGhbcGFnZUlkeF0gfHwgbnVsbDtcbiAgICAgIHRoaXMubWF0Y2hlcyA9IHRoaXMuX2NvbnZlcnRNYXRjaGVzKHBhZ2VNYXRjaGVzLCBwYWdlTWF0Y2hlc0xlbmd0aCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlck1hdGNoZXModGhpcy5tYXRjaGVzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRNb3VzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYmluZE1vdXNlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBkaXYgPSB0aGlzLnRleHRMYXllckRpdjtcbiAgICAgIHZhciBleHBhbmREaXZzVGltZXIgPSBudWxsO1xuICAgICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBpZiAoX3RoaXMyLmVuaGFuY2VUZXh0U2VsZWN0aW9uICYmIF90aGlzMi50ZXh0TGF5ZXJSZW5kZXJUYXNrKSB7XG4gICAgICAgICAgX3RoaXMyLnRleHRMYXllclJlbmRlclRhc2suZXhwYW5kVGV4dERpdnModHJ1ZSk7XG5cbiAgICAgICAgICBpZiAoZXhwYW5kRGl2c1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZXhwYW5kRGl2c1RpbWVyKTtcbiAgICAgICAgICAgIGV4cGFuZERpdnNUaW1lciA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuZCA9IGRpdi5xdWVyeVNlbGVjdG9yKFwiLmVuZE9mQ29udGVudFwiKTtcblxuICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhZGp1c3RUb3AgPSBldnQudGFyZ2V0ICE9PSBkaXY7XG4gICAgICAgIGFkanVzdFRvcCA9IGFkanVzdFRvcCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbmQpLmdldFByb3BlcnR5VmFsdWUoXCItbW96LXVzZXItc2VsZWN0XCIpICE9PSBcIm5vbmVcIjtcblxuICAgICAgICBpZiAoYWRqdXN0VG9wKSB7XG4gICAgICAgICAgdmFyIGRpdkJvdW5kcyA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICB2YXIgciA9IE1hdGgubWF4KDAsIChldnQucGFnZVkgLSBkaXZCb3VuZHMudG9wKSAvIGRpdkJvdW5kcy5oZWlnaHQpO1xuICAgICAgICAgIGVuZC5zdHlsZS50b3AgPSAociAqIDEwMCkudG9GaXhlZCgyKSArIFwiJVwiO1xuICAgICAgICB9XG5cbiAgICAgICAgZW5kLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICB9KTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIuZW5oYW5jZVRleHRTZWxlY3Rpb24gJiYgX3RoaXMyLnRleHRMYXllclJlbmRlclRhc2spIHtcbiAgICAgICAgICBleHBhbmREaXZzVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczIudGV4dExheWVyUmVuZGVyVGFzaykge1xuICAgICAgICAgICAgICBfdGhpczIudGV4dExheWVyUmVuZGVyVGFzay5leHBhbmRUZXh0RGl2cyhmYWxzZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4cGFuZERpdnNUaW1lciA9IG51bGw7XG4gICAgICAgICAgfSwgRVhQQU5EX0RJVlNfVElNRU9VVCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGVuZCA9IGRpdi5xdWVyeVNlbGVjdG9yKFwiLmVuZE9mQ29udGVudFwiKTtcblxuICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGVuZC5zdHlsZS50b3AgPSBcIlwiO1xuICAgICAgICBlbmQuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBUZXh0TGF5ZXJCdWlsZGVyO1xufSgpO1xuXG5leHBvcnRzLlRleHRMYXllckJ1aWxkZXIgPSBUZXh0TGF5ZXJCdWlsZGVyO1xuXG52YXIgRGVmYXVsdFRleHRMYXllckZhY3RvcnkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBEZWZhdWx0VGV4dExheWVyRmFjdG9yeSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRGVmYXVsdFRleHRMYXllckZhY3RvcnkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERlZmF1bHRUZXh0TGF5ZXJGYWN0b3J5LCBbe1xuICAgIGtleTogXCJjcmVhdGVUZXh0TGF5ZXJCdWlsZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVRleHRMYXllckJ1aWxkZXIodGV4dExheWVyRGl2LCBwYWdlSW5kZXgsIHZpZXdwb3J0KSB7XG4gICAgICB2YXIgZW5oYW5jZVRleHRTZWxlY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgICAgdmFyIGV2ZW50QnVzID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gbmV3IFRleHRMYXllckJ1aWxkZXIoe1xuICAgICAgICB0ZXh0TGF5ZXJEaXY6IHRleHRMYXllckRpdixcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgICAgZW5oYW5jZVRleHRTZWxlY3Rpb246IGVuaGFuY2VUZXh0U2VsZWN0aW9uLFxuICAgICAgICBldmVudEJ1czogZXZlbnRCdXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBEZWZhdWx0VGV4dExheWVyRmFjdG9yeTtcbn0oKTtcblxuZXhwb3J0cy5EZWZhdWx0VGV4dExheWVyRmFjdG9yeSA9IERlZmF1bHRUZXh0TGF5ZXJGYWN0b3J5O1xuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuRG93bmxvYWRNYW5hZ2VyID0gdm9pZCAwO1xuXG52YXIgX3BkZmpzTGliID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxudmFyIF92aWV3ZXJfY29tcGF0aWJpbGl0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbjtcblxuZnVuY3Rpb24gX2Rvd25sb2FkKGJsb2JVcmwsIGZpbGVuYW1lKSB7XG4gIHZhciBhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG5cbiAgaWYgKCFhLmNsaWNrKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEb3dubG9hZE1hbmFnZXI6IFwiYS5jbGljaygpXCIgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgfVxuXG4gIGEuaHJlZiA9IGJsb2JVcmw7XG4gIGEudGFyZ2V0ID0gXCJfcGFyZW50XCI7XG5cbiAgaWYgKFwiZG93bmxvYWRcIiBpbiBhKSB7XG4gICAgYS5kb3dubG9hZCA9IGZpbGVuYW1lO1xuICB9XG5cbiAgKGRvY3VtZW50LmJvZHkgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChhKTtcbiAgYS5jbGljaygpO1xuICBhLnJlbW92ZSgpO1xufVxuXG52YXIgRG93bmxvYWRNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRG93bmxvYWRNYW5hZ2VyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEb3dubG9hZE1hbmFnZXIpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKERvd25sb2FkTWFuYWdlciwgW3tcbiAgICBrZXk6IFwiZG93bmxvYWRVcmxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bmxvYWRVcmwodXJsLCBmaWxlbmFtZSkge1xuICAgICAgaWYgKCEoMCwgX3BkZmpzTGliLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwpKHVybCwgXCJodHRwOi8vZXhhbXBsZS5jb21cIikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfZG93bmxvYWQodXJsICsgXCIjcGRmanMuYWN0aW9uPWRvd25sb2FkXCIsIGZpbGVuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG93bmxvYWREYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRvd25sb2FkRGF0YShkYXRhLCBmaWxlbmFtZSwgY29udGVudFR5cGUpIHtcbiAgICAgIGlmIChuYXZpZ2F0b3IubXNTYXZlQmxvYikge1xuICAgICAgICBuYXZpZ2F0b3IubXNTYXZlQmxvYihuZXcgQmxvYihbZGF0YV0sIHtcbiAgICAgICAgICB0eXBlOiBjb250ZW50VHlwZVxuICAgICAgICB9KSwgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBibG9iVXJsID0gKDAsIF9wZGZqc0xpYi5jcmVhdGVPYmplY3RVUkwpKGRhdGEsIGNvbnRlbnRUeXBlLCBfdmlld2VyX2NvbXBhdGliaWxpdHkudmlld2VyQ29tcGF0aWJpbGl0eVBhcmFtcy5kaXNhYmxlQ3JlYXRlT2JqZWN0VVJMKTtcblxuICAgICAgX2Rvd25sb2FkKGJsb2JVcmwsIGZpbGVuYW1lKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZG93bmxvYWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZG93bmxvYWQoYmxvYiwgdXJsLCBmaWxlbmFtZSkge1xuICAgICAgdmFyIHNvdXJjZUV2ZW50VHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogXCJkb3dubG9hZFwiO1xuXG4gICAgICBpZiAobmF2aWdhdG9yLm1zU2F2ZUJsb2IpIHtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IubXNTYXZlQmxvYihibG9iLCBmaWxlbmFtZSkpIHtcbiAgICAgICAgICB0aGlzLmRvd25sb2FkVXJsKHVybCwgZmlsZW5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3ZpZXdlcl9jb21wYXRpYmlsaXR5LnZpZXdlckNvbXBhdGliaWxpdHlQYXJhbXMuZGlzYWJsZUNyZWF0ZU9iamVjdFVSTCkge1xuICAgICAgICB0aGlzLmRvd25sb2FkVXJsKHVybCwgZmlsZW5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBibG9iVXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuICAgICAgX2Rvd25sb2FkKGJsb2JVcmwsIGZpbGVuYW1lKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gRG93bmxvYWRNYW5hZ2VyO1xufSgpO1xuXG5leHBvcnRzLkRvd25sb2FkTWFuYWdlciA9IERvd25sb2FkTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy52aWV3ZXJDb21wYXRpYmlsaXR5UGFyYW1zID0gdm9pZCAwO1xudmFyIGNvbXBhdGliaWxpdHlQYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xue1xuICB2YXIgdXNlckFnZW50ID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3IudXNlckFnZW50IHx8IFwiXCI7XG4gIHZhciBwbGF0Zm9ybSA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLnBsYXRmb3JtIHx8IFwiXCI7XG4gIHZhciBtYXhUb3VjaFBvaW50cyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzIHx8IDE7XG4gIHZhciBpc0FuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50Ly50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBpc0lPUyA9IC9cXGIoaVBhZHxpUGhvbmV8aVBvZCkoPz07KS8udGVzdCh1c2VyQWdlbnQpIHx8IHBsYXRmb3JtID09PSBcIk1hY0ludGVsXCIgJiYgbWF4VG91Y2hQb2ludHMgPiAxO1xuICB2YXIgaXNJT1NDaHJvbWUgPSAvQ3JpT1MvLnRlc3QodXNlckFnZW50KTtcblxuICAoZnVuY3Rpb24gY2hlY2tPbkJsb2JTdXBwb3J0KCkge1xuICAgIGlmIChpc0lFIHx8IGlzSU9TQ2hyb21lKSB7XG4gICAgICBjb21wYXRpYmlsaXR5UGFyYW1zLmRpc2FibGVDcmVhdGVPYmplY3RVUkwgPSB0cnVlO1xuICAgIH1cbiAgfSkoKTtcblxuICAoZnVuY3Rpb24gY2hlY2tDYW52YXNTaXplTGltaXRhdGlvbigpIHtcbiAgICBpZiAoaXNJT1MgfHwgaXNBbmRyb2lkKSB7XG4gICAgICBjb21wYXRpYmlsaXR5UGFyYW1zLm1heENhbnZhc1BpeGVscyA9IDUyNDI4ODA7XG4gICAgfVxuICB9KSgpO1xufVxudmFyIHZpZXdlckNvbXBhdGliaWxpdHlQYXJhbXMgPSBPYmplY3QuZnJlZXplKGNvbXBhdGliaWxpdHlQYXJhbXMpO1xuZXhwb3J0cy52aWV3ZXJDb21wYXRpYmlsaXR5UGFyYW1zID0gdmlld2VyQ29tcGF0aWJpbGl0eVBhcmFtcztcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5HZW5lcmljTDEwbiA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193X3BkZmpzX3JlcXVpcmVfXyg0KSk7XG5cbl9fd19wZGZqc19yZXF1aXJlX18oMTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBcImRlZmF1bHRcIjogb2JqIH07IH1cblxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykgeyB0cnkgeyB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7IHZhciB2YWx1ZSA9IGluZm8udmFsdWU7IH0gY2F0Y2ggKGVycm9yKSB7IHJlamVjdChlcnJvcik7IHJldHVybjsgfSBpZiAoaW5mby5kb25lKSB7IHJlc29sdmUodmFsdWUpOyB9IGVsc2UgeyBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7IH0gfVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgc2VsZiA9IHRoaXMsIGFyZ3MgPSBhcmd1bWVudHM7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTsgZnVuY3Rpb24gX25leHQodmFsdWUpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpOyB9IGZ1bmN0aW9uIF90aHJvdyhlcnIpIHsgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7IH0gX25leHQodW5kZWZpbmVkKTsgfSk7IH07IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgd2ViTDEwbiA9IGRvY3VtZW50LndlYkwxMG47XG5cbnZhciBHZW5lcmljTDEwbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEdlbmVyaWNMMTBuKGxhbmcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgR2VuZXJpY0wxMG4pO1xuXG4gICAgdGhpcy5fbGFuZyA9IGxhbmc7XG4gICAgdGhpcy5fcmVhZHkgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB3ZWJMMTBuLnNldExhbmd1YWdlKGxhbmcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzb2x2ZSh3ZWJMMTBuKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdlbmVyaWNMMTBuLCBbe1xuICAgIGtleTogXCJnZXRMYW5ndWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldExhbmd1YWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIGwxMG47XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZSQoX2NvbnRleHQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBsMTBuID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGwxMG4uZ2V0TGFuZ3VhZ2UoKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBnZXRMYW5ndWFnZSgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRMYW5ndWFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0TGFuZ3VhZ2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGlyZWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0RGlyZWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHZhciBsMTBuO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyJChfY29udGV4dDIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5O1xuXG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBsMTBuID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgbDEwbi5nZXREaXJlY3Rpb24oKSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMiwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIGdldERpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9nZXREaXJlY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGdldERpcmVjdGlvbjtcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhwcm9wZXJ0eSwgYXJncywgZmFsbGJhY2spIHtcbiAgICAgICAgdmFyIGwxMG47XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMkKF9jb250ZXh0Mykge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGwxMG4gPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCBsMTBuLmdldChwcm9wZXJ0eSwgYXJncywgZmFsbGJhY2spKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gZ2V0KF94LCBfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZ2V0O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcInRyYW5zbGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RyYW5zbGF0ZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGwxMG47XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQkKF9jb250ZXh0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0NC5wcmV2ID0gX2NvbnRleHQ0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHk7XG5cbiAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGwxMG4gPSBfY29udGV4dDQuc2VudDtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCBsMTBuLnRyYW5zbGF0ZShlbGVtZW50KSk7XG5cbiAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNCwgdGhpcyk7XG4gICAgICB9KSk7XG5cbiAgICAgIGZ1bmN0aW9uIHRyYW5zbGF0ZShfeDQpIHtcbiAgICAgICAgcmV0dXJuIF90cmFuc2xhdGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRyYW5zbGF0ZTtcbiAgICB9KClcbiAgfV0pO1xuXG4gIHJldHVybiBHZW5lcmljTDEwbjtcbn0oKTtcblxuZXhwb3J0cy5HZW5lcmljTDEwbiA9IEdlbmVyaWNMMTBuO1xuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmRvY3VtZW50LndlYkwxMG4gPSBmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG4gIHZhciBnTDEwbkRhdGEgPSB7fTtcbiAgdmFyIGdUZXh0RGF0YSA9ICcnO1xuICB2YXIgZ1RleHRQcm9wID0gJ3RleHRDb250ZW50JztcbiAgdmFyIGdMYW5ndWFnZSA9ICcnO1xuICB2YXIgZ01hY3JvcyA9IHt9O1xuICB2YXIgZ1JlYWR5U3RhdGUgPSAnbG9hZGluZyc7XG4gIHZhciBnQXN5bmNSZXNvdXJjZUxvYWRpbmcgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIGdldEwxMG5SZXNvdXJjZUxpbmtzKCkge1xuICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW3R5cGU9XCJhcHBsaWNhdGlvbi9sMTBuXCJdJyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMMTBuRGljdGlvbmFyeSgpIHtcbiAgICB2YXIgc2NyaXB0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3R5cGU9XCJhcHBsaWNhdGlvbi9sMTBuXCJdJyk7XG4gICAgcmV0dXJuIHNjcmlwdCA/IEpTT04ucGFyc2Uoc2NyaXB0LmlubmVySFRNTCkgOiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VHJhbnNsYXRhYmxlQ2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50ID8gZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcqW2RhdGEtbDEwbi1pZF0nKSA6IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TDEwbkF0dHJpYnV0ZXMoZWxlbWVudCkge1xuICAgIGlmICghZWxlbWVudCkgcmV0dXJuIHt9O1xuICAgIHZhciBsMTBuSWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1sMTBuLWlkJyk7XG4gICAgdmFyIGwxMG5BcmdzID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtbDEwbi1hcmdzJyk7XG4gICAgdmFyIGFyZ3MgPSB7fTtcblxuICAgIGlmIChsMTBuQXJncykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXJncyA9IEpTT04ucGFyc2UobDEwbkFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2NvdWxkIG5vdCBwYXJzZSBhcmd1bWVudHMgZm9yICMnICsgbDEwbklkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IGwxMG5JZCxcbiAgICAgIGFyZ3M6IGFyZ3NcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24geGhyTG9hZFRleHQodXJsLCBvblN1Y2Nlc3MsIG9uRmFpbHVyZSkge1xuICAgIG9uU3VjY2VzcyA9IG9uU3VjY2VzcyB8fCBmdW5jdGlvbiBfb25TdWNjZXNzKGRhdGEpIHt9O1xuXG4gICAgb25GYWlsdXJlID0gb25GYWlsdXJlIHx8IGZ1bmN0aW9uIF9vbkZhaWx1cmUoKSB7fTtcblxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbignR0VUJywgdXJsLCBnQXN5bmNSZXNvdXJjZUxvYWRpbmcpO1xuXG4gICAgaWYgKHhoci5vdmVycmlkZU1pbWVUeXBlKSB7XG4gICAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOCcpO1xuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDAgfHwgeGhyLnN0YXR1cyA9PT0gMCkge1xuICAgICAgICAgIG9uU3VjY2Vzcyh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbkZhaWx1cmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB4aHIub25lcnJvciA9IG9uRmFpbHVyZTtcbiAgICB4aHIub250aW1lb3V0ID0gb25GYWlsdXJlO1xuXG4gICAgdHJ5IHtcbiAgICAgIHhoci5zZW5kKG51bGwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIG9uRmFpbHVyZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlUmVzb3VyY2UoaHJlZiwgbGFuZywgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICB2YXIgYmFzZVVSTCA9IGhyZWYucmVwbGFjZSgvW15cXC9dKiQvLCAnJykgfHwgJy4vJztcblxuICAgIGZ1bmN0aW9uIGV2YWxTdHJpbmcodGV4dCkge1xuICAgICAgaWYgKHRleHQubGFzdEluZGV4T2YoJ1xcXFwnKSA8IDApIHJldHVybiB0ZXh0O1xuICAgICAgcmV0dXJuIHRleHQucmVwbGFjZSgvXFxcXFxcXFwvZywgJ1xcXFwnKS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJykucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpLnJlcGxhY2UoL1xcXFx0L2csICdcXHQnKS5yZXBsYWNlKC9cXFxcYi9nLCAnXFxiJykucmVwbGFjZSgvXFxcXGYvZywgJ1xcZicpLnJlcGxhY2UoL1xcXFx7L2csICd7JykucmVwbGFjZSgvXFxcXH0vZywgJ30nKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykucmVwbGFjZSgvXFxcXCcvZywgXCInXCIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlUHJvcGVydGllcyh0ZXh0LCBwYXJzZWRQcm9wZXJ0aWVzQ2FsbGJhY2spIHtcbiAgICAgIHZhciBkaWN0aW9uYXJ5ID0ge307XG4gICAgICB2YXIgcmVCbGFuayA9IC9eXFxzKnxcXHMqJC87XG4gICAgICB2YXIgcmVDb21tZW50ID0gL15cXHMqI3xeXFxzKiQvO1xuICAgICAgdmFyIHJlU2VjdGlvbiA9IC9eXFxzKlxcWyguKilcXF1cXHMqJC87XG4gICAgICB2YXIgcmVJbXBvcnQgPSAvXlxccypAaW1wb3J0XFxzK3VybFxcKCguKilcXClcXHMqJC9pO1xuICAgICAgdmFyIHJlU3BsaXQgPSAvXihbXj1cXHNdKilcXHMqPVxccyooLispJC87XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlUmF3TGluZXMocmF3VGV4dCwgZXh0ZW5kZWRTeW50YXgsIHBhcnNlZFJhd0xpbmVzQ2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGVudHJpZXMgPSByYXdUZXh0LnJlcGxhY2UocmVCbGFuaywgJycpLnNwbGl0KC9bXFxyXFxuXSsvKTtcbiAgICAgICAgdmFyIGN1cnJlbnRMYW5nID0gJyonO1xuICAgICAgICB2YXIgZ2VuZXJpY0xhbmcgPSBsYW5nLnNwbGl0KCctJywgMSlbMF07XG4gICAgICAgIHZhciBza2lwTGFuZyA9IGZhbHNlO1xuICAgICAgICB2YXIgbWF0Y2ggPSAnJztcblxuICAgICAgICBmdW5jdGlvbiBuZXh0RW50cnkoKSB7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGlmICghZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcGFyc2VkUmF3TGluZXNDYWxsYmFjaygpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBsaW5lID0gZW50cmllcy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKHJlQ29tbWVudC50ZXN0KGxpbmUpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgaWYgKGV4dGVuZGVkU3ludGF4KSB7XG4gICAgICAgICAgICAgIG1hdGNoID0gcmVTZWN0aW9uLmV4ZWMobGluZSk7XG5cbiAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExhbmcgPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHNraXBMYW5nID0gY3VycmVudExhbmcgIT09ICcqJyAmJiBjdXJyZW50TGFuZyAhPT0gbGFuZyAmJiBjdXJyZW50TGFuZyAhPT0gZ2VuZXJpY0xhbmc7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2tpcExhbmcpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG1hdGNoID0gcmVJbXBvcnQuZXhlYyhsaW5lKTtcblxuICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsb2FkSW1wb3J0KGJhc2VVUkwgKyBtYXRjaFsxXSwgbmV4dEVudHJ5KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRtcCA9IGxpbmUubWF0Y2gocmVTcGxpdCk7XG5cbiAgICAgICAgICAgIGlmICh0bXAgJiYgdG1wLmxlbmd0aCA9PSAzKSB7XG4gICAgICAgICAgICAgIGRpY3Rpb25hcnlbdG1wWzFdXSA9IGV2YWxTdHJpbmcodG1wWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0RW50cnkoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gbG9hZEltcG9ydCh1cmwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHhockxvYWRUZXh0KHVybCwgZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICBwYXJzZVJhd0xpbmVzKGNvbnRlbnQsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4odXJsICsgJyBub3QgZm91bmQuJyk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHBhcnNlUmF3TGluZXModGV4dCwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBwYXJzZWRQcm9wZXJ0aWVzQ2FsbGJhY2soZGljdGlvbmFyeSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB4aHJMb2FkVGV4dChocmVmLCBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgIGdUZXh0RGF0YSArPSByZXNwb25zZTtcbiAgICAgIHBhcnNlUHJvcGVydGllcyhyZXNwb25zZSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICB2YXIgaWQsXG4gICAgICAgICAgICAgIHByb3AsXG4gICAgICAgICAgICAgIGluZGV4ID0ga2V5Lmxhc3RJbmRleE9mKCcuJyk7XG5cbiAgICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBpZCA9IGtleS5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgcHJvcCA9IGtleS5zdWJzdHJpbmcoaW5kZXggKyAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWQgPSBrZXk7XG4gICAgICAgICAgICBwcm9wID0gZ1RleHRQcm9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghZ0wxMG5EYXRhW2lkXSkge1xuICAgICAgICAgICAgZ0wxMG5EYXRhW2lkXSA9IHt9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGdMMTBuRGF0YVtpZF1bcHJvcF0gPSBkYXRhW2tleV07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3VjY2Vzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgc3VjY2Vzc0NhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGZhaWx1cmVDYWxsYmFjayk7XG4gIH1cblxuICBmdW5jdGlvbiBsb2FkTG9jYWxlKGxhbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGxhbmcpIHtcbiAgICAgIGxhbmcgPSBsYW5nLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayB8fCBmdW5jdGlvbiBfY2FsbGJhY2soKSB7fTtcblxuICAgIGNsZWFyKCk7XG4gICAgZ0xhbmd1YWdlID0gbGFuZztcbiAgICB2YXIgbGFuZ0xpbmtzID0gZ2V0TDEwblJlc291cmNlTGlua3MoKTtcbiAgICB2YXIgbGFuZ0NvdW50ID0gbGFuZ0xpbmtzLmxlbmd0aDtcblxuICAgIGlmIChsYW5nQ291bnQgPT09IDApIHtcbiAgICAgIHZhciBkaWN0ID0gZ2V0TDEwbkRpY3Rpb25hcnkoKTtcblxuICAgICAgaWYgKGRpY3QgJiYgZGljdC5sb2NhbGVzICYmIGRpY3QuZGVmYXVsdF9sb2NhbGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3VzaW5nIHRoZSBlbWJlZGRlZCBKU09OIGRpcmVjdG9yeSwgZWFybHkgd2F5IG91dCcpO1xuICAgICAgICBnTDEwbkRhdGEgPSBkaWN0LmxvY2FsZXNbbGFuZ107XG5cbiAgICAgICAgaWYgKCFnTDEwbkRhdGEpIHtcbiAgICAgICAgICB2YXIgZGVmYXVsdExvY2FsZSA9IGRpY3QuZGVmYXVsdF9sb2NhbGUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgIGZvciAodmFyIGFueUNhc2VMYW5nIGluIGRpY3QubG9jYWxlcykge1xuICAgICAgICAgICAgYW55Q2FzZUxhbmcgPSBhbnlDYXNlTGFuZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgICAgICBpZiAoYW55Q2FzZUxhbmcgPT09IGxhbmcpIHtcbiAgICAgICAgICAgICAgZ0wxMG5EYXRhID0gZGljdC5sb2NhbGVzW2xhbmddO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYW55Q2FzZUxhbmcgPT09IGRlZmF1bHRMb2NhbGUpIHtcbiAgICAgICAgICAgICAgZ0wxMG5EYXRhID0gZGljdC5sb2NhbGVzW2RlZmF1bHRMb2NhbGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnbm8gcmVzb3VyY2UgdG8gbG9hZCwgZWFybHkgd2F5IG91dCcpO1xuICAgICAgfVxuXG4gICAgICBnUmVhZHlTdGF0ZSA9ICdjb21wbGV0ZSc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG9uUmVzb3VyY2VMb2FkZWQgPSBudWxsO1xuICAgIHZhciBnUmVzb3VyY2VDb3VudCA9IDA7XG5cbiAgICBvblJlc291cmNlTG9hZGVkID0gZnVuY3Rpb24gb25SZXNvdXJjZUxvYWRlZCgpIHtcbiAgICAgIGdSZXNvdXJjZUNvdW50Kys7XG5cbiAgICAgIGlmIChnUmVzb3VyY2VDb3VudCA+PSBsYW5nQ291bnQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgZ1JlYWR5U3RhdGUgPSAnY29tcGxldGUnO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBMMTBuUmVzb3VyY2VMaW5rKGxpbmspIHtcbiAgICAgIHZhciBocmVmID0gbGluay5ocmVmO1xuXG4gICAgICB0aGlzLmxvYWQgPSBmdW5jdGlvbiAobGFuZywgY2FsbGJhY2spIHtcbiAgICAgICAgcGFyc2VSZXNvdXJjZShocmVmLCBsYW5nLCBjYWxsYmFjaywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihocmVmICsgJyBub3QgZm91bmQuJyk7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdcIicgKyBsYW5nICsgJ1wiIHJlc291cmNlIG5vdCBmb3VuZCcpO1xuICAgICAgICAgIGdMYW5ndWFnZSA9ICcnO1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhbmdDb3VudDsgaSsrKSB7XG4gICAgICB2YXIgcmVzb3VyY2UgPSBuZXcgTDEwblJlc291cmNlTGluayhsYW5nTGlua3NbaV0pO1xuICAgICAgcmVzb3VyY2UubG9hZChsYW5nLCBvblJlc291cmNlTG9hZGVkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBnTDEwbkRhdGEgPSB7fTtcbiAgICBnVGV4dERhdGEgPSAnJztcbiAgICBnTGFuZ3VhZ2UgPSAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFBsdXJhbFJ1bGVzKGxhbmcpIHtcbiAgICB2YXIgbG9jYWxlczJydWxlcyA9IHtcbiAgICAgICdhZic6IDMsXG4gICAgICAnYWsnOiA0LFxuICAgICAgJ2FtJzogNCxcbiAgICAgICdhcic6IDEsXG4gICAgICAnYXNhJzogMyxcbiAgICAgICdheic6IDAsXG4gICAgICAnYmUnOiAxMSxcbiAgICAgICdiZW0nOiAzLFxuICAgICAgJ2Jleic6IDMsXG4gICAgICAnYmcnOiAzLFxuICAgICAgJ2JoJzogNCxcbiAgICAgICdibSc6IDAsXG4gICAgICAnYm4nOiAzLFxuICAgICAgJ2JvJzogMCxcbiAgICAgICdicic6IDIwLFxuICAgICAgJ2JyeCc6IDMsXG4gICAgICAnYnMnOiAxMSxcbiAgICAgICdjYSc6IDMsXG4gICAgICAnY2dnJzogMyxcbiAgICAgICdjaHInOiAzLFxuICAgICAgJ2NzJzogMTIsXG4gICAgICAnY3knOiAxNyxcbiAgICAgICdkYSc6IDMsXG4gICAgICAnZGUnOiAzLFxuICAgICAgJ2R2JzogMyxcbiAgICAgICdkeic6IDAsXG4gICAgICAnZWUnOiAzLFxuICAgICAgJ2VsJzogMyxcbiAgICAgICdlbic6IDMsXG4gICAgICAnZW8nOiAzLFxuICAgICAgJ2VzJzogMyxcbiAgICAgICdldCc6IDMsXG4gICAgICAnZXUnOiAzLFxuICAgICAgJ2ZhJzogMCxcbiAgICAgICdmZic6IDUsXG4gICAgICAnZmknOiAzLFxuICAgICAgJ2ZpbCc6IDQsXG4gICAgICAnZm8nOiAzLFxuICAgICAgJ2ZyJzogNSxcbiAgICAgICdmdXInOiAzLFxuICAgICAgJ2Z5JzogMyxcbiAgICAgICdnYSc6IDgsXG4gICAgICAnZ2QnOiAyNCxcbiAgICAgICdnbCc6IDMsXG4gICAgICAnZ3N3JzogMyxcbiAgICAgICdndSc6IDMsXG4gICAgICAnZ3V3JzogNCxcbiAgICAgICdndic6IDIzLFxuICAgICAgJ2hhJzogMyxcbiAgICAgICdoYXcnOiAzLFxuICAgICAgJ2hlJzogMixcbiAgICAgICdoaSc6IDQsXG4gICAgICAnaHInOiAxMSxcbiAgICAgICdodSc6IDAsXG4gICAgICAnaWQnOiAwLFxuICAgICAgJ2lnJzogMCxcbiAgICAgICdpaSc6IDAsXG4gICAgICAnaXMnOiAzLFxuICAgICAgJ2l0JzogMyxcbiAgICAgICdpdSc6IDcsXG4gICAgICAnamEnOiAwLFxuICAgICAgJ2ptYyc6IDMsXG4gICAgICAnanYnOiAwLFxuICAgICAgJ2thJzogMCxcbiAgICAgICdrYWInOiA1LFxuICAgICAgJ2thaic6IDMsXG4gICAgICAna2NnJzogMyxcbiAgICAgICdrZGUnOiAwLFxuICAgICAgJ2tlYSc6IDAsXG4gICAgICAna2snOiAzLFxuICAgICAgJ2tsJzogMyxcbiAgICAgICdrbSc6IDAsXG4gICAgICAna24nOiAwLFxuICAgICAgJ2tvJzogMCxcbiAgICAgICdrc2InOiAzLFxuICAgICAgJ2tzaCc6IDIxLFxuICAgICAgJ2t1JzogMyxcbiAgICAgICdrdyc6IDcsXG4gICAgICAnbGFnJzogMTgsXG4gICAgICAnbGInOiAzLFxuICAgICAgJ2xnJzogMyxcbiAgICAgICdsbic6IDQsXG4gICAgICAnbG8nOiAwLFxuICAgICAgJ2x0JzogMTAsXG4gICAgICAnbHYnOiA2LFxuICAgICAgJ21hcyc6IDMsXG4gICAgICAnbWcnOiA0LFxuICAgICAgJ21rJzogMTYsXG4gICAgICAnbWwnOiAzLFxuICAgICAgJ21uJzogMyxcbiAgICAgICdtbyc6IDksXG4gICAgICAnbXInOiAzLFxuICAgICAgJ21zJzogMCxcbiAgICAgICdtdCc6IDE1LFxuICAgICAgJ215JzogMCxcbiAgICAgICduYWgnOiAzLFxuICAgICAgJ25hcSc6IDcsXG4gICAgICAnbmInOiAzLFxuICAgICAgJ25kJzogMyxcbiAgICAgICduZSc6IDMsXG4gICAgICAnbmwnOiAzLFxuICAgICAgJ25uJzogMyxcbiAgICAgICdubyc6IDMsXG4gICAgICAnbnInOiAzLFxuICAgICAgJ25zbyc6IDQsXG4gICAgICAnbnknOiAzLFxuICAgICAgJ255bic6IDMsXG4gICAgICAnb20nOiAzLFxuICAgICAgJ29yJzogMyxcbiAgICAgICdwYSc6IDMsXG4gICAgICAncGFwJzogMyxcbiAgICAgICdwbCc6IDEzLFxuICAgICAgJ3BzJzogMyxcbiAgICAgICdwdCc6IDMsXG4gICAgICAncm0nOiAzLFxuICAgICAgJ3JvJzogOSxcbiAgICAgICdyb2YnOiAzLFxuICAgICAgJ3J1JzogMTEsXG4gICAgICAncndrJzogMyxcbiAgICAgICdzYWgnOiAwLFxuICAgICAgJ3NhcSc6IDMsXG4gICAgICAnc2UnOiA3LFxuICAgICAgJ3NlaCc6IDMsXG4gICAgICAnc2VzJzogMCxcbiAgICAgICdzZyc6IDAsXG4gICAgICAnc2gnOiAxMSxcbiAgICAgICdzaGknOiAxOSxcbiAgICAgICdzayc6IDEyLFxuICAgICAgJ3NsJzogMTQsXG4gICAgICAnc21hJzogNyxcbiAgICAgICdzbWknOiA3LFxuICAgICAgJ3Ntaic6IDcsXG4gICAgICAnc21uJzogNyxcbiAgICAgICdzbXMnOiA3LFxuICAgICAgJ3NuJzogMyxcbiAgICAgICdzbyc6IDMsXG4gICAgICAnc3EnOiAzLFxuICAgICAgJ3NyJzogMTEsXG4gICAgICAnc3MnOiAzLFxuICAgICAgJ3NzeSc6IDMsXG4gICAgICAnc3QnOiAzLFxuICAgICAgJ3N2JzogMyxcbiAgICAgICdzdyc6IDMsXG4gICAgICAnc3lyJzogMyxcbiAgICAgICd0YSc6IDMsXG4gICAgICAndGUnOiAzLFxuICAgICAgJ3Rlbyc6IDMsXG4gICAgICAndGgnOiAwLFxuICAgICAgJ3RpJzogNCxcbiAgICAgICd0aWcnOiAzLFxuICAgICAgJ3RrJzogMyxcbiAgICAgICd0bCc6IDQsXG4gICAgICAndG4nOiAzLFxuICAgICAgJ3RvJzogMCxcbiAgICAgICd0cic6IDAsXG4gICAgICAndHMnOiAzLFxuICAgICAgJ3R6bSc6IDIyLFxuICAgICAgJ3VrJzogMTEsXG4gICAgICAndXInOiAzLFxuICAgICAgJ3ZlJzogMyxcbiAgICAgICd2aSc6IDAsXG4gICAgICAndnVuJzogMyxcbiAgICAgICd3YSc6IDQsXG4gICAgICAnd2FlJzogMyxcbiAgICAgICd3byc6IDAsXG4gICAgICAneGgnOiAzLFxuICAgICAgJ3hvZyc6IDMsXG4gICAgICAneW8nOiAwLFxuICAgICAgJ3poJzogMCxcbiAgICAgICd6dSc6IDNcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNJbihuLCBsaXN0KSB7XG4gICAgICByZXR1cm4gbGlzdC5pbmRleE9mKG4pICE9PSAtMTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JldHdlZW4obiwgc3RhcnQsIGVuZCkge1xuICAgICAgcmV0dXJuIHN0YXJ0IDw9IG4gJiYgbiA8PSBlbmQ7XG4gICAgfVxuXG4gICAgdmFyIHBsdXJhbFJ1bGVzID0ge1xuICAgICAgJzAnOiBmdW5jdGlvbiBfKG4pIHtcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9LFxuICAgICAgJzEnOiBmdW5jdGlvbiBfKG4pIHtcbiAgICAgICAgaWYgKGlzQmV0d2VlbihuICUgMTAwLCAzLCAxMCkpIHJldHVybiAnZmV3JztcbiAgICAgICAgaWYgKG4gPT09IDApIHJldHVybiAnemVybyc7XG4gICAgICAgIGlmIChpc0JldHdlZW4obiAlIDEwMCwgMTEsIDk5KSkgcmV0dXJuICdtYW55JztcbiAgICAgICAgaWYgKG4gPT0gMikgcmV0dXJuICd0d28nO1xuICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcyJzogZnVuY3Rpb24gXyhuKSB7XG4gICAgICAgIGlmIChuICE9PSAwICYmIG4gJSAxMCA9PT0gMCkgcmV0dXJuICdtYW55JztcbiAgICAgICAgaWYgKG4gPT0gMikgcmV0dXJuICd0d28nO1xuICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICczJzogZnVuY3Rpb24gXyhuKSB7XG4gICAgICAgIGlmIChuID09IDEpIHJldHVybiAnb25lJztcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9LFxuICAgICAgJzQnOiBmdW5jdGlvbiBfKG4pIHtcbiAgICAgICAgaWYgKGlzQmV0d2VlbihuLCAwLCAxKSkgcmV0dXJuICdvbmUnO1xuICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICAgIH0sXG4gICAgICAnNSc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4sIDAsIDIpICYmIG4gIT0gMikgcmV0dXJuICdvbmUnO1xuICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICAgIH0sXG4gICAgICAnNic6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuICd6ZXJvJztcbiAgICAgICAgaWYgKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEpIHJldHVybiAnb25lJztcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9LFxuICAgICAgJzcnOiBmdW5jdGlvbiBfKG4pIHtcbiAgICAgICAgaWYgKG4gPT0gMikgcmV0dXJuICd0d28nO1xuICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICc4JzogZnVuY3Rpb24gXyhuKSB7XG4gICAgICAgIGlmIChpc0JldHdlZW4obiwgMywgNikpIHJldHVybiAnZmV3JztcbiAgICAgICAgaWYgKGlzQmV0d2VlbihuLCA3LCAxMCkpIHJldHVybiAnbWFueSc7XG4gICAgICAgIGlmIChuID09IDIpIHJldHVybiAndHdvJztcbiAgICAgICAgaWYgKG4gPT0gMSkgcmV0dXJuICdvbmUnO1xuICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICAgIH0sXG4gICAgICAnOSc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAobiA9PT0gMCB8fCBuICE9IDEgJiYgaXNCZXR3ZWVuKG4gJSAxMDAsIDEsIDE5KSkgcmV0dXJuICdmZXcnO1xuICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcxMCc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4gJSAxMCwgMiwgOSkgJiYgIWlzQmV0d2VlbihuICUgMTAwLCAxMSwgMTkpKSByZXR1cm4gJ2Zldyc7XG4gICAgICAgIGlmIChuICUgMTAgPT0gMSAmJiAhaXNCZXR3ZWVuKG4gJSAxMDAsIDExLCAxOSkpIHJldHVybiAnb25lJztcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9LFxuICAgICAgJzExJzogZnVuY3Rpb24gXyhuKSB7XG4gICAgICAgIGlmIChpc0JldHdlZW4obiAlIDEwLCAyLCA0KSAmJiAhaXNCZXR3ZWVuKG4gJSAxMDAsIDEyLCAxNCkpIHJldHVybiAnZmV3JztcbiAgICAgICAgaWYgKG4gJSAxMCA9PT0gMCB8fCBpc0JldHdlZW4obiAlIDEwLCA1LCA5KSB8fCBpc0JldHdlZW4obiAlIDEwMCwgMTEsIDE0KSkgcmV0dXJuICdtYW55JztcbiAgICAgICAgaWYgKG4gJSAxMCA9PSAxICYmIG4gJSAxMDAgIT0gMTEpIHJldHVybiAnb25lJztcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9LFxuICAgICAgJzEyJzogZnVuY3Rpb24gXyhuKSB7XG4gICAgICAgIGlmIChpc0JldHdlZW4obiwgMiwgNCkpIHJldHVybiAnZmV3JztcbiAgICAgICAgaWYgKG4gPT0gMSkgcmV0dXJuICdvbmUnO1xuICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICAgIH0sXG4gICAgICAnMTMnOiBmdW5jdGlvbiBfKG4pIHtcbiAgICAgICAgaWYgKGlzQmV0d2VlbihuICUgMTAsIDIsIDQpICYmICFpc0JldHdlZW4obiAlIDEwMCwgMTIsIDE0KSkgcmV0dXJuICdmZXcnO1xuICAgICAgICBpZiAobiAhPSAxICYmIGlzQmV0d2VlbihuICUgMTAsIDAsIDEpIHx8IGlzQmV0d2VlbihuICUgMTAsIDUsIDkpIHx8IGlzQmV0d2VlbihuICUgMTAwLCAxMiwgMTQpKSByZXR1cm4gJ21hbnknO1xuICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcxNCc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4gJSAxMDAsIDMsIDQpKSByZXR1cm4gJ2Zldyc7XG4gICAgICAgIGlmIChuICUgMTAwID09IDIpIHJldHVybiAndHdvJztcbiAgICAgICAgaWYgKG4gJSAxMDAgPT0gMSkgcmV0dXJuICdvbmUnO1xuICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICAgIH0sXG4gICAgICAnMTUnOiBmdW5jdGlvbiBfKG4pIHtcbiAgICAgICAgaWYgKG4gPT09IDAgfHwgaXNCZXR3ZWVuKG4gJSAxMDAsIDIsIDEwKSkgcmV0dXJuICdmZXcnO1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4gJSAxMDAsIDExLCAxOSkpIHJldHVybiAnbWFueSc7XG4gICAgICAgIGlmIChuID09IDEpIHJldHVybiAnb25lJztcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9LFxuICAgICAgJzE2JzogZnVuY3Rpb24gXyhuKSB7XG4gICAgICAgIGlmIChuICUgMTAgPT0gMSAmJiBuICE9IDExKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcxNyc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAobiA9PSAzKSByZXR1cm4gJ2Zldyc7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gJ3plcm8nO1xuICAgICAgICBpZiAobiA9PSA2KSByZXR1cm4gJ21hbnknO1xuICAgICAgICBpZiAobiA9PSAyKSByZXR1cm4gJ3R3byc7XG4gICAgICAgIGlmIChuID09IDEpIHJldHVybiAnb25lJztcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9LFxuICAgICAgJzE4JzogZnVuY3Rpb24gXyhuKSB7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gJ3plcm8nO1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4sIDAsIDIpICYmIG4gIT09IDAgJiYgbiAhPSAyKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcxOSc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4sIDIsIDEwKSkgcmV0dXJuICdmZXcnO1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4sIDAsIDEpKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcyMCc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAoKGlzQmV0d2VlbihuICUgMTAsIDMsIDQpIHx8IG4gJSAxMCA9PSA5KSAmJiAhKGlzQmV0d2VlbihuICUgMTAwLCAxMCwgMTkpIHx8IGlzQmV0d2VlbihuICUgMTAwLCA3MCwgNzkpIHx8IGlzQmV0d2VlbihuICUgMTAwLCA5MCwgOTkpKSkgcmV0dXJuICdmZXcnO1xuICAgICAgICBpZiAobiAlIDEwMDAwMDAgPT09IDAgJiYgbiAhPT0gMCkgcmV0dXJuICdtYW55JztcbiAgICAgICAgaWYgKG4gJSAxMCA9PSAyICYmICFpc0luKG4gJSAxMDAsIFsxMiwgNzIsIDkyXSkpIHJldHVybiAndHdvJztcbiAgICAgICAgaWYgKG4gJSAxMCA9PSAxICYmICFpc0luKG4gJSAxMDAsIFsxMSwgNzEsIDkxXSkpIHJldHVybiAnb25lJztcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9LFxuICAgICAgJzIxJzogZnVuY3Rpb24gXyhuKSB7XG4gICAgICAgIGlmIChuID09PSAwKSByZXR1cm4gJ3plcm8nO1xuICAgICAgICBpZiAobiA9PSAxKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcyMic6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4sIDAsIDEpIHx8IGlzQmV0d2VlbihuLCAxMSwgOTkpKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcyMyc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4gJSAxMCwgMSwgMikgfHwgbiAlIDIwID09PSAwKSByZXR1cm4gJ29uZSc7XG4gICAgICAgIHJldHVybiAnb3RoZXInO1xuICAgICAgfSxcbiAgICAgICcyNCc6IGZ1bmN0aW9uIF8obikge1xuICAgICAgICBpZiAoaXNCZXR3ZWVuKG4sIDMsIDEwKSB8fCBpc0JldHdlZW4obiwgMTMsIDE5KSkgcmV0dXJuICdmZXcnO1xuICAgICAgICBpZiAoaXNJbihuLCBbMiwgMTJdKSkgcmV0dXJuICd0d28nO1xuICAgICAgICBpZiAoaXNJbihuLCBbMSwgMTFdKSkgcmV0dXJuICdvbmUnO1xuICAgICAgICByZXR1cm4gJ290aGVyJztcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBpbmRleCA9IGxvY2FsZXMycnVsZXNbbGFuZy5yZXBsYWNlKC8tLiokLywgJycpXTtcblxuICAgIGlmICghKGluZGV4IGluIHBsdXJhbFJ1bGVzKSkge1xuICAgICAgY29uc29sZS53YXJuKCdwbHVyYWwgZm9ybSB1bmtub3duIGZvciBbJyArIGxhbmcgKyAnXScpO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdvdGhlcic7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBwbHVyYWxSdWxlc1tpbmRleF07XG4gIH1cblxuICBnTWFjcm9zLnBsdXJhbCA9IGZ1bmN0aW9uIChzdHIsIHBhcmFtLCBrZXksIHByb3ApIHtcbiAgICB2YXIgbiA9IHBhcnNlRmxvYXQocGFyYW0pO1xuICAgIGlmIChpc05hTihuKSkgcmV0dXJuIHN0cjtcbiAgICBpZiAocHJvcCAhPSBnVGV4dFByb3ApIHJldHVybiBzdHI7XG5cbiAgICBpZiAoIWdNYWNyb3MuX3BsdXJhbFJ1bGVzKSB7XG4gICAgICBnTWFjcm9zLl9wbHVyYWxSdWxlcyA9IGdldFBsdXJhbFJ1bGVzKGdMYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gJ1snICsgZ01hY3Jvcy5fcGx1cmFsUnVsZXMobikgKyAnXSc7XG5cbiAgICBpZiAobiA9PT0gMCAmJiBrZXkgKyAnW3plcm9dJyBpbiBnTDEwbkRhdGEpIHtcbiAgICAgIHN0ciA9IGdMMTBuRGF0YVtrZXkgKyAnW3plcm9dJ11bcHJvcF07XG4gICAgfSBlbHNlIGlmIChuID09IDEgJiYga2V5ICsgJ1tvbmVdJyBpbiBnTDEwbkRhdGEpIHtcbiAgICAgIHN0ciA9IGdMMTBuRGF0YVtrZXkgKyAnW29uZV0nXVtwcm9wXTtcbiAgICB9IGVsc2UgaWYgKG4gPT0gMiAmJiBrZXkgKyAnW3R3b10nIGluIGdMMTBuRGF0YSkge1xuICAgICAgc3RyID0gZ0wxMG5EYXRhW2tleSArICdbdHdvXSddW3Byb3BdO1xuICAgIH0gZWxzZSBpZiAoa2V5ICsgaW5kZXggaW4gZ0wxMG5EYXRhKSB7XG4gICAgICBzdHIgPSBnTDEwbkRhdGFba2V5ICsgaW5kZXhdW3Byb3BdO1xuICAgIH0gZWxzZSBpZiAoa2V5ICsgJ1tvdGhlcl0nIGluIGdMMTBuRGF0YSkge1xuICAgICAgc3RyID0gZ0wxMG5EYXRhW2tleSArICdbb3RoZXJdJ11bcHJvcF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cjtcbiAgfTtcblxuICBmdW5jdGlvbiBnZXRMMTBuRGF0YShrZXksIGFyZ3MsIGZhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSBnTDEwbkRhdGFba2V5XTtcblxuICAgIGlmICghZGF0YSkge1xuICAgICAgY29uc29sZS53YXJuKCcjJyArIGtleSArICcgaXMgdW5kZWZpbmVkLicpO1xuXG4gICAgICBpZiAoIWZhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBkYXRhID0gZmFsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHJ2ID0ge307XG5cbiAgICBmb3IgKHZhciBwcm9wIGluIGRhdGEpIHtcbiAgICAgIHZhciBzdHIgPSBkYXRhW3Byb3BdO1xuICAgICAgc3RyID0gc3Vic3RJbmRleGVzKHN0ciwgYXJncywga2V5LCBwcm9wKTtcbiAgICAgIHN0ciA9IHN1YnN0QXJndW1lbnRzKHN0ciwgYXJncywga2V5KTtcbiAgICAgIHJ2W3Byb3BdID0gc3RyO1xuICAgIH1cblxuICAgIHJldHVybiBydjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHN1YnN0SW5kZXhlcyhzdHIsIGFyZ3MsIGtleSwgcHJvcCkge1xuICAgIHZhciByZUluZGV4ID0gL1xce1xcW1xccyooW2EtekEtWl0rKVxcKChbYS16QS1aXSspXFwpXFxzKlxcXVxcfS87XG4gICAgdmFyIHJlTWF0Y2ggPSByZUluZGV4LmV4ZWMoc3RyKTtcbiAgICBpZiAoIXJlTWF0Y2ggfHwgIXJlTWF0Y2gubGVuZ3RoKSByZXR1cm4gc3RyO1xuICAgIHZhciBtYWNyb05hbWUgPSByZU1hdGNoWzFdO1xuICAgIHZhciBwYXJhbU5hbWUgPSByZU1hdGNoWzJdO1xuICAgIHZhciBwYXJhbTtcblxuICAgIGlmIChhcmdzICYmIHBhcmFtTmFtZSBpbiBhcmdzKSB7XG4gICAgICBwYXJhbSA9IGFyZ3NbcGFyYW1OYW1lXTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSBpbiBnTDEwbkRhdGEpIHtcbiAgICAgIHBhcmFtID0gZ0wxMG5EYXRhW3BhcmFtTmFtZV07XG4gICAgfVxuXG4gICAgaWYgKG1hY3JvTmFtZSBpbiBnTWFjcm9zKSB7XG4gICAgICB2YXIgbWFjcm8gPSBnTWFjcm9zW21hY3JvTmFtZV07XG4gICAgICBzdHIgPSBtYWNybyhzdHIsIHBhcmFtLCBrZXksIHByb3ApO1xuICAgIH1cblxuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICBmdW5jdGlvbiBzdWJzdEFyZ3VtZW50cyhzdHIsIGFyZ3MsIGtleSkge1xuICAgIHZhciByZUFyZ3MgPSAvXFx7XFx7XFxzKiguKz8pXFxzKlxcfVxcfS9nO1xuICAgIHJldHVybiBzdHIucmVwbGFjZShyZUFyZ3MsIGZ1bmN0aW9uIChtYXRjaGVkX3RleHQsIGFyZykge1xuICAgICAgaWYgKGFyZ3MgJiYgYXJnIGluIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnXTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFyZyBpbiBnTDEwbkRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGdMMTBuRGF0YVthcmddO1xuICAgICAgfVxuXG4gICAgICBjb25zb2xlLmxvZygnYXJndW1lbnQge3snICsgYXJnICsgJ319IGZvciAjJyArIGtleSArICcgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgcmV0dXJuIG1hdGNoZWRfdGV4dDtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHZhciBsMTBuID0gZ2V0TDEwbkF0dHJpYnV0ZXMoZWxlbWVudCk7XG4gICAgaWYgKCFsMTBuLmlkKSByZXR1cm47XG4gICAgdmFyIGRhdGEgPSBnZXRMMTBuRGF0YShsMTBuLmlkLCBsMTBuLmFyZ3MpO1xuXG4gICAgaWYgKCFkYXRhKSB7XG4gICAgICBjb25zb2xlLndhcm4oJyMnICsgbDEwbi5pZCArICcgaXMgdW5kZWZpbmVkLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChkYXRhW2dUZXh0UHJvcF0pIHtcbiAgICAgIGlmIChnZXRDaGlsZEVsZW1lbnRDb3VudChlbGVtZW50KSA9PT0gMCkge1xuICAgICAgICBlbGVtZW50W2dUZXh0UHJvcF0gPSBkYXRhW2dUZXh0UHJvcF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLm5vZGVUeXBlID09PSAzICYmIC9cXFMvLnRlc3QoY2hpbGRyZW5baV0ubm9kZVZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgIGNoaWxkcmVuW2ldLm5vZGVWYWx1ZSA9ICcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW5baV0ubm9kZVZhbHVlID0gZGF0YVtnVGV4dFByb3BdO1xuICAgICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmb3VuZCkge1xuICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGFbZ1RleHRQcm9wXSk7XG4gICAgICAgICAgZWxlbWVudC5pbnNlcnRCZWZvcmUodGV4dE5vZGUsIGVsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZGVsZXRlIGRhdGFbZ1RleHRQcm9wXTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrIGluIGRhdGEpIHtcbiAgICAgIGVsZW1lbnRba10gPSBkYXRhW2tdO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENoaWxkRWxlbWVudENvdW50KGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5jaGlsZEVsZW1lbnRDb3VudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50LmNoaWxkRWxlbWVudENvdW50O1xuICAgIH1cblxuICAgIHZhciBjb3VudCA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVsZW1lbnQuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY291bnQgKz0gZWxlbWVudC5ub2RlVHlwZSA9PT0gMSA/IDEgOiAwO1xuICAgIH1cblxuICAgIHJldHVybiBjb3VudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHRyYW5zbGF0ZUZyYWdtZW50KGVsZW1lbnQpIHtcbiAgICBlbGVtZW50ID0gZWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgdmFyIGNoaWxkcmVuID0gZ2V0VHJhbnNsYXRhYmxlQ2hpbGRyZW4oZWxlbWVudCk7XG4gICAgdmFyIGVsZW1lbnRDb3VudCA9IGNoaWxkcmVuLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWxlbWVudENvdW50OyBpKyspIHtcbiAgICAgIHRyYW5zbGF0ZUVsZW1lbnQoY2hpbGRyZW5baV0pO1xuICAgIH1cblxuICAgIHRyYW5zbGF0ZUVsZW1lbnQoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSwgYXJncywgZmFsbGJhY2tTdHJpbmcpIHtcbiAgICAgIHZhciBpbmRleCA9IGtleS5sYXN0SW5kZXhPZignLicpO1xuICAgICAgdmFyIHByb3AgPSBnVGV4dFByb3A7XG5cbiAgICAgIGlmIChpbmRleCA+IDApIHtcbiAgICAgICAgcHJvcCA9IGtleS5zdWJzdHJpbmcoaW5kZXggKyAxKTtcbiAgICAgICAga2V5ID0ga2V5LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBmYWxsYmFjaztcblxuICAgICAgaWYgKGZhbGxiYWNrU3RyaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrID0ge307XG4gICAgICAgIGZhbGxiYWNrW3Byb3BdID0gZmFsbGJhY2tTdHJpbmc7XG4gICAgICB9XG5cbiAgICAgIHZhciBkYXRhID0gZ2V0TDEwbkRhdGEoa2V5LCBhcmdzLCBmYWxsYmFjayk7XG5cbiAgICAgIGlmIChkYXRhICYmIHByb3AgaW4gZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YVtwcm9wXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICd7eycgKyBrZXkgKyAnfX0nO1xuICAgIH0sXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24gZ2V0RGF0YSgpIHtcbiAgICAgIHJldHVybiBnTDEwbkRhdGE7XG4gICAgfSxcbiAgICBnZXRUZXh0OiBmdW5jdGlvbiBnZXRUZXh0KCkge1xuICAgICAgcmV0dXJuIGdUZXh0RGF0YTtcbiAgICB9LFxuICAgIGdldExhbmd1YWdlOiBmdW5jdGlvbiBnZXRMYW5ndWFnZSgpIHtcbiAgICAgIHJldHVybiBnTGFuZ3VhZ2U7XG4gICAgfSxcbiAgICBzZXRMYW5ndWFnZTogZnVuY3Rpb24gc2V0TGFuZ3VhZ2UobGFuZywgY2FsbGJhY2spIHtcbiAgICAgIGxvYWRMb2NhbGUobGFuZywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGdldERpcmVjdGlvbjogZnVuY3Rpb24gZ2V0RGlyZWN0aW9uKCkge1xuICAgICAgdmFyIHJ0bExpc3QgPSBbJ2FyJywgJ2hlJywgJ2ZhJywgJ3BzJywgJ3VyJ107XG4gICAgICB2YXIgc2hvcnRDb2RlID0gZ0xhbmd1YWdlLnNwbGl0KCctJywgMSlbMF07XG4gICAgICByZXR1cm4gcnRsTGlzdC5pbmRleE9mKHNob3J0Q29kZSkgPj0gMCA/ICdydGwnIDogJ2x0cic7XG4gICAgfSxcbiAgICB0cmFuc2xhdGU6IHRyYW5zbGF0ZUZyYWdtZW50LFxuICAgIGdldFJlYWR5U3RhdGU6IGZ1bmN0aW9uIGdldFJlYWR5U3RhdGUoKSB7XG4gICAgICByZXR1cm4gZ1JlYWR5U3RhdGU7XG4gICAgfSxcbiAgICByZWFkeTogZnVuY3Rpb24gcmVhZHkoY2FsbGJhY2spIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChnUmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnIHx8IGdSZWFkeVN0YXRlID09ICdpbnRlcmFjdGl2ZScpIHtcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvY2FsaXplZCcsIGZ1bmN0aW9uIG9uY2UoKSB7XG4gICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9jYWxpemVkJywgb25jZSk7XG4gICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufSh3aW5kb3csIGRvY3VtZW50KTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QREZGaW5kQ29udHJvbGxlciA9IGV4cG9ydHMuRmluZFN0YXRlID0gdm9pZCAwO1xuXG52YXIgX3BkZmpzTGliID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxudmFyIF9wZGZfZmluZF91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xuXG52YXIgX3VpX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgRmluZFN0YXRlID0ge1xuICBGT1VORDogMCxcbiAgTk9UX0ZPVU5EOiAxLFxuICBXUkFQUEVEOiAyLFxuICBQRU5ESU5HOiAzXG59O1xuZXhwb3J0cy5GaW5kU3RhdGUgPSBGaW5kU3RhdGU7XG52YXIgRklORF9USU1FT1VUID0gMjUwO1xudmFyIE1BVENIX1NDUk9MTF9PRkZTRVRfVE9QID0gLTUwO1xudmFyIE1BVENIX1NDUk9MTF9PRkZTRVRfTEVGVCA9IC00MDA7XG52YXIgQ0hBUkFDVEVSU19UT19OT1JNQUxJWkUgPSB7XG4gIFwiXFx1MjAxOFwiOiBcIidcIixcbiAgXCJcXHUyMDE5XCI6IFwiJ1wiLFxuICBcIlxcdTIwMUFcIjogXCInXCIsXG4gIFwiXFx1MjAxQlwiOiBcIidcIixcbiAgXCJcXHUyMDFDXCI6ICdcIicsXG4gIFwiXFx1MjAxRFwiOiAnXCInLFxuICBcIlxcdTIwMUVcIjogJ1wiJyxcbiAgXCJcXHUyMDFGXCI6ICdcIicsXG4gIFwiXFx4QkNcIjogXCIxLzRcIixcbiAgXCJcXHhCRFwiOiBcIjEvMlwiLFxuICBcIlxceEJFXCI6IFwiMy80XCJcbn07XG52YXIgbm9ybWFsaXphdGlvblJlZ2V4ID0gbnVsbDtcblxuZnVuY3Rpb24gbm9ybWFsaXplKHRleHQpIHtcbiAgaWYgKCFub3JtYWxpemF0aW9uUmVnZXgpIHtcbiAgICB2YXIgcmVwbGFjZSA9IE9iamVjdC5rZXlzKENIQVJBQ1RFUlNfVE9fTk9STUFMSVpFKS5qb2luKFwiXCIpO1xuICAgIG5vcm1hbGl6YXRpb25SZWdleCA9IG5ldyBSZWdFeHAoXCJbXCIuY29uY2F0KHJlcGxhY2UsIFwiXVwiKSwgXCJnXCIpO1xuICB9XG5cbiAgcmV0dXJuIHRleHQucmVwbGFjZShub3JtYWxpemF0aW9uUmVnZXgsIGZ1bmN0aW9uIChjaCkge1xuICAgIHJldHVybiBDSEFSQUNURVJTX1RPX05PUk1BTElaRVtjaF07XG4gIH0pO1xufVxuXG52YXIgUERGRmluZENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZGaW5kQ29udHJvbGxlcihfcmVmKSB7XG4gICAgdmFyIGxpbmtTZXJ2aWNlID0gX3JlZi5saW5rU2VydmljZSxcbiAgICAgICAgZXZlbnRCdXMgPSBfcmVmLmV2ZW50QnVzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERkZpbmRDb250cm9sbGVyKTtcblxuICAgIHRoaXMuX2xpbmtTZXJ2aWNlID0gbGlua1NlcnZpY2U7XG4gICAgdGhpcy5fZXZlbnRCdXMgPSBldmVudEJ1cztcblxuICAgIHRoaXMuX3Jlc2V0KCk7XG5cbiAgICBldmVudEJ1cy5fb24oXCJmaW5kYmFyY2xvc2VcIiwgdGhpcy5fb25GaW5kQmFyQ2xvc2UuYmluZCh0aGlzKSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGRmluZENvbnRyb2xsZXIsIFt7XG4gICAga2V5OiBcInNldERvY3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERvY3VtZW50KHBkZkRvY3VtZW50KSB7XG4gICAgICBpZiAodGhpcy5fcGRmRG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwZGZEb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BkZkRvY3VtZW50ID0gcGRmRG9jdW1lbnQ7XG5cbiAgICAgIHRoaXMuX2ZpcnN0UGFnZUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJleGVjdXRlQ29tbWFuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleGVjdXRlQ29tbWFuZChjbWQsIHN0YXRlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBkZkRvY3VtZW50ID0gdGhpcy5fcGRmRG9jdW1lbnQ7XG5cbiAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gbnVsbCB8fCB0aGlzLl9zaG91bGREaXJ0eU1hdGNoKGNtZCwgc3RhdGUpKSB7XG4gICAgICAgIHRoaXMuX2RpcnR5TWF0Y2ggPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICBpZiAoY21kICE9PSBcImZpbmRoaWdobGlnaHRhbGxjaGFuZ2VcIikge1xuICAgICAgICB0aGlzLl91cGRhdGVVSVN0YXRlKEZpbmRTdGF0ZS5QRU5ESU5HKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZmlyc3RQYWdlQ2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIV90aGlzLl9wZGZEb2N1bWVudCB8fCBwZGZEb2N1bWVudCAmJiBfdGhpcy5fcGRmRG9jdW1lbnQgIT09IHBkZkRvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMuX2V4dHJhY3RUZXh0KCk7XG5cbiAgICAgICAgdmFyIGZpbmRiYXJDbG9zZWQgPSAhX3RoaXMuX2hpZ2hsaWdodE1hdGNoZXM7XG4gICAgICAgIHZhciBwZW5kaW5nVGltZW91dCA9ICEhX3RoaXMuX2ZpbmRUaW1lb3V0O1xuXG4gICAgICAgIGlmIChfdGhpcy5fZmluZFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMuX2ZpbmRUaW1lb3V0KTtcbiAgICAgICAgICBfdGhpcy5fZmluZFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNtZCA9PT0gXCJmaW5kXCIpIHtcbiAgICAgICAgICBfdGhpcy5fZmluZFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLl9uZXh0TWF0Y2goKTtcblxuICAgICAgICAgICAgX3RoaXMuX2ZpbmRUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB9LCBGSU5EX1RJTUVPVVQpO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLl9kaXJ0eU1hdGNoKSB7XG4gICAgICAgICAgX3RoaXMuX25leHRNYXRjaCgpO1xuICAgICAgICB9IGVsc2UgaWYgKGNtZCA9PT0gXCJmaW5kYWdhaW5cIikge1xuICAgICAgICAgIF90aGlzLl9uZXh0TWF0Y2goKTtcblxuICAgICAgICAgIGlmIChmaW5kYmFyQ2xvc2VkICYmIF90aGlzLl9zdGF0ZS5oaWdobGlnaHRBbGwpIHtcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVBbGxQYWdlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChjbWQgPT09IFwiZmluZGhpZ2hsaWdodGFsbGNoYW5nZVwiKSB7XG4gICAgICAgICAgaWYgKHBlbmRpbmdUaW1lb3V0KSB7XG4gICAgICAgICAgICBfdGhpcy5fbmV4dE1hdGNoKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLl9oaWdobGlnaHRNYXRjaGVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpcy5fdXBkYXRlQWxsUGFnZXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5fbmV4dE1hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JvbGxNYXRjaEludG9WaWV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjcm9sbE1hdGNoSW50b1ZpZXcoX3JlZjIpIHtcbiAgICAgIHZhciBfcmVmMiRlbGVtZW50ID0gX3JlZjIuZWxlbWVudCxcbiAgICAgICAgICBlbGVtZW50ID0gX3JlZjIkZWxlbWVudCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYyJGVsZW1lbnQsXG4gICAgICAgICAgX3JlZjIkcGFnZUluZGV4ID0gX3JlZjIucGFnZUluZGV4LFxuICAgICAgICAgIHBhZ2VJbmRleCA9IF9yZWYyJHBhZ2VJbmRleCA9PT0gdm9pZCAwID8gLTEgOiBfcmVmMiRwYWdlSW5kZXgsXG4gICAgICAgICAgX3JlZjIkbWF0Y2hJbmRleCA9IF9yZWYyLm1hdGNoSW5kZXgsXG4gICAgICAgICAgbWF0Y2hJbmRleCA9IF9yZWYyJG1hdGNoSW5kZXggPT09IHZvaWQgMCA/IC0xIDogX3JlZjIkbWF0Y2hJbmRleDtcblxuICAgICAgaWYgKCF0aGlzLl9zY3JvbGxNYXRjaGVzIHx8ICFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobWF0Y2hJbmRleCA9PT0gLTEgfHwgbWF0Y2hJbmRleCAhPT0gdGhpcy5fc2VsZWN0ZWQubWF0Y2hJZHgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChwYWdlSW5kZXggPT09IC0xIHx8IHBhZ2VJbmRleCAhPT0gdGhpcy5fc2VsZWN0ZWQucGFnZUlkeCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Njcm9sbE1hdGNoZXMgPSBmYWxzZTtcbiAgICAgIHZhciBzcG90ID0ge1xuICAgICAgICB0b3A6IE1BVENIX1NDUk9MTF9PRkZTRVRfVE9QLFxuICAgICAgICBsZWZ0OiBNQVRDSF9TQ1JPTExfT0ZGU0VUX0xFRlRcbiAgICAgIH07XG4gICAgICAoMCwgX3VpX3V0aWxzLnNjcm9sbEludG9WaWV3KShlbGVtZW50LCBzcG90LCB0cnVlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldCgpIHtcbiAgICAgIHRoaXMuX2hpZ2hsaWdodE1hdGNoZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Njcm9sbE1hdGNoZXMgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3BkZkRvY3VtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMuX3BhZ2VNYXRjaGVzID0gW107XG4gICAgICB0aGlzLl9wYWdlTWF0Y2hlc0xlbmd0aCA9IFtdO1xuICAgICAgdGhpcy5fc3RhdGUgPSBudWxsO1xuICAgICAgdGhpcy5fc2VsZWN0ZWQgPSB7XG4gICAgICAgIHBhZ2VJZHg6IC0xLFxuICAgICAgICBtYXRjaElkeDogLTFcbiAgICAgIH07XG4gICAgICB0aGlzLl9vZmZzZXQgPSB7XG4gICAgICAgIHBhZ2VJZHg6IG51bGwsXG4gICAgICAgIG1hdGNoSWR4OiBudWxsLFxuICAgICAgICB3cmFwcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2V4dHJhY3RUZXh0UHJvbWlzZXMgPSBbXTtcbiAgICAgIHRoaXMuX3BhZ2VDb250ZW50cyA9IFtdO1xuICAgICAgdGhpcy5fbWF0Y2hlc0NvdW50VG90YWwgPSAwO1xuICAgICAgdGhpcy5fcGFnZXNUb1NlYXJjaCA9IG51bGw7XG4gICAgICB0aGlzLl9wZW5kaW5nRmluZE1hdGNoZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fcmVzdW1lUGFnZUlkeCA9IG51bGw7XG4gICAgICB0aGlzLl9kaXJ0eU1hdGNoID0gZmFsc2U7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fZmluZFRpbWVvdXQpO1xuICAgICAgdGhpcy5fZmluZFRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fZmlyc3RQYWdlQ2FwYWJpbGl0eSA9ICgwLCBfcGRmanNMaWIuY3JlYXRlUHJvbWlzZUNhcGFiaWxpdHkpKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zaG91bGREaXJ0eU1hdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zaG91bGREaXJ0eU1hdGNoKGNtZCwgc3RhdGUpIHtcbiAgICAgIGlmIChzdGF0ZS5xdWVyeSAhPT0gdGhpcy5fc3RhdGUucXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAoY21kKSB7XG4gICAgICAgIGNhc2UgXCJmaW5kYWdhaW5cIjpcbiAgICAgICAgICB2YXIgcGFnZU51bWJlciA9IHRoaXMuX3NlbGVjdGVkLnBhZ2VJZHggKyAxO1xuICAgICAgICAgIHZhciBsaW5rU2VydmljZSA9IHRoaXMuX2xpbmtTZXJ2aWNlO1xuXG4gICAgICAgICAgaWYgKHBhZ2VOdW1iZXIgPj0gMSAmJiBwYWdlTnVtYmVyIDw9IGxpbmtTZXJ2aWNlLnBhZ2VzQ291bnQgJiYgcGFnZU51bWJlciAhPT0gbGlua1NlcnZpY2UucGFnZSAmJiAhbGlua1NlcnZpY2UuaXNQYWdlVmlzaWJsZShwYWdlTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNhc2UgXCJmaW5kaGlnaGxpZ2h0YWxsY2hhbmdlXCI6XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ByZXBhcmVNYXRjaGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlTWF0Y2hlcyhtYXRjaGVzV2l0aExlbmd0aCwgbWF0Y2hlcywgbWF0Y2hlc0xlbmd0aCkge1xuICAgICAgZnVuY3Rpb24gaXNTdWJUZXJtKGN1cnJlbnRJbmRleCkge1xuICAgICAgICB2YXIgY3VycmVudEVsZW0gPSBtYXRjaGVzV2l0aExlbmd0aFtjdXJyZW50SW5kZXhdO1xuICAgICAgICB2YXIgbmV4dEVsZW0gPSBtYXRjaGVzV2l0aExlbmd0aFtjdXJyZW50SW5kZXggKyAxXTtcblxuICAgICAgICBpZiAoY3VycmVudEluZGV4IDwgbWF0Y2hlc1dpdGhMZW5ndGgubGVuZ3RoIC0gMSAmJiBjdXJyZW50RWxlbS5tYXRjaCA9PT0gbmV4dEVsZW0ubWF0Y2gpIHtcbiAgICAgICAgICBjdXJyZW50RWxlbS5za2lwcGVkID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSBjdXJyZW50SW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciBwcmV2RWxlbSA9IG1hdGNoZXNXaXRoTGVuZ3RoW2ldO1xuXG4gICAgICAgICAgaWYgKHByZXZFbGVtLnNraXBwZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmV2RWxlbS5tYXRjaCArIHByZXZFbGVtLm1hdGNoTGVuZ3RoIDwgY3VycmVudEVsZW0ubWF0Y2gpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwcmV2RWxlbS5tYXRjaCArIHByZXZFbGVtLm1hdGNoTGVuZ3RoID49IGN1cnJlbnRFbGVtLm1hdGNoICsgY3VycmVudEVsZW0ubWF0Y2hMZW5ndGgpIHtcbiAgICAgICAgICAgIGN1cnJlbnRFbGVtLnNraXBwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBtYXRjaGVzV2l0aExlbmd0aC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLm1hdGNoID09PSBiLm1hdGNoID8gYS5tYXRjaExlbmd0aCAtIGIubWF0Y2hMZW5ndGggOiBhLm1hdGNoIC0gYi5tYXRjaDtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWF0Y2hlc1dpdGhMZW5ndGgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGlzU3ViVGVybShpKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbWF0Y2hlcy5wdXNoKG1hdGNoZXNXaXRoTGVuZ3RoW2ldLm1hdGNoKTtcbiAgICAgICAgbWF0Y2hlc0xlbmd0aC5wdXNoKG1hdGNoZXNXaXRoTGVuZ3RoW2ldLm1hdGNoTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzRW50aXJlV29yZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNFbnRpcmVXb3JkKGNvbnRlbnQsIHN0YXJ0SWR4LCBsZW5ndGgpIHtcbiAgICAgIGlmIChzdGFydElkeCA+IDApIHtcbiAgICAgICAgdmFyIGZpcnN0ID0gY29udGVudC5jaGFyQ29kZUF0KHN0YXJ0SWR4KTtcbiAgICAgICAgdmFyIGxpbWl0ID0gY29udGVudC5jaGFyQ29kZUF0KHN0YXJ0SWR4IC0gMSk7XG5cbiAgICAgICAgaWYgKCgwLCBfcGRmX2ZpbmRfdXRpbHMuZ2V0Q2hhcmFjdGVyVHlwZSkoZmlyc3QpID09PSAoMCwgX3BkZl9maW5kX3V0aWxzLmdldENoYXJhY3RlclR5cGUpKGxpbWl0KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZW5kSWR4ID0gc3RhcnRJZHggKyBsZW5ndGggLSAxO1xuXG4gICAgICBpZiAoZW5kSWR4IDwgY29udGVudC5sZW5ndGggLSAxKSB7XG4gICAgICAgIHZhciBsYXN0ID0gY29udGVudC5jaGFyQ29kZUF0KGVuZElkeCk7XG5cbiAgICAgICAgdmFyIF9saW1pdCA9IGNvbnRlbnQuY2hhckNvZGVBdChlbmRJZHggKyAxKTtcblxuICAgICAgICBpZiAoKDAsIF9wZGZfZmluZF91dGlscy5nZXRDaGFyYWN0ZXJUeXBlKShsYXN0KSA9PT0gKDAsIF9wZGZfZmluZF91dGlscy5nZXRDaGFyYWN0ZXJUeXBlKShfbGltaXQpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlUGhyYXNlTWF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZVBocmFzZU1hdGNoKHF1ZXJ5LCBwYWdlSW5kZXgsIHBhZ2VDb250ZW50LCBlbnRpcmVXb3JkKSB7XG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgICAgdmFyIHF1ZXJ5TGVuID0gcXVlcnkubGVuZ3RoO1xuICAgICAgdmFyIG1hdGNoSWR4ID0gLXF1ZXJ5TGVuO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBtYXRjaElkeCA9IHBhZ2VDb250ZW50LmluZGV4T2YocXVlcnksIG1hdGNoSWR4ICsgcXVlcnlMZW4pO1xuXG4gICAgICAgIGlmIChtYXRjaElkeCA9PT0gLTEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbnRpcmVXb3JkICYmICF0aGlzLl9pc0VudGlyZVdvcmQocGFnZUNvbnRlbnQsIG1hdGNoSWR4LCBxdWVyeUxlbikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1hdGNoZXMucHVzaChtYXRjaElkeCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BhZ2VNYXRjaGVzW3BhZ2VJbmRleF0gPSBtYXRjaGVzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlV29yZE1hdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYWxjdWxhdGVXb3JkTWF0Y2gocXVlcnksIHBhZ2VJbmRleCwgcGFnZUNvbnRlbnQsIGVudGlyZVdvcmQpIHtcbiAgICAgIHZhciBtYXRjaGVzV2l0aExlbmd0aCA9IFtdO1xuICAgICAgdmFyIHF1ZXJ5QXJyYXkgPSBxdWVyeS5tYXRjaCgvXFxTKy9nKTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHF1ZXJ5QXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHN1YnF1ZXJ5ID0gcXVlcnlBcnJheVtpXTtcbiAgICAgICAgdmFyIHN1YnF1ZXJ5TGVuID0gc3VicXVlcnkubGVuZ3RoO1xuICAgICAgICB2YXIgbWF0Y2hJZHggPSAtc3VicXVlcnlMZW47XG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBtYXRjaElkeCA9IHBhZ2VDb250ZW50LmluZGV4T2Yoc3VicXVlcnksIG1hdGNoSWR4ICsgc3VicXVlcnlMZW4pO1xuXG4gICAgICAgICAgaWYgKG1hdGNoSWR4ID09PSAtMSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVudGlyZVdvcmQgJiYgIXRoaXMuX2lzRW50aXJlV29yZChwYWdlQ29udGVudCwgbWF0Y2hJZHgsIHN1YnF1ZXJ5TGVuKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbWF0Y2hlc1dpdGhMZW5ndGgucHVzaCh7XG4gICAgICAgICAgICBtYXRjaDogbWF0Y2hJZHgsXG4gICAgICAgICAgICBtYXRjaExlbmd0aDogc3VicXVlcnlMZW4sXG4gICAgICAgICAgICBza2lwcGVkOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3BhZ2VNYXRjaGVzTGVuZ3RoW3BhZ2VJbmRleF0gPSBbXTtcbiAgICAgIHRoaXMuX3BhZ2VNYXRjaGVzW3BhZ2VJbmRleF0gPSBbXTtcblxuICAgICAgdGhpcy5fcHJlcGFyZU1hdGNoZXMobWF0Y2hlc1dpdGhMZW5ndGgsIHRoaXMuX3BhZ2VNYXRjaGVzW3BhZ2VJbmRleF0sIHRoaXMuX3BhZ2VNYXRjaGVzTGVuZ3RoW3BhZ2VJbmRleF0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FsY3VsYXRlTWF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2NhbGN1bGF0ZU1hdGNoKHBhZ2VJbmRleCkge1xuICAgICAgdmFyIHBhZ2VDb250ZW50ID0gdGhpcy5fcGFnZUNvbnRlbnRzW3BhZ2VJbmRleF07XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeTtcbiAgICAgIHZhciBfdGhpcyRfc3RhdGUgPSB0aGlzLl9zdGF0ZSxcbiAgICAgICAgICBjYXNlU2Vuc2l0aXZlID0gX3RoaXMkX3N0YXRlLmNhc2VTZW5zaXRpdmUsXG4gICAgICAgICAgZW50aXJlV29yZCA9IF90aGlzJF9zdGF0ZS5lbnRpcmVXb3JkLFxuICAgICAgICAgIHBocmFzZVNlYXJjaCA9IF90aGlzJF9zdGF0ZS5waHJhc2VTZWFyY2g7XG5cbiAgICAgIGlmIChxdWVyeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICAgICAgcGFnZUNvbnRlbnQgPSBwYWdlQ29udGVudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LnRvTG93ZXJDYXNlKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwaHJhc2VTZWFyY2gpIHtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlUGhyYXNlTWF0Y2gocXVlcnksIHBhZ2VJbmRleCwgcGFnZUNvbnRlbnQsIGVudGlyZVdvcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fY2FsY3VsYXRlV29yZE1hdGNoKHF1ZXJ5LCBwYWdlSW5kZXgsIHBhZ2VDb250ZW50LCBlbnRpcmVXb3JkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRlLmhpZ2hsaWdodEFsbCkge1xuICAgICAgICB0aGlzLl91cGRhdGVQYWdlKHBhZ2VJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZXN1bWVQYWdlSWR4ID09PSBwYWdlSW5kZXgpIHtcbiAgICAgICAgdGhpcy5fcmVzdW1lUGFnZUlkeCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5fbmV4dFBhZ2VNYXRjaCgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFnZU1hdGNoZXNDb3VudCA9IHRoaXMuX3BhZ2VNYXRjaGVzW3BhZ2VJbmRleF0ubGVuZ3RoO1xuXG4gICAgICBpZiAocGFnZU1hdGNoZXNDb3VudCA+IDApIHtcbiAgICAgICAgdGhpcy5fbWF0Y2hlc0NvdW50VG90YWwgKz0gcGFnZU1hdGNoZXNDb3VudDtcblxuICAgICAgICB0aGlzLl91cGRhdGVVSVJlc3VsdHNDb3VudCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZXh0cmFjdFRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2V4dHJhY3RUZXh0KCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLl9leHRyYWN0VGV4dFByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChpLCBpaSkge1xuICAgICAgICB2YXIgZXh0cmFjdFRleHRDYXBhYmlsaXR5ID0gKDAsIF9wZGZqc0xpYi5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgICAgX3RoaXMyLl9leHRyYWN0VGV4dFByb21pc2VzW2ldID0gZXh0cmFjdFRleHRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBfdGhpczIuX3BkZkRvY3VtZW50LmdldFBhZ2UoaSArIDEpLnRoZW4oZnVuY3Rpb24gKHBkZlBhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiBwZGZQYWdlLmdldFRleHRDb250ZW50KHtcbiAgICAgICAgICAgICAgbm9ybWFsaXplV2hpdGVzcGFjZTogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbiAodGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0SXRlbXMgPSB0ZXh0Q29udGVudC5pdGVtcztcbiAgICAgICAgICAgIHZhciBzdHJCdWYgPSBbXTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpqID0gdGV4dEl0ZW1zLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgICAgICAgc3RyQnVmLnB1c2godGV4dEl0ZW1zW2pdLnN0cik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIF90aGlzMi5fcGFnZUNvbnRlbnRzW2ldID0gbm9ybWFsaXplKHN0ckJ1Zi5qb2luKFwiXCIpKTtcbiAgICAgICAgICAgIGV4dHJhY3RUZXh0Q2FwYWJpbGl0eS5yZXNvbHZlKGkpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVbmFibGUgdG8gZ2V0IHRleHQgY29udGVudCBmb3IgcGFnZSBcIi5jb25jYXQoaSArIDEpLCByZWFzb24pO1xuICAgICAgICAgICAgX3RoaXMyLl9wYWdlQ29udGVudHNbaV0gPSBcIlwiO1xuICAgICAgICAgICAgZXh0cmFjdFRleHRDYXBhYmlsaXR5LnJlc29sdmUoaSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5fbGlua1NlcnZpY2UucGFnZXNDb3VudDsgaSA8IGlpOyBpKyspIHtcbiAgICAgICAgX2xvb3AoaSwgaWkpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlUGFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUGFnZShpbmRleCkge1xuICAgICAgaWYgKHRoaXMuX3Njcm9sbE1hdGNoZXMgJiYgdGhpcy5fc2VsZWN0ZWQucGFnZUlkeCA9PT0gaW5kZXgpIHtcbiAgICAgICAgdGhpcy5fbGlua1NlcnZpY2UucGFnZSA9IGluZGV4ICsgMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fZXZlbnRCdXMuZGlzcGF0Y2goXCJ1cGRhdGV0ZXh0bGF5ZXJtYXRjaGVzXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBwYWdlSW5kZXg6IGluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUFsbFBhZ2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVBbGxQYWdlcygpIHtcbiAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwidXBkYXRldGV4dGxheWVybWF0Y2hlc1wiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgcGFnZUluZGV4OiAtMVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9uZXh0TWF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX25leHRNYXRjaCgpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJldmlvdXMgPSB0aGlzLl9zdGF0ZS5maW5kUHJldmlvdXM7XG4gICAgICB2YXIgY3VycmVudFBhZ2VJbmRleCA9IHRoaXMuX2xpbmtTZXJ2aWNlLnBhZ2UgLSAxO1xuICAgICAgdmFyIG51bVBhZ2VzID0gdGhpcy5fbGlua1NlcnZpY2UucGFnZXNDb3VudDtcbiAgICAgIHRoaXMuX2hpZ2hsaWdodE1hdGNoZXMgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5fZGlydHlNYXRjaCkge1xuICAgICAgICB0aGlzLl9kaXJ0eU1hdGNoID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkLnBhZ2VJZHggPSB0aGlzLl9zZWxlY3RlZC5tYXRjaElkeCA9IC0xO1xuICAgICAgICB0aGlzLl9vZmZzZXQucGFnZUlkeCA9IGN1cnJlbnRQYWdlSW5kZXg7XG4gICAgICAgIHRoaXMuX29mZnNldC5tYXRjaElkeCA9IG51bGw7XG4gICAgICAgIHRoaXMuX29mZnNldC53cmFwcGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc3VtZVBhZ2VJZHggPSBudWxsO1xuICAgICAgICB0aGlzLl9wYWdlTWF0Y2hlcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9wYWdlTWF0Y2hlc0xlbmd0aC5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLl9tYXRjaGVzQ291bnRUb3RhbCA9IDA7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQWxsUGFnZXMoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVBhZ2VzOyBpKyspIHtcbiAgICAgICAgICBpZiAodGhpcy5fcGVuZGluZ0ZpbmRNYXRjaGVzW2ldID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLl9wZW5kaW5nRmluZE1hdGNoZXNbaV0gPSB0cnVlO1xuXG4gICAgICAgICAgdGhpcy5fZXh0cmFjdFRleHRQcm9taXNlc1tpXS50aGVuKGZ1bmN0aW9uIChwYWdlSWR4KSB7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMzLl9wZW5kaW5nRmluZE1hdGNoZXNbcGFnZUlkeF07XG5cbiAgICAgICAgICAgIF90aGlzMy5fY2FsY3VsYXRlTWF0Y2gocGFnZUlkeCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3F1ZXJ5ID09PSBcIlwiKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVVJU3RhdGUoRmluZFN0YXRlLkZPVU5EKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9yZXN1bWVQYWdlSWR4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHRoaXMuX3BhZ2VzVG9TZWFyY2ggPSBudW1QYWdlcztcblxuICAgICAgaWYgKG9mZnNldC5tYXRjaElkeCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgbnVtUGFnZU1hdGNoZXMgPSB0aGlzLl9wYWdlTWF0Y2hlc1tvZmZzZXQucGFnZUlkeF0ubGVuZ3RoO1xuXG4gICAgICAgIGlmICghcHJldmlvdXMgJiYgb2Zmc2V0Lm1hdGNoSWR4ICsgMSA8IG51bVBhZ2VNYXRjaGVzIHx8IHByZXZpb3VzICYmIG9mZnNldC5tYXRjaElkeCA+IDApIHtcbiAgICAgICAgICBvZmZzZXQubWF0Y2hJZHggPSBwcmV2aW91cyA/IG9mZnNldC5tYXRjaElkeCAtIDEgOiBvZmZzZXQubWF0Y2hJZHggKyAxO1xuXG4gICAgICAgICAgdGhpcy5fdXBkYXRlTWF0Y2godHJ1ZSk7XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hZHZhbmNlT2Zmc2V0UGFnZShwcmV2aW91cyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX25leHRQYWdlTWF0Y2goKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX21hdGNoZXNSZWFkeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfbWF0Y2hlc1JlYWR5KG1hdGNoZXMpIHtcbiAgICAgIHZhciBvZmZzZXQgPSB0aGlzLl9vZmZzZXQ7XG4gICAgICB2YXIgbnVtTWF0Y2hlcyA9IG1hdGNoZXMubGVuZ3RoO1xuICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5fc3RhdGUuZmluZFByZXZpb3VzO1xuXG4gICAgICBpZiAobnVtTWF0Y2hlcykge1xuICAgICAgICBvZmZzZXQubWF0Y2hJZHggPSBwcmV2aW91cyA/IG51bU1hdGNoZXMgLSAxIDogMDtcblxuICAgICAgICB0aGlzLl91cGRhdGVNYXRjaCh0cnVlKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYWR2YW5jZU9mZnNldFBhZ2UocHJldmlvdXMpO1xuXG4gICAgICBpZiAob2Zmc2V0LndyYXBwZWQpIHtcbiAgICAgICAgb2Zmc2V0Lm1hdGNoSWR4ID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5fcGFnZXNUb1NlYXJjaCA8IDApIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVNYXRjaChmYWxzZSk7XG5cbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9uZXh0UGFnZU1hdGNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9uZXh0UGFnZU1hdGNoKCkge1xuICAgICAgaWYgKHRoaXMuX3Jlc3VtZVBhZ2VJZHggIT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZXJlIGNhbiBvbmx5IGJlIG9uZSBwZW5kaW5nIHBhZ2UuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IG51bGw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgdmFyIHBhZ2VJZHggPSB0aGlzLl9vZmZzZXQucGFnZUlkeDtcbiAgICAgICAgbWF0Y2hlcyA9IHRoaXMuX3BhZ2VNYXRjaGVzW3BhZ2VJZHhdO1xuXG4gICAgICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgICAgIHRoaXMuX3Jlc3VtZVBhZ2VJZHggPSBwYWdlSWR4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghdGhpcy5fbWF0Y2hlc1JlYWR5KG1hdGNoZXMpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkdmFuY2VPZmZzZXRQYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9hZHZhbmNlT2Zmc2V0UGFnZShwcmV2aW91cykge1xuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldDtcbiAgICAgIHZhciBudW1QYWdlcyA9IHRoaXMuX2xpbmtTZXJ2aWNlLnBhZ2VzQ291bnQ7XG4gICAgICBvZmZzZXQucGFnZUlkeCA9IHByZXZpb3VzID8gb2Zmc2V0LnBhZ2VJZHggLSAxIDogb2Zmc2V0LnBhZ2VJZHggKyAxO1xuICAgICAgb2Zmc2V0Lm1hdGNoSWR4ID0gbnVsbDtcbiAgICAgIHRoaXMuX3BhZ2VzVG9TZWFyY2gtLTtcblxuICAgICAgaWYgKG9mZnNldC5wYWdlSWR4ID49IG51bVBhZ2VzIHx8IG9mZnNldC5wYWdlSWR4IDwgMCkge1xuICAgICAgICBvZmZzZXQucGFnZUlkeCA9IHByZXZpb3VzID8gbnVtUGFnZXMgLSAxIDogMDtcbiAgICAgICAgb2Zmc2V0LndyYXBwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlTWF0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZU1hdGNoKCkge1xuICAgICAgdmFyIGZvdW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICAgIHZhciBzdGF0ZSA9IEZpbmRTdGF0ZS5OT1RfRk9VTkQ7XG4gICAgICB2YXIgd3JhcHBlZCA9IHRoaXMuX29mZnNldC53cmFwcGVkO1xuICAgICAgdGhpcy5fb2Zmc2V0LndyYXBwZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgIHZhciBwcmV2aW91c1BhZ2UgPSB0aGlzLl9zZWxlY3RlZC5wYWdlSWR4O1xuICAgICAgICB0aGlzLl9zZWxlY3RlZC5wYWdlSWR4ID0gdGhpcy5fb2Zmc2V0LnBhZ2VJZHg7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkLm1hdGNoSWR4ID0gdGhpcy5fb2Zmc2V0Lm1hdGNoSWR4O1xuICAgICAgICBzdGF0ZSA9IHdyYXBwZWQgPyBGaW5kU3RhdGUuV1JBUFBFRCA6IEZpbmRTdGF0ZS5GT1VORDtcblxuICAgICAgICBpZiAocHJldmlvdXNQYWdlICE9PSAtMSAmJiBwcmV2aW91c1BhZ2UgIT09IHRoaXMuX3NlbGVjdGVkLnBhZ2VJZHgpIHtcbiAgICAgICAgICB0aGlzLl91cGRhdGVQYWdlKHByZXZpb3VzUGFnZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlVUlTdGF0ZShzdGF0ZSwgdGhpcy5fc3RhdGUuZmluZFByZXZpb3VzKTtcblxuICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkLnBhZ2VJZHggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3Njcm9sbE1hdGNoZXMgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBhZ2UodGhpcy5fc2VsZWN0ZWQucGFnZUlkeCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbkZpbmRCYXJDbG9zZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfb25GaW5kQmFyQ2xvc2UoZXZ0KSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgdmFyIHBkZkRvY3VtZW50ID0gdGhpcy5fcGRmRG9jdW1lbnQ7XG5cbiAgICAgIHRoaXMuX2ZpcnN0UGFnZUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFfdGhpczQuX3BkZkRvY3VtZW50IHx8IHBkZkRvY3VtZW50ICYmIF90aGlzNC5fcGRmRG9jdW1lbnQgIT09IHBkZkRvY3VtZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNC5fZmluZFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXM0Ll9maW5kVGltZW91dCk7XG4gICAgICAgICAgX3RoaXM0Ll9maW5kVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoX3RoaXM0Ll9yZXN1bWVQYWdlSWR4KSB7XG4gICAgICAgICAgX3RoaXM0Ll9yZXN1bWVQYWdlSWR4ID0gbnVsbDtcbiAgICAgICAgICBfdGhpczQuX2RpcnR5TWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXM0Ll91cGRhdGVVSVN0YXRlKEZpbmRTdGF0ZS5GT1VORCk7XG5cbiAgICAgICAgX3RoaXM0Ll9oaWdobGlnaHRNYXRjaGVzID0gZmFsc2U7XG5cbiAgICAgICAgX3RoaXM0Ll91cGRhdGVBbGxQYWdlcygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXF1ZXN0TWF0Y2hlc0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXF1ZXN0TWF0Y2hlc0NvdW50KCkge1xuICAgICAgdmFyIF90aGlzJF9zZWxlY3RlZCA9IHRoaXMuX3NlbGVjdGVkLFxuICAgICAgICAgIHBhZ2VJZHggPSBfdGhpcyRfc2VsZWN0ZWQucGFnZUlkeCxcbiAgICAgICAgICBtYXRjaElkeCA9IF90aGlzJF9zZWxlY3RlZC5tYXRjaElkeDtcbiAgICAgIHZhciBjdXJyZW50ID0gMCxcbiAgICAgICAgICB0b3RhbCA9IHRoaXMuX21hdGNoZXNDb3VudFRvdGFsO1xuXG4gICAgICBpZiAobWF0Y2hJZHggIT09IC0xKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFnZUlkeDsgaSsrKSB7XG4gICAgICAgICAgY3VycmVudCArPSB0aGlzLl9wYWdlTWF0Y2hlc1tpXSAmJiB0aGlzLl9wYWdlTWF0Y2hlc1tpXS5sZW5ndGggfHwgMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgKz0gbWF0Y2hJZHggKyAxO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudCA8IDEgfHwgY3VycmVudCA+IHRvdGFsKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0b3RhbCA9IDA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGN1cnJlbnQ6IGN1cnJlbnQsXG4gICAgICAgIHRvdGFsOiB0b3RhbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZVVJUmVzdWx0c0NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVVSVJlc3VsdHNDb3VudCgpIHtcbiAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwidXBkYXRlZmluZG1hdGNoZXNjb3VudFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbWF0Y2hlc0NvdW50OiB0aGlzLl9yZXF1ZXN0TWF0Y2hlc0NvdW50KClcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlVUlTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlVUlTdGF0ZShzdGF0ZSwgcHJldmlvdXMpIHtcbiAgICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwidXBkYXRlZmluZGNvbnRyb2xzdGF0ZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICBwcmV2aW91czogcHJldmlvdXMsXG4gICAgICAgIG1hdGNoZXNDb3VudDogdGhpcy5fcmVxdWVzdE1hdGNoZXNDb3VudCgpLFxuICAgICAgICByYXdRdWVyeTogdGhpcy5fc3RhdGUgPyB0aGlzLl9zdGF0ZS5xdWVyeSA6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoaWdobGlnaHRNYXRjaGVzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faGlnaGxpZ2h0TWF0Y2hlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZU1hdGNoZXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlTWF0Y2hlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZU1hdGNoZXNMZW5ndGhcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlTWF0Y2hlc0xlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VsZWN0ZWRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic3RhdGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdGF0ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3F1ZXJ5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUucXVlcnkgIT09IHRoaXMuX3Jhd1F1ZXJ5KSB7XG4gICAgICAgIHRoaXMuX3Jhd1F1ZXJ5ID0gdGhpcy5fc3RhdGUucXVlcnk7XG4gICAgICAgIHRoaXMuX25vcm1hbGl6ZWRRdWVyeSA9IG5vcm1hbGl6ZSh0aGlzLl9zdGF0ZS5xdWVyeSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVkUXVlcnk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERkZpbmRDb250cm9sbGVyO1xufSgpO1xuXG5leHBvcnRzLlBERkZpbmRDb250cm9sbGVyID0gUERGRmluZENvbnRyb2xsZXI7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuZ2V0Q2hhcmFjdGVyVHlwZSA9IGdldENoYXJhY3RlclR5cGU7XG5leHBvcnRzLkNoYXJhY3RlclR5cGUgPSB2b2lkIDA7XG52YXIgQ2hhcmFjdGVyVHlwZSA9IHtcbiAgU1BBQ0U6IDAsXG4gIEFMUEhBX0xFVFRFUjogMSxcbiAgUFVOQ1Q6IDIsXG4gIEhBTl9MRVRURVI6IDMsXG4gIEtBVEFLQU5BX0xFVFRFUjogNCxcbiAgSElSQUdBTkFfTEVUVEVSOiA1LFxuICBIQUxGV0lEVEhfS0FUQUtBTkFfTEVUVEVSOiA2LFxuICBUSEFJX0xFVFRFUjogN1xufTtcbmV4cG9ydHMuQ2hhcmFjdGVyVHlwZSA9IENoYXJhY3RlclR5cGU7XG5cbmZ1bmN0aW9uIGlzQWxwaGFiZXRpY2FsU2NyaXB0KGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA8IDB4MmU4MDtcbn1cblxuZnVuY3Rpb24gaXNBc2NpaShjaGFyQ29kZSkge1xuICByZXR1cm4gKGNoYXJDb2RlICYgMHhmZjgwKSA9PT0gMDtcbn1cblxuZnVuY3Rpb24gaXNBc2NpaUFscGhhKGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweDYxICYmIGNoYXJDb2RlIDw9IDB4N2EgfHwgY2hhckNvZGUgPj0gMHg0MSAmJiBjaGFyQ29kZSA8PSAweDVhO1xufVxuXG5mdW5jdGlvbiBpc0FzY2lpRGlnaXQoY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4MzAgJiYgY2hhckNvZGUgPD0gMHgzOTtcbn1cblxuZnVuY3Rpb24gaXNBc2NpaVNwYWNlKGNoYXJDb2RlKSB7XG4gIHJldHVybiBjaGFyQ29kZSA9PT0gMHgyMCB8fCBjaGFyQ29kZSA9PT0gMHgwOSB8fCBjaGFyQ29kZSA9PT0gMHgwZCB8fCBjaGFyQ29kZSA9PT0gMHgwYTtcbn1cblxuZnVuY3Rpb24gaXNIYW4oY2hhckNvZGUpIHtcbiAgcmV0dXJuIGNoYXJDb2RlID49IDB4MzQwMCAmJiBjaGFyQ29kZSA8PSAweDlmZmYgfHwgY2hhckNvZGUgPj0gMHhmOTAwICYmIGNoYXJDb2RlIDw9IDB4ZmFmZjtcbn1cblxuZnVuY3Rpb24gaXNLYXRha2FuYShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHgzMGEwICYmIGNoYXJDb2RlIDw9IDB4MzBmZjtcbn1cblxuZnVuY3Rpb24gaXNIaXJhZ2FuYShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHgzMDQwICYmIGNoYXJDb2RlIDw9IDB4MzA5Zjtcbn1cblxuZnVuY3Rpb24gaXNIYWxmd2lkdGhLYXRha2FuYShjaGFyQ29kZSkge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhmZjYwICYmIGNoYXJDb2RlIDw9IDB4ZmY5Zjtcbn1cblxuZnVuY3Rpb24gaXNUaGFpKGNoYXJDb2RlKSB7XG4gIHJldHVybiAoY2hhckNvZGUgJiAweGZmODApID09PSAweDBlMDA7XG59XG5cbmZ1bmN0aW9uIGdldENoYXJhY3RlclR5cGUoY2hhckNvZGUpIHtcbiAgaWYgKGlzQWxwaGFiZXRpY2FsU2NyaXB0KGNoYXJDb2RlKSkge1xuICAgIGlmIChpc0FzY2lpKGNoYXJDb2RlKSkge1xuICAgICAgaWYgKGlzQXNjaWlTcGFjZShjaGFyQ29kZSkpIHtcbiAgICAgICAgcmV0dXJuIENoYXJhY3RlclR5cGUuU1BBQ0U7XG4gICAgICB9IGVsc2UgaWYgKGlzQXNjaWlBbHBoYShjaGFyQ29kZSkgfHwgaXNBc2NpaURpZ2l0KGNoYXJDb2RlKSB8fCBjaGFyQ29kZSA9PT0gMHg1Zikge1xuICAgICAgICByZXR1cm4gQ2hhcmFjdGVyVHlwZS5BTFBIQV9MRVRURVI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDaGFyYWN0ZXJUeXBlLlBVTkNUO1xuICAgIH0gZWxzZSBpZiAoaXNUaGFpKGNoYXJDb2RlKSkge1xuICAgICAgcmV0dXJuIENoYXJhY3RlclR5cGUuVEhBSV9MRVRURVI7XG4gICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PT0gMHhhMCkge1xuICAgICAgcmV0dXJuIENoYXJhY3RlclR5cGUuU1BBQ0U7XG4gICAgfVxuXG4gICAgcmV0dXJuIENoYXJhY3RlclR5cGUuQUxQSEFfTEVUVEVSO1xuICB9XG5cbiAgaWYgKGlzSGFuKGNoYXJDb2RlKSkge1xuICAgIHJldHVybiBDaGFyYWN0ZXJUeXBlLkhBTl9MRVRURVI7XG4gIH0gZWxzZSBpZiAoaXNLYXRha2FuYShjaGFyQ29kZSkpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyVHlwZS5LQVRBS0FOQV9MRVRURVI7XG4gIH0gZWxzZSBpZiAoaXNIaXJhZ2FuYShjaGFyQ29kZSkpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyVHlwZS5ISVJBR0FOQV9MRVRURVI7XG4gIH0gZWxzZSBpZiAoaXNIYWxmd2lkdGhLYXRha2FuYShjaGFyQ29kZSkpIHtcbiAgICByZXR1cm4gQ2hhcmFjdGVyVHlwZS5IQUxGV0lEVEhfS0FUQUtBTkFfTEVUVEVSO1xuICB9XG5cbiAgcmV0dXJuIENoYXJhY3RlclR5cGUuQUxQSEFfTEVUVEVSO1xufVxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLmlzRGVzdEhhc2hlc0VxdWFsID0gaXNEZXN0SGFzaGVzRXF1YWw7XG5leHBvcnRzLmlzRGVzdEFycmF5c0VxdWFsID0gaXNEZXN0QXJyYXlzRXF1YWw7XG5leHBvcnRzLlBERkhpc3RvcnkgPSB2b2lkIDA7XG5cbnZhciBfdWlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkgeyByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8ICEoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSkgcmV0dXJuOyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIEhBU0hfQ0hBTkdFX1RJTUVPVVQgPSAxMDAwO1xudmFyIFBPU0lUSU9OX1VQREFURURfVEhSRVNIT0xEID0gNTA7XG52YXIgVVBEQVRFX1ZJRVdBUkVBX1RJTUVPVVQgPSAxMDAwO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50SGFzaCgpIHtcbiAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhhc2g7XG59XG5cbnZhciBQREZIaXN0b3J5ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUERGSGlzdG9yeShfcmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBsaW5rU2VydmljZSA9IF9yZWYubGlua1NlcnZpY2UsXG4gICAgICAgIGV2ZW50QnVzID0gX3JlZi5ldmVudEJ1cztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZIaXN0b3J5KTtcblxuICAgIHRoaXMubGlua1NlcnZpY2UgPSBsaW5rU2VydmljZTtcbiAgICB0aGlzLmV2ZW50QnVzID0gZXZlbnRCdXM7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW5nZXJwcmludCA9IFwiXCI7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHRoaXMuX2JvdW5kRXZlbnRzID0gbnVsbDtcbiAgICB0aGlzLl9pc1ZpZXdlckluUHJlc2VudGF0aW9uTW9kZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5ldmVudEJ1cy5fb24oXCJwcmVzZW50YXRpb25tb2RlY2hhbmdlZFwiLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBfdGhpcy5faXNWaWV3ZXJJblByZXNlbnRhdGlvbk1vZGUgPSBldnQuYWN0aXZlIHx8IGV2dC5zd2l0Y2hJblByb2dyZXNzO1xuICAgIH0pO1xuXG4gICAgdGhpcy5ldmVudEJ1cy5fb24oXCJwYWdlc2luaXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgX3RoaXMuX2lzUGFnZXNMb2FkZWQgPSBmYWxzZTtcblxuICAgICAgdmFyIG9uUGFnZXNMb2FkZWQgPSBmdW5jdGlvbiBvblBhZ2VzTG9hZGVkKGV2dCkge1xuICAgICAgICBfdGhpcy5ldmVudEJ1cy5fb2ZmKFwicGFnZXNsb2FkZWRcIiwgb25QYWdlc0xvYWRlZCk7XG5cbiAgICAgICAgX3RoaXMuX2lzUGFnZXNMb2FkZWQgPSAhIWV2dC5wYWdlc0NvdW50O1xuICAgICAgfTtcblxuICAgICAgX3RoaXMuZXZlbnRCdXMuX29uKFwicGFnZXNsb2FkZWRcIiwgb25QYWdlc0xvYWRlZCk7XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGSGlzdG9yeSwgW3tcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKF9yZWYyKSB7XG4gICAgICB2YXIgZmluZ2VycHJpbnQgPSBfcmVmMi5maW5nZXJwcmludCxcbiAgICAgICAgICBfcmVmMiRyZXNldEhpc3RvcnkgPSBfcmVmMi5yZXNldEhpc3RvcnksXG4gICAgICAgICAgcmVzZXRIaXN0b3J5ID0gX3JlZjIkcmVzZXRIaXN0b3J5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJHJlc2V0SGlzdG9yeSxcbiAgICAgICAgICBfcmVmMiR1cGRhdGVVcmwgPSBfcmVmMi51cGRhdGVVcmwsXG4gICAgICAgICAgdXBkYXRlVXJsID0gX3JlZjIkdXBkYXRlVXJsID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJHVwZGF0ZVVybDtcblxuICAgICAgaWYgKCFmaW5nZXJwcmludCB8fCB0eXBlb2YgZmluZ2VycHJpbnQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignUERGSGlzdG9yeS5pbml0aWFsaXplOiBUaGUgXCJmaW5nZXJwcmludFwiIG11c3QgYmUgYSBub24tZW1wdHkgc3RyaW5nLicpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZUluaXRpYWxpemVkID0gdGhpcy5fZmluZ2VycHJpbnQgIT09IFwiXCIgJiYgdGhpcy5fZmluZ2VycHJpbnQgIT09IGZpbmdlcnByaW50O1xuICAgICAgdGhpcy5fZmluZ2VycHJpbnQgPSBmaW5nZXJwcmludDtcbiAgICAgIHRoaXMuX3VwZGF0ZVVybCA9IHVwZGF0ZVVybCA9PT0gdHJ1ZTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgdGhpcy5fYmluZEV2ZW50cygpO1xuXG4gICAgICB2YXIgc3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZTtcbiAgICAgIHRoaXMuX3BvcFN0YXRlSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgdGhpcy5fYmxvY2tIYXNoQ2hhbmdlID0gMDtcbiAgICAgIHRoaXMuX2N1cnJlbnRIYXNoID0gZ2V0Q3VycmVudEhhc2goKTtcbiAgICAgIHRoaXMuX251bVBvc2l0aW9uVXBkYXRlcyA9IDA7XG4gICAgICB0aGlzLl91aWQgPSB0aGlzLl9tYXhVaWQgPSAwO1xuICAgICAgdGhpcy5fZGVzdGluYXRpb24gPSBudWxsO1xuICAgICAgdGhpcy5fcG9zaXRpb24gPSBudWxsO1xuXG4gICAgICBpZiAoIXRoaXMuX2lzVmFsaWRTdGF0ZShzdGF0ZSwgdHJ1ZSkgfHwgcmVzZXRIaXN0b3J5KSB7XG4gICAgICAgIHZhciBfdGhpcyRfcGFyc2VDdXJyZW50SGEgPSB0aGlzLl9wYXJzZUN1cnJlbnRIYXNoKHRydWUpLFxuICAgICAgICAgICAgaGFzaCA9IF90aGlzJF9wYXJzZUN1cnJlbnRIYS5oYXNoLFxuICAgICAgICAgICAgcGFnZSA9IF90aGlzJF9wYXJzZUN1cnJlbnRIYS5wYWdlLFxuICAgICAgICAgICAgcm90YXRpb24gPSBfdGhpcyRfcGFyc2VDdXJyZW50SGEucm90YXRpb247XG5cbiAgICAgICAgaWYgKCFoYXNoIHx8IHJlSW5pdGlhbGl6ZWQgfHwgcmVzZXRIaXN0b3J5KSB7XG4gICAgICAgICAgdGhpcy5fcHVzaE9yUmVwbGFjZVN0YXRlKG51bGwsIHRydWUpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fcHVzaE9yUmVwbGFjZVN0YXRlKHtcbiAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgIHBhZ2U6IHBhZ2UsXG4gICAgICAgICAgcm90YXRpb246IHJvdGF0aW9uXG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlc3RpbmF0aW9uID0gc3RhdGUuZGVzdGluYXRpb247XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUludGVybmFsU3RhdGUoZGVzdGluYXRpb24sIHN0YXRlLnVpZCwgdHJ1ZSk7XG5cbiAgICAgIGlmICh0aGlzLl91aWQgPiB0aGlzLl9tYXhVaWQpIHtcbiAgICAgICAgdGhpcy5fbWF4VWlkID0gdGhpcy5fdWlkO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGVzdGluYXRpb24ucm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLl9pbml0aWFsUm90YXRpb24gPSBkZXN0aW5hdGlvbi5yb3RhdGlvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGRlc3RpbmF0aW9uLmRlc3QpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbEJvb2ttYXJrID0gSlNPTi5zdHJpbmdpZnkoZGVzdGluYXRpb24uZGVzdCk7XG4gICAgICAgIHRoaXMuX2Rlc3RpbmF0aW9uLnBhZ2UgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmIChkZXN0aW5hdGlvbi5oYXNoKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxCb29rbWFyayA9IGRlc3RpbmF0aW9uLmhhc2g7XG4gICAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uLnBhZ2UpIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbEJvb2ttYXJrID0gXCJwYWdlPVwiLmNvbmNhdChkZXN0aW5hdGlvbi5wYWdlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fcGFnZUhpZGUoKTtcblxuICAgICAgICB0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3VuYmluZEV2ZW50cygpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fdXBkYXRlVmlld2FyZWFUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVWaWV3YXJlYVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl91cGRhdGVWaWV3YXJlYVRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9pbml0aWFsQm9va21hcmsgPSBudWxsO1xuICAgICAgdGhpcy5faW5pdGlhbFJvdGF0aW9uID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKF9yZWYzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIF9yZWYzJG5hbWVkRGVzdCA9IF9yZWYzLm5hbWVkRGVzdCxcbiAgICAgICAgICBuYW1lZERlc3QgPSBfcmVmMyRuYW1lZERlc3QgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmMyRuYW1lZERlc3QsXG4gICAgICAgICAgZXhwbGljaXREZXN0ID0gX3JlZjMuZXhwbGljaXREZXN0LFxuICAgICAgICAgIHBhZ2VOdW1iZXIgPSBfcmVmMy5wYWdlTnVtYmVyO1xuXG4gICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWVkRGVzdCAmJiB0eXBlb2YgbmFtZWREZXN0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQREZIaXN0b3J5LnB1c2g6IFwiICsgXCJcXFwiXCIuY29uY2F0KG5hbWVkRGVzdCwgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIG5hbWVkRGVzdCBwYXJhbWV0ZXIuXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShleHBsaWNpdERlc3QpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQREZIaXN0b3J5LnB1c2g6IFwiICsgXCJcXFwiXCIuY29uY2F0KGV4cGxpY2l0RGVzdCwgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIGV4cGxpY2l0RGVzdCBwYXJhbWV0ZXIuXCIpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICghKE51bWJlci5pc0ludGVnZXIocGFnZU51bWJlcikgJiYgcGFnZU51bWJlciA+IDAgJiYgcGFnZU51bWJlciA8PSB0aGlzLmxpbmtTZXJ2aWNlLnBhZ2VzQ291bnQpKSB7XG4gICAgICAgIGlmIChwYWdlTnVtYmVyICE9PSBudWxsIHx8IHRoaXMuX2Rlc3RpbmF0aW9uKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlBERkhpc3RvcnkucHVzaDogXCIgKyBcIlxcXCJcIi5jb25jYXQocGFnZU51bWJlciwgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIHBhZ2VOdW1iZXIgcGFyYW1ldGVyLlwiKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBoYXNoID0gbmFtZWREZXN0IHx8IEpTT04uc3RyaW5naWZ5KGV4cGxpY2l0RGVzdCk7XG5cbiAgICAgIGlmICghaGFzaCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmb3JjZVJlcGxhY2UgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX2Rlc3RpbmF0aW9uICYmIChpc0Rlc3RIYXNoZXNFcXVhbCh0aGlzLl9kZXN0aW5hdGlvbi5oYXNoLCBoYXNoKSB8fCBpc0Rlc3RBcnJheXNFcXVhbCh0aGlzLl9kZXN0aW5hdGlvbi5kZXN0LCBleHBsaWNpdERlc3QpKSkge1xuICAgICAgICBpZiAodGhpcy5fZGVzdGluYXRpb24ucGFnZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcmNlUmVwbGFjZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9wb3BTdGF0ZUluUHJvZ3Jlc3MgJiYgIWZvcmNlUmVwbGFjZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3B1c2hPclJlcGxhY2VTdGF0ZSh7XG4gICAgICAgIGRlc3Q6IGV4cGxpY2l0RGVzdCxcbiAgICAgICAgaGFzaDogaGFzaCxcbiAgICAgICAgcGFnZTogcGFnZU51bWJlcixcbiAgICAgICAgcm90YXRpb246IHRoaXMubGlua1NlcnZpY2Uucm90YXRpb25cbiAgICAgIH0sIGZvcmNlUmVwbGFjZSk7XG5cbiAgICAgIGlmICghdGhpcy5fcG9wU3RhdGVJblByb2dyZXNzKSB7XG4gICAgICAgIHRoaXMuX3BvcFN0YXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMi5fcG9wU3RhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwdXNoQ3VycmVudFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2hDdXJyZW50UG9zaXRpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX2luaXRpYWxpemVkIHx8IHRoaXMuX3BvcFN0YXRlSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3RyeVB1c2hDdXJyZW50UG9zaXRpb24oKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiYWNrKCkge1xuICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCB8fCB0aGlzLl9wb3BTdGF0ZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSB3aW5kb3cuaGlzdG9yeS5zdGF0ZTtcblxuICAgICAgaWYgKHRoaXMuX2lzVmFsaWRTdGF0ZShzdGF0ZSkgJiYgc3RhdGUudWlkID4gMCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcndhcmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9yd2FyZCgpIHtcbiAgICAgIGlmICghdGhpcy5faW5pdGlhbGl6ZWQgfHwgdGhpcy5fcG9wU3RhdGVJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXRlID0gd2luZG93Lmhpc3Rvcnkuc3RhdGU7XG5cbiAgICAgIGlmICh0aGlzLl9pc1ZhbGlkU3RhdGUoc3RhdGUpICYmIHN0YXRlLnVpZCA8IHRoaXMuX21heFVpZCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5mb3J3YXJkKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9wdXNoT3JSZXBsYWNlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3B1c2hPclJlcGxhY2VTdGF0ZShkZXN0aW5hdGlvbikge1xuICAgICAgdmFyIGZvcmNlUmVwbGFjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgICB2YXIgc2hvdWxkUmVwbGFjZSA9IGZvcmNlUmVwbGFjZSB8fCAhdGhpcy5fZGVzdGluYXRpb247XG4gICAgICB2YXIgbmV3U3RhdGUgPSB7XG4gICAgICAgIGZpbmdlcnByaW50OiB0aGlzLl9maW5nZXJwcmludCxcbiAgICAgICAgdWlkOiBzaG91bGRSZXBsYWNlID8gdGhpcy5fdWlkIDogdGhpcy5fdWlkICsgMSxcbiAgICAgICAgZGVzdGluYXRpb246IGRlc3RpbmF0aW9uXG4gICAgICB9O1xuXG4gICAgICB0aGlzLl91cGRhdGVJbnRlcm5hbFN0YXRlKGRlc3RpbmF0aW9uLCBuZXdTdGF0ZS51aWQpO1xuXG4gICAgICB2YXIgbmV3VXJsO1xuXG4gICAgICBpZiAodGhpcy5fdXBkYXRlVXJsICYmIGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLmhhc2gpIHtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmLnNwbGl0KFwiI1wiKVswXTtcblxuICAgICAgICBpZiAoIWJhc2VVcmwuc3RhcnRzV2l0aChcImZpbGU6Ly9cIikpIHtcbiAgICAgICAgICBuZXdVcmwgPSBcIlwiLmNvbmNhdChiYXNlVXJsLCBcIiNcIikuY29uY2F0KGRlc3RpbmF0aW9uLmhhc2gpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRSZXBsYWNlKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnJlcGxhY2VTdGF0ZShuZXdTdGF0ZSwgXCJcIiwgbmV3VXJsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX21heFVpZCA9IHRoaXMuX3VpZDtcbiAgICAgICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG5ld1N0YXRlLCBcIlwiLCBuZXdVcmwpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdHJ5UHVzaEN1cnJlbnRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdHJ5UHVzaEN1cnJlbnRQb3NpdGlvbigpIHtcbiAgICAgIHZhciB0ZW1wb3JhcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIXRoaXMuX3Bvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG5cbiAgICAgIGlmICh0ZW1wb3JhcnkpIHtcbiAgICAgICAgcG9zaXRpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHRoaXMuX3Bvc2l0aW9uKTtcbiAgICAgICAgcG9zaXRpb24udGVtcG9yYXJ5ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9kZXN0aW5hdGlvbikge1xuICAgICAgICB0aGlzLl9wdXNoT3JSZXBsYWNlU3RhdGUocG9zaXRpb24pO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2Rlc3RpbmF0aW9uLnRlbXBvcmFyeSkge1xuICAgICAgICB0aGlzLl9wdXNoT3JSZXBsYWNlU3RhdGUocG9zaXRpb24sIHRydWUpO1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2Rlc3RpbmF0aW9uLmhhc2ggPT09IHBvc2l0aW9uLmhhc2gpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2Rlc3RpbmF0aW9uLnBhZ2UgJiYgKFBPU0lUSU9OX1VQREFURURfVEhSRVNIT0xEIDw9IDAgfHwgdGhpcy5fbnVtUG9zaXRpb25VcGRhdGVzIDw9IFBPU0lUSU9OX1VQREFURURfVEhSRVNIT0xEKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmb3JjZVJlcGxhY2UgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuX2Rlc3RpbmF0aW9uLnBhZ2UgPj0gcG9zaXRpb24uZmlyc3QgJiYgdGhpcy5fZGVzdGluYXRpb24ucGFnZSA8PSBwb3NpdGlvbi5wYWdlKSB7XG4gICAgICAgIGlmICh0aGlzLl9kZXN0aW5hdGlvbi5kZXN0IHx8ICF0aGlzLl9kZXN0aW5hdGlvbi5maXJzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcmNlUmVwbGFjZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3B1c2hPclJlcGxhY2VTdGF0ZShwb3NpdGlvbiwgZm9yY2VSZXBsYWNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2lzVmFsaWRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaXNWYWxpZFN0YXRlKHN0YXRlKSB7XG4gICAgICB2YXIgY2hlY2tSZWxvYWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmZpbmdlcnByaW50ICE9PSB0aGlzLl9maW5nZXJwcmludCkge1xuICAgICAgICBpZiAoY2hlY2tSZWxvYWQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlLmZpbmdlcnByaW50ICE9PSBcInN0cmluZ1wiIHx8IHN0YXRlLmZpbmdlcnByaW50Lmxlbmd0aCAhPT0gdGhpcy5fZmluZ2VycHJpbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9wZXJmb3JtYW5jZSRnZXRFbnRyaSA9IHBlcmZvcm1hbmNlLmdldEVudHJpZXNCeVR5cGUoXCJuYXZpZ2F0aW9uXCIpLFxuICAgICAgICAgICAgICBfcGVyZm9ybWFuY2UkZ2V0RW50cmkyID0gX3NsaWNlZFRvQXJyYXkoX3BlcmZvcm1hbmNlJGdldEVudHJpLCAxKSxcbiAgICAgICAgICAgICAgcGVyZkVudHJ5ID0gX3BlcmZvcm1hbmNlJGdldEVudHJpMlswXTtcblxuICAgICAgICAgIGlmICghcGVyZkVudHJ5IHx8IHBlcmZFbnRyeS50eXBlICE9PSBcInJlbG9hZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc3RhdGUudWlkKSB8fCBzdGF0ZS51aWQgPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlLmRlc3RpbmF0aW9uID09PSBudWxsIHx8IF90eXBlb2Yoc3RhdGUuZGVzdGluYXRpb24pICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVJbnRlcm5hbFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVJbnRlcm5hbFN0YXRlKGRlc3RpbmF0aW9uLCB1aWQpIHtcbiAgICAgIHZhciByZW1vdmVUZW1wb3JhcnkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5fdXBkYXRlVmlld2FyZWFUaW1lb3V0KSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl91cGRhdGVWaWV3YXJlYVRpbWVvdXQpO1xuICAgICAgICB0aGlzLl91cGRhdGVWaWV3YXJlYVRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVtb3ZlVGVtcG9yYXJ5ICYmIGRlc3RpbmF0aW9uICYmIGRlc3RpbmF0aW9uLnRlbXBvcmFyeSkge1xuICAgICAgICBkZWxldGUgZGVzdGluYXRpb24udGVtcG9yYXJ5O1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9kZXN0aW5hdGlvbiA9IGRlc3RpbmF0aW9uO1xuICAgICAgdGhpcy5fdWlkID0gdWlkO1xuICAgICAgdGhpcy5fbnVtUG9zaXRpb25VcGRhdGVzID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnNlQ3VycmVudEhhc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlQ3VycmVudEhhc2goKSB7XG4gICAgICB2YXIgY2hlY2tOYW1lZGRlc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgICAgdmFyIGhhc2ggPSB1bmVzY2FwZShnZXRDdXJyZW50SGFzaCgpKS5zdWJzdHJpbmcoMSk7XG4gICAgICB2YXIgcGFyYW1zID0gKDAsIF91aV91dGlscy5wYXJzZVF1ZXJ5U3RyaW5nKShoYXNoKTtcbiAgICAgIHZhciBuYW1lZGRlc3QgPSBwYXJhbXMubmFtZWRkZXN0IHx8IFwiXCI7XG4gICAgICB2YXIgcGFnZSA9IHBhcmFtcy5wYWdlIHwgMDtcblxuICAgICAgaWYgKCEoTnVtYmVyLmlzSW50ZWdlcihwYWdlKSAmJiBwYWdlID4gMCAmJiBwYWdlIDw9IHRoaXMubGlua1NlcnZpY2UucGFnZXNDb3VudCkgfHwgY2hlY2tOYW1lZGRlc3QgJiYgbmFtZWRkZXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFnZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgIHBhZ2U6IHBhZ2UsXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLmxpbmtTZXJ2aWNlLnJvdGF0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlVmlld2FyZWFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VwZGF0ZVZpZXdhcmVhKF9yZWY0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIGxvY2F0aW9uID0gX3JlZjQubG9jYXRpb247XG5cbiAgICAgIGlmICh0aGlzLl91cGRhdGVWaWV3YXJlYVRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3VwZGF0ZVZpZXdhcmVhVGltZW91dCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZpZXdhcmVhVGltZW91dCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Bvc2l0aW9uID0ge1xuICAgICAgICBoYXNoOiB0aGlzLl9pc1ZpZXdlckluUHJlc2VudGF0aW9uTW9kZSA/IFwicGFnZT1cIi5jb25jYXQobG9jYXRpb24ucGFnZU51bWJlcikgOiBsb2NhdGlvbi5wZGZPcGVuUGFyYW1zLnN1YnN0cmluZygxKSxcbiAgICAgICAgcGFnZTogdGhpcy5saW5rU2VydmljZS5wYWdlLFxuICAgICAgICBmaXJzdDogbG9jYXRpb24ucGFnZU51bWJlcixcbiAgICAgICAgcm90YXRpb246IGxvY2F0aW9uLnJvdGF0aW9uXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5fcG9wU3RhdGVJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKFBPU0lUSU9OX1VQREFURURfVEhSRVNIT0xEID4gMCAmJiB0aGlzLl9pc1BhZ2VzTG9hZGVkICYmIHRoaXMuX2Rlc3RpbmF0aW9uICYmICF0aGlzLl9kZXN0aW5hdGlvbi5wYWdlKSB7XG4gICAgICAgIHRoaXMuX251bVBvc2l0aW9uVXBkYXRlcysrO1xuICAgICAgfVxuXG4gICAgICBpZiAoVVBEQVRFX1ZJRVdBUkVBX1RJTUVPVVQgPiAwKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZpZXdhcmVhVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICghX3RoaXMzLl9wb3BTdGF0ZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIF90aGlzMy5fdHJ5UHVzaEN1cnJlbnRQb3NpdGlvbih0cnVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGhpczMuX3VwZGF0ZVZpZXdhcmVhVGltZW91dCA9IG51bGw7XG4gICAgICAgIH0sIFVQREFURV9WSUVXQVJFQV9USU1FT1VUKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BvcFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wb3BTdGF0ZShfcmVmNSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlO1xuICAgICAgdmFyIG5ld0hhc2ggPSBnZXRDdXJyZW50SGFzaCgpLFxuICAgICAgICAgIGhhc2hDaGFuZ2VkID0gdGhpcy5fY3VycmVudEhhc2ggIT09IG5ld0hhc2g7XG4gICAgICB0aGlzLl9jdXJyZW50SGFzaCA9IG5ld0hhc2g7XG5cbiAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgdGhpcy5fdWlkKys7XG5cbiAgICAgICAgdmFyIF90aGlzJF9wYXJzZUN1cnJlbnRIYTIgPSB0aGlzLl9wYXJzZUN1cnJlbnRIYXNoKCksXG4gICAgICAgICAgICBoYXNoID0gX3RoaXMkX3BhcnNlQ3VycmVudEhhMi5oYXNoLFxuICAgICAgICAgICAgcGFnZSA9IF90aGlzJF9wYXJzZUN1cnJlbnRIYTIucGFnZSxcbiAgICAgICAgICAgIHJvdGF0aW9uID0gX3RoaXMkX3BhcnNlQ3VycmVudEhhMi5yb3RhdGlvbjtcblxuICAgICAgICB0aGlzLl9wdXNoT3JSZXBsYWNlU3RhdGUoe1xuICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgcGFnZTogcGFnZSxcbiAgICAgICAgICByb3RhdGlvbjogcm90YXRpb25cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX2lzVmFsaWRTdGF0ZShzdGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wb3BTdGF0ZUluUHJvZ3Jlc3MgPSB0cnVlO1xuXG4gICAgICBpZiAoaGFzaENoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5fYmxvY2tIYXNoQ2hhbmdlKys7XG4gICAgICAgICgwLCBfdWlfdXRpbHMud2FpdE9uRXZlbnRPclRpbWVvdXQpKHtcbiAgICAgICAgICB0YXJnZXQ6IHdpbmRvdyxcbiAgICAgICAgICBuYW1lOiBcImhhc2hjaGFuZ2VcIixcbiAgICAgICAgICBkZWxheTogSEFTSF9DSEFOR0VfVElNRU9VVFxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQuX2Jsb2NrSGFzaENoYW5nZS0tO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRlc3RpbmF0aW9uID0gc3RhdGUuZGVzdGluYXRpb247XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUludGVybmFsU3RhdGUoZGVzdGluYXRpb24sIHN0YXRlLnVpZCwgdHJ1ZSk7XG5cbiAgICAgIGlmICh0aGlzLl91aWQgPiB0aGlzLl9tYXhVaWQpIHtcbiAgICAgICAgdGhpcy5fbWF4VWlkID0gdGhpcy5fdWlkO1xuICAgICAgfVxuXG4gICAgICBpZiAoKDAsIF91aV91dGlscy5pc1ZhbGlkUm90YXRpb24pKGRlc3RpbmF0aW9uLnJvdGF0aW9uKSkge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLnJvdGF0aW9uID0gZGVzdGluYXRpb24ucm90YXRpb247XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXN0aW5hdGlvbi5kZXN0KSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UubmF2aWdhdGVUbyhkZXN0aW5hdGlvbi5kZXN0KTtcbiAgICAgIH0gZWxzZSBpZiAoZGVzdGluYXRpb24uaGFzaCkge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLnNldEhhc2goZGVzdGluYXRpb24uaGFzaCk7XG4gICAgICB9IGVsc2UgaWYgKGRlc3RpbmF0aW9uLnBhZ2UpIHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5wYWdlID0gZGVzdGluYXRpb24ucGFnZTtcbiAgICAgIH1cblxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNC5fcG9wU3RhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhZ2VIaWRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYWdlSGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5fZGVzdGluYXRpb24gfHwgdGhpcy5fZGVzdGluYXRpb24udGVtcG9yYXJ5KSB7XG4gICAgICAgIHRoaXMuX3RyeVB1c2hDdXJyZW50UG9zaXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2JpbmRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2JpbmRFdmVudHMoKSB7XG4gICAgICBpZiAodGhpcy5fYm91bmRFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ib3VuZEV2ZW50cyA9IHtcbiAgICAgICAgdXBkYXRlVmlld2FyZWE6IHRoaXMuX3VwZGF0ZVZpZXdhcmVhLmJpbmQodGhpcyksXG4gICAgICAgIHBvcFN0YXRlOiB0aGlzLl9wb3BTdGF0ZS5iaW5kKHRoaXMpLFxuICAgICAgICBwYWdlSGlkZTogdGhpcy5fcGFnZUhpZGUuYmluZCh0aGlzKVxuICAgICAgfTtcblxuICAgICAgdGhpcy5ldmVudEJ1cy5fb24oXCJ1cGRhdGV2aWV3YXJlYVwiLCB0aGlzLl9ib3VuZEV2ZW50cy51cGRhdGVWaWV3YXJlYSk7XG5cbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5fYm91bmRFdmVudHMucG9wU3RhdGUpO1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCB0aGlzLl9ib3VuZEV2ZW50cy5wYWdlSGlkZSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91bmJpbmRFdmVudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3VuYmluZEV2ZW50cygpIHtcbiAgICAgIGlmICghdGhpcy5fYm91bmRFdmVudHMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV2ZW50QnVzLl9vZmYoXCJ1cGRhdGV2aWV3YXJlYVwiLCB0aGlzLl9ib3VuZEV2ZW50cy51cGRhdGVWaWV3YXJlYSk7XG5cbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5fYm91bmRFdmVudHMucG9wU3RhdGUpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCB0aGlzLl9ib3VuZEV2ZW50cy5wYWdlSGlkZSk7XG4gICAgICB0aGlzLl9ib3VuZEV2ZW50cyA9IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBvcFN0YXRlSW5Qcm9ncmVzc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVkICYmICh0aGlzLl9wb3BTdGF0ZUluUHJvZ3Jlc3MgfHwgdGhpcy5fYmxvY2tIYXNoQ2hhbmdlID4gMCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxCb29rbWFya1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRpYWxpemVkID8gdGhpcy5faW5pdGlhbEJvb2ttYXJrIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbFJvdGF0aW9uXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5faW5pdGlhbGl6ZWQgPyB0aGlzLl9pbml0aWFsUm90YXRpb24gOiBudWxsO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQREZIaXN0b3J5O1xufSgpO1xuXG5leHBvcnRzLlBERkhpc3RvcnkgPSBQREZIaXN0b3J5O1xuXG5mdW5jdGlvbiBpc0Rlc3RIYXNoZXNFcXVhbChkZXN0SGFzaCwgcHVzaEhhc2gpIHtcbiAgaWYgKHR5cGVvZiBkZXN0SGFzaCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgcHVzaEhhc2ggIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZGVzdEhhc2ggPT09IHB1c2hIYXNoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgX3BhcnNlUXVlcnlTdHJpbmcgPSAoMCwgX3VpX3V0aWxzLnBhcnNlUXVlcnlTdHJpbmcpKGRlc3RIYXNoKSxcbiAgICAgIG5hbWVkZGVzdCA9IF9wYXJzZVF1ZXJ5U3RyaW5nLm5hbWVkZGVzdDtcblxuICBpZiAobmFtZWRkZXN0ID09PSBwdXNoSGFzaCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc0Rlc3RBcnJheXNFcXVhbChmaXJzdERlc3QsIHNlY29uZERlc3QpIHtcbiAgZnVuY3Rpb24gaXNFbnRyeUVxdWFsKGZpcnN0LCBzZWNvbmQpIHtcbiAgICBpZiAoX3R5cGVvZihmaXJzdCkgIT09IF90eXBlb2Yoc2Vjb25kKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGZpcnN0KSB8fCBBcnJheS5pc0FycmF5KHNlY29uZCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAoZmlyc3QgIT09IG51bGwgJiYgX3R5cGVvZihmaXJzdCkgPT09IFwib2JqZWN0XCIgJiYgc2Vjb25kICE9PSBudWxsKSB7XG4gICAgICBpZiAoT2JqZWN0LmtleXMoZmlyc3QpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoc2Vjb25kKS5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gZmlyc3QpIHtcbiAgICAgICAgaWYgKCFpc0VudHJ5RXF1YWwoZmlyc3Rba2V5XSwgc2Vjb25kW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmaXJzdCA9PT0gc2Vjb25kIHx8IE51bWJlci5pc05hTihmaXJzdCkgJiYgTnVtYmVyLmlzTmFOKHNlY29uZCk7XG4gIH1cblxuICBpZiAoIShBcnJheS5pc0FycmF5KGZpcnN0RGVzdCkgJiYgQXJyYXkuaXNBcnJheShzZWNvbmREZXN0KSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoZmlyc3REZXN0Lmxlbmd0aCAhPT0gc2Vjb25kRGVzdC5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgaWkgPSBmaXJzdERlc3QubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgIGlmICghaXNFbnRyeUVxdWFsKGZpcnN0RGVzdFtpXSwgc2Vjb25kRGVzdFtpXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqKi8gfSksXG4vKiAxNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QREZQYWdlVmlldyA9IHZvaWQgMDtcblxudmFyIF9yZWdlbmVyYXRvciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193X3BkZmpzX3JlcXVpcmVfXyg0KSk7XG5cbnZhciBfdWlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xuXG52YXIgX3BkZmpzTGliID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxudmFyIF9wZGZfcmVuZGVyaW5nX3F1ZXVlID0gX193X3BkZmpzX3JlcXVpcmVfXygxNyk7XG5cbnZhciBfdmlld2VyX2NvbXBhdGliaWxpdHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgXCJkZWZhdWx0XCI6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHsgdHJ5IHsgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpOyB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlOyB9IGNhdGNoIChlcnJvcikgeyByZWplY3QoZXJyb3IpOyByZXR1cm47IH0gaWYgKGluZm8uZG9uZSkgeyByZXNvbHZlKHZhbHVlKTsgfSBlbHNlIHsgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpOyB9IH1cblxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHsgdmFyIHNlbGYgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzOyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7IGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTsgfSBmdW5jdGlvbiBfdGhyb3coZXJyKSB7IGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpOyB9IF9uZXh0KHVuZGVmaW5lZCk7IH0pOyB9OyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxudmFyIE1BWF9DQU5WQVNfUElYRUxTID0gX3ZpZXdlcl9jb21wYXRpYmlsaXR5LnZpZXdlckNvbXBhdGliaWxpdHlQYXJhbXMubWF4Q2FudmFzUGl4ZWxzIHx8IDE2Nzc3MjE2O1xuXG52YXIgUERGUGFnZVZpZXcgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQREZQYWdlVmlldyhvcHRpb25zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERlBhZ2VWaWV3KTtcblxuICAgIHZhciBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lcjtcbiAgICB2YXIgZGVmYXVsdFZpZXdwb3J0ID0gb3B0aW9ucy5kZWZhdWx0Vmlld3BvcnQ7XG4gICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQ7XG4gICAgdGhpcy5yZW5kZXJpbmdJZCA9IFwicGFnZVwiICsgdGhpcy5pZDtcbiAgICB0aGlzLnBkZlBhZ2UgPSBudWxsO1xuICAgIHRoaXMucGFnZUxhYmVsID0gbnVsbDtcbiAgICB0aGlzLnJvdGF0aW9uID0gMDtcbiAgICB0aGlzLnNjYWxlID0gb3B0aW9ucy5zY2FsZSB8fCBfdWlfdXRpbHMuREVGQVVMVF9TQ0FMRTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gZGVmYXVsdFZpZXdwb3J0O1xuICAgIHRoaXMucGRmUGFnZVJvdGF0ZSA9IGRlZmF1bHRWaWV3cG9ydC5yb3RhdGlvbjtcbiAgICB0aGlzLl9hbm5vdGF0aW9uU3RvcmFnZSA9IG9wdGlvbnMuYW5ub3RhdGlvblN0b3JhZ2UgfHwgbnVsbDtcbiAgICB0aGlzLl9vcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gb3B0aW9ucy5vcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlIHx8IG51bGw7XG4gICAgdGhpcy5oYXNSZXN0cmljdGVkU2NhbGluZyA9IGZhbHNlO1xuICAgIHRoaXMudGV4dExheWVyTW9kZSA9IE51bWJlci5pc0ludGVnZXIob3B0aW9ucy50ZXh0TGF5ZXJNb2RlKSA/IG9wdGlvbnMudGV4dExheWVyTW9kZSA6IF91aV91dGlscy5UZXh0TGF5ZXJNb2RlLkVOQUJMRTtcbiAgICB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCA9IG9wdGlvbnMuaW1hZ2VSZXNvdXJjZXNQYXRoIHx8IFwiXCI7XG4gICAgdGhpcy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID0gdHlwZW9mIG9wdGlvbnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyA9PT0gXCJib29sZWFuXCIgPyBvcHRpb25zLnJlbmRlckludGVyYWN0aXZlRm9ybXMgOiB0cnVlO1xuICAgIHRoaXMudXNlT25seUNzc1pvb20gPSBvcHRpb25zLnVzZU9ubHlDc3Nab29tIHx8IGZhbHNlO1xuICAgIHRoaXMubWF4Q2FudmFzUGl4ZWxzID0gb3B0aW9ucy5tYXhDYW52YXNQaXhlbHMgfHwgTUFYX0NBTlZBU19QSVhFTFM7XG4gICAgdGhpcy5ldmVudEJ1cyA9IG9wdGlvbnMuZXZlbnRCdXM7XG4gICAgdGhpcy5yZW5kZXJpbmdRdWV1ZSA9IG9wdGlvbnMucmVuZGVyaW5nUXVldWU7XG4gICAgdGhpcy50ZXh0TGF5ZXJGYWN0b3J5ID0gb3B0aW9ucy50ZXh0TGF5ZXJGYWN0b3J5O1xuICAgIHRoaXMuYW5ub3RhdGlvbkxheWVyRmFjdG9yeSA9IG9wdGlvbnMuYW5ub3RhdGlvbkxheWVyRmFjdG9yeTtcbiAgICB0aGlzLnJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlciB8fCBfdWlfdXRpbHMuUmVuZGVyZXJUeXBlLkNBTlZBUztcbiAgICB0aGlzLmVuYWJsZVdlYkdMID0gb3B0aW9ucy5lbmFibGVXZWJHTCB8fCBmYWxzZTtcbiAgICB0aGlzLmwxMG4gPSBvcHRpb25zLmwxMG4gfHwgX3VpX3V0aWxzLk51bGxMMTBuO1xuICAgIHRoaXMucGFpbnRUYXNrID0gbnVsbDtcbiAgICB0aGlzLnBhaW50ZWRWaWV3cG9ydE1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy5yZW5kZXJpbmdTdGF0ZSA9IF9wZGZfcmVuZGVyaW5nX3F1ZXVlLlJlbmRlcmluZ1N0YXRlcy5JTklUSUFMO1xuICAgIHRoaXMucmVzdW1lID0gbnVsbDtcbiAgICB0aGlzLmVycm9yID0gbnVsbDtcbiAgICB0aGlzLmFubm90YXRpb25MYXllciA9IG51bGw7XG4gICAgdGhpcy50ZXh0TGF5ZXIgPSBudWxsO1xuICAgIHRoaXMuem9vbUxheWVyID0gbnVsbDtcbiAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBkaXYuY2xhc3NOYW1lID0gXCJwYWdlXCI7XG4gICAgZGl2LnN0eWxlLndpZHRoID0gTWF0aC5mbG9vcih0aGlzLnZpZXdwb3J0LndpZHRoKSArIFwicHhcIjtcbiAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gTWF0aC5mbG9vcih0aGlzLnZpZXdwb3J0LmhlaWdodCkgKyBcInB4XCI7XG4gICAgZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtcGFnZS1udW1iZXJcIiwgdGhpcy5pZCk7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRpdik7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGUGFnZVZpZXcsIFt7XG4gICAga2V5OiBcInNldFBkZlBhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGRmUGFnZShwZGZQYWdlKSB7XG4gICAgICB0aGlzLnBkZlBhZ2UgPSBwZGZQYWdlO1xuICAgICAgdGhpcy5wZGZQYWdlUm90YXRlID0gcGRmUGFnZS5yb3RhdGU7XG4gICAgICB2YXIgdG90YWxSb3RhdGlvbiA9ICh0aGlzLnJvdGF0aW9uICsgdGhpcy5wZGZQYWdlUm90YXRlKSAlIDM2MDtcbiAgICAgIHRoaXMudmlld3BvcnQgPSBwZGZQYWdlLmdldFZpZXdwb3J0KHtcbiAgICAgICAgc2NhbGU6IHRoaXMuc2NhbGUgKiBfdWlfdXRpbHMuQ1NTX1VOSVRTLFxuICAgICAgICByb3RhdGlvbjogdG90YWxSb3RhdGlvblxuICAgICAgfSk7XG4gICAgICB0aGlzLnN0YXRzID0gcGRmUGFnZS5zdGF0cztcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVzdHJveVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuXG4gICAgICBpZiAodGhpcy5wZGZQYWdlKSB7XG4gICAgICAgIHRoaXMucGRmUGFnZS5jbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZW5kZXJBbm5vdGF0aW9uTGF5ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW5kZXJBbm5vdGF0aW9uTGF5ZXIyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZSgpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIGVycm9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbm5vdGF0aW9uTGF5ZXIucmVuZGVyKHRoaXMudmlld3BvcnQsIFwiZGlzcGxheVwiKTtcblxuICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA2O1xuICAgICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgxKTtcbiAgICAgICAgICAgICAgICBlcnJvciA9IF9jb250ZXh0LnQwO1xuXG4gICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gOTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50QnVzLmRpc3BhdGNoKFwiYW5ub3RhdGlvbmxheWVycmVuZGVyZWRcIiwge1xuICAgICAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgcGFnZU51bWJlcjogdGhpcy5pZCxcbiAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5maW5pc2goOSk7XG5cbiAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCB0aGlzLCBbWzEsIDYsIDksIDEyXV0pO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBfcmVuZGVyQW5ub3RhdGlvbkxheWVyKCkge1xuICAgICAgICByZXR1cm4gX3JlbmRlckFubm90YXRpb25MYXllcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9yZW5kZXJBbm5vdGF0aW9uTGF5ZXI7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Jlc2V0Wm9vbUxheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXNldFpvb21MYXllcigpIHtcbiAgICAgIHZhciByZW1vdmVGcm9tRE9NID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcblxuICAgICAgaWYgKCF0aGlzLnpvb21MYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB6b29tTGF5ZXJDYW52YXMgPSB0aGlzLnpvb21MYXllci5maXJzdENoaWxkO1xuICAgICAgdGhpcy5wYWludGVkVmlld3BvcnRNYXBbXCJkZWxldGVcIl0oem9vbUxheWVyQ2FudmFzKTtcbiAgICAgIHpvb21MYXllckNhbnZhcy53aWR0aCA9IDA7XG4gICAgICB6b29tTGF5ZXJDYW52YXMuaGVpZ2h0ID0gMDtcblxuICAgICAgaWYgKHJlbW92ZUZyb21ET00pIHtcbiAgICAgICAgdGhpcy56b29tTGF5ZXIucmVtb3ZlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuem9vbUxheWVyID0gbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXQoKSB7XG4gICAgICB2YXIga2VlcFpvb21MYXllciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgICB2YXIga2VlcEFubm90YXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHRoaXMuY2FuY2VsUmVuZGVyaW5nKGtlZXBBbm5vdGF0aW9ucyk7XG4gICAgICB0aGlzLnJlbmRlcmluZ1N0YXRlID0gX3BkZl9yZW5kZXJpbmdfcXVldWUuUmVuZGVyaW5nU3RhdGVzLklOSVRJQUw7XG4gICAgICB2YXIgZGl2ID0gdGhpcy5kaXY7XG4gICAgICBkaXYuc3R5bGUud2lkdGggPSBNYXRoLmZsb29yKHRoaXMudmlld3BvcnQud2lkdGgpICsgXCJweFwiO1xuICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IE1hdGguZmxvb3IodGhpcy52aWV3cG9ydC5oZWlnaHQpICsgXCJweFwiO1xuICAgICAgdmFyIGNoaWxkTm9kZXMgPSBkaXYuY2hpbGROb2RlcztcbiAgICAgIHZhciBjdXJyZW50Wm9vbUxheWVyTm9kZSA9IGtlZXBab29tTGF5ZXIgJiYgdGhpcy56b29tTGF5ZXIgfHwgbnVsbDtcbiAgICAgIHZhciBjdXJyZW50QW5ub3RhdGlvbk5vZGUgPSBrZWVwQW5ub3RhdGlvbnMgJiYgdGhpcy5hbm5vdGF0aW9uTGF5ZXIgJiYgdGhpcy5hbm5vdGF0aW9uTGF5ZXIuZGl2IHx8IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSBjaGlsZE5vZGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBub2RlID0gY2hpbGROb2Rlc1tpXTtcblxuICAgICAgICBpZiAoY3VycmVudFpvb21MYXllck5vZGUgPT09IG5vZGUgfHwgY3VycmVudEFubm90YXRpb25Ob2RlID09PSBub2RlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBkaXYucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG5cbiAgICAgIGRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLWxvYWRlZFwiKTtcblxuICAgICAgaWYgKGN1cnJlbnRBbm5vdGF0aW9uTm9kZSkge1xuICAgICAgICB0aGlzLmFubm90YXRpb25MYXllci5oaWRlKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkxheWVyLmNhbmNlbCgpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25MYXllciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICghY3VycmVudFpvb21MYXllck5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgdGhpcy5wYWludGVkVmlld3BvcnRNYXBbXCJkZWxldGVcIl0odGhpcy5jYW52YXMpO1xuICAgICAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gMDtcbiAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhcztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Jlc2V0Wm9vbUxheWVyKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnN2Zykge1xuICAgICAgICB0aGlzLnBhaW50ZWRWaWV3cG9ydE1hcFtcImRlbGV0ZVwiXSh0aGlzLnN2Zyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnN2ZztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2FkaW5nSWNvbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICB0aGlzLmxvYWRpbmdJY29uRGl2LmNsYXNzTmFtZSA9IFwibG9hZGluZ0ljb25cIjtcbiAgICAgIGRpdi5hcHBlbmRDaGlsZCh0aGlzLmxvYWRpbmdJY29uRGl2KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZShzY2FsZSwgcm90YXRpb24pIHtcbiAgICAgIHZhciBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlIHx8IHRoaXMuc2NhbGU7XG5cbiAgICAgIGlmICh0eXBlb2Ygcm90YXRpb24gIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhpcy5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAob3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSA9IG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2U7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbFJvdGF0aW9uID0gKHRoaXMucm90YXRpb24gKyB0aGlzLnBkZlBhZ2VSb3RhdGUpICUgMzYwO1xuICAgICAgdGhpcy52aWV3cG9ydCA9IHRoaXMudmlld3BvcnQuY2xvbmUoe1xuICAgICAgICBzY2FsZTogdGhpcy5zY2FsZSAqIF91aV91dGlscy5DU1NfVU5JVFMsXG4gICAgICAgIHJvdGF0aW9uOiB0b3RhbFJvdGF0aW9uXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuc3ZnKSB7XG4gICAgICAgIHRoaXMuY3NzVHJhbnNmb3JtKHRoaXMuc3ZnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5kaXNwYXRjaChcInBhZ2VyZW5kZXJlZFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIHBhZ2VOdW1iZXI6IHRoaXMuaWQsXG4gICAgICAgICAgY3NzVHJhbnNmb3JtOiB0cnVlLFxuICAgICAgICAgIHRpbWVzdGFtcDogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGlzU2NhbGluZ1Jlc3RyaWN0ZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMuY2FudmFzICYmIHRoaXMubWF4Q2FudmFzUGl4ZWxzID4gMCkge1xuICAgICAgICB2YXIgb3V0cHV0U2NhbGUgPSB0aGlzLm91dHB1dFNjYWxlO1xuXG4gICAgICAgIGlmICgoTWF0aC5mbG9vcih0aGlzLnZpZXdwb3J0LndpZHRoKSAqIG91dHB1dFNjYWxlLnN4IHwgMCkgKiAoTWF0aC5mbG9vcih0aGlzLnZpZXdwb3J0LmhlaWdodCkgKiBvdXRwdXRTY2FsZS5zeSB8IDApID4gdGhpcy5tYXhDYW52YXNQaXhlbHMpIHtcbiAgICAgICAgICBpc1NjYWxpbmdSZXN0cmljdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5jYW52YXMpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlT25seUNzc1pvb20gfHwgdGhpcy5oYXNSZXN0cmljdGVkU2NhbGluZyAmJiBpc1NjYWxpbmdSZXN0cmljdGVkKSB7XG4gICAgICAgICAgdGhpcy5jc3NUcmFuc2Zvcm0odGhpcy5jYW52YXMsIHRydWUpO1xuICAgICAgICAgIHRoaXMuZXZlbnRCdXMuZGlzcGF0Y2goXCJwYWdlcmVuZGVyZWRcIiwge1xuICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgcGFnZU51bWJlcjogdGhpcy5pZCxcbiAgICAgICAgICAgIGNzc1RyYW5zZm9ybTogdHJ1ZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuem9vbUxheWVyICYmICF0aGlzLmNhbnZhcy5oYXNBdHRyaWJ1dGUoXCJoaWRkZW5cIikpIHtcbiAgICAgICAgICB0aGlzLnpvb21MYXllciA9IHRoaXMuY2FudmFzLnBhcmVudE5vZGU7XG4gICAgICAgICAgdGhpcy56b29tTGF5ZXIuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuem9vbUxheWVyKSB7XG4gICAgICAgIHRoaXMuY3NzVHJhbnNmb3JtKHRoaXMuem9vbUxheWVyLmZpcnN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc2V0KHRydWUsIHRydWUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYW5jZWxSZW5kZXJpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FuY2VsUmVuZGVyaW5nKCkge1xuICAgICAgdmFyIGtlZXBBbm5vdGF0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnBhaW50VGFzaykge1xuICAgICAgICB0aGlzLnBhaW50VGFzay5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5wYWludFRhc2sgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlc3VtZSA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLnRleHRMYXllcikge1xuICAgICAgICB0aGlzLnRleHRMYXllci5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy50ZXh0TGF5ZXIgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWtlZXBBbm5vdGF0aW9ucyAmJiB0aGlzLmFubm90YXRpb25MYXllcikge1xuICAgICAgICB0aGlzLmFubm90YXRpb25MYXllci5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5hbm5vdGF0aW9uTGF5ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjc3NUcmFuc2Zvcm1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3NzVHJhbnNmb3JtKHRhcmdldCkge1xuICAgICAgdmFyIHJlZHJhd0Fubm90YXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMudmlld3BvcnQud2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy52aWV3cG9ydC5oZWlnaHQ7XG4gICAgICB2YXIgZGl2ID0gdGhpcy5kaXY7XG4gICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSB0YXJnZXQucGFyZW50Tm9kZS5zdHlsZS53aWR0aCA9IGRpdi5zdHlsZS53aWR0aCA9IE1hdGguZmxvb3Iod2lkdGgpICsgXCJweFwiO1xuICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IHRhcmdldC5wYXJlbnROb2RlLnN0eWxlLmhlaWdodCA9IGRpdi5zdHlsZS5oZWlnaHQgPSBNYXRoLmZsb29yKGhlaWdodCkgKyBcInB4XCI7XG4gICAgICB2YXIgcmVsYXRpdmVSb3RhdGlvbiA9IHRoaXMudmlld3BvcnQucm90YXRpb24gLSB0aGlzLnBhaW50ZWRWaWV3cG9ydE1hcC5nZXQodGFyZ2V0KS5yb3RhdGlvbjtcbiAgICAgIHZhciBhYnNSb3RhdGlvbiA9IE1hdGguYWJzKHJlbGF0aXZlUm90YXRpb24pO1xuICAgICAgdmFyIHNjYWxlWCA9IDEsXG4gICAgICAgICAgc2NhbGVZID0gMTtcblxuICAgICAgaWYgKGFic1JvdGF0aW9uID09PSA5MCB8fCBhYnNSb3RhdGlvbiA9PT0gMjcwKSB7XG4gICAgICAgIHNjYWxlWCA9IGhlaWdodCAvIHdpZHRoO1xuICAgICAgICBzY2FsZVkgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdmFyIGNzc1RyYW5zZm9ybSA9IFwicm90YXRlKFwiICsgcmVsYXRpdmVSb3RhdGlvbiArIFwiZGVnKSBcIiArIFwic2NhbGUoXCIgKyBzY2FsZVggKyBcIixcIiArIHNjYWxlWSArIFwiKVwiO1xuICAgICAgdGFyZ2V0LnN0eWxlLnRyYW5zZm9ybSA9IGNzc1RyYW5zZm9ybTtcblxuICAgICAgaWYgKHRoaXMudGV4dExheWVyKSB7XG4gICAgICAgIHZhciB0ZXh0TGF5ZXJWaWV3cG9ydCA9IHRoaXMudGV4dExheWVyLnZpZXdwb3J0O1xuICAgICAgICB2YXIgdGV4dFJlbGF0aXZlUm90YXRpb24gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uIC0gdGV4dExheWVyVmlld3BvcnQucm90YXRpb247XG4gICAgICAgIHZhciB0ZXh0QWJzUm90YXRpb24gPSBNYXRoLmFicyh0ZXh0UmVsYXRpdmVSb3RhdGlvbik7XG4gICAgICAgIHZhciBzY2FsZSA9IHdpZHRoIC8gdGV4dExheWVyVmlld3BvcnQud2lkdGg7XG5cbiAgICAgICAgaWYgKHRleHRBYnNSb3RhdGlvbiA9PT0gOTAgfHwgdGV4dEFic1JvdGF0aW9uID09PSAyNzApIHtcbiAgICAgICAgICBzY2FsZSA9IHdpZHRoIC8gdGV4dExheWVyVmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRleHRMYXllckRpdiA9IHRoaXMudGV4dExheWVyLnRleHRMYXllckRpdjtcbiAgICAgICAgdmFyIHRyYW5zWCwgdHJhbnNZO1xuXG4gICAgICAgIHN3aXRjaCAodGV4dEFic1JvdGF0aW9uKSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgdHJhbnNYID0gdHJhbnNZID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSA5MDpcbiAgICAgICAgICAgIHRyYW5zWCA9IDA7XG4gICAgICAgICAgICB0cmFuc1kgPSBcIi1cIiArIHRleHRMYXllckRpdi5zdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMTgwOlxuICAgICAgICAgICAgdHJhbnNYID0gXCItXCIgKyB0ZXh0TGF5ZXJEaXYuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICB0cmFuc1kgPSBcIi1cIiArIHRleHRMYXllckRpdi5zdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMjcwOlxuICAgICAgICAgICAgdHJhbnNYID0gXCItXCIgKyB0ZXh0TGF5ZXJEaXYuc3R5bGUud2lkdGg7XG4gICAgICAgICAgICB0cmFuc1kgPSAwO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkJhZCByb3RhdGlvbiB2YWx1ZS5cIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHRleHRMYXllckRpdi5zdHlsZS50cmFuc2Zvcm0gPSBcInJvdGF0ZShcIiArIHRleHRBYnNSb3RhdGlvbiArIFwiZGVnKSBcIiArIFwic2NhbGUoXCIgKyBzY2FsZSArIFwiLCBcIiArIHNjYWxlICsgXCIpIFwiICsgXCJ0cmFuc2xhdGUoXCIgKyB0cmFuc1ggKyBcIiwgXCIgKyB0cmFuc1kgKyBcIilcIjtcbiAgICAgICAgdGV4dExheWVyRGl2LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IFwiMCUgMCVcIjtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZHJhd0Fubm90YXRpb25zICYmIHRoaXMuYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlckFubm90YXRpb25MYXllcigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYWdlUG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFnZVBvaW50KHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZpZXdwb3J0LmNvbnZlcnRUb1BkZlBvaW50KHgsIHkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5yZW5kZXJpbmdTdGF0ZSAhPT0gX3BkZl9yZW5kZXJpbmdfcXVldWUuUmVuZGVyaW5nU3RhdGVzLklOSVRJQUwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIk11c3QgYmUgaW4gbmV3IHN0YXRlIGJlZm9yZSBkcmF3aW5nXCIpO1xuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBkaXYgPSB0aGlzLmRpdixcbiAgICAgICAgICBwZGZQYWdlID0gdGhpcy5wZGZQYWdlO1xuXG4gICAgICBpZiAoIXBkZlBhZ2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdTdGF0ZSA9IF9wZGZfcmVuZGVyaW5nX3F1ZXVlLlJlbmRlcmluZ1N0YXRlcy5GSU5JU0hFRDtcblxuICAgICAgICBpZiAodGhpcy5sb2FkaW5nSWNvbkRpdikge1xuICAgICAgICAgIGRpdi5yZW1vdmVDaGlsZCh0aGlzLmxvYWRpbmdJY29uRGl2KTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5sb2FkaW5nSWNvbkRpdjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJwZGZQYWdlIGlzIG5vdCBsb2FkZWRcIikpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlcmluZ1N0YXRlID0gX3BkZl9yZW5kZXJpbmdfcXVldWUuUmVuZGVyaW5nU3RhdGVzLlJVTk5JTkc7XG4gICAgICB2YXIgY2FudmFzV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICBjYW52YXNXcmFwcGVyLnN0eWxlLndpZHRoID0gZGl2LnN0eWxlLndpZHRoO1xuICAgICAgY2FudmFzV3JhcHBlci5zdHlsZS5oZWlnaHQgPSBkaXYuc3R5bGUuaGVpZ2h0O1xuICAgICAgY2FudmFzV3JhcHBlci5jbGFzc0xpc3QuYWRkKFwiY2FudmFzV3JhcHBlclwiKTtcblxuICAgICAgaWYgKHRoaXMuYW5ub3RhdGlvbkxheWVyICYmIHRoaXMuYW5ub3RhdGlvbkxheWVyLmRpdikge1xuICAgICAgICBkaXYuaW5zZXJ0QmVmb3JlKGNhbnZhc1dyYXBwZXIsIHRoaXMuYW5ub3RhdGlvbkxheWVyLmRpdik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoY2FudmFzV3JhcHBlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciB0ZXh0TGF5ZXIgPSBudWxsO1xuXG4gICAgICBpZiAodGhpcy50ZXh0TGF5ZXJNb2RlICE9PSBfdWlfdXRpbHMuVGV4dExheWVyTW9kZS5ESVNBQkxFICYmIHRoaXMudGV4dExheWVyRmFjdG9yeSkge1xuICAgICAgICB2YXIgdGV4dExheWVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGV4dExheWVyRGl2LmNsYXNzTmFtZSA9IFwidGV4dExheWVyXCI7XG4gICAgICAgIHRleHRMYXllckRpdi5zdHlsZS53aWR0aCA9IGNhbnZhc1dyYXBwZXIuc3R5bGUud2lkdGg7XG4gICAgICAgIHRleHRMYXllckRpdi5zdHlsZS5oZWlnaHQgPSBjYW52YXNXcmFwcGVyLnN0eWxlLmhlaWdodDtcblxuICAgICAgICBpZiAodGhpcy5hbm5vdGF0aW9uTGF5ZXIgJiYgdGhpcy5hbm5vdGF0aW9uTGF5ZXIuZGl2KSB7XG4gICAgICAgICAgZGl2Lmluc2VydEJlZm9yZSh0ZXh0TGF5ZXJEaXYsIHRoaXMuYW5ub3RhdGlvbkxheWVyLmRpdik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGl2LmFwcGVuZENoaWxkKHRleHRMYXllckRpdik7XG4gICAgICAgIH1cblxuICAgICAgICB0ZXh0TGF5ZXIgPSB0aGlzLnRleHRMYXllckZhY3RvcnkuY3JlYXRlVGV4dExheWVyQnVpbGRlcih0ZXh0TGF5ZXJEaXYsIHRoaXMuaWQgLSAxLCB0aGlzLnZpZXdwb3J0LCB0aGlzLnRleHRMYXllck1vZGUgPT09IF91aV91dGlscy5UZXh0TGF5ZXJNb2RlLkVOQUJMRV9FTkhBTkNFLCB0aGlzLmV2ZW50QnVzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50ZXh0TGF5ZXIgPSB0ZXh0TGF5ZXI7XG4gICAgICB2YXIgcmVuZGVyQ29udGludWVDYWxsYmFjayA9IG51bGw7XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcmluZ1F1ZXVlKSB7XG4gICAgICAgIHJlbmRlckNvbnRpbnVlQ2FsbGJhY2sgPSBmdW5jdGlvbiByZW5kZXJDb250aW51ZUNhbGxiYWNrKGNvbnQpIHtcbiAgICAgICAgICBpZiAoIV90aGlzLnJlbmRlcmluZ1F1ZXVlLmlzSGlnaGVzdFByaW9yaXR5KF90aGlzKSkge1xuICAgICAgICAgICAgX3RoaXMucmVuZGVyaW5nU3RhdGUgPSBfcGRmX3JlbmRlcmluZ19xdWV1ZS5SZW5kZXJpbmdTdGF0ZXMuUEFVU0VEO1xuXG4gICAgICAgICAgICBfdGhpcy5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF90aGlzLnJlbmRlcmluZ1N0YXRlID0gX3BkZl9yZW5kZXJpbmdfcXVldWUuUmVuZGVyaW5nU3RhdGVzLlJVTk5JTkc7XG4gICAgICAgICAgICAgIGNvbnQoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb250KCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5pc2hQYWludFRhc2sgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICBpZiAocGFpbnRUYXNrID09PSBfdGhpcy5wYWludFRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGFpbnRUYXNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgaWYgKCEoZXJyb3IgaW5zdGFuY2VvZiBfcGRmanNMaWIuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlcmluZ1N0YXRlID0gX3BkZl9yZW5kZXJpbmdfcXVldWUuUmVuZGVyaW5nU3RhdGVzLkZJTklTSEVEO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoX3RoaXMubG9hZGluZ0ljb25EaXYpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LnJlbW92ZUNoaWxkKF90aGlzLmxvYWRpbmdJY29uRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLmxvYWRpbmdJY29uRGl2O1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBfdGhpcy5fcmVzZXRab29tTGF5ZXIodHJ1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICBfdGhpcy5zdGF0cyA9IHBkZlBhZ2Uuc3RhdHM7XG5cbiAgICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50QnVzLmRpc3BhdGNoKFwicGFnZXJlbmRlcmVkXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBfdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgcGFnZU51bWJlcjogX3RoaXMuaWQsXG4gICAgICAgICAgICAgICAgICAgIGNzc1RyYW5zZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogcGVyZm9ybWFuY2Uubm93KClcbiAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoIWVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcblxuICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBfY2FsbGVlMik7XG4gICAgICAgIH0pKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gZmluaXNoUGFpbnRUYXNrKF94KSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oKTtcblxuICAgICAgdmFyIHBhaW50VGFzayA9IHRoaXMucmVuZGVyZXIgPT09IF91aV91dGlscy5SZW5kZXJlclR5cGUuU1ZHID8gdGhpcy5wYWludE9uU3ZnKGNhbnZhc1dyYXBwZXIpIDogdGhpcy5wYWludE9uQ2FudmFzKGNhbnZhc1dyYXBwZXIpO1xuICAgICAgcGFpbnRUYXNrLm9uUmVuZGVyQ29udGludWUgPSByZW5kZXJDb250aW51ZUNhbGxiYWNrO1xuICAgICAgdGhpcy5wYWludFRhc2sgPSBwYWludFRhc2s7XG4gICAgICB2YXIgcmVzdWx0UHJvbWlzZSA9IHBhaW50VGFzay5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmluaXNoUGFpbnRUYXNrKG51bGwpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0ZXh0TGF5ZXIpIHtcbiAgICAgICAgICAgIHZhciByZWFkYWJsZVN0cmVhbSA9IHBkZlBhZ2Uuc3RyZWFtVGV4dENvbnRlbnQoe1xuICAgICAgICAgICAgICBub3JtYWxpemVXaGl0ZXNwYWNlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRleHRMYXllci5zZXRUZXh0Q29udGVudFN0cmVhbShyZWFkYWJsZVN0cmVhbSk7XG4gICAgICAgICAgICB0ZXh0TGF5ZXIucmVuZGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgcmV0dXJuIGZpbmlzaFBhaW50VGFzayhyZWFzb24pO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmFubm90YXRpb25MYXllckZhY3RvcnkpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFubm90YXRpb25MYXllcikge1xuICAgICAgICAgIHRoaXMuYW5ub3RhdGlvbkxheWVyID0gdGhpcy5hbm5vdGF0aW9uTGF5ZXJGYWN0b3J5LmNyZWF0ZUFubm90YXRpb25MYXllckJ1aWxkZXIoZGl2LCBwZGZQYWdlLCB0aGlzLl9hbm5vdGF0aW9uU3RvcmFnZSwgdGhpcy5pbWFnZVJlc291cmNlc1BhdGgsIHRoaXMucmVuZGVySW50ZXJhY3RpdmVGb3JtcywgdGhpcy5sMTBuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbmRlckFubm90YXRpb25MYXllcigpO1xuICAgICAgfVxuXG4gICAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1sb2FkZWRcIiwgdHJ1ZSk7XG4gICAgICB0aGlzLmV2ZW50QnVzLmRpc3BhdGNoKFwicGFnZXJlbmRlclwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgcGFnZU51bWJlcjogdGhpcy5pZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0UHJvbWlzZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFpbnRPbkNhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYWludE9uQ2FudmFzKGNhbnZhc1dyYXBwZXIpIHtcbiAgICAgIHZhciByZW5kZXJDYXBhYmlsaXR5ID0gKDAsIF9wZGZqc0xpYi5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHByb21pc2U6IHJlbmRlckNhcGFiaWxpdHkucHJvbWlzZSxcbiAgICAgICAgb25SZW5kZXJDb250aW51ZTogZnVuY3Rpb24gb25SZW5kZXJDb250aW51ZShjb250KSB7XG4gICAgICAgICAgY29udCgpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICByZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydDtcbiAgICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgdGhpcy5sMTBuLmdldChcInBhZ2VfY2FudmFzXCIsIHtcbiAgICAgICAgcGFnZTogdGhpcy5pZFxuICAgICAgfSwgXCJQYWdlIHt7cGFnZX19XCIpLnRoZW4oZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBtc2cpO1xuICAgICAgfSk7XG4gICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIFwiaGlkZGVuXCIpO1xuICAgICAgdmFyIGlzQ2FudmFzSGlkZGVuID0gdHJ1ZTtcblxuICAgICAgdmFyIHNob3dDYW52YXMgPSBmdW5jdGlvbiBzaG93Q2FudmFzKCkge1xuICAgICAgICBpZiAoaXNDYW52YXNIaWRkZW4pIHtcbiAgICAgICAgICBjYW52YXMucmVtb3ZlQXR0cmlidXRlKFwiaGlkZGVuXCIpO1xuICAgICAgICAgIGlzQ2FudmFzSGlkZGVuID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGNhbnZhc1dyYXBwZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgY2FudmFzLm1vek9wYXF1ZSA9IHRydWU7XG4gICAgICB2YXIgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICAgIGFscGhhOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICB2YXIgb3V0cHV0U2NhbGUgPSAoMCwgX3VpX3V0aWxzLmdldE91dHB1dFNjYWxlKShjdHgpO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZSA9IG91dHB1dFNjYWxlO1xuXG4gICAgICBpZiAodGhpcy51c2VPbmx5Q3NzWm9vbSkge1xuICAgICAgICB2YXIgYWN0dWFsU2l6ZVZpZXdwb3J0ID0gdmlld3BvcnQuY2xvbmUoe1xuICAgICAgICAgIHNjYWxlOiBfdWlfdXRpbHMuQ1NTX1VOSVRTXG4gICAgICAgIH0pO1xuICAgICAgICBvdXRwdXRTY2FsZS5zeCAqPSBhY3R1YWxTaXplVmlld3BvcnQud2lkdGggLyB2aWV3cG9ydC53aWR0aDtcbiAgICAgICAgb3V0cHV0U2NhbGUuc3kgKj0gYWN0dWFsU2l6ZVZpZXdwb3J0LmhlaWdodCAvIHZpZXdwb3J0LmhlaWdodDtcbiAgICAgICAgb3V0cHV0U2NhbGUuc2NhbGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMubWF4Q2FudmFzUGl4ZWxzID4gMCkge1xuICAgICAgICB2YXIgcGl4ZWxzSW5WaWV3cG9ydCA9IHZpZXdwb3J0LndpZHRoICogdmlld3BvcnQuaGVpZ2h0O1xuICAgICAgICB2YXIgbWF4U2NhbGUgPSBNYXRoLnNxcnQodGhpcy5tYXhDYW52YXNQaXhlbHMgLyBwaXhlbHNJblZpZXdwb3J0KTtcblxuICAgICAgICBpZiAob3V0cHV0U2NhbGUuc3ggPiBtYXhTY2FsZSB8fCBvdXRwdXRTY2FsZS5zeSA+IG1heFNjYWxlKSB7XG4gICAgICAgICAgb3V0cHV0U2NhbGUuc3ggPSBtYXhTY2FsZTtcbiAgICAgICAgICBvdXRwdXRTY2FsZS5zeSA9IG1heFNjYWxlO1xuICAgICAgICAgIG91dHB1dFNjYWxlLnNjYWxlZCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5oYXNSZXN0cmljdGVkU2NhbGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oYXNSZXN0cmljdGVkU2NhbGluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzZnggPSAoMCwgX3VpX3V0aWxzLmFwcHJveGltYXRlRnJhY3Rpb24pKG91dHB1dFNjYWxlLnN4KTtcbiAgICAgIHZhciBzZnkgPSAoMCwgX3VpX3V0aWxzLmFwcHJveGltYXRlRnJhY3Rpb24pKG91dHB1dFNjYWxlLnN5KTtcbiAgICAgIGNhbnZhcy53aWR0aCA9ICgwLCBfdWlfdXRpbHMucm91bmRUb0RpdmlkZSkodmlld3BvcnQud2lkdGggKiBvdXRwdXRTY2FsZS5zeCwgc2Z4WzBdKTtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSAoMCwgX3VpX3V0aWxzLnJvdW5kVG9EaXZpZGUpKHZpZXdwb3J0LmhlaWdodCAqIG91dHB1dFNjYWxlLnN5LCBzZnlbMF0pO1xuICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gKDAsIF91aV91dGlscy5yb3VuZFRvRGl2aWRlKSh2aWV3cG9ydC53aWR0aCwgc2Z4WzFdKSArIFwicHhcIjtcbiAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSAoMCwgX3VpX3V0aWxzLnJvdW5kVG9EaXZpZGUpKHZpZXdwb3J0LmhlaWdodCwgc2Z5WzFdKSArIFwicHhcIjtcbiAgICAgIHRoaXMucGFpbnRlZFZpZXdwb3J0TWFwLnNldChjYW52YXMsIHZpZXdwb3J0KTtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSAhb3V0cHV0U2NhbGUuc2NhbGVkID8gbnVsbCA6IFtvdXRwdXRTY2FsZS5zeCwgMCwgMCwgb3V0cHV0U2NhbGUuc3ksIDAsIDBdO1xuICAgICAgdmFyIHJlbmRlckNvbnRleHQgPSB7XG4gICAgICAgIGNhbnZhc0NvbnRleHQ6IGN0eCxcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm0sXG4gICAgICAgIHZpZXdwb3J0OiB0aGlzLnZpZXdwb3J0LFxuICAgICAgICBlbmFibGVXZWJHTDogdGhpcy5lbmFibGVXZWJHTCxcbiAgICAgICAgcmVuZGVySW50ZXJhY3RpdmVGb3JtczogdGhpcy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zLFxuICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlOiB0aGlzLl9vcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlXG4gICAgICB9O1xuICAgICAgdmFyIHJlbmRlclRhc2sgPSB0aGlzLnBkZlBhZ2UucmVuZGVyKHJlbmRlckNvbnRleHQpO1xuXG4gICAgICByZW5kZXJUYXNrLm9uQ29udGludWUgPSBmdW5jdGlvbiAoY29udCkge1xuICAgICAgICBzaG93Q2FudmFzKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5vblJlbmRlckNvbnRpbnVlKSB7XG4gICAgICAgICAgcmVzdWx0Lm9uUmVuZGVyQ29udGludWUoY29udCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udCgpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZW5kZXJUYXNrLnByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNob3dDYW52YXMoKTtcbiAgICAgICAgcmVuZGVyQ2FwYWJpbGl0eS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgc2hvd0NhbnZhcygpO1xuICAgICAgICByZW5kZXJDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhaW50T25TdmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFpbnRPblN2Zyh3cmFwcGVyKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIGNhbmNlbGxlZCA9IGZhbHNlO1xuXG4gICAgICB2YXIgZW5zdXJlTm90Q2FuY2VsbGVkID0gZnVuY3Rpb24gZW5zdXJlTm90Q2FuY2VsbGVkKCkge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IF9wZGZqc0xpYi5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24oXCJSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlIFwiLmNvbmNhdChfdGhpczIuaWQpLCBcInN2Z1wiKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgdmFyIHBkZlBhZ2UgPSB0aGlzLnBkZlBhZ2U7XG4gICAgICB2YXIgYWN0dWFsU2l6ZVZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydC5jbG9uZSh7XG4gICAgICAgIHNjYWxlOiBfdWlfdXRpbHMuQ1NTX1VOSVRTXG4gICAgICB9KTtcbiAgICAgIHZhciBwcm9taXNlID0gcGRmUGFnZS5nZXRPcGVyYXRvckxpc3QoKS50aGVuKGZ1bmN0aW9uIChvcExpc3QpIHtcbiAgICAgICAgZW5zdXJlTm90Q2FuY2VsbGVkKCk7XG4gICAgICAgIHZhciBzdmdHZnggPSBuZXcgX3BkZmpzTGliLlNWR0dyYXBoaWNzKHBkZlBhZ2UuY29tbW9uT2JqcywgcGRmUGFnZS5vYmpzKTtcbiAgICAgICAgcmV0dXJuIHN2Z0dmeC5nZXRTVkcob3BMaXN0LCBhY3R1YWxTaXplVmlld3BvcnQpLnRoZW4oZnVuY3Rpb24gKHN2Zykge1xuICAgICAgICAgIGVuc3VyZU5vdENhbmNlbGxlZCgpO1xuICAgICAgICAgIF90aGlzMi5zdmcgPSBzdmc7XG5cbiAgICAgICAgICBfdGhpczIucGFpbnRlZFZpZXdwb3J0TWFwLnNldChzdmcsIGFjdHVhbFNpemVWaWV3cG9ydCk7XG5cbiAgICAgICAgICBzdmcuc3R5bGUud2lkdGggPSB3cmFwcGVyLnN0eWxlLndpZHRoO1xuICAgICAgICAgIHN2Zy5zdHlsZS5oZWlnaHQgPSB3cmFwcGVyLnN0eWxlLmhlaWdodDtcbiAgICAgICAgICBfdGhpczIucmVuZGVyaW5nU3RhdGUgPSBfcGRmX3JlbmRlcmluZ19xdWV1ZS5SZW5kZXJpbmdTdGF0ZXMuRklOSVNIRUQ7XG4gICAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogcHJvbWlzZSxcbiAgICAgICAgb25SZW5kZXJDb250aW51ZTogZnVuY3Rpb24gb25SZW5kZXJDb250aW51ZShjb250KSB7XG4gICAgICAgICAgY29udCgpO1xuICAgICAgICB9LFxuICAgICAgICBjYW5jZWw6IGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRQYWdlTGFiZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFnZUxhYmVsKGxhYmVsKSB7XG4gICAgICB0aGlzLnBhZ2VMYWJlbCA9IHR5cGVvZiBsYWJlbCA9PT0gXCJzdHJpbmdcIiA/IGxhYmVsIDogbnVsbDtcblxuICAgICAgaWYgKHRoaXMucGFnZUxhYmVsICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImRhdGEtcGFnZS1sYWJlbFwiLCB0aGlzLnBhZ2VMYWJlbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLXBhZ2UtbGFiZWxcIik7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIndpZHRoXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC53aWR0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGVpZ2h0XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy52aWV3cG9ydC5oZWlnaHQ7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERlBhZ2VWaWV3O1xufSgpO1xuXG5leHBvcnRzLlBERlBhZ2VWaWV3ID0gUERGUGFnZVZpZXc7XG5cbi8qKiovIH0pLFxuLyogMTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMuUERGUmVuZGVyaW5nUXVldWUgPSBleHBvcnRzLlJlbmRlcmluZ1N0YXRlcyA9IHZvaWQgMDtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgQ0xFQU5VUF9USU1FT1VUID0gMzAwMDA7XG52YXIgUmVuZGVyaW5nU3RhdGVzID0ge1xuICBJTklUSUFMOiAwLFxuICBSVU5OSU5HOiAxLFxuICBQQVVTRUQ6IDIsXG4gIEZJTklTSEVEOiAzXG59O1xuZXhwb3J0cy5SZW5kZXJpbmdTdGF0ZXMgPSBSZW5kZXJpbmdTdGF0ZXM7XG5cbnZhciBQREZSZW5kZXJpbmdRdWV1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFBERlJlbmRlcmluZ1F1ZXVlKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQREZSZW5kZXJpbmdRdWV1ZSk7XG5cbiAgICB0aGlzLnBkZlZpZXdlciA9IG51bGw7XG4gICAgdGhpcy5wZGZUaHVtYm5haWxWaWV3ZXIgPSBudWxsO1xuICAgIHRoaXMub25JZGxlID0gbnVsbDtcbiAgICB0aGlzLmhpZ2hlc3RQcmlvcml0eVBhZ2UgPSBudWxsO1xuICAgIHRoaXMuaWRsZVRpbWVvdXQgPSBudWxsO1xuICAgIHRoaXMucHJpbnRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzVGh1bWJuYWlsVmlld0VuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZSZW5kZXJpbmdRdWV1ZSwgW3tcbiAgICBrZXk6IFwic2V0Vmlld2VyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFZpZXdlcihwZGZWaWV3ZXIpIHtcbiAgICAgIHRoaXMucGRmVmlld2VyID0gcGRmVmlld2VyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRUaHVtYm5haWxWaWV3ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VGh1bWJuYWlsVmlld2VyKHBkZlRodW1ibmFpbFZpZXdlcikge1xuICAgICAgdGhpcy5wZGZUaHVtYm5haWxWaWV3ZXIgPSBwZGZUaHVtYm5haWxWaWV3ZXI7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSGlnaGVzdFByaW9yaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzSGlnaGVzdFByaW9yaXR5KHZpZXcpIHtcbiAgICAgIHJldHVybiB0aGlzLmhpZ2hlc3RQcmlvcml0eVBhZ2UgPT09IHZpZXcucmVuZGVyaW5nSWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckhpZ2hlc3RQcmlvcml0eVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJIaWdoZXN0UHJpb3JpdHkoY3VycmVudGx5VmlzaWJsZVBhZ2VzKSB7XG4gICAgICBpZiAodGhpcy5pZGxlVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZW91dCk7XG4gICAgICAgIHRoaXMuaWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5wZGZWaWV3ZXIuZm9yY2VSZW5kZXJpbmcoY3VycmVudGx5VmlzaWJsZVBhZ2VzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnBkZlRodW1ibmFpbFZpZXdlciAmJiB0aGlzLmlzVGh1bWJuYWlsVmlld0VuYWJsZWQpIHtcbiAgICAgICAgaWYgKHRoaXMucGRmVGh1bWJuYWlsVmlld2VyLmZvcmNlUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMucHJpbnRpbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5vbklkbGUpIHtcbiAgICAgICAgdGhpcy5pZGxlVGltZW91dCA9IHNldFRpbWVvdXQodGhpcy5vbklkbGUuYmluZCh0aGlzKSwgQ0xFQU5VUF9USU1FT1VUKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SGlnaGVzdFByaW9yaXR5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eSh2aXNpYmxlLCB2aWV3cywgc2Nyb2xsZWREb3duKSB7XG4gICAgICB2YXIgdmlzaWJsZVZpZXdzID0gdmlzaWJsZS52aWV3cztcbiAgICAgIHZhciBudW1WaXNpYmxlID0gdmlzaWJsZVZpZXdzLmxlbmd0aDtcblxuICAgICAgaWYgKG51bVZpc2libGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVmlzaWJsZTsgKytpKSB7XG4gICAgICAgIHZhciB2aWV3ID0gdmlzaWJsZVZpZXdzW2ldLnZpZXc7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmlld0ZpbmlzaGVkKHZpZXcpKSB7XG4gICAgICAgICAgcmV0dXJuIHZpZXc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjcm9sbGVkRG93bikge1xuICAgICAgICB2YXIgbmV4dFBhZ2VJbmRleCA9IHZpc2libGUubGFzdC5pZDtcblxuICAgICAgICBpZiAodmlld3NbbmV4dFBhZ2VJbmRleF0gJiYgIXRoaXMuaXNWaWV3RmluaXNoZWQodmlld3NbbmV4dFBhZ2VJbmRleF0pKSB7XG4gICAgICAgICAgcmV0dXJuIHZpZXdzW25leHRQYWdlSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJldmlvdXNQYWdlSW5kZXggPSB2aXNpYmxlLmZpcnN0LmlkIC0gMjtcblxuICAgICAgICBpZiAodmlld3NbcHJldmlvdXNQYWdlSW5kZXhdICYmICF0aGlzLmlzVmlld0ZpbmlzaGVkKHZpZXdzW3ByZXZpb3VzUGFnZUluZGV4XSkpIHtcbiAgICAgICAgICByZXR1cm4gdmlld3NbcHJldmlvdXNQYWdlSW5kZXhdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc1ZpZXdGaW5pc2hlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1ZpZXdGaW5pc2hlZCh2aWV3KSB7XG4gICAgICByZXR1cm4gdmlldy5yZW5kZXJpbmdTdGF0ZSA9PT0gUmVuZGVyaW5nU3RhdGVzLkZJTklTSEVEO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJWaWV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclZpZXcodmlldykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgc3dpdGNoICh2aWV3LnJlbmRlcmluZ1N0YXRlKSB7XG4gICAgICAgIGNhc2UgUmVuZGVyaW5nU3RhdGVzLkZJTklTSEVEOlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcblxuICAgICAgICBjYXNlIFJlbmRlcmluZ1N0YXRlcy5QQVVTRUQ6XG4gICAgICAgICAgdGhpcy5oaWdoZXN0UHJpb3JpdHlQYWdlID0gdmlldy5yZW5kZXJpbmdJZDtcbiAgICAgICAgICB2aWV3LnJlc3VtZSgpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUmVuZGVyaW5nU3RhdGVzLlJVTk5JTkc6XG4gICAgICAgICAgdGhpcy5oaWdoZXN0UHJpb3JpdHlQYWdlID0gdmlldy5yZW5kZXJpbmdJZDtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJlbmRlcmluZ1N0YXRlcy5JTklUSUFMOlxuICAgICAgICAgIHRoaXMuaGlnaGVzdFByaW9yaXR5UGFnZSA9IHZpZXcucmVuZGVyaW5nSWQ7XG4gICAgICAgICAgdmlldy5kcmF3KClbXCJmaW5hbGx5XCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnJlbmRlckhpZ2hlc3RQcmlvcml0eSgpO1xuICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcInJlbmRlclZpZXc6IFxcXCJcIi5jb25jYXQocmVhc29uLCBcIlxcXCJcIikpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGUmVuZGVyaW5nUXVldWU7XG59KCk7XG5cbmV4cG9ydHMuUERGUmVuZGVyaW5nUXVldWUgPSBQREZSZW5kZXJpbmdRdWV1ZTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5QREZTaW5nbGVQYWdlVmlld2VyID0gdm9pZCAwO1xuXG52YXIgX2Jhc2Vfdmlld2VyID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG5cbnZhciBfcGRmanNMaWIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuXG5mdW5jdGlvbiBfdHlwZW9mKG9iaikgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH1cblxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH1cblxuZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHsgX2dldCA9IFJlZmxlY3QuZ2V0OyB9IGVsc2UgeyBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikgeyB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpOyBpZiAoIWJhc2UpIHJldHVybjsgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2UsIHByb3BlcnR5KTsgaWYgKGRlc2MuZ2V0KSB7IHJldHVybiBkZXNjLmdldC5jYWxsKHJlY2VpdmVyKTsgfSByZXR1cm4gZGVzYy52YWx1ZTsgfTsgfSByZXR1cm4gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlciB8fCB0YXJnZXQpOyB9XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHsgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHsgb2JqZWN0ID0gX2dldFByb3RvdHlwZU9mKG9iamVjdCk7IGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrOyB9IHJldHVybiBvYmplY3Q7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7IH1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHsgX3NldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IG8uX19wcm90b19fID0gcDsgcmV0dXJuIG87IH07IHJldHVybiBfc2V0UHJvdG90eXBlT2YobywgcCk7IH1cblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkgeyByZXR1cm4gY2FsbDsgfSByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTsgfVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKFJlZmxlY3QuY29uc3RydWN0KERhdGUsIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YobykgeyByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pOyB9OyByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pOyB9XG5cbnZhciBQREZTaW5nbGVQYWdlVmlld2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVZpZXdlcikge1xuICBfaW5oZXJpdHMoUERGU2luZ2xlUGFnZVZpZXdlciwgX0Jhc2VWaWV3ZXIpO1xuXG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUERGU2luZ2xlUGFnZVZpZXdlcik7XG5cbiAgZnVuY3Rpb24gUERGU2luZ2xlUGFnZVZpZXdlcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBERlNpbmdsZVBhZ2VWaWV3ZXIpO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICAgIF90aGlzLmV2ZW50QnVzLl9vbihcInBhZ2VzaW5pdFwiLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICBfdGhpcy5fZW5zdXJlUGFnZVZpZXdWaXNpYmxlKCk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoUERGU2luZ2xlUGFnZVZpZXdlciwgW3tcbiAgICBrZXk6IFwiX3Jlc2V0Vmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVzZXRWaWV3KCkge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoUERGU2luZ2xlUGFnZVZpZXdlci5wcm90b3R5cGUpLCBcIl9yZXNldFZpZXdcIiwgdGhpcykuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5fcHJldmlvdXNQYWdlTnVtYmVyID0gMTtcbiAgICAgIHRoaXMuX3NoYWRvd1ZpZXdlciA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbERvd24gPSBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZW5zdXJlUGFnZVZpZXdWaXNpYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVQYWdlVmlld1Zpc2libGUoKSB7XG4gICAgICB2YXIgcGFnZVZpZXcgPSB0aGlzLl9wYWdlc1t0aGlzLl9jdXJyZW50UGFnZU51bWJlciAtIDFdO1xuICAgICAgdmFyIHByZXZpb3VzUGFnZVZpZXcgPSB0aGlzLl9wYWdlc1t0aGlzLl9wcmV2aW91c1BhZ2VOdW1iZXIgLSAxXTtcbiAgICAgIHZhciB2aWV3ZXJOb2RlcyA9IHRoaXMudmlld2VyLmNoaWxkTm9kZXM7XG5cbiAgICAgIHN3aXRjaCAodmlld2VyTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICB0aGlzLnZpZXdlci5hcHBlbmRDaGlsZChwYWdlVmlldy5kaXYpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAodmlld2VyTm9kZXNbMF0gIT09IHByZXZpb3VzUGFnZVZpZXcuZGl2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfZW5zdXJlUGFnZVZpZXdWaXNpYmxlOiBVbmV4cGVjdGVkIHByZXZpb3VzbHkgdmlzaWJsZSBwYWdlLlwiKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFnZVZpZXcgPT09IHByZXZpb3VzUGFnZVZpZXcpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMuX3NoYWRvd1ZpZXdlci5hcHBlbmRDaGlsZChwcmV2aW91c1BhZ2VWaWV3LmRpdik7XG5cbiAgICAgICAgICB0aGlzLnZpZXdlci5hcHBlbmRDaGlsZChwYWdlVmlldy5kaXYpO1xuICAgICAgICAgIHRoaXMuY29udGFpbmVyLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJfZW5zdXJlUGFnZVZpZXdWaXNpYmxlOiBPbmx5IG9uZSBwYWdlIHNob3VsZCBiZSB2aXNpYmxlIGF0IGEgdGltZS5cIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ByZXZpb3VzUGFnZU51bWJlciA9IHRoaXMuX2N1cnJlbnRQYWdlTnVtYmVyO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2Nyb2xsVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY3JvbGxVcGRhdGUoKSB7XG4gICAgICBpZiAodGhpcy5fdXBkYXRlU2Nyb2xsRG93bikge1xuICAgICAgICB0aGlzLl91cGRhdGVTY3JvbGxEb3duKCk7XG4gICAgICB9XG5cbiAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKFBERlNpbmdsZVBhZ2VWaWV3ZXIucHJvdG90eXBlKSwgXCJfc2Nyb2xsVXBkYXRlXCIsIHRoaXMpLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zY3JvbGxJbnRvVmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2Nyb2xsSW50b1ZpZXcoX3JlZikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBwYWdlRGl2ID0gX3JlZi5wYWdlRGl2LFxuICAgICAgICAgIF9yZWYkcGFnZVNwb3QgPSBfcmVmLnBhZ2VTcG90LFxuICAgICAgICAgIHBhZ2VTcG90ID0gX3JlZiRwYWdlU3BvdCA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkcGFnZVNwb3QsXG4gICAgICAgICAgX3JlZiRwYWdlTnVtYmVyID0gX3JlZi5wYWdlTnVtYmVyLFxuICAgICAgICAgIHBhZ2VOdW1iZXIgPSBfcmVmJHBhZ2VOdW1iZXIgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJHBhZ2VOdW1iZXI7XG5cbiAgICAgIGlmIChwYWdlTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3NldEN1cnJlbnRQYWdlTnVtYmVyKHBhZ2VOdW1iZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2Nyb2xsZWREb3duID0gdGhpcy5fY3VycmVudFBhZ2VOdW1iZXIgPj0gdGhpcy5fcHJldmlvdXNQYWdlTnVtYmVyO1xuXG4gICAgICB0aGlzLl9lbnN1cmVQYWdlVmlld1Zpc2libGUoKTtcblxuICAgICAgdGhpcy51cGRhdGUoKTtcblxuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoUERGU2luZ2xlUGFnZVZpZXdlci5wcm90b3R5cGUpLCBcIl9zY3JvbGxJbnRvVmlld1wiLCB0aGlzKS5jYWxsKHRoaXMsIHtcbiAgICAgICAgcGFnZURpdjogcGFnZURpdixcbiAgICAgICAgcGFnZVNwb3Q6IHBhZ2VTcG90LFxuICAgICAgICBwYWdlTnVtYmVyOiBwYWdlTnVtYmVyXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsRG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNjcm9sbC5kb3duID0gc2Nyb2xsZWREb3duO1xuICAgICAgICBfdGhpczIuX3VwZGF0ZVNjcm9sbERvd24gPSBudWxsO1xuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFZpc2libGVQYWdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0VmlzaWJsZVBhZ2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldEN1cnJlbnRWaXNpYmxlUGFnZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlSGVscGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVIZWxwZXIodmlzaWJsZVBhZ2VzKSB7fVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTY3JvbGxNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTY3JvbGxNb2RlKCkge31cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlU3ByZWFkTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU3ByZWFkTW9kZSgpIHt9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZpZXdlckVsZW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAoMCwgX3BkZmpzTGliLnNoYWRvdykodGhpcywgXCJfdmlld2VyRWxlbWVudFwiLCB0aGlzLl9zaGFkb3dWaWV3ZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNTY3JvbGxNb2RlSG9yaXpvbnRhbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICgwLCBfcGRmanNMaWIuc2hhZG93KSh0aGlzLCBcIl9pc1Njcm9sbE1vZGVIb3Jpem9udGFsXCIsIGZhbHNlKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUERGU2luZ2xlUGFnZVZpZXdlcjtcbn0oX2Jhc2Vfdmlld2VyLkJhc2VWaWV3ZXIpO1xuXG5leHBvcnRzLlBERlNpbmdsZVBhZ2VWaWV3ZXIgPSBQREZTaW5nbGVQYWdlVmlld2VyO1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLkJhc2VWaWV3ZXIgPSB2b2lkIDA7XG5cbnZhciBfdWlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xuXG52YXIgX3BkZl9yZW5kZXJpbmdfcXVldWUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3KTtcblxudmFyIF9hbm5vdGF0aW9uX2xheWVyX2J1aWxkZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3BkZmpzTGliID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxudmFyIF9wZGZfcGFnZV92aWV3ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNik7XG5cbnZhciBfcGRmX2xpbmtfc2VydmljZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG5cbnZhciBfdGV4dF9sYXllcl9idWlsZGVyID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0OyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJ1bmRlZmluZWRcIiB8fCBvW1N5bWJvbC5pdGVyYXRvcl0gPT0gbnVsbCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBvW1N5bWJvbC5pdGVyYXRvcl0oKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgREVGQVVMVF9DQUNIRV9TSVpFID0gMTA7XG5cbmZ1bmN0aW9uIFBERlBhZ2VWaWV3QnVmZmVyKHNpemUpIHtcbiAgdmFyIGRhdGEgPSBbXTtcblxuICB0aGlzLnB1c2ggPSBmdW5jdGlvbiAodmlldykge1xuICAgIHZhciBpID0gZGF0YS5pbmRleE9mKHZpZXcpO1xuXG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgZGF0YS5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgZGF0YS5wdXNoKHZpZXcpO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gc2l6ZSkge1xuICAgICAgZGF0YS5zaGlmdCgpLmRlc3Ryb3koKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5yZXNpemUgPSBmdW5jdGlvbiAobmV3U2l6ZSwgcGFnZXNUb0tlZXApIHtcbiAgICBzaXplID0gbmV3U2l6ZTtcblxuICAgIGlmIChwYWdlc1RvS2VlcCkge1xuICAgICAgdmFyIHBhZ2VJZHNUb0tlZXAgPSBuZXcgU2V0KCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBpTWF4ID0gcGFnZXNUb0tlZXAubGVuZ3RoOyBpIDwgaU1heDsgKytpKSB7XG4gICAgICAgIHBhZ2VJZHNUb0tlZXAuYWRkKHBhZ2VzVG9LZWVwW2ldLmlkKTtcbiAgICAgIH1cblxuICAgICAgKDAsIF91aV91dGlscy5tb3ZlVG9FbmRPZkFycmF5KShkYXRhLCBmdW5jdGlvbiAocGFnZSkge1xuICAgICAgICByZXR1cm4gcGFnZUlkc1RvS2VlcC5oYXMocGFnZS5pZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB3aGlsZSAoZGF0YS5sZW5ndGggPiBzaXplKSB7XG4gICAgICBkYXRhLnNoaWZ0KCkuZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNTYW1lU2NhbGUob2xkU2NhbGUsIG5ld1NjYWxlKSB7XG4gIGlmIChuZXdTY2FsZSA9PT0gb2xkU2NhbGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmIChNYXRoLmFicyhuZXdTY2FsZSAtIG9sZFNjYWxlKSA8IDFlLTE1KSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBCYXNlVmlld2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQmFzZVZpZXdlcihvcHRpb25zKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCYXNlVmlld2VyKTtcblxuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlVmlld2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlVmlld2VyLlwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy52aWV3ZXIgPSBvcHRpb25zLnZpZXdlciB8fCBvcHRpb25zLmNvbnRhaW5lci5maXJzdEVsZW1lbnRDaGlsZDtcblxuICAgIGlmICghKHRoaXMuY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTERpdkVsZW1lbnQgJiYgdGhpcy52aWV3ZXIgaW5zdGFuY2VvZiBIVE1MRGl2RWxlbWVudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYGNvbnRhaW5lcmAgYW5kL29yIGB2aWV3ZXJgIG9wdGlvbi5cIik7XG4gICAgfVxuXG4gICAgdGhpcy5ldmVudEJ1cyA9IG9wdGlvbnMuZXZlbnRCdXM7XG4gICAgdGhpcy5saW5rU2VydmljZSA9IG9wdGlvbnMubGlua1NlcnZpY2UgfHwgbmV3IF9wZGZfbGlua19zZXJ2aWNlLlNpbXBsZUxpbmtTZXJ2aWNlKCk7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXIgPSBvcHRpb25zLmRvd25sb2FkTWFuYWdlciB8fCBudWxsO1xuICAgIHRoaXMuZmluZENvbnRyb2xsZXIgPSBvcHRpb25zLmZpbmRDb250cm9sbGVyIHx8IG51bGw7XG4gICAgdGhpcy5yZW1vdmVQYWdlQm9yZGVycyA9IG9wdGlvbnMucmVtb3ZlUGFnZUJvcmRlcnMgfHwgZmFsc2U7XG4gICAgdGhpcy50ZXh0TGF5ZXJNb2RlID0gTnVtYmVyLmlzSW50ZWdlcihvcHRpb25zLnRleHRMYXllck1vZGUpID8gb3B0aW9ucy50ZXh0TGF5ZXJNb2RlIDogX3VpX3V0aWxzLlRleHRMYXllck1vZGUuRU5BQkxFO1xuICAgIHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoID0gb3B0aW9ucy5pbWFnZVJlc291cmNlc1BhdGggfHwgXCJcIjtcbiAgICB0aGlzLnJlbmRlckludGVyYWN0aXZlRm9ybXMgPSB0eXBlb2Ygb3B0aW9ucy5yZW5kZXJJbnRlcmFjdGl2ZUZvcm1zID09PSBcImJvb2xlYW5cIiA/IG9wdGlvbnMucmVuZGVySW50ZXJhY3RpdmVGb3JtcyA6IHRydWU7XG4gICAgdGhpcy5lbmFibGVQcmludEF1dG9Sb3RhdGUgPSBvcHRpb25zLmVuYWJsZVByaW50QXV0b1JvdGF0ZSB8fCBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gb3B0aW9ucy5yZW5kZXJlciB8fCBfdWlfdXRpbHMuUmVuZGVyZXJUeXBlLkNBTlZBUztcbiAgICB0aGlzLmVuYWJsZVdlYkdMID0gb3B0aW9ucy5lbmFibGVXZWJHTCB8fCBmYWxzZTtcbiAgICB0aGlzLnVzZU9ubHlDc3Nab29tID0gb3B0aW9ucy51c2VPbmx5Q3NzWm9vbSB8fCBmYWxzZTtcbiAgICB0aGlzLm1heENhbnZhc1BpeGVscyA9IG9wdGlvbnMubWF4Q2FudmFzUGl4ZWxzO1xuICAgIHRoaXMubDEwbiA9IG9wdGlvbnMubDEwbiB8fCBfdWlfdXRpbHMuTnVsbEwxMG47XG4gICAgdGhpcy5kZWZhdWx0UmVuZGVyaW5nUXVldWUgPSAhb3B0aW9ucy5yZW5kZXJpbmdRdWV1ZTtcblxuICAgIGlmICh0aGlzLmRlZmF1bHRSZW5kZXJpbmdRdWV1ZSkge1xuICAgICAgdGhpcy5yZW5kZXJpbmdRdWV1ZSA9IG5ldyBfcGRmX3JlbmRlcmluZ19xdWV1ZS5QREZSZW5kZXJpbmdRdWV1ZSgpO1xuICAgICAgdGhpcy5yZW5kZXJpbmdRdWV1ZS5zZXRWaWV3ZXIodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyaW5nUXVldWUgPSBvcHRpb25zLnJlbmRlcmluZ1F1ZXVlO1xuICAgIH1cblxuICAgIHRoaXMuc2Nyb2xsID0gKDAsIF91aV91dGlscy53YXRjaFNjcm9sbCkodGhpcy5jb250YWluZXIsIHRoaXMuX3Njcm9sbFVwZGF0ZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLnByZXNlbnRhdGlvbk1vZGVTdGF0ZSA9IF91aV91dGlscy5QcmVzZW50YXRpb25Nb2RlU3RhdGUuVU5LTk9XTjtcbiAgICB0aGlzLl9vbkJlZm9yZURyYXcgPSB0aGlzLl9vbkFmdGVyRHJhdyA9IG51bGw7XG5cbiAgICB0aGlzLl9yZXNldFZpZXcoKTtcblxuICAgIGlmICh0aGlzLnJlbW92ZVBhZ2VCb3JkZXJzKSB7XG4gICAgICB0aGlzLnZpZXdlci5jbGFzc0xpc3QuYWRkKFwicmVtb3ZlUGFnZUJvcmRlcnNcIik7XG4gICAgfVxuXG4gICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBfdGhpcy5ldmVudEJ1cy5kaXNwYXRjaChcImJhc2V2aWV3ZXJpbml0XCIsIHtcbiAgICAgICAgc291cmNlOiBfdGhpc1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQmFzZVZpZXdlciwgW3tcbiAgICBrZXk6IFwiZ2V0UGFnZVZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFnZVZpZXcoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlc1tpbmRleF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9zZXRDdXJyZW50UGFnZU51bWJlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0Q3VycmVudFBhZ2VOdW1iZXIodmFsKSB7XG4gICAgICB2YXIgcmVzZXRDdXJyZW50UGFnZVZpZXcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgICBpZiAodGhpcy5fY3VycmVudFBhZ2VOdW1iZXIgPT09IHZhbCkge1xuICAgICAgICBpZiAocmVzZXRDdXJyZW50UGFnZVZpZXcpIHtcbiAgICAgICAgICB0aGlzLl9yZXNldEN1cnJlbnRQYWdlVmlldygpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmICghKDAgPCB2YWwgJiYgdmFsIDw9IHRoaXMucGFnZXNDb3VudCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jdXJyZW50UGFnZU51bWJlciA9IHZhbDtcbiAgICAgIHRoaXMuZXZlbnRCdXMuZGlzcGF0Y2goXCJwYWdlY2hhbmdpbmdcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIHBhZ2VOdW1iZXI6IHZhbCxcbiAgICAgICAgcGFnZUxhYmVsOiB0aGlzLl9wYWdlTGFiZWxzICYmIHRoaXMuX3BhZ2VMYWJlbHNbdmFsIC0gMV1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAocmVzZXRDdXJyZW50UGFnZVZpZXcpIHtcbiAgICAgICAgdGhpcy5fcmVzZXRDdXJyZW50UGFnZVZpZXcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9vbmVQYWdlUmVuZGVyZWRPckZvcmNlRmV0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX29uZVBhZ2VSZW5kZXJlZE9yRm9yY2VGZXRjaCgpIHtcbiAgICAgIGlmICghdGhpcy5jb250YWluZXIub2Zmc2V0UGFyZW50IHx8IHRoaXMuX2dldFZpc2libGVQYWdlcygpLnZpZXdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLl9vbmVQYWdlUmVuZGVyZWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldERvY3VtZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldERvY3VtZW50KHBkZkRvY3VtZW50KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMucGRmRG9jdW1lbnQpIHtcbiAgICAgICAgdGhpcy5fY2FuY2VsUmVuZGVyaW5nKCk7XG5cbiAgICAgICAgdGhpcy5fcmVzZXRWaWV3KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZmluZENvbnRyb2xsZXIpIHtcbiAgICAgICAgICB0aGlzLmZpbmRDb250cm9sbGVyLnNldERvY3VtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGRmRG9jdW1lbnQgPSBwZGZEb2N1bWVudDtcblxuICAgICAgaWYgKCFwZGZEb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWdlc0NvdW50ID0gcGRmRG9jdW1lbnQubnVtUGFnZXM7XG4gICAgICB2YXIgZmlyc3RQYWdlUHJvbWlzZSA9IHBkZkRvY3VtZW50LmdldFBhZ2UoMSk7XG4gICAgICB2YXIgYW5ub3RhdGlvblN0b3JhZ2UgPSBwZGZEb2N1bWVudC5hbm5vdGF0aW9uU3RvcmFnZTtcbiAgICAgIHZhciBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gcGRmRG9jdW1lbnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG5cbiAgICAgIHRoaXMuX3BhZ2VzQ2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZXZlbnRCdXMuZGlzcGF0Y2goXCJwYWdlc2xvYWRlZFwiLCB7XG4gICAgICAgICAgc291cmNlOiBfdGhpczIsXG4gICAgICAgICAgcGFnZXNDb3VudDogcGFnZXNDb3VudFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9vbkJlZm9yZURyYXcgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciBwYWdlVmlldyA9IF90aGlzMi5fcGFnZXNbZXZ0LnBhZ2VOdW1iZXIgLSAxXTtcblxuICAgICAgICBpZiAoIXBhZ2VWaWV3KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLl9idWZmZXIucHVzaChwYWdlVmlldyk7XG4gICAgICB9O1xuXG4gICAgICB0aGlzLmV2ZW50QnVzLl9vbihcInBhZ2VyZW5kZXJcIiwgdGhpcy5fb25CZWZvcmVEcmF3KTtcblxuICAgICAgdGhpcy5fb25BZnRlckRyYXcgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIGlmIChldnQuY3NzVHJhbnNmb3JtIHx8IF90aGlzMi5fb25lUGFnZVJlbmRlcmVkQ2FwYWJpbGl0eS5zZXR0bGVkKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMyLl9vbmVQYWdlUmVuZGVyZWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgICBfdGhpczIuZXZlbnRCdXMuX29mZihcInBhZ2VyZW5kZXJlZFwiLCBfdGhpczIuX29uQWZ0ZXJEcmF3KTtcblxuICAgICAgICBfdGhpczIuX29uQWZ0ZXJEcmF3ID0gbnVsbDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuZXZlbnRCdXMuX29uKFwicGFnZXJlbmRlcmVkXCIsIHRoaXMuX29uQWZ0ZXJEcmF3KTtcblxuICAgICAgZmlyc3RQYWdlUHJvbWlzZS50aGVuKGZ1bmN0aW9uIChmaXJzdFBkZlBhZ2UpIHtcbiAgICAgICAgX3RoaXMyLl9maXJzdFBhZ2VDYXBhYmlsaXR5LnJlc29sdmUoZmlyc3RQZGZQYWdlKTtcblxuICAgICAgICBfdGhpczIuX29wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlO1xuICAgICAgICB2YXIgc2NhbGUgPSBfdGhpczIuY3VycmVudFNjYWxlO1xuICAgICAgICB2YXIgdmlld3BvcnQgPSBmaXJzdFBkZlBhZ2UuZ2V0Vmlld3BvcnQoe1xuICAgICAgICAgIHNjYWxlOiBzY2FsZSAqIF91aV91dGlscy5DU1NfVU5JVFNcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciB0ZXh0TGF5ZXJGYWN0b3J5ID0gX3RoaXMyLnRleHRMYXllck1vZGUgIT09IF91aV91dGlscy5UZXh0TGF5ZXJNb2RlLkRJU0FCTEUgPyBfdGhpczIgOiBudWxsO1xuXG4gICAgICAgIGZvciAodmFyIHBhZ2VOdW0gPSAxOyBwYWdlTnVtIDw9IHBhZ2VzQ291bnQ7ICsrcGFnZU51bSkge1xuICAgICAgICAgIHZhciBwYWdlVmlldyA9IG5ldyBfcGRmX3BhZ2Vfdmlldy5QREZQYWdlVmlldyh7XG4gICAgICAgICAgICBjb250YWluZXI6IF90aGlzMi5fdmlld2VyRWxlbWVudCxcbiAgICAgICAgICAgIGV2ZW50QnVzOiBfdGhpczIuZXZlbnRCdXMsXG4gICAgICAgICAgICBpZDogcGFnZU51bSxcbiAgICAgICAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgICAgICAgIGRlZmF1bHRWaWV3cG9ydDogdmlld3BvcnQuY2xvbmUoKSxcbiAgICAgICAgICAgIGFubm90YXRpb25TdG9yYWdlOiBhbm5vdGF0aW9uU3RvcmFnZSxcbiAgICAgICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2U6IG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UsXG4gICAgICAgICAgICByZW5kZXJpbmdRdWV1ZTogX3RoaXMyLnJlbmRlcmluZ1F1ZXVlLFxuICAgICAgICAgICAgdGV4dExheWVyRmFjdG9yeTogdGV4dExheWVyRmFjdG9yeSxcbiAgICAgICAgICAgIHRleHRMYXllck1vZGU6IF90aGlzMi50ZXh0TGF5ZXJNb2RlLFxuICAgICAgICAgICAgYW5ub3RhdGlvbkxheWVyRmFjdG9yeTogX3RoaXMyLFxuICAgICAgICAgICAgaW1hZ2VSZXNvdXJjZXNQYXRoOiBfdGhpczIuaW1hZ2VSZXNvdXJjZXNQYXRoLFxuICAgICAgICAgICAgcmVuZGVySW50ZXJhY3RpdmVGb3JtczogX3RoaXMyLnJlbmRlckludGVyYWN0aXZlRm9ybXMsXG4gICAgICAgICAgICByZW5kZXJlcjogX3RoaXMyLnJlbmRlcmVyLFxuICAgICAgICAgICAgZW5hYmxlV2ViR0w6IF90aGlzMi5lbmFibGVXZWJHTCxcbiAgICAgICAgICAgIHVzZU9ubHlDc3Nab29tOiBfdGhpczIudXNlT25seUNzc1pvb20sXG4gICAgICAgICAgICBtYXhDYW52YXNQaXhlbHM6IF90aGlzMi5tYXhDYW52YXNQaXhlbHMsXG4gICAgICAgICAgICBsMTBuOiBfdGhpczIubDEwblxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgX3RoaXMyLl9wYWdlcy5wdXNoKHBhZ2VWaWV3KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBmaXJzdFBhZ2VWaWV3ID0gX3RoaXMyLl9wYWdlc1swXTtcblxuICAgICAgICBpZiAoZmlyc3RQYWdlVmlldykge1xuICAgICAgICAgIGZpcnN0UGFnZVZpZXcuc2V0UGRmUGFnZShmaXJzdFBkZlBhZ2UpO1xuXG4gICAgICAgICAgX3RoaXMyLmxpbmtTZXJ2aWNlLmNhY2hlUGFnZVJlZigxLCBmaXJzdFBkZlBhZ2UucmVmKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfdGhpczIuX3NwcmVhZE1vZGUgIT09IF91aV91dGlscy5TcHJlYWRNb2RlLk5PTkUpIHtcbiAgICAgICAgICBfdGhpczIuX3VwZGF0ZVNwcmVhZE1vZGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5fb25lUGFnZVJlbmRlcmVkT3JGb3JjZUZldGNoKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzMi5maW5kQ29udHJvbGxlcikge1xuICAgICAgICAgICAgX3RoaXMyLmZpbmRDb250cm9sbGVyLnNldERvY3VtZW50KHBkZkRvY3VtZW50KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGRmRG9jdW1lbnQubG9hZGluZ1BhcmFtcy5kaXNhYmxlQXV0b0ZldGNoIHx8IHBhZ2VzQ291bnQgPiA3NTAwKSB7XG4gICAgICAgICAgICBfdGhpczIuX3BhZ2VzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgZ2V0UGFnZXNMZWZ0ID0gcGFnZXNDb3VudCAtIDE7XG5cbiAgICAgICAgICBpZiAoZ2V0UGFnZXNMZWZ0IDw9IDApIHtcbiAgICAgICAgICAgIF90aGlzMi5fcGFnZXNDYXBhYmlsaXR5LnJlc29sdmUoKTtcblxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9wYWdlTnVtKSB7XG4gICAgICAgICAgICBwZGZEb2N1bWVudC5nZXRQYWdlKF9wYWdlTnVtKS50aGVuKGZ1bmN0aW9uIChwZGZQYWdlKSB7XG4gICAgICAgICAgICAgIHZhciBwYWdlVmlldyA9IF90aGlzMi5fcGFnZXNbX3BhZ2VOdW0gLSAxXTtcblxuICAgICAgICAgICAgICBpZiAoIXBhZ2VWaWV3LnBkZlBhZ2UpIHtcbiAgICAgICAgICAgICAgICBwYWdlVmlldy5zZXRQZGZQYWdlKHBkZlBhZ2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX3RoaXMyLmxpbmtTZXJ2aWNlLmNhY2hlUGFnZVJlZihfcGFnZU51bSwgcGRmUGFnZS5yZWYpO1xuXG4gICAgICAgICAgICAgIGlmICgtLWdldFBhZ2VzTGVmdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIF90aGlzMi5fcGFnZXNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGdldCBwYWdlIFwiLmNvbmNhdChfcGFnZU51bSwgXCIgdG8gaW5pdGlhbGl6ZSB2aWV3ZXJcIiksIHJlYXNvbik7XG5cbiAgICAgICAgICAgICAgaWYgKC0tZ2V0UGFnZXNMZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMyLl9wYWdlc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgZm9yICh2YXIgX3BhZ2VOdW0gPSAyOyBfcGFnZU51bSA8PSBwYWdlc0NvdW50OyArK19wYWdlTnVtKSB7XG4gICAgICAgICAgICBfbG9vcChfcGFnZU51bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBfdGhpczIuZXZlbnRCdXMuZGlzcGF0Y2goXCJwYWdlc2luaXRcIiwge1xuICAgICAgICAgIHNvdXJjZTogX3RoaXMyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChfdGhpczIuZGVmYXVsdFJlbmRlcmluZ1F1ZXVlKSB7XG4gICAgICAgICAgX3RoaXMyLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlVuYWJsZSB0byBpbml0aWFsaXplIHZpZXdlclwiLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFBhZ2VMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UGFnZUxhYmVscyhsYWJlbHMpIHtcbiAgICAgIGlmICghdGhpcy5wZGZEb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghbGFiZWxzKSB7XG4gICAgICAgIHRoaXMuX3BhZ2VMYWJlbHMgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICghKEFycmF5LmlzQXJyYXkobGFiZWxzKSAmJiB0aGlzLnBkZkRvY3VtZW50Lm51bVBhZ2VzID09PSBsYWJlbHMubGVuZ3RoKSkge1xuICAgICAgICB0aGlzLl9wYWdlTGFiZWxzID0gbnVsbDtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdCh0aGlzLl9uYW1lLCBcIi5zZXRQYWdlTGFiZWxzOiBJbnZhbGlkIHBhZ2UgbGFiZWxzLlwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYWdlTGFiZWxzID0gbGFiZWxzO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9wYWdlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBwYWdlVmlldyA9IHRoaXMuX3BhZ2VzW2ldO1xuICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9wYWdlTGFiZWxzICYmIHRoaXMuX3BhZ2VMYWJlbHNbaV07XG4gICAgICAgIHBhZ2VWaWV3LnNldFBhZ2VMYWJlbChsYWJlbCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9yZXNldFZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0VmlldygpIHtcbiAgICAgIHRoaXMuX3BhZ2VzID0gW107XG4gICAgICB0aGlzLl9jdXJyZW50UGFnZU51bWJlciA9IDE7XG4gICAgICB0aGlzLl9jdXJyZW50U2NhbGUgPSBfdWlfdXRpbHMuVU5LTk9XTl9TQ0FMRTtcbiAgICAgIHRoaXMuX2N1cnJlbnRTY2FsZVZhbHVlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BhZ2VMYWJlbHMgPSBudWxsO1xuICAgICAgdGhpcy5fYnVmZmVyID0gbmV3IFBERlBhZ2VWaWV3QnVmZmVyKERFRkFVTFRfQ0FDSEVfU0laRSk7XG4gICAgICB0aGlzLl9sb2NhdGlvbiA9IG51bGw7XG4gICAgICB0aGlzLl9wYWdlc1JvdGF0aW9uID0gMDtcbiAgICAgIHRoaXMuX29wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBudWxsO1xuICAgICAgdGhpcy5fcGFnZXNSZXF1ZXN0cyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICB0aGlzLl9maXJzdFBhZ2VDYXBhYmlsaXR5ID0gKDAsIF9wZGZqc0xpYi5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgIHRoaXMuX29uZVBhZ2VSZW5kZXJlZENhcGFiaWxpdHkgPSAoMCwgX3BkZmpzTGliLmNyZWF0ZVByb21pc2VDYXBhYmlsaXR5KSgpO1xuICAgICAgdGhpcy5fcGFnZXNDYXBhYmlsaXR5ID0gKDAsIF9wZGZqc0xpYi5jcmVhdGVQcm9taXNlQ2FwYWJpbGl0eSkoKTtcbiAgICAgIHRoaXMuX3Njcm9sbE1vZGUgPSBfdWlfdXRpbHMuU2Nyb2xsTW9kZS5WRVJUSUNBTDtcbiAgICAgIHRoaXMuX3NwcmVhZE1vZGUgPSBfdWlfdXRpbHMuU3ByZWFkTW9kZS5OT05FO1xuXG4gICAgICBpZiAodGhpcy5fb25CZWZvcmVEcmF3KSB7XG4gICAgICAgIHRoaXMuZXZlbnRCdXMuX29mZihcInBhZ2VyZW5kZXJcIiwgdGhpcy5fb25CZWZvcmVEcmF3KTtcblxuICAgICAgICB0aGlzLl9vbkJlZm9yZURyYXcgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fb25BZnRlckRyYXcpIHtcbiAgICAgICAgdGhpcy5ldmVudEJ1cy5fb2ZmKFwicGFnZXJlbmRlcmVkXCIsIHRoaXMuX29uQWZ0ZXJEcmF3KTtcblxuICAgICAgICB0aGlzLl9vbkFmdGVyRHJhdyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlld2VyLnRleHRDb250ZW50ID0gXCJcIjtcblxuICAgICAgdGhpcy5fdXBkYXRlU2Nyb2xsTW9kZSgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2Nyb2xsVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY3JvbGxVcGRhdGUoKSB7XG4gICAgICBpZiAodGhpcy5wYWdlc0NvdW50ID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3Njcm9sbEludG9WaWV3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zY3JvbGxJbnRvVmlldyhfcmVmKSB7XG4gICAgICB2YXIgcGFnZURpdiA9IF9yZWYucGFnZURpdixcbiAgICAgICAgICBfcmVmJHBhZ2VTcG90ID0gX3JlZi5wYWdlU3BvdCxcbiAgICAgICAgICBwYWdlU3BvdCA9IF9yZWYkcGFnZVNwb3QgPT09IHZvaWQgMCA/IG51bGwgOiBfcmVmJHBhZ2VTcG90LFxuICAgICAgICAgIF9yZWYkcGFnZU51bWJlciA9IF9yZWYucGFnZU51bWJlcixcbiAgICAgICAgICBwYWdlTnVtYmVyID0gX3JlZiRwYWdlTnVtYmVyID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRwYWdlTnVtYmVyO1xuICAgICAgKDAsIF91aV91dGlscy5zY3JvbGxJbnRvVmlldykocGFnZURpdiwgcGFnZVNwb3QpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U2NhbGVVcGRhdGVQYWdlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0U2NhbGVVcGRhdGVQYWdlcyhuZXdTY2FsZSwgbmV3VmFsdWUpIHtcbiAgICAgIHZhciBub1Njcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgICB2YXIgcHJlc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICAgIHRoaXMuX2N1cnJlbnRTY2FsZVZhbHVlID0gbmV3VmFsdWUudG9TdHJpbmcoKTtcblxuICAgICAgaWYgKGlzU2FtZVNjYWxlKHRoaXMuX2N1cnJlbnRTY2FsZSwgbmV3U2NhbGUpKSB7XG4gICAgICAgIGlmIChwcmVzZXQpIHtcbiAgICAgICAgICB0aGlzLmV2ZW50QnVzLmRpc3BhdGNoKFwic2NhbGVjaGFuZ2luZ1wiLCB7XG4gICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICBzY2FsZTogbmV3U2NhbGUsXG4gICAgICAgICAgICBwcmVzZXRWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gdGhpcy5fcGFnZXMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICB0aGlzLl9wYWdlc1tpXS51cGRhdGUobmV3U2NhbGUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jdXJyZW50U2NhbGUgPSBuZXdTY2FsZTtcblxuICAgICAgaWYgKCFub1Njcm9sbCkge1xuICAgICAgICB2YXIgcGFnZSA9IHRoaXMuX2N1cnJlbnRQYWdlTnVtYmVyLFxuICAgICAgICAgICAgZGVzdDtcblxuICAgICAgICBpZiAodGhpcy5fbG9jYXRpb24gJiYgISh0aGlzLmlzSW5QcmVzZW50YXRpb25Nb2RlIHx8IHRoaXMuaXNDaGFuZ2luZ1ByZXNlbnRhdGlvbk1vZGUpKSB7XG4gICAgICAgICAgcGFnZSA9IHRoaXMuX2xvY2F0aW9uLnBhZ2VOdW1iZXI7XG4gICAgICAgICAgZGVzdCA9IFtudWxsLCB7XG4gICAgICAgICAgICBuYW1lOiBcIlhZWlwiXG4gICAgICAgICAgfSwgdGhpcy5fbG9jYXRpb24ubGVmdCwgdGhpcy5fbG9jYXRpb24udG9wLCBudWxsXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2Nyb2xsUGFnZUludG9WaWV3KHtcbiAgICAgICAgICBwYWdlTnVtYmVyOiBwYWdlLFxuICAgICAgICAgIGRlc3RBcnJheTogZGVzdCxcbiAgICAgICAgICBhbGxvd05lZ2F0aXZlT2Zmc2V0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmV2ZW50QnVzLmRpc3BhdGNoKFwic2NhbGVjaGFuZ2luZ1wiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgc2NhbGU6IG5ld1NjYWxlLFxuICAgICAgICBwcmVzZXRWYWx1ZTogcHJlc2V0ID8gbmV3VmFsdWUgOiB1bmRlZmluZWRcbiAgICAgIH0pO1xuXG4gICAgICBpZiAodGhpcy5kZWZhdWx0UmVuZGVyaW5nUXVldWUpIHtcbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3NldFNjYWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTY2FsZSh2YWx1ZSkge1xuICAgICAgdmFyIG5vU2Nyb2xsID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICAgIHZhciBzY2FsZSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuXG4gICAgICBpZiAoc2NhbGUgPiAwKSB7XG4gICAgICAgIHRoaXMuX3NldFNjYWxlVXBkYXRlUGFnZXMoc2NhbGUsIHZhbHVlLCBub1Njcm9sbCwgZmFsc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGN1cnJlbnRQYWdlID0gdGhpcy5fcGFnZXNbdGhpcy5fY3VycmVudFBhZ2VOdW1iZXIgLSAxXTtcblxuICAgICAgICBpZiAoIWN1cnJlbnRQYWdlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5vUGFkZGluZyA9IHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUgfHwgdGhpcy5yZW1vdmVQYWdlQm9yZGVycztcbiAgICAgICAgdmFyIGhQYWRkaW5nID0gbm9QYWRkaW5nID8gMCA6IF91aV91dGlscy5TQ1JPTExCQVJfUEFERElORztcbiAgICAgICAgdmFyIHZQYWRkaW5nID0gbm9QYWRkaW5nID8gMCA6IF91aV91dGlscy5WRVJUSUNBTF9QQURESU5HO1xuXG4gICAgICAgIGlmICghbm9QYWRkaW5nICYmIHRoaXMuX2lzU2Nyb2xsTW9kZUhvcml6b250YWwpIHtcbiAgICAgICAgICB2YXIgX3JlZjIgPSBbdlBhZGRpbmcsIGhQYWRkaW5nXTtcbiAgICAgICAgICBoUGFkZGluZyA9IF9yZWYyWzBdO1xuICAgICAgICAgIHZQYWRkaW5nID0gX3JlZjJbMV07XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGFnZVdpZHRoU2NhbGUgPSAodGhpcy5jb250YWluZXIuY2xpZW50V2lkdGggLSBoUGFkZGluZykgLyBjdXJyZW50UGFnZS53aWR0aCAqIGN1cnJlbnRQYWdlLnNjYWxlO1xuICAgICAgICB2YXIgcGFnZUhlaWdodFNjYWxlID0gKHRoaXMuY29udGFpbmVyLmNsaWVudEhlaWdodCAtIHZQYWRkaW5nKSAvIGN1cnJlbnRQYWdlLmhlaWdodCAqIGN1cnJlbnRQYWdlLnNjYWxlO1xuXG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICBjYXNlIFwicGFnZS1hY3R1YWxcIjpcbiAgICAgICAgICAgIHNjYWxlID0gMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcInBhZ2Utd2lkdGhcIjpcbiAgICAgICAgICAgIHNjYWxlID0gcGFnZVdpZHRoU2NhbGU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJwYWdlLWhlaWdodFwiOlxuICAgICAgICAgICAgc2NhbGUgPSBwYWdlSGVpZ2h0U2NhbGU7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgXCJwYWdlLWZpdFwiOlxuICAgICAgICAgICAgc2NhbGUgPSBNYXRoLm1pbihwYWdlV2lkdGhTY2FsZSwgcGFnZUhlaWdodFNjYWxlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBcImF1dG9cIjpcbiAgICAgICAgICAgIHZhciBob3Jpem9udGFsU2NhbGUgPSAoMCwgX3VpX3V0aWxzLmlzUG9ydHJhaXRPcmllbnRhdGlvbikoY3VycmVudFBhZ2UpID8gcGFnZVdpZHRoU2NhbGUgOiBNYXRoLm1pbihwYWdlSGVpZ2h0U2NhbGUsIHBhZ2VXaWR0aFNjYWxlKTtcbiAgICAgICAgICAgIHNjYWxlID0gTWF0aC5taW4oX3VpX3V0aWxzLk1BWF9BVVRPX1NDQUxFLCBob3Jpem9udGFsU2NhbGUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdCh0aGlzLl9uYW1lLCBcIi5fc2V0U2NhbGU6IFxcXCJcIikuY29uY2F0KHZhbHVlLCBcIlxcXCIgaXMgYW4gdW5rbm93biB6b29tIHZhbHVlLlwiKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZXRTY2FsZVVwZGF0ZVBhZ2VzKHNjYWxlLCB2YWx1ZSwgbm9TY3JvbGwsIHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfcmVzZXRDdXJyZW50UGFnZVZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3Jlc2V0Q3VycmVudFBhZ2VWaWV3KCkge1xuICAgICAgaWYgKHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUpIHtcbiAgICAgICAgdGhpcy5fc2V0U2NhbGUodGhpcy5fY3VycmVudFNjYWxlVmFsdWUsIHRydWUpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFnZVZpZXcgPSB0aGlzLl9wYWdlc1t0aGlzLl9jdXJyZW50UGFnZU51bWJlciAtIDFdO1xuXG4gICAgICB0aGlzLl9zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgIHBhZ2VEaXY6IHBhZ2VWaWV3LmRpdlxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNjcm9sbFBhZ2VJbnRvVmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxQYWdlSW50b1ZpZXcoX3JlZjMpIHtcbiAgICAgIHZhciBwYWdlTnVtYmVyID0gX3JlZjMucGFnZU51bWJlcixcbiAgICAgICAgICBfcmVmMyRkZXN0QXJyYXkgPSBfcmVmMy5kZXN0QXJyYXksXG4gICAgICAgICAgZGVzdEFycmF5ID0gX3JlZjMkZGVzdEFycmF5ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZjMkZGVzdEFycmF5LFxuICAgICAgICAgIF9yZWYzJGFsbG93TmVnYXRpdmVPZiA9IF9yZWYzLmFsbG93TmVnYXRpdmVPZmZzZXQsXG4gICAgICAgICAgYWxsb3dOZWdhdGl2ZU9mZnNldCA9IF9yZWYzJGFsbG93TmVnYXRpdmVPZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRhbGxvd05lZ2F0aXZlT2YsXG4gICAgICAgICAgX3JlZjMkaWdub3JlRGVzdGluYXRpID0gX3JlZjMuaWdub3JlRGVzdGluYXRpb25ab29tLFxuICAgICAgICAgIGlnbm9yZURlc3RpbmF0aW9uWm9vbSA9IF9yZWYzJGlnbm9yZURlc3RpbmF0aSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcmVmMyRpZ25vcmVEZXN0aW5hdGk7XG5cbiAgICAgIGlmICghdGhpcy5wZGZEb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBwYWdlVmlldyA9IE51bWJlci5pc0ludGVnZXIocGFnZU51bWJlcikgJiYgdGhpcy5fcGFnZXNbcGFnZU51bWJlciAtIDFdO1xuXG4gICAgICBpZiAoIXBhZ2VWaWV3KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQodGhpcy5fbmFtZSwgXCIuc2Nyb2xsUGFnZUludG9WaWV3OiBcIikgKyBcIlxcXCJcIi5jb25jYXQocGFnZU51bWJlciwgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIHBhZ2VOdW1iZXIgcGFyYW1ldGVyLlwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUgfHwgIWRlc3RBcnJheSkge1xuICAgICAgICB0aGlzLl9zZXRDdXJyZW50UGFnZU51bWJlcihwYWdlTnVtYmVyLCB0cnVlKTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB4ID0gMCxcbiAgICAgICAgICB5ID0gMDtcbiAgICAgIHZhciB3aWR0aCA9IDAsXG4gICAgICAgICAgaGVpZ2h0ID0gMCxcbiAgICAgICAgICB3aWR0aFNjYWxlLFxuICAgICAgICAgIGhlaWdodFNjYWxlO1xuICAgICAgdmFyIGNoYW5nZU9yaWVudGF0aW9uID0gcGFnZVZpZXcucm90YXRpb24gJSAxODAgIT09IDA7XG4gICAgICB2YXIgcGFnZVdpZHRoID0gKGNoYW5nZU9yaWVudGF0aW9uID8gcGFnZVZpZXcuaGVpZ2h0IDogcGFnZVZpZXcud2lkdGgpIC8gcGFnZVZpZXcuc2NhbGUgLyBfdWlfdXRpbHMuQ1NTX1VOSVRTO1xuICAgICAgdmFyIHBhZ2VIZWlnaHQgPSAoY2hhbmdlT3JpZW50YXRpb24gPyBwYWdlVmlldy53aWR0aCA6IHBhZ2VWaWV3LmhlaWdodCkgLyBwYWdlVmlldy5zY2FsZSAvIF91aV91dGlscy5DU1NfVU5JVFM7XG4gICAgICB2YXIgc2NhbGUgPSAwO1xuXG4gICAgICBzd2l0Y2ggKGRlc3RBcnJheVsxXS5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJYWVpcIjpcbiAgICAgICAgICB4ID0gZGVzdEFycmF5WzJdO1xuICAgICAgICAgIHkgPSBkZXN0QXJyYXlbM107XG4gICAgICAgICAgc2NhbGUgPSBkZXN0QXJyYXlbNF07XG4gICAgICAgICAgeCA9IHggIT09IG51bGwgPyB4IDogMDtcbiAgICAgICAgICB5ID0geSAhPT0gbnVsbCA/IHkgOiBwYWdlSGVpZ2h0O1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJGaXRcIjpcbiAgICAgICAgY2FzZSBcIkZpdEJcIjpcbiAgICAgICAgICBzY2FsZSA9IFwicGFnZS1maXRcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiRml0SFwiOlxuICAgICAgICBjYXNlIFwiRml0QkhcIjpcbiAgICAgICAgICB5ID0gZGVzdEFycmF5WzJdO1xuICAgICAgICAgIHNjYWxlID0gXCJwYWdlLXdpZHRoXCI7XG5cbiAgICAgICAgICBpZiAoeSA9PT0gbnVsbCAmJiB0aGlzLl9sb2NhdGlvbikge1xuICAgICAgICAgICAgeCA9IHRoaXMuX2xvY2F0aW9uLmxlZnQ7XG4gICAgICAgICAgICB5ID0gdGhpcy5fbG9jYXRpb24udG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgXCJGaXRWXCI6XG4gICAgICAgIGNhc2UgXCJGaXRCVlwiOlxuICAgICAgICAgIHggPSBkZXN0QXJyYXlbMl07XG4gICAgICAgICAgd2lkdGggPSBwYWdlV2lkdGg7XG4gICAgICAgICAgaGVpZ2h0ID0gcGFnZUhlaWdodDtcbiAgICAgICAgICBzY2FsZSA9IFwicGFnZS1oZWlnaHRcIjtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwiRml0UlwiOlxuICAgICAgICAgIHggPSBkZXN0QXJyYXlbMl07XG4gICAgICAgICAgeSA9IGRlc3RBcnJheVszXTtcbiAgICAgICAgICB3aWR0aCA9IGRlc3RBcnJheVs0XSAtIHg7XG4gICAgICAgICAgaGVpZ2h0ID0gZGVzdEFycmF5WzVdIC0geTtcbiAgICAgICAgICB2YXIgaFBhZGRpbmcgPSB0aGlzLnJlbW92ZVBhZ2VCb3JkZXJzID8gMCA6IF91aV91dGlscy5TQ1JPTExCQVJfUEFERElORztcbiAgICAgICAgICB2YXIgdlBhZGRpbmcgPSB0aGlzLnJlbW92ZVBhZ2VCb3JkZXJzID8gMCA6IF91aV91dGlscy5WRVJUSUNBTF9QQURESU5HO1xuICAgICAgICAgIHdpZHRoU2NhbGUgPSAodGhpcy5jb250YWluZXIuY2xpZW50V2lkdGggLSBoUGFkZGluZykgLyB3aWR0aCAvIF91aV91dGlscy5DU1NfVU5JVFM7XG4gICAgICAgICAgaGVpZ2h0U2NhbGUgPSAodGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0IC0gdlBhZGRpbmcpIC8gaGVpZ2h0IC8gX3VpX3V0aWxzLkNTU19VTklUUztcbiAgICAgICAgICBzY2FsZSA9IE1hdGgubWluKE1hdGguYWJzKHdpZHRoU2NhbGUpLCBNYXRoLmFicyhoZWlnaHRTY2FsZSkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdCh0aGlzLl9uYW1lLCBcIi5zY3JvbGxQYWdlSW50b1ZpZXc6IFwiKSArIFwiXFxcIlwiLmNvbmNhdChkZXN0QXJyYXlbMV0ubmFtZSwgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIGRlc3RpbmF0aW9uIHR5cGUuXCIpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghaWdub3JlRGVzdGluYXRpb25ab29tKSB7XG4gICAgICAgIGlmIChzY2FsZSAmJiBzY2FsZSAhPT0gdGhpcy5fY3VycmVudFNjYWxlKSB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50U2NhbGVWYWx1ZSA9IHNjYWxlO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRTY2FsZSA9PT0gX3VpX3V0aWxzLlVOS05PV05fU0NBTEUpIHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRTY2FsZVZhbHVlID0gX3VpX3V0aWxzLkRFRkFVTFRfU0NBTEVfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHNjYWxlID09PSBcInBhZ2UtZml0XCIgJiYgIWRlc3RBcnJheVs0XSkge1xuICAgICAgICB0aGlzLl9zY3JvbGxJbnRvVmlldyh7XG4gICAgICAgICAgcGFnZURpdjogcGFnZVZpZXcuZGl2LFxuICAgICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXJcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYm91bmRpbmdSZWN0ID0gW3BhZ2VWaWV3LnZpZXdwb3J0LmNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCwgeSksIHBhZ2VWaWV3LnZpZXdwb3J0LmNvbnZlcnRUb1ZpZXdwb3J0UG9pbnQoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KV07XG4gICAgICB2YXIgbGVmdCA9IE1hdGgubWluKGJvdW5kaW5nUmVjdFswXVswXSwgYm91bmRpbmdSZWN0WzFdWzBdKTtcbiAgICAgIHZhciB0b3AgPSBNYXRoLm1pbihib3VuZGluZ1JlY3RbMF1bMV0sIGJvdW5kaW5nUmVjdFsxXVsxXSk7XG5cbiAgICAgIGlmICghYWxsb3dOZWdhdGl2ZU9mZnNldCkge1xuICAgICAgICBsZWZ0ID0gTWF0aC5tYXgobGVmdCwgMCk7XG4gICAgICAgIHRvcCA9IE1hdGgubWF4KHRvcCwgMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3Njcm9sbEludG9WaWV3KHtcbiAgICAgICAgcGFnZURpdjogcGFnZVZpZXcuZGl2LFxuICAgICAgICBwYWdlU3BvdDoge1xuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgdG9wOiB0b3BcbiAgICAgICAgfSxcbiAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bWJlclxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVMb2NhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlTG9jYXRpb24oZmlyc3RQYWdlKSB7XG4gICAgICB2YXIgY3VycmVudFNjYWxlID0gdGhpcy5fY3VycmVudFNjYWxlO1xuICAgICAgdmFyIGN1cnJlbnRTY2FsZVZhbHVlID0gdGhpcy5fY3VycmVudFNjYWxlVmFsdWU7XG4gICAgICB2YXIgbm9ybWFsaXplZFNjYWxlVmFsdWUgPSBwYXJzZUZsb2F0KGN1cnJlbnRTY2FsZVZhbHVlKSA9PT0gY3VycmVudFNjYWxlID8gTWF0aC5yb3VuZChjdXJyZW50U2NhbGUgKiAxMDAwMCkgLyAxMDAgOiBjdXJyZW50U2NhbGVWYWx1ZTtcbiAgICAgIHZhciBwYWdlTnVtYmVyID0gZmlyc3RQYWdlLmlkO1xuICAgICAgdmFyIHBkZk9wZW5QYXJhbXMgPSBcIiNwYWdlPVwiICsgcGFnZU51bWJlcjtcbiAgICAgIHBkZk9wZW5QYXJhbXMgKz0gXCImem9vbT1cIiArIG5vcm1hbGl6ZWRTY2FsZVZhbHVlO1xuICAgICAgdmFyIGN1cnJlbnRQYWdlVmlldyA9IHRoaXMuX3BhZ2VzW3BhZ2VOdW1iZXIgLSAxXTtcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgIHZhciB0b3BMZWZ0ID0gY3VycmVudFBhZ2VWaWV3LmdldFBhZ2VQb2ludChjb250YWluZXIuc2Nyb2xsTGVmdCAtIGZpcnN0UGFnZS54LCBjb250YWluZXIuc2Nyb2xsVG9wIC0gZmlyc3RQYWdlLnkpO1xuICAgICAgdmFyIGludExlZnQgPSBNYXRoLnJvdW5kKHRvcExlZnRbMF0pO1xuICAgICAgdmFyIGludFRvcCA9IE1hdGgucm91bmQodG9wTGVmdFsxXSk7XG4gICAgICBwZGZPcGVuUGFyYW1zICs9IFwiLFwiICsgaW50TGVmdCArIFwiLFwiICsgaW50VG9wO1xuICAgICAgdGhpcy5fbG9jYXRpb24gPSB7XG4gICAgICAgIHBhZ2VOdW1iZXI6IHBhZ2VOdW1iZXIsXG4gICAgICAgIHNjYWxlOiBub3JtYWxpemVkU2NhbGVWYWx1ZSxcbiAgICAgICAgdG9wOiBpbnRUb3AsXG4gICAgICAgIGxlZnQ6IGludExlZnQsXG4gICAgICAgIHJvdGF0aW9uOiB0aGlzLl9wYWdlc1JvdGF0aW9uLFxuICAgICAgICBwZGZPcGVuUGFyYW1zOiBwZGZPcGVuUGFyYW1zXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlSGVscGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVIZWxwZXIodmlzaWJsZVBhZ2VzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQ6IF91cGRhdGVIZWxwZXJcIik7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuX2dldFZpc2libGVQYWdlcygpO1xuXG4gICAgICB2YXIgdmlzaWJsZVBhZ2VzID0gdmlzaWJsZS52aWV3cyxcbiAgICAgICAgICBudW1WaXNpYmxlUGFnZXMgPSB2aXNpYmxlUGFnZXMubGVuZ3RoO1xuXG4gICAgICBpZiAobnVtVmlzaWJsZVBhZ2VzID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0NhY2hlU2l6ZSA9IE1hdGgubWF4KERFRkFVTFRfQ0FDSEVfU0laRSwgMiAqIG51bVZpc2libGVQYWdlcyArIDEpO1xuXG4gICAgICB0aGlzLl9idWZmZXIucmVzaXplKG5ld0NhY2hlU2l6ZSwgdmlzaWJsZVBhZ2VzKTtcblxuICAgICAgdGhpcy5yZW5kZXJpbmdRdWV1ZS5yZW5kZXJIaWdoZXN0UHJpb3JpdHkodmlzaWJsZSk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUhlbHBlcih2aXNpYmxlUGFnZXMpO1xuXG4gICAgICB0aGlzLl91cGRhdGVMb2NhdGlvbih2aXNpYmxlLmZpcnN0KTtcblxuICAgICAgdGhpcy5ldmVudEJ1cy5kaXNwYXRjaChcInVwZGF0ZXZpZXdhcmVhXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBsb2NhdGlvbjogdGhpcy5fbG9jYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb250YWluc0VsZW1lbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29udGFpbnNFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5jb250YWlucyhlbGVtZW50KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZm9jdXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5mb2N1cygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0Q3VycmVudFZpc2libGVQYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRDdXJyZW50VmlzaWJsZVBhZ2UoKSB7XG4gICAgICBpZiAoIXRoaXMucGFnZXNDb3VudCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZpZXdzOiBbXVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFnZVZpZXcgPSB0aGlzLl9wYWdlc1t0aGlzLl9jdXJyZW50UGFnZU51bWJlciAtIDFdO1xuICAgICAgdmFyIGVsZW1lbnQgPSBwYWdlVmlldy5kaXY7XG4gICAgICB2YXIgdmlldyA9IHtcbiAgICAgICAgaWQ6IHBhZ2VWaWV3LmlkLFxuICAgICAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQgKyBlbGVtZW50LmNsaWVudExlZnQsXG4gICAgICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wICsgZWxlbWVudC5jbGllbnRUb3AsXG4gICAgICAgIHZpZXc6IHBhZ2VWaWV3XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZmlyc3Q6IHZpZXcsXG4gICAgICAgIGxhc3Q6IHZpZXcsXG4gICAgICAgIHZpZXdzOiBbdmlld11cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaXNpYmxlUGFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpc2libGVQYWdlcygpIHtcbiAgICAgIHJldHVybiAoMCwgX3VpX3V0aWxzLmdldFZpc2libGVFbGVtZW50cykodGhpcy5jb250YWluZXIsIHRoaXMuX3BhZ2VzLCB0cnVlLCB0aGlzLl9pc1Njcm9sbE1vZGVIb3Jpem9udGFsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNQYWdlVmlzaWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc1BhZ2VWaXNpYmxlKHBhZ2VOdW1iZXIpIHtcbiAgICAgIGlmICghdGhpcy5wZGZEb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChwYWdlTnVtYmVyIDwgMSB8fCBwYWdlTnVtYmVyID4gdGhpcy5wYWdlc0NvdW50KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQodGhpcy5fbmFtZSwgXCIuaXNQYWdlVmlzaWJsZTogXFxcIlwiKS5jb25jYXQocGFnZU51bWJlciwgXCJcXFwiIGlzIG91dCBvZiBib3VuZHMuXCIpKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VmlzaWJsZVBhZ2VzKCkudmlld3Muc29tZShmdW5jdGlvbiAodmlldykge1xuICAgICAgICByZXR1cm4gdmlldy5pZCA9PT0gcGFnZU51bWJlcjtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbGVhbnVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9wYWdlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYWdlc1tpXSAmJiB0aGlzLl9wYWdlc1tpXS5yZW5kZXJpbmdTdGF0ZSAhPT0gX3BkZl9yZW5kZXJpbmdfcXVldWUuUmVuZGVyaW5nU3RhdGVzLkZJTklTSEVEKSB7XG4gICAgICAgICAgdGhpcy5fcGFnZXNbaV0ucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfY2FuY2VsUmVuZGVyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9jYW5jZWxSZW5kZXJpbmcoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9wYWdlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYWdlc1tpXSkge1xuICAgICAgICAgIHRoaXMuX3BhZ2VzW2ldLmNhbmNlbFJlbmRlcmluZygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9lbnN1cmVQZGZQYWdlTG9hZGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9lbnN1cmVQZGZQYWdlTG9hZGVkKHBhZ2VWaWV3KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHBhZ2VWaWV3LnBkZlBhZ2UpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYWdlVmlldy5wZGZQYWdlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3BhZ2VzUmVxdWVzdHMuaGFzKHBhZ2VWaWV3KSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFnZXNSZXF1ZXN0cy5nZXQocGFnZVZpZXcpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJvbWlzZSA9IHRoaXMucGRmRG9jdW1lbnQuZ2V0UGFnZShwYWdlVmlldy5pZCkudGhlbihmdW5jdGlvbiAocGRmUGFnZSkge1xuICAgICAgICBpZiAoIXBhZ2VWaWV3LnBkZlBhZ2UpIHtcbiAgICAgICAgICBwYWdlVmlldy5zZXRQZGZQYWdlKHBkZlBhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXMzLl9wYWdlc1JlcXVlc3RzW1wiZGVsZXRlXCJdKHBhZ2VWaWV3KTtcblxuICAgICAgICByZXR1cm4gcGRmUGFnZTtcbiAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiVW5hYmxlIHRvIGdldCBwYWdlIGZvciBwYWdlIHZpZXdcIiwgcmVhc29uKTtcblxuICAgICAgICBfdGhpczMuX3BhZ2VzUmVxdWVzdHNbXCJkZWxldGVcIl0ocGFnZVZpZXcpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3BhZ2VzUmVxdWVzdHMuc2V0KHBhZ2VWaWV3LCBwcm9taXNlKTtcblxuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZvcmNlUmVuZGVyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZvcmNlUmVuZGVyaW5nKGN1cnJlbnRseVZpc2libGVQYWdlcykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIHZhciB2aXNpYmxlUGFnZXMgPSBjdXJyZW50bHlWaXNpYmxlUGFnZXMgfHwgdGhpcy5fZ2V0VmlzaWJsZVBhZ2VzKCk7XG5cbiAgICAgIHZhciBzY3JvbGxBaGVhZCA9IHRoaXMuX2lzU2Nyb2xsTW9kZUhvcml6b250YWwgPyB0aGlzLnNjcm9sbC5yaWdodCA6IHRoaXMuc2Nyb2xsLmRvd247XG4gICAgICB2YXIgcGFnZVZpZXcgPSB0aGlzLnJlbmRlcmluZ1F1ZXVlLmdldEhpZ2hlc3RQcmlvcml0eSh2aXNpYmxlUGFnZXMsIHRoaXMuX3BhZ2VzLCBzY3JvbGxBaGVhZCk7XG5cbiAgICAgIGlmIChwYWdlVmlldykge1xuICAgICAgICB0aGlzLl9lbnN1cmVQZGZQYWdlTG9hZGVkKHBhZ2VWaWV3KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQucmVuZGVyaW5nUXVldWUucmVuZGVyVmlldyhwYWdlVmlldyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVRleHRMYXllckJ1aWxkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlVGV4dExheWVyQnVpbGRlcih0ZXh0TGF5ZXJEaXYsIHBhZ2VJbmRleCwgdmlld3BvcnQpIHtcbiAgICAgIHZhciBlbmhhbmNlVGV4dFNlbGVjdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogZmFsc2U7XG4gICAgICB2YXIgZXZlbnRCdXMgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBuZXcgX3RleHRfbGF5ZXJfYnVpbGRlci5UZXh0TGF5ZXJCdWlsZGVyKHtcbiAgICAgICAgdGV4dExheWVyRGl2OiB0ZXh0TGF5ZXJEaXYsXG4gICAgICAgIGV2ZW50QnVzOiBldmVudEJ1cyxcbiAgICAgICAgcGFnZUluZGV4OiBwYWdlSW5kZXgsXG4gICAgICAgIHZpZXdwb3J0OiB2aWV3cG9ydCxcbiAgICAgICAgZmluZENvbnRyb2xsZXI6IHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUgPyBudWxsIDogdGhpcy5maW5kQ29udHJvbGxlcixcbiAgICAgICAgZW5oYW5jZVRleHRTZWxlY3Rpb246IHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUgPyBmYWxzZSA6IGVuaGFuY2VUZXh0U2VsZWN0aW9uXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQW5ub3RhdGlvbkxheWVyQnVpbGRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVBbm5vdGF0aW9uTGF5ZXJCdWlsZGVyKHBhZ2VEaXYsIHBkZlBhZ2UpIHtcbiAgICAgIHZhciBhbm5vdGF0aW9uU3RvcmFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICAgIHZhciBpbWFnZVJlc291cmNlc1BhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IFwiXCI7XG4gICAgICB2YXIgcmVuZGVySW50ZXJhY3RpdmVGb3JtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogZmFsc2U7XG4gICAgICB2YXIgbDEwbiA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogX3VpX3V0aWxzLk51bGxMMTBuO1xuICAgICAgcmV0dXJuIG5ldyBfYW5ub3RhdGlvbl9sYXllcl9idWlsZGVyLkFubm90YXRpb25MYXllckJ1aWxkZXIoe1xuICAgICAgICBwYWdlRGl2OiBwYWdlRGl2LFxuICAgICAgICBwZGZQYWdlOiBwZGZQYWdlLFxuICAgICAgICBhbm5vdGF0aW9uU3RvcmFnZTogYW5ub3RhdGlvblN0b3JhZ2UsXG4gICAgICAgIGltYWdlUmVzb3VyY2VzUGF0aDogaW1hZ2VSZXNvdXJjZXNQYXRoLFxuICAgICAgICByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zOiByZW5kZXJJbnRlcmFjdGl2ZUZvcm1zLFxuICAgICAgICBsaW5rU2VydmljZTogdGhpcy5saW5rU2VydmljZSxcbiAgICAgICAgZG93bmxvYWRNYW5hZ2VyOiB0aGlzLmRvd25sb2FkTWFuYWdlcixcbiAgICAgICAgbDEwbjogbDEwblxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBhZ2VzT3ZlcnZpZXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UGFnZXNPdmVydmlldygpIHtcbiAgICAgIHZhciBwYWdlc092ZXJ2aWV3ID0gdGhpcy5fcGFnZXMubWFwKGZ1bmN0aW9uIChwYWdlVmlldykge1xuICAgICAgICB2YXIgdmlld3BvcnQgPSBwYWdlVmlldy5wZGZQYWdlLmdldFZpZXdwb3J0KHtcbiAgICAgICAgICBzY2FsZTogMVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogdmlld3BvcnQud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB2aWV3cG9ydC5oZWlnaHQsXG4gICAgICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgICAgIH07XG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aGlzLmVuYWJsZVByaW50QXV0b1JvdGF0ZSkge1xuICAgICAgICByZXR1cm4gcGFnZXNPdmVydmlldztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhZ2VzT3ZlcnZpZXcubWFwKGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICAgIGlmICgoMCwgX3VpX3V0aWxzLmlzUG9ydHJhaXRPcmllbnRhdGlvbikoc2l6ZSkpIHtcbiAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IHNpemUuaGVpZ2h0LFxuICAgICAgICAgIGhlaWdodDogc2l6ZS53aWR0aCxcbiAgICAgICAgICByb3RhdGlvbjogKHNpemUucm90YXRpb24gKyA5MCkgJSAzNjBcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlU2Nyb2xsTW9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlU2Nyb2xsTW9kZSgpIHtcbiAgICAgIHZhciBwYWdlTnVtYmVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgICAgdmFyIHNjcm9sbE1vZGUgPSB0aGlzLl9zY3JvbGxNb2RlLFxuICAgICAgICAgIHZpZXdlciA9IHRoaXMudmlld2VyO1xuICAgICAgdmlld2VyLmNsYXNzTGlzdC50b2dnbGUoXCJzY3JvbGxIb3Jpem9udGFsXCIsIHNjcm9sbE1vZGUgPT09IF91aV91dGlscy5TY3JvbGxNb2RlLkhPUklaT05UQUwpO1xuICAgICAgdmlld2VyLmNsYXNzTGlzdC50b2dnbGUoXCJzY3JvbGxXcmFwcGVkXCIsIHNjcm9sbE1vZGUgPT09IF91aV91dGlscy5TY3JvbGxNb2RlLldSQVBQRUQpO1xuXG4gICAgICBpZiAoIXRoaXMucGRmRG9jdW1lbnQgfHwgIXBhZ2VOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fY3VycmVudFNjYWxlVmFsdWUgJiYgaXNOYU4odGhpcy5fY3VycmVudFNjYWxlVmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX3NldFNjYWxlKHRoaXMuX2N1cnJlbnRTY2FsZVZhbHVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0Q3VycmVudFBhZ2VOdW1iZXIocGFnZU51bWJlciwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTcHJlYWRNb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVTcHJlYWRNb2RlKCkge1xuICAgICAgdmFyIHBhZ2VOdW1iZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IG51bGw7XG5cbiAgICAgIGlmICghdGhpcy5wZGZEb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB2aWV3ZXIgPSB0aGlzLnZpZXdlcixcbiAgICAgICAgICBwYWdlcyA9IHRoaXMuX3BhZ2VzO1xuICAgICAgdmlld2VyLnRleHRDb250ZW50ID0gXCJcIjtcblxuICAgICAgaWYgKHRoaXMuX3NwcmVhZE1vZGUgPT09IF91aV91dGlscy5TcHJlYWRNb2RlLk5PTkUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlNYXggPSBwYWdlcy5sZW5ndGg7IGkgPCBpTWF4OyArK2kpIHtcbiAgICAgICAgICB2aWV3ZXIuYXBwZW5kQ2hpbGQocGFnZXNbaV0uZGl2KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHBhcml0eSA9IHRoaXMuX3NwcmVhZE1vZGUgLSAxO1xuICAgICAgICB2YXIgc3ByZWFkID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9pTWF4ID0gcGFnZXMubGVuZ3RoOyBfaSA8IF9pTWF4OyArK19pKSB7XG4gICAgICAgICAgaWYgKHNwcmVhZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgc3ByZWFkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHNwcmVhZC5jbGFzc05hbWUgPSBcInNwcmVhZFwiO1xuICAgICAgICAgICAgdmlld2VyLmFwcGVuZENoaWxkKHNwcmVhZCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChfaSAlIDIgPT09IHBhcml0eSkge1xuICAgICAgICAgICAgc3ByZWFkID0gc3ByZWFkLmNsb25lTm9kZShmYWxzZSk7XG4gICAgICAgICAgICB2aWV3ZXIuYXBwZW5kQ2hpbGQoc3ByZWFkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzcHJlYWQuYXBwZW5kQ2hpbGQocGFnZXNbX2ldLmRpdik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFwYWdlTnVtYmVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0Q3VycmVudFBhZ2VOdW1iZXIocGFnZU51bWJlciwgdHJ1ZSk7XG5cbiAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VzQ291bnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9wYWdlcy5sZW5ndGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VWaWV3c1JlYWR5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICBpZiAoIXRoaXMuX3BhZ2VzQ2FwYWJpbGl0eS5zZXR0bGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VzLmV2ZXJ5KGZ1bmN0aW9uIChwYWdlVmlldykge1xuICAgICAgICByZXR1cm4gcGFnZVZpZXcgJiYgcGFnZVZpZXcucGRmUGFnZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50UGFnZU51bWJlclwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRQYWdlTnVtYmVyO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodmFsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhZ2UgbnVtYmVyLlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLnBkZkRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9zZXRDdXJyZW50UGFnZU51bWJlcih2YWwsIHRydWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQodGhpcy5fbmFtZSwgXCIuY3VycmVudFBhZ2VOdW1iZXI6IFxcXCJcIikuY29uY2F0KHZhbCwgXCJcXFwiIGlzIG5vdCBhIHZhbGlkIHBhZ2UuXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY3VycmVudFBhZ2VMYWJlbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VMYWJlbHMgJiYgdGhpcy5fcGFnZUxhYmVsc1t0aGlzLl9jdXJyZW50UGFnZU51bWJlciAtIDFdO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICBpZiAoIXRoaXMucGRmRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcGFnZSA9IHZhbCB8IDA7XG5cbiAgICAgIGlmICh0aGlzLl9wYWdlTGFiZWxzKSB7XG4gICAgICAgIHZhciBpID0gdGhpcy5fcGFnZUxhYmVscy5pbmRleE9mKHZhbCk7XG5cbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgIHBhZ2UgPSBpICsgMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX3NldEN1cnJlbnRQYWdlTnVtYmVyKHBhZ2UsIHRydWUpKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQodGhpcy5fbmFtZSwgXCIuY3VycmVudFBhZ2VMYWJlbDogXFxcIlwiKS5jb25jYXQodmFsLCBcIlxcXCIgaXMgbm90IGEgdmFsaWQgcGFnZS5cIikpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50U2NhbGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U2NhbGUgIT09IF91aV91dGlscy5VTktOT1dOX1NDQUxFID8gdGhpcy5fY3VycmVudFNjYWxlIDogX3VpX3V0aWxzLkRFRkFVTFRfU0NBTEU7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgbnVtZXJpYyBzY2FsZS5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5wZGZEb2N1bWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3NldFNjYWxlKHZhbCwgZmFsc2UpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjdXJyZW50U2NhbGVWYWx1ZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTY2FsZVZhbHVlO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgICBpZiAoIXRoaXMucGRmRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zZXRTY2FsZSh2YWwsIGZhbHNlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicGFnZXNSb3RhdGlvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhZ2VzUm90YXRpb247XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChyb3RhdGlvbikge1xuICAgICAgaWYgKCEoMCwgX3VpX3V0aWxzLmlzVmFsaWRSb3RhdGlvbikocm90YXRpb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcGFnZXMgcm90YXRpb24gYW5nbGUuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucGRmRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcGFnZXNSb3RhdGlvbiA9PT0gcm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9wYWdlc1JvdGF0aW9uID0gcm90YXRpb247XG4gICAgICB2YXIgcGFnZU51bWJlciA9IHRoaXMuX2N1cnJlbnRQYWdlTnVtYmVyO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSB0aGlzLl9wYWdlcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICAgIHZhciBwYWdlVmlldyA9IHRoaXMuX3BhZ2VzW2ldO1xuICAgICAgICBwYWdlVmlldy51cGRhdGUocGFnZVZpZXcuc2NhbGUsIHJvdGF0aW9uKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTY2FsZVZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NldFNjYWxlKHRoaXMuX2N1cnJlbnRTY2FsZVZhbHVlLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ldmVudEJ1cy5kaXNwYXRjaChcInJvdGF0aW9uY2hhbmdpbmdcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIHBhZ2VzUm90YXRpb246IHJvdGF0aW9uLFxuICAgICAgICBwYWdlTnVtYmVyOiBwYWdlTnVtYmVyXG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMuZGVmYXVsdFJlbmRlcmluZ1F1ZXVlKSB7XG4gICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImZpcnN0UGFnZVByb21pc2VcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnBkZkRvY3VtZW50ID8gdGhpcy5fZmlyc3RQYWdlQ2FwYWJpbGl0eS5wcm9taXNlIDogbnVsbDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib25lUGFnZVJlbmRlcmVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wZGZEb2N1bWVudCA/IHRoaXMuX29uZVBhZ2VSZW5kZXJlZENhcGFiaWxpdHkucHJvbWlzZSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInBhZ2VzUHJvbWlzZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMucGRmRG9jdW1lbnQgPyB0aGlzLl9wYWdlc0NhcGFiaWxpdHkucHJvbWlzZSA6IG51bGw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl92aWV3ZXJFbGVtZW50XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQ6IF92aWV3ZXJFbGVtZW50XCIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfaXNTY3JvbGxNb2RlSG9yaXpvbnRhbFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUgPyBmYWxzZSA6IHRoaXMuX3Njcm9sbE1vZGUgPT09IF91aV91dGlscy5TY3JvbGxNb2RlLkhPUklaT05UQUw7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzSW5QcmVzZW50YXRpb25Nb2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcmVzZW50YXRpb25Nb2RlU3RhdGUgPT09IF91aV91dGlscy5QcmVzZW50YXRpb25Nb2RlU3RhdGUuRlVMTFNDUkVFTjtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDaGFuZ2luZ1ByZXNlbnRhdGlvbk1vZGVcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnByZXNlbnRhdGlvbk1vZGVTdGF0ZSA9PT0gX3VpX3V0aWxzLlByZXNlbnRhdGlvbk1vZGVTdGF0ZS5DSEFOR0lORztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNIb3Jpem9udGFsU2Nyb2xsYmFyRW5hYmxlZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUgPyBmYWxzZSA6IHRoaXMuY29udGFpbmVyLnNjcm9sbFdpZHRoID4gdGhpcy5jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzVmVydGljYWxTY3JvbGxiYXJFbmFibGVkXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0luUHJlc2VudGF0aW9uTW9kZSA/IGZhbHNlIDogdGhpcy5jb250YWluZXIuc2Nyb2xsSGVpZ2h0ID4gdGhpcy5jb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNFcXVhbFBhZ2VTaXplc1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgdmFyIGZpcnN0UGFnZVZpZXcgPSB0aGlzLl9wYWdlc1swXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDEsIGlpID0gdGhpcy5fcGFnZXMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xuICAgICAgICB2YXIgcGFnZVZpZXcgPSB0aGlzLl9wYWdlc1tpXTtcblxuICAgICAgICBpZiAocGFnZVZpZXcud2lkdGggIT09IGZpcnN0UGFnZVZpZXcud2lkdGggfHwgcGFnZVZpZXcuaGVpZ2h0ICE9PSBmaXJzdFBhZ2VWaWV3LmhlaWdodCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgaWYgKCF0aGlzLnBkZkRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUobnVsbCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZGZEb2N1bWVudC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2U7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChwcm9taXNlKSB7XG4gICAgICBpZiAoIShwcm9taXNlIGluc3RhbmNlb2YgUHJvbWlzZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlOiBcIi5jb25jYXQocHJvbWlzZSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMucGRmRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMuX29wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9vcHRpb25hbENvbnRlbnRDb25maWdQcm9taXNlID0gcHJvbWlzZTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHRoaXMuX3BhZ2VzKSxcbiAgICAgICAgICBfc3RlcDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3IucygpOyAhKF9zdGVwID0gX2l0ZXJhdG9yLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgcGFnZVZpZXcgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBwYWdlVmlldy51cGRhdGUocGFnZVZpZXcuc2NhbGUsIHBhZ2VWaWV3LnJvdGF0aW9uLCBwcm9taXNlKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgdGhpcy5ldmVudEJ1cy5kaXNwYXRjaChcIm9wdGlvbmFsY29udGVudGNvbmZpZ2NoYW5nZWRcIiwge1xuICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgIHByb21pc2U6IHByb21pc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzY3JvbGxNb2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2Nyb2xsTW9kZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG1vZGUpIHtcbiAgICAgIGlmICh0aGlzLl9zY3JvbGxNb2RlID09PSBtb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoMCwgX3VpX3V0aWxzLmlzVmFsaWRTY3JvbGxNb2RlKShtb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNjcm9sbCBtb2RlOiBcIi5jb25jYXQobW9kZSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zY3JvbGxNb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuZXZlbnRCdXMuZGlzcGF0Y2goXCJzY3JvbGxtb2RlY2hhbmdlZFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVNjcm9sbE1vZGUodGhpcy5fY3VycmVudFBhZ2VOdW1iZXIpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzcHJlYWRNb2RlXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3ByZWFkTW9kZTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gc2V0KG1vZGUpIHtcbiAgICAgIGlmICh0aGlzLl9zcHJlYWRNb2RlID09PSBtb2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCEoMCwgX3VpX3V0aWxzLmlzVmFsaWRTcHJlYWRNb2RlKShtb2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHNwcmVhZCBtb2RlOiBcIi5jb25jYXQobW9kZSkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zcHJlYWRNb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuZXZlbnRCdXMuZGlzcGF0Y2goXCJzcHJlYWRtb2RlY2hhbmdlZFwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZTogbW9kZVxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZVNwcmVhZE1vZGUodGhpcy5fY3VycmVudFBhZ2VOdW1iZXIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCYXNlVmlld2VyO1xufSgpO1xuXG5leHBvcnRzLkJhc2VWaWV3ZXIgPSBCYXNlVmlld2VyO1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICB2YWx1ZTogdHJ1ZVxufSk7XG5leHBvcnRzLlBERlZpZXdlciA9IHZvaWQgMDtcblxudmFyIF9iYXNlX3ZpZXdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xuXG52YXIgX3BkZmpzTGliID0gX193X3BkZmpzX3JlcXVpcmVfXygyKTtcblxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQ7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcInVuZGVmaW5lZFwiIHx8IG9bU3ltYm9sLml0ZXJhdG9yXSA9PSBudWxsKSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IG9bU3ltYm9sLml0ZXJhdG9yXSgpOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cblxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pOyB9XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbmZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7IF9nZXQgPSBSZWZsZWN0LmdldDsgfSBlbHNlIHsgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHsgdmFyIGJhc2UgPSBfc3VwZXJQcm9wQmFzZSh0YXJnZXQsIHByb3BlcnR5KTsgaWYgKCFiYXNlKSByZXR1cm47IHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7IGlmIChkZXNjLmdldCkgeyByZXR1cm4gZGVzYy5nZXQuY2FsbChyZWNlaXZlcik7IH0gcmV0dXJuIGRlc2MudmFsdWU7IH07IH0gcmV0dXJuIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIgfHwgdGFyZ2V0KTsgfVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZShvYmplY3QsIHByb3BlcnR5KSB7IHdoaWxlICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7IG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpOyBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhazsgfSByZXR1cm4gb2JqZWN0OyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBfc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpOyB9XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fCBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkgeyBvLl9fcHJvdG9fXyA9IHA7IHJldHVybiBvOyB9OyByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApOyB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHsgcmV0dXJuIGNhbGw7IH0gcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZik7IH1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHsgcmV0dXJuIG8uX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihvKTsgfTsgcmV0dXJuIF9nZXRQcm90b3R5cGVPZihvKTsgfVxuXG52YXIgUERGVmlld2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQmFzZVZpZXdlcikge1xuICBfaW5oZXJpdHMoUERGVmlld2VyLCBfQmFzZVZpZXdlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihQREZWaWV3ZXIpO1xuXG4gIGZ1bmN0aW9uIFBERlZpZXdlcigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUERGVmlld2VyKTtcblxuICAgIHJldHVybiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQREZWaWV3ZXIsIFt7XG4gICAga2V5OiBcIl9zY3JvbGxJbnRvVmlld1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfc2Nyb2xsSW50b1ZpZXcoX3JlZikge1xuICAgICAgdmFyIHBhZ2VEaXYgPSBfcmVmLnBhZ2VEaXYsXG4gICAgICAgICAgX3JlZiRwYWdlU3BvdCA9IF9yZWYucGFnZVNwb3QsXG4gICAgICAgICAgcGFnZVNwb3QgPSBfcmVmJHBhZ2VTcG90ID09PSB2b2lkIDAgPyBudWxsIDogX3JlZiRwYWdlU3BvdCxcbiAgICAgICAgICBfcmVmJHBhZ2VOdW1iZXIgPSBfcmVmLnBhZ2VOdW1iZXIsXG4gICAgICAgICAgcGFnZU51bWJlciA9IF9yZWYkcGFnZU51bWJlciA9PT0gdm9pZCAwID8gbnVsbCA6IF9yZWYkcGFnZU51bWJlcjtcblxuICAgICAgaWYgKCFwYWdlU3BvdCAmJiAhdGhpcy5pc0luUHJlc2VudGF0aW9uTW9kZSkge1xuICAgICAgICB2YXIgbGVmdCA9IHBhZ2VEaXYub2Zmc2V0TGVmdCArIHBhZ2VEaXYuY2xpZW50TGVmdDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gbGVmdCArIHBhZ2VEaXYuY2xpZW50V2lkdGg7XG4gICAgICAgIHZhciBfdGhpcyRjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSBfdGhpcyRjb250YWluZXIuc2Nyb2xsTGVmdCxcbiAgICAgICAgICAgIGNsaWVudFdpZHRoID0gX3RoaXMkY29udGFpbmVyLmNsaWVudFdpZHRoO1xuXG4gICAgICAgIGlmICh0aGlzLl9pc1Njcm9sbE1vZGVIb3Jpem9udGFsIHx8IGxlZnQgPCBzY3JvbGxMZWZ0IHx8IHJpZ2h0ID4gc2Nyb2xsTGVmdCArIGNsaWVudFdpZHRoKSB7XG4gICAgICAgICAgcGFnZVNwb3QgPSB7XG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgdG9wOiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihQREZWaWV3ZXIucHJvdG90eXBlKSwgXCJfc2Nyb2xsSW50b1ZpZXdcIiwgdGhpcykuY2FsbCh0aGlzLCB7XG4gICAgICAgIHBhZ2VEaXY6IHBhZ2VEaXYsXG4gICAgICAgIHBhZ2VTcG90OiBwYWdlU3BvdCxcbiAgICAgICAgcGFnZU51bWJlcjogcGFnZU51bWJlclxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRWaXNpYmxlUGFnZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldFZpc2libGVQYWdlcygpIHtcbiAgICAgIGlmICh0aGlzLmlzSW5QcmVzZW50YXRpb25Nb2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRDdXJyZW50VmlzaWJsZVBhZ2UoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9nZXQoX2dldFByb3RvdHlwZU9mKFBERlZpZXdlci5wcm90b3R5cGUpLCBcIl9nZXRWaXNpYmxlUGFnZXNcIiwgdGhpcykuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3VwZGF0ZUhlbHBlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlSGVscGVyKHZpc2libGVQYWdlcykge1xuICAgICAgaWYgKHRoaXMuaXNJblByZXNlbnRhdGlvbk1vZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3VycmVudElkID0gdGhpcy5fY3VycmVudFBhZ2VOdW1iZXI7XG4gICAgICB2YXIgc3RpbGxGdWxseVZpc2libGUgPSBmYWxzZTtcblxuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKHZpc2libGVQYWdlcyksXG4gICAgICAgICAgX3N0ZXA7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIHBhZ2UgPSBfc3RlcC52YWx1ZTtcblxuICAgICAgICAgIGlmIChwYWdlLnBlcmNlbnQgPCAxMDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYWdlLmlkID09PSBjdXJyZW50SWQpIHtcbiAgICAgICAgICAgIHN0aWxsRnVsbHlWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0aWxsRnVsbHlWaXNpYmxlKSB7XG4gICAgICAgIGN1cnJlbnRJZCA9IHZpc2libGVQYWdlc1swXS5pZDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fc2V0Q3VycmVudFBhZ2VOdW1iZXIoY3VycmVudElkKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX3ZpZXdlckVsZW1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiAoMCwgX3BkZmpzTGliLnNoYWRvdykodGhpcywgXCJfdmlld2VyRWxlbWVudFwiLCB0aGlzLnZpZXdlcik7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBERlZpZXdlcjtcbn0oX2Jhc2Vfdmlld2VyLkJhc2VWaWV3ZXIpO1xuXG5leHBvcnRzLlBERlZpZXdlciA9IFBERlZpZXdlcjtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZGZfdmlld2VyLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/pdfjs-dist-sig/es5/web/pdf_viewer.js\n");

/***/ }),

/***/ "./node_modules/pdfobject/pdfobject.js":
/*!*********************************************!*\
  !*** ./node_modules/pdfobject/pdfobject.js ***!
  \*********************************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n *  PDFObject v2.2.5\n *  https://github.com/pipwerks/PDFObject\n *  @license\n *  Copyright (c) 2008-2021 Philip Hutchison\n *  MIT-style license: http://pipwerks.mit-license.org/\n *  UMD module pattern from https://github.com/umdjs/umd/blob/master/templates/returnExports.js\n */\n\n(function (root, factory) {\n    if (true) {\n        // AMD. Register as an anonymous module.\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n}(this, function () {\n\n    \"use strict\";\n\n    //PDFObject is designed for client-side (browsers), not server-side (node)\n    //Will choke on undefined navigator and window vars when run on server\n    //Return boolean false and exit function when running server-side\n\n    if( typeof window === \"undefined\" || \n        window.navigator === undefined || \n        window.navigator.userAgent === undefined || \n        window.navigator.mimeTypes === undefined){ \n            return false;\n    }\n\n    let pdfobjectversion = \"2.2.3\";\n    let nav = window.navigator;\n    let ua = window.navigator.userAgent;\n\n    //Time to jump through hoops -- browser vendors do not make it easy to detect PDF support.\n\n    /*\n        IE11 still uses ActiveX for Adobe Reader, but IE 11 doesn't expose window.ActiveXObject the same way \n        previous versions of IE did. window.ActiveXObject will evaluate to false in IE 11, but \"ActiveXObject\" \n        in window evaluates to true.\n\n        MS Edge does not support ActiveX so this test will evaluate false\n    */\n    let isIE = (\"ActiveXObject\" in window);\n\n    /*\n        There is a coincidental correlation between implementation of window.promises and native PDF support in desktop browsers\n        We use this to assume if the browser supports promises it supports embedded PDFs\n        Is this fragile? Sort of. But browser vendors removed mimetype detection, so we're left to improvise\n    */\n    let isModernBrowser = (window.Promise !== undefined);\n\n    //Older browsers still expose the mimeType\n    let supportsPdfMimeType = (nav.mimeTypes[\"application/pdf\"] !== undefined);\n\n    //Safari on iPadOS doesn't report as 'mobile' when requesting desktop site, yet still fails to embed PDFs\n    let isSafariIOSDesktopMode = (  nav.platform !== undefined && \n                                    nav.platform === \"MacIntel\" && \n                                    nav.maxTouchPoints !== undefined && \n                                    nav.maxTouchPoints > 1 );\n\n    //Quick test for mobile devices.\n    let isMobileDevice = (isSafariIOSDesktopMode || /Mobi|Tablet|Android|iPad|iPhone/.test(ua));\n\n    //Safari desktop requires special handling \n    let isSafariDesktop = ( !isMobileDevice && \n                            nav.vendor !== undefined && \n                            /Apple/.test(nav.vendor) && \n                            /Safari/.test(ua) );\n    \n    //Firefox started shipping PDF.js in Firefox 19. If this is Firefox 19 or greater, assume PDF.js is available\n    let isFirefoxWithPDFJS = (!isMobileDevice && /irefox/.test(ua) && ua.split(\"rv:\").length > 1) ? (parseInt(ua.split(\"rv:\")[1].split(\".\")[0], 10) > 18) : false;\n\n\n    /* ----------------------------------------------------\n       Supporting functions\n       ---------------------------------------------------- */\n\n    let createAXO = function (type){\n        var ax;\n        try {\n            ax = new ActiveXObject(type);\n        } catch (e) {\n            ax = null; //ensure ax remains null\n        }\n        return ax;\n    };\n\n    //If either ActiveX support for \"AcroPDF.PDF\" or \"PDF.PdfCtrl\" are found, return true\n    //Constructed as a method (not a prop) to avoid unneccesarry overhead -- will only be evaluated if needed\n    let supportsPdfActiveX = function (){ return !!(createAXO(\"AcroPDF.PDF\") || createAXO(\"PDF.PdfCtrl\")); };\n\n    //Determines whether PDF support is available\n    let supportsPDFs = (\n        //As of Sept 2020 no mobile browsers properly support PDF embeds\n        !isMobileDevice && (\n            //We're moving into the age of MIME-less browsers. They mostly all support PDF rendering without plugins.\n            isModernBrowser ||\n            //Modern versions of Firefox come bundled with PDFJS\n            isFirefoxWithPDFJS ||\n            //Browsers that still support the original MIME type check\n            supportsPdfMimeType ||\n            //Pity the poor souls still using IE\n            (isIE && supportsPdfActiveX())\n        )\n    );\n\n    //Create a fragment identifier for using PDF Open parameters when embedding PDF\n    let buildURLFragmentString = function(pdfParams){\n\n        let string = \"\";\n        let prop;\n\n        if(pdfParams){\n\n            for (prop in pdfParams) {\n                if (pdfParams.hasOwnProperty(prop)) {\n                    string += encodeURIComponent(prop) + \"=\" + encodeURIComponent(pdfParams[prop]) + \"&\";\n                }\n            }\n\n            //The string will be empty if no PDF Params found\n            if(string){\n\n                string = \"#\" + string;\n\n                //Remove last ampersand\n                string = string.slice(0, string.length - 1);\n\n            }\n\n        }\n\n        return string;\n\n    };\n\n    let embedError = function (msg, suppressConsole){\n        if(!suppressConsole){\n            console.log(\"[PDFObject] \" + msg);\n        }\n        return false;\n    };\n\n    let emptyNodeContents = function (node){\n        while(node.firstChild){\n            node.removeChild(node.firstChild);\n        }\n    };\n\n    let getTargetElement = function (targetSelector){\n\n        //Default to body for full-browser PDF\n        let targetNode = document.body;\n\n        //If a targetSelector is specified, check to see whether\n        //it's passing a selector, jQuery object, or an HTML element\n\n        if(typeof targetSelector === \"string\"){\n\n            //Is CSS selector\n            targetNode = document.querySelector(targetSelector);\n\n        } else if (window.jQuery !== undefined && targetSelector instanceof jQuery && targetSelector.length) {\n\n            //Is jQuery element. Extract HTML node\n            targetNode = targetSelector.get(0);\n\n        } else if (targetSelector.nodeType !== undefined && targetSelector.nodeType === 1){\n\n            //Is HTML element\n            targetNode = targetSelector;\n\n        }\n\n        return targetNode;\n\n    };\n\n    let generatePDFJSMarkup = function (targetNode, url, pdfOpenFragment, PDFJS_URL, id, omitInlineStyles){\n\n        //Ensure target element is empty first\n        emptyNodeContents(targetNode);\n\n        let fullURL = PDFJS_URL + \"?file=\" + encodeURIComponent(url) + pdfOpenFragment;\n        let div = document.createElement(\"div\");\n        let iframe = document.createElement(\"iframe\");\n        \n        iframe.src = fullURL;\n        iframe.className = \"pdfobject\";\n        iframe.type = \"application/pdf\";\n        iframe.frameborder = \"0\";\n        iframe.allow = \"fullscreen\";\n        \n        if(id){\n            iframe.id = id;\n        }\n\n        if(!omitInlineStyles){\n            div.style.cssText = \"position: absolute; top: 0; right: 0; bottom: 0; left: 0;\";\n            iframe.style.cssText = \"border: none; width: 100%; height: 100%;\";\n            targetNode.style.position = \"relative\";\n            targetNode.style.overflow = \"auto\";        \n        }\n\n        div.appendChild(iframe);\n        targetNode.appendChild(div);\n        targetNode.classList.add(\"pdfobject-container\");\n        \n        return targetNode.getElementsByTagName(\"iframe\")[0];\n\n    };\n\n    let generatePDFObjectMarkup = function (embedType, targetNode, targetSelector, url, pdfOpenFragment, width, height, id, omitInlineStyles){\n\n        //Ensure target element is empty first\n        emptyNodeContents(targetNode);\n\n        let embed = document.createElement(embedType);\n        embed.src = url + pdfOpenFragment;\n        embed.className = \"pdfobject\";\n        embed.type = \"application/pdf\";\n\n        if(id){\n            embed.id = id;\n        }\n\n        if(embedType === \"iframe\"){\n            embed.allow = \"fullscreen\";\n        }\n\n        if(!omitInlineStyles){\n\n            let style = (embedType === \"embed\") ? \"overflow: auto;\" : \"border: none;\";\n\n            if(targetSelector && targetSelector !== document.body){\n                style += \"width: \" + width + \"; height: \" + height + \";\";\n            } else {\n                style += \"position: absolute; top: 0; right: 0; bottom: 0; left: 0; width: 100%; height: 100%;\";\n            }\n\n            embed.style.cssText = style; \n\n        }\n\n        targetNode.classList.add(\"pdfobject-container\");\n        targetNode.appendChild(embed);\n\n        return targetNode.getElementsByTagName(embedType)[0];\n\n    };\n\n    let embed = function(url, targetSelector, options){\n\n        //If targetSelector is not defined, convert to boolean\n        let selector = targetSelector || false;\n\n        //Ensure options object is not undefined -- enables easier error checking below\n        let opt = options || {};\n\n        //Get passed options, or set reasonable defaults\n        let id = (typeof opt.id === \"string\") ? opt.id : \"\";\n        let page = opt.page || false;\n        let pdfOpenParams = opt.pdfOpenParams || {};\n        let fallbackLink = opt.fallbackLink || true;\n        let width = opt.width || \"100%\";\n        let height = opt.height || \"100%\";\n        let assumptionMode = (typeof opt.assumptionMode === \"boolean\") ? opt.assumptionMode : true;\n        let forcePDFJS = (typeof opt.forcePDFJS === \"boolean\") ? opt.forcePDFJS : false;\n        let supportRedirect = (typeof opt.supportRedirect === \"boolean\") ? opt.supportRedirect : false;\n        let omitInlineStyles = (typeof opt.omitInlineStyles === \"boolean\") ? opt.omitInlineStyles : false;\n        let suppressConsole = (typeof opt.suppressConsole === \"boolean\") ? opt.suppressConsole : false;\n        let forceIframe = (typeof opt.forceIframe === \"boolean\") ? opt.forceIframe : false;\n        let PDFJS_URL = opt.PDFJS_URL || false;\n        let targetNode = getTargetElement(selector);\n        let fallbackHTML = \"\";\n        let pdfOpenFragment = \"\";\n        let fallbackHTML_default = \"<p>This browser does not support inline PDFs. Please download the PDF to view it: <a href='[url]'>Download PDF</a></p>\";\n\n        //Ensure URL is available. If not, exit now.\n        if(typeof url !== \"string\"){ return embedError(\"URL is not valid\", suppressConsole); }\n\n        //If target element is specified but is not valid, exit without doing anything\n        if(!targetNode){ return embedError(\"Target element cannot be determined\", suppressConsole); }\n\n        //page option overrides pdfOpenParams, if found\n        if(page){ pdfOpenParams.page = page; }\n\n        //Stringify optional Adobe params for opening document (as fragment identifier)\n        pdfOpenFragment = buildURLFragmentString(pdfOpenParams);\n\n\n        // --== Do the dance: Embed attempt #1 ==--\n\n        //If the forcePDFJS option is invoked, skip everything else and embed as directed\n        if(forcePDFJS && PDFJS_URL){\n            return generatePDFJSMarkup(targetNode, url, pdfOpenFragment, PDFJS_URL, id, omitInlineStyles);\n        }\n \n        // --== Embed attempt #2 ==--\n\n        //Embed PDF if traditional support is provided, or if this developer is willing to roll with assumption\n        //that modern desktop (not mobile) browsers natively support PDFs \n        if(supportsPDFs || (assumptionMode && !isMobileDevice)){\n            \n            //Should we use <embed> or <iframe>? In most cases <embed>. \n            //Allow developer to force <iframe>, if desired\n            //There is an edge case where Safari does not respect 302 redirect requests for PDF files when using <embed> element.\n            //Redirect appears to work fine when using <iframe> instead of <embed> (Addresses issue #210)\n            let embedtype = (forceIframe || (supportRedirect && isSafariDesktop)) ? \"iframe\" : \"embed\";\n            \n            return generatePDFObjectMarkup(embedtype, targetNode, targetSelector, url, pdfOpenFragment, width, height, id, omitInlineStyles);\n\n        }\n        \n        // --== Embed attempt #3 ==--\n        \n        //If everything else has failed and a PDFJS fallback is provided, try to use it\n        if(PDFJS_URL){\n            return generatePDFJSMarkup(targetNode, url, pdfOpenFragment, PDFJS_URL, id, omitInlineStyles);\n        }\n        \n        // --== PDF embed not supported! Use fallback ==-- \n\n        //Display the fallback link if available\n        if(fallbackLink){\n\n            fallbackHTML = (typeof fallbackLink === \"string\") ? fallbackLink : fallbackHTML_default;\n            targetNode.innerHTML = fallbackHTML.replace(/\\[url\\]/g, url);\n\n        }\n\n        return embedError(\"This browser does not support embedded PDFs\", suppressConsole);\n\n    };\n\n    return {\n        embed: function (a,b,c){ return embed(a,b,c); },\n        pdfobjectversion: (function () { return pdfobjectversion; })(),\n        supportsPDFs: (function (){ return supportsPDFs; })()\n    };\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGRmb2JqZWN0L3BkZm9iamVjdC5qcz8yNWMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRLElBQTBDO0FBQ2xEO0FBQ0EsUUFBUSxpQ0FBTyxFQUFFLG9DQUFFLE9BQU87QUFBQTtBQUFBO0FBQUEsa0dBQUM7QUFDM0IsS0FBSyxNQUFNLEVBUVI7QUFDSCxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Qsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUNBQXlDLGlFQUFpRTs7QUFFMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUzs7QUFFVDtBQUNBOztBQUVBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxRQUFRLFVBQVUsV0FBVyxTQUFTO0FBQzFGLGlEQUFpRCxhQUFhLGNBQWM7QUFDNUU7QUFDQSwrQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0VBQWtFLGtCQUFrQjs7QUFFcEY7QUFDQSwrQ0FBK0Msd0JBQXdCO0FBQ3ZFLGFBQWE7QUFDYiw2Q0FBNkMsUUFBUSxVQUFVLFdBQVcsU0FBUyxhQUFhLGNBQWM7QUFDOUc7O0FBRUEsd0M7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DLHdEQUF3RDs7QUFFNUY7QUFDQSx3QkFBd0IsMkVBQTJFOztBQUVuRztBQUNBLGlCQUFpQiwyQkFBMkI7O0FBRTVDO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQyxxQkFBcUIsRUFBRTtBQUN2RCx3Q0FBd0MseUJBQXlCLEVBQUU7QUFDbkUsbUNBQW1DLHFCQUFxQixFQUFFO0FBQzFEOztBQUVBLENBQUMiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcGRmb2JqZWN0L3BkZm9iamVjdC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIFBERk9iamVjdCB2Mi4yLjVcbiAqICBodHRwczovL2dpdGh1Yi5jb20vcGlwd2Vya3MvUERGT2JqZWN0XG4gKiAgQGxpY2Vuc2VcbiAqICBDb3B5cmlnaHQgKGMpIDIwMDgtMjAyMSBQaGlsaXAgSHV0Y2hpc29uXG4gKiAgTUlULXN0eWxlIGxpY2Vuc2U6IGh0dHA6Ly9waXB3ZXJrcy5taXQtbGljZW5zZS5vcmcvXG4gKiAgVU1EIG1vZHVsZSBwYXR0ZXJuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL3VtZGpzL3VtZC9ibG9iL21hc3Rlci90ZW1wbGF0ZXMvcmV0dXJuRXhwb3J0cy5qc1xuICovXG5cbihmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICAvLyBBTUQuIFJlZ2lzdGVyIGFzIGFuIGFub255bW91cyBtb2R1bGUuXG4gICAgICAgIGRlZmluZShbXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIC8vIE5vZGUuIERvZXMgbm90IHdvcmsgd2l0aCBzdHJpY3QgQ29tbW9uSlMsIGJ1dFxuICAgICAgICAvLyBvbmx5IENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cyxcbiAgICAgICAgLy8gbGlrZSBOb2RlLlxuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBCcm93c2VyIGdsb2JhbHMgKHJvb3QgaXMgd2luZG93KVxuICAgICAgICByb290LlBERk9iamVjdCA9IGZhY3RvcnkoKTtcbiAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIC8vUERGT2JqZWN0IGlzIGRlc2lnbmVkIGZvciBjbGllbnQtc2lkZSAoYnJvd3NlcnMpLCBub3Qgc2VydmVyLXNpZGUgKG5vZGUpXG4gICAgLy9XaWxsIGNob2tlIG9uIHVuZGVmaW5lZCBuYXZpZ2F0b3IgYW5kIHdpbmRvdyB2YXJzIHdoZW4gcnVuIG9uIHNlcnZlclxuICAgIC8vUmV0dXJuIGJvb2xlYW4gZmFsc2UgYW5kIGV4aXQgZnVuY3Rpb24gd2hlbiBydW5uaW5nIHNlcnZlci1zaWRlXG5cbiAgICBpZiggdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiB8fCBcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvciA9PT0gdW5kZWZpbmVkIHx8IFxuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA9PT0gdW5kZWZpbmVkIHx8IFxuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1pbWVUeXBlcyA9PT0gdW5kZWZpbmVkKXsgXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgbGV0IHBkZm9iamVjdHZlcnNpb24gPSBcIjIuMi4zXCI7XG4gICAgbGV0IG5hdiA9IHdpbmRvdy5uYXZpZ2F0b3I7XG4gICAgbGV0IHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG5cbiAgICAvL1RpbWUgdG8ganVtcCB0aHJvdWdoIGhvb3BzIC0tIGJyb3dzZXIgdmVuZG9ycyBkbyBub3QgbWFrZSBpdCBlYXN5IHRvIGRldGVjdCBQREYgc3VwcG9ydC5cblxuICAgIC8qXG4gICAgICAgIElFMTEgc3RpbGwgdXNlcyBBY3RpdmVYIGZvciBBZG9iZSBSZWFkZXIsIGJ1dCBJRSAxMSBkb2Vzbid0IGV4cG9zZSB3aW5kb3cuQWN0aXZlWE9iamVjdCB0aGUgc2FtZSB3YXkgXG4gICAgICAgIHByZXZpb3VzIHZlcnNpb25zIG9mIElFIGRpZC4gd2luZG93LkFjdGl2ZVhPYmplY3Qgd2lsbCBldmFsdWF0ZSB0byBmYWxzZSBpbiBJRSAxMSwgYnV0IFwiQWN0aXZlWE9iamVjdFwiIFxuICAgICAgICBpbiB3aW5kb3cgZXZhbHVhdGVzIHRvIHRydWUuXG5cbiAgICAgICAgTVMgRWRnZSBkb2VzIG5vdCBzdXBwb3J0IEFjdGl2ZVggc28gdGhpcyB0ZXN0IHdpbGwgZXZhbHVhdGUgZmFsc2VcbiAgICAqL1xuICAgIGxldCBpc0lFID0gKFwiQWN0aXZlWE9iamVjdFwiIGluIHdpbmRvdyk7XG5cbiAgICAvKlxuICAgICAgICBUaGVyZSBpcyBhIGNvaW5jaWRlbnRhbCBjb3JyZWxhdGlvbiBiZXR3ZWVuIGltcGxlbWVudGF0aW9uIG9mIHdpbmRvdy5wcm9taXNlcyBhbmQgbmF0aXZlIFBERiBzdXBwb3J0IGluIGRlc2t0b3AgYnJvd3NlcnNcbiAgICAgICAgV2UgdXNlIHRoaXMgdG8gYXNzdW1lIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIHByb21pc2VzIGl0IHN1cHBvcnRzIGVtYmVkZGVkIFBERnNcbiAgICAgICAgSXMgdGhpcyBmcmFnaWxlPyBTb3J0IG9mLiBCdXQgYnJvd3NlciB2ZW5kb3JzIHJlbW92ZWQgbWltZXR5cGUgZGV0ZWN0aW9uLCBzbyB3ZSdyZSBsZWZ0IHRvIGltcHJvdmlzZVxuICAgICovXG4gICAgbGV0IGlzTW9kZXJuQnJvd3NlciA9ICh3aW5kb3cuUHJvbWlzZSAhPT0gdW5kZWZpbmVkKTtcblxuICAgIC8vT2xkZXIgYnJvd3NlcnMgc3RpbGwgZXhwb3NlIHRoZSBtaW1lVHlwZVxuICAgIGxldCBzdXBwb3J0c1BkZk1pbWVUeXBlID0gKG5hdi5taW1lVHlwZXNbXCJhcHBsaWNhdGlvbi9wZGZcIl0gIT09IHVuZGVmaW5lZCk7XG5cbiAgICAvL1NhZmFyaSBvbiBpUGFkT1MgZG9lc24ndCByZXBvcnQgYXMgJ21vYmlsZScgd2hlbiByZXF1ZXN0aW5nIGRlc2t0b3Agc2l0ZSwgeWV0IHN0aWxsIGZhaWxzIHRvIGVtYmVkIFBERnNcbiAgICBsZXQgaXNTYWZhcmlJT1NEZXNrdG9wTW9kZSA9ICggIG5hdi5wbGF0Zm9ybSAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2LnBsYXRmb3JtID09PSBcIk1hY0ludGVsXCIgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYXYubWF4VG91Y2hQb2ludHMgIT09IHVuZGVmaW5lZCAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdi5tYXhUb3VjaFBvaW50cyA+IDEgKTtcblxuICAgIC8vUXVpY2sgdGVzdCBmb3IgbW9iaWxlIGRldmljZXMuXG4gICAgbGV0IGlzTW9iaWxlRGV2aWNlID0gKGlzU2FmYXJpSU9TRGVza3RvcE1vZGUgfHwgL01vYml8VGFibGV0fEFuZHJvaWR8aVBhZHxpUGhvbmUvLnRlc3QodWEpKTtcblxuICAgIC8vU2FmYXJpIGRlc2t0b3AgcmVxdWlyZXMgc3BlY2lhbCBoYW5kbGluZyBcbiAgICBsZXQgaXNTYWZhcmlEZXNrdG9wID0gKCAhaXNNb2JpbGVEZXZpY2UgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2LnZlbmRvciAhPT0gdW5kZWZpbmVkICYmIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9BcHBsZS8udGVzdChuYXYudmVuZG9yKSAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvU2FmYXJpLy50ZXN0KHVhKSApO1xuICAgIFxuICAgIC8vRmlyZWZveCBzdGFydGVkIHNoaXBwaW5nIFBERi5qcyBpbiBGaXJlZm94IDE5LiBJZiB0aGlzIGlzIEZpcmVmb3ggMTkgb3IgZ3JlYXRlciwgYXNzdW1lIFBERi5qcyBpcyBhdmFpbGFibGVcbiAgICBsZXQgaXNGaXJlZm94V2l0aFBERkpTID0gKCFpc01vYmlsZURldmljZSAmJiAvaXJlZm94Ly50ZXN0KHVhKSAmJiB1YS5zcGxpdChcInJ2OlwiKS5sZW5ndGggPiAxKSA/IChwYXJzZUludCh1YS5zcGxpdChcInJ2OlwiKVsxXS5zcGxpdChcIi5cIilbMF0sIDEwKSA+IDE4KSA6IGZhbHNlO1xuXG5cbiAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgU3VwcG9ydGluZyBmdW5jdGlvbnNcbiAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cbiAgICBsZXQgY3JlYXRlQVhPID0gZnVuY3Rpb24gKHR5cGUpe1xuICAgICAgICB2YXIgYXg7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBheCA9IG5ldyBBY3RpdmVYT2JqZWN0KHR5cGUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBheCA9IG51bGw7IC8vZW5zdXJlIGF4IHJlbWFpbnMgbnVsbFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBheDtcbiAgICB9O1xuXG4gICAgLy9JZiBlaXRoZXIgQWN0aXZlWCBzdXBwb3J0IGZvciBcIkFjcm9QREYuUERGXCIgb3IgXCJQREYuUGRmQ3RybFwiIGFyZSBmb3VuZCwgcmV0dXJuIHRydWVcbiAgICAvL0NvbnN0cnVjdGVkIGFzIGEgbWV0aG9kIChub3QgYSBwcm9wKSB0byBhdm9pZCB1bm5lY2Nlc2Fycnkgb3ZlcmhlYWQgLS0gd2lsbCBvbmx5IGJlIGV2YWx1YXRlZCBpZiBuZWVkZWRcbiAgICBsZXQgc3VwcG9ydHNQZGZBY3RpdmVYID0gZnVuY3Rpb24gKCl7IHJldHVybiAhIShjcmVhdGVBWE8oXCJBY3JvUERGLlBERlwiKSB8fCBjcmVhdGVBWE8oXCJQREYuUGRmQ3RybFwiKSk7IH07XG5cbiAgICAvL0RldGVybWluZXMgd2hldGhlciBQREYgc3VwcG9ydCBpcyBhdmFpbGFibGVcbiAgICBsZXQgc3VwcG9ydHNQREZzID0gKFxuICAgICAgICAvL0FzIG9mIFNlcHQgMjAyMCBubyBtb2JpbGUgYnJvd3NlcnMgcHJvcGVybHkgc3VwcG9ydCBQREYgZW1iZWRzXG4gICAgICAgICFpc01vYmlsZURldmljZSAmJiAoXG4gICAgICAgICAgICAvL1dlJ3JlIG1vdmluZyBpbnRvIHRoZSBhZ2Ugb2YgTUlNRS1sZXNzIGJyb3dzZXJzLiBUaGV5IG1vc3RseSBhbGwgc3VwcG9ydCBQREYgcmVuZGVyaW5nIHdpdGhvdXQgcGx1Z2lucy5cbiAgICAgICAgICAgIGlzTW9kZXJuQnJvd3NlciB8fFxuICAgICAgICAgICAgLy9Nb2Rlcm4gdmVyc2lvbnMgb2YgRmlyZWZveCBjb21lIGJ1bmRsZWQgd2l0aCBQREZKU1xuICAgICAgICAgICAgaXNGaXJlZm94V2l0aFBERkpTIHx8XG4gICAgICAgICAgICAvL0Jyb3dzZXJzIHRoYXQgc3RpbGwgc3VwcG9ydCB0aGUgb3JpZ2luYWwgTUlNRSB0eXBlIGNoZWNrXG4gICAgICAgICAgICBzdXBwb3J0c1BkZk1pbWVUeXBlIHx8XG4gICAgICAgICAgICAvL1BpdHkgdGhlIHBvb3Igc291bHMgc3RpbGwgdXNpbmcgSUVcbiAgICAgICAgICAgIChpc0lFICYmIHN1cHBvcnRzUGRmQWN0aXZlWCgpKVxuICAgICAgICApXG4gICAgKTtcblxuICAgIC8vQ3JlYXRlIGEgZnJhZ21lbnQgaWRlbnRpZmllciBmb3IgdXNpbmcgUERGIE9wZW4gcGFyYW1ldGVycyB3aGVuIGVtYmVkZGluZyBQREZcbiAgICBsZXQgYnVpbGRVUkxGcmFnbWVudFN0cmluZyA9IGZ1bmN0aW9uKHBkZlBhcmFtcyl7XG5cbiAgICAgICAgbGV0IHN0cmluZyA9IFwiXCI7XG4gICAgICAgIGxldCBwcm9wO1xuXG4gICAgICAgIGlmKHBkZlBhcmFtcyl7XG5cbiAgICAgICAgICAgIGZvciAocHJvcCBpbiBwZGZQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAocGRmUGFyYW1zLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBlbmNvZGVVUklDb21wb25lbnQocHJvcCkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChwZGZQYXJhbXNbcHJvcF0pICsgXCImXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvL1RoZSBzdHJpbmcgd2lsbCBiZSBlbXB0eSBpZiBubyBQREYgUGFyYW1zIGZvdW5kXG4gICAgICAgICAgICBpZihzdHJpbmcpe1xuXG4gICAgICAgICAgICAgICAgc3RyaW5nID0gXCIjXCIgKyBzdHJpbmc7XG5cbiAgICAgICAgICAgICAgICAvL1JlbW92ZSBsYXN0IGFtcGVyc2FuZFxuICAgICAgICAgICAgICAgIHN0cmluZyA9IHN0cmluZy5zbGljZSgwLCBzdHJpbmcubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cmluZztcblxuICAgIH07XG5cbiAgICBsZXQgZW1iZWRFcnJvciA9IGZ1bmN0aW9uIChtc2csIHN1cHByZXNzQ29uc29sZSl7XG4gICAgICAgIGlmKCFzdXBwcmVzc0NvbnNvbGUpe1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJbUERGT2JqZWN0XSBcIiArIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICBsZXQgZW1wdHlOb2RlQ29udGVudHMgPSBmdW5jdGlvbiAobm9kZSl7XG4gICAgICAgIHdoaWxlKG5vZGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgbGV0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbiAodGFyZ2V0U2VsZWN0b3Ipe1xuXG4gICAgICAgIC8vRGVmYXVsdCB0byBib2R5IGZvciBmdWxsLWJyb3dzZXIgUERGXG4gICAgICAgIGxldCB0YXJnZXROb2RlID0gZG9jdW1lbnQuYm9keTtcblxuICAgICAgICAvL0lmIGEgdGFyZ2V0U2VsZWN0b3IgaXMgc3BlY2lmaWVkLCBjaGVjayB0byBzZWUgd2hldGhlclxuICAgICAgICAvL2l0J3MgcGFzc2luZyBhIHNlbGVjdG9yLCBqUXVlcnkgb2JqZWN0LCBvciBhbiBIVE1MIGVsZW1lbnRcblxuICAgICAgICBpZih0eXBlb2YgdGFyZ2V0U2VsZWN0b3IgPT09IFwic3RyaW5nXCIpe1xuXG4gICAgICAgICAgICAvL0lzIENTUyBzZWxlY3RvclxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0U2VsZWN0b3IpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93LmpRdWVyeSAhPT0gdW5kZWZpbmVkICYmIHRhcmdldFNlbGVjdG9yIGluc3RhbmNlb2YgalF1ZXJ5ICYmIHRhcmdldFNlbGVjdG9yLmxlbmd0aCkge1xuXG4gICAgICAgICAgICAvL0lzIGpRdWVyeSBlbGVtZW50LiBFeHRyYWN0IEhUTUwgbm9kZVxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRhcmdldFNlbGVjdG9yLmdldCgwKTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFNlbGVjdG9yLm5vZGVUeXBlICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0U2VsZWN0b3Iubm9kZVR5cGUgPT09IDEpe1xuXG4gICAgICAgICAgICAvL0lzIEhUTUwgZWxlbWVudFxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IHRhcmdldFNlbGVjdG9yO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0Tm9kZTtcblxuICAgIH07XG5cbiAgICBsZXQgZ2VuZXJhdGVQREZKU01hcmt1cCA9IGZ1bmN0aW9uICh0YXJnZXROb2RlLCB1cmwsIHBkZk9wZW5GcmFnbWVudCwgUERGSlNfVVJMLCBpZCwgb21pdElubGluZVN0eWxlcyl7XG5cbiAgICAgICAgLy9FbnN1cmUgdGFyZ2V0IGVsZW1lbnQgaXMgZW1wdHkgZmlyc3RcbiAgICAgICAgZW1wdHlOb2RlQ29udGVudHModGFyZ2V0Tm9kZSk7XG5cbiAgICAgICAgbGV0IGZ1bGxVUkwgPSBQREZKU19VUkwgKyBcIj9maWxlPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHVybCkgKyBwZGZPcGVuRnJhZ21lbnQ7XG4gICAgICAgIGxldCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBsZXQgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmcmFtZS5zcmMgPSBmdWxsVVJMO1xuICAgICAgICBpZnJhbWUuY2xhc3NOYW1lID0gXCJwZGZvYmplY3RcIjtcbiAgICAgICAgaWZyYW1lLnR5cGUgPSBcImFwcGxpY2F0aW9uL3BkZlwiO1xuICAgICAgICBpZnJhbWUuZnJhbWVib3JkZXIgPSBcIjBcIjtcbiAgICAgICAgaWZyYW1lLmFsbG93ID0gXCJmdWxsc2NyZWVuXCI7XG4gICAgICAgIFxuICAgICAgICBpZihpZCl7XG4gICAgICAgICAgICBpZnJhbWUuaWQgPSBpZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvbWl0SW5saW5lU3R5bGVzKXtcbiAgICAgICAgICAgIGRpdi5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogYWJzb2x1dGU7IHRvcDogMDsgcmlnaHQ6IDA7IGJvdHRvbTogMDsgbGVmdDogMDtcIjtcbiAgICAgICAgICAgIGlmcmFtZS5zdHlsZS5jc3NUZXh0ID0gXCJib3JkZXI6IG5vbmU7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7XCI7XG4gICAgICAgICAgICB0YXJnZXROb2RlLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZS5zdHlsZS5vdmVyZmxvdyA9IFwiYXV0b1wiOyAgICAgICAgXG4gICAgICAgIH1cblxuICAgICAgICBkaXYuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgdGFyZ2V0Tm9kZS5hcHBlbmRDaGlsZChkaXYpO1xuICAgICAgICB0YXJnZXROb2RlLmNsYXNzTGlzdC5hZGQoXCJwZGZvYmplY3QtY29udGFpbmVyXCIpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRhcmdldE5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJpZnJhbWVcIilbMF07XG5cbiAgICB9O1xuXG4gICAgbGV0IGdlbmVyYXRlUERGT2JqZWN0TWFya3VwID0gZnVuY3Rpb24gKGVtYmVkVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0U2VsZWN0b3IsIHVybCwgcGRmT3BlbkZyYWdtZW50LCB3aWR0aCwgaGVpZ2h0LCBpZCwgb21pdElubGluZVN0eWxlcyl7XG5cbiAgICAgICAgLy9FbnN1cmUgdGFyZ2V0IGVsZW1lbnQgaXMgZW1wdHkgZmlyc3RcbiAgICAgICAgZW1wdHlOb2RlQ29udGVudHModGFyZ2V0Tm9kZSk7XG5cbiAgICAgICAgbGV0IGVtYmVkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChlbWJlZFR5cGUpO1xuICAgICAgICBlbWJlZC5zcmMgPSB1cmwgKyBwZGZPcGVuRnJhZ21lbnQ7XG4gICAgICAgIGVtYmVkLmNsYXNzTmFtZSA9IFwicGRmb2JqZWN0XCI7XG4gICAgICAgIGVtYmVkLnR5cGUgPSBcImFwcGxpY2F0aW9uL3BkZlwiO1xuXG4gICAgICAgIGlmKGlkKXtcbiAgICAgICAgICAgIGVtYmVkLmlkID0gaWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZihlbWJlZFR5cGUgPT09IFwiaWZyYW1lXCIpe1xuICAgICAgICAgICAgZW1iZWQuYWxsb3cgPSBcImZ1bGxzY3JlZW5cIjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvbWl0SW5saW5lU3R5bGVzKXtcblxuICAgICAgICAgICAgbGV0IHN0eWxlID0gKGVtYmVkVHlwZSA9PT0gXCJlbWJlZFwiKSA/IFwib3ZlcmZsb3c6IGF1dG87XCIgOiBcImJvcmRlcjogbm9uZTtcIjtcblxuICAgICAgICAgICAgaWYodGFyZ2V0U2VsZWN0b3IgJiYgdGFyZ2V0U2VsZWN0b3IgIT09IGRvY3VtZW50LmJvZHkpe1xuICAgICAgICAgICAgICAgIHN0eWxlICs9IFwid2lkdGg6IFwiICsgd2lkdGggKyBcIjsgaGVpZ2h0OiBcIiArIGhlaWdodCArIFwiO1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZSArPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBsZWZ0OiAwOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlO1wiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbWJlZC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7IFxuXG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXROb2RlLmNsYXNzTGlzdC5hZGQoXCJwZGZvYmplY3QtY29udGFpbmVyXCIpO1xuICAgICAgICB0YXJnZXROb2RlLmFwcGVuZENoaWxkKGVtYmVkKTtcblxuICAgICAgICByZXR1cm4gdGFyZ2V0Tm9kZS5nZXRFbGVtZW50c0J5VGFnTmFtZShlbWJlZFR5cGUpWzBdO1xuXG4gICAgfTtcblxuICAgIGxldCBlbWJlZCA9IGZ1bmN0aW9uKHVybCwgdGFyZ2V0U2VsZWN0b3IsIG9wdGlvbnMpe1xuXG4gICAgICAgIC8vSWYgdGFyZ2V0U2VsZWN0b3IgaXMgbm90IGRlZmluZWQsIGNvbnZlcnQgdG8gYm9vbGVhblxuICAgICAgICBsZXQgc2VsZWN0b3IgPSB0YXJnZXRTZWxlY3RvciB8fCBmYWxzZTtcblxuICAgICAgICAvL0Vuc3VyZSBvcHRpb25zIG9iamVjdCBpcyBub3QgdW5kZWZpbmVkIC0tIGVuYWJsZXMgZWFzaWVyIGVycm9yIGNoZWNraW5nIGJlbG93XG4gICAgICAgIGxldCBvcHQgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIC8vR2V0IHBhc3NlZCBvcHRpb25zLCBvciBzZXQgcmVhc29uYWJsZSBkZWZhdWx0c1xuICAgICAgICBsZXQgaWQgPSAodHlwZW9mIG9wdC5pZCA9PT0gXCJzdHJpbmdcIikgPyBvcHQuaWQgOiBcIlwiO1xuICAgICAgICBsZXQgcGFnZSA9IG9wdC5wYWdlIHx8IGZhbHNlO1xuICAgICAgICBsZXQgcGRmT3BlblBhcmFtcyA9IG9wdC5wZGZPcGVuUGFyYW1zIHx8IHt9O1xuICAgICAgICBsZXQgZmFsbGJhY2tMaW5rID0gb3B0LmZhbGxiYWNrTGluayB8fCB0cnVlO1xuICAgICAgICBsZXQgd2lkdGggPSBvcHQud2lkdGggfHwgXCIxMDAlXCI7XG4gICAgICAgIGxldCBoZWlnaHQgPSBvcHQuaGVpZ2h0IHx8IFwiMTAwJVwiO1xuICAgICAgICBsZXQgYXNzdW1wdGlvbk1vZGUgPSAodHlwZW9mIG9wdC5hc3N1bXB0aW9uTW9kZSA9PT0gXCJib29sZWFuXCIpID8gb3B0LmFzc3VtcHRpb25Nb2RlIDogdHJ1ZTtcbiAgICAgICAgbGV0IGZvcmNlUERGSlMgPSAodHlwZW9mIG9wdC5mb3JjZVBERkpTID09PSBcImJvb2xlYW5cIikgPyBvcHQuZm9yY2VQREZKUyA6IGZhbHNlO1xuICAgICAgICBsZXQgc3VwcG9ydFJlZGlyZWN0ID0gKHR5cGVvZiBvcHQuc3VwcG9ydFJlZGlyZWN0ID09PSBcImJvb2xlYW5cIikgPyBvcHQuc3VwcG9ydFJlZGlyZWN0IDogZmFsc2U7XG4gICAgICAgIGxldCBvbWl0SW5saW5lU3R5bGVzID0gKHR5cGVvZiBvcHQub21pdElubGluZVN0eWxlcyA9PT0gXCJib29sZWFuXCIpID8gb3B0Lm9taXRJbmxpbmVTdHlsZXMgOiBmYWxzZTtcbiAgICAgICAgbGV0IHN1cHByZXNzQ29uc29sZSA9ICh0eXBlb2Ygb3B0LnN1cHByZXNzQ29uc29sZSA9PT0gXCJib29sZWFuXCIpID8gb3B0LnN1cHByZXNzQ29uc29sZSA6IGZhbHNlO1xuICAgICAgICBsZXQgZm9yY2VJZnJhbWUgPSAodHlwZW9mIG9wdC5mb3JjZUlmcmFtZSA9PT0gXCJib29sZWFuXCIpID8gb3B0LmZvcmNlSWZyYW1lIDogZmFsc2U7XG4gICAgICAgIGxldCBQREZKU19VUkwgPSBvcHQuUERGSlNfVVJMIHx8IGZhbHNlO1xuICAgICAgICBsZXQgdGFyZ2V0Tm9kZSA9IGdldFRhcmdldEVsZW1lbnQoc2VsZWN0b3IpO1xuICAgICAgICBsZXQgZmFsbGJhY2tIVE1MID0gXCJcIjtcbiAgICAgICAgbGV0IHBkZk9wZW5GcmFnbWVudCA9IFwiXCI7XG4gICAgICAgIGxldCBmYWxsYmFja0hUTUxfZGVmYXVsdCA9IFwiPHA+VGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgaW5saW5lIFBERnMuIFBsZWFzZSBkb3dubG9hZCB0aGUgUERGIHRvIHZpZXcgaXQ6IDxhIGhyZWY9J1t1cmxdJz5Eb3dubG9hZCBQREY8L2E+PC9wPlwiO1xuXG4gICAgICAgIC8vRW5zdXJlIFVSTCBpcyBhdmFpbGFibGUuIElmIG5vdCwgZXhpdCBub3cuXG4gICAgICAgIGlmKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIpeyByZXR1cm4gZW1iZWRFcnJvcihcIlVSTCBpcyBub3QgdmFsaWRcIiwgc3VwcHJlc3NDb25zb2xlKTsgfVxuXG4gICAgICAgIC8vSWYgdGFyZ2V0IGVsZW1lbnQgaXMgc3BlY2lmaWVkIGJ1dCBpcyBub3QgdmFsaWQsIGV4aXQgd2l0aG91dCBkb2luZyBhbnl0aGluZ1xuICAgICAgICBpZighdGFyZ2V0Tm9kZSl7IHJldHVybiBlbWJlZEVycm9yKFwiVGFyZ2V0IGVsZW1lbnQgY2Fubm90IGJlIGRldGVybWluZWRcIiwgc3VwcHJlc3NDb25zb2xlKTsgfVxuXG4gICAgICAgIC8vcGFnZSBvcHRpb24gb3ZlcnJpZGVzIHBkZk9wZW5QYXJhbXMsIGlmIGZvdW5kXG4gICAgICAgIGlmKHBhZ2UpeyBwZGZPcGVuUGFyYW1zLnBhZ2UgPSBwYWdlOyB9XG5cbiAgICAgICAgLy9TdHJpbmdpZnkgb3B0aW9uYWwgQWRvYmUgcGFyYW1zIGZvciBvcGVuaW5nIGRvY3VtZW50IChhcyBmcmFnbWVudCBpZGVudGlmaWVyKVxuICAgICAgICBwZGZPcGVuRnJhZ21lbnQgPSBidWlsZFVSTEZyYWdtZW50U3RyaW5nKHBkZk9wZW5QYXJhbXMpO1xuXG5cbiAgICAgICAgLy8gLS09PSBEbyB0aGUgZGFuY2U6IEVtYmVkIGF0dGVtcHQgIzEgPT0tLVxuXG4gICAgICAgIC8vSWYgdGhlIGZvcmNlUERGSlMgb3B0aW9uIGlzIGludm9rZWQsIHNraXAgZXZlcnl0aGluZyBlbHNlIGFuZCBlbWJlZCBhcyBkaXJlY3RlZFxuICAgICAgICBpZihmb3JjZVBERkpTICYmIFBERkpTX1VSTCl7XG4gICAgICAgICAgICByZXR1cm4gZ2VuZXJhdGVQREZKU01hcmt1cCh0YXJnZXROb2RlLCB1cmwsIHBkZk9wZW5GcmFnbWVudCwgUERGSlNfVVJMLCBpZCwgb21pdElubGluZVN0eWxlcyk7XG4gICAgICAgIH1cbiBcbiAgICAgICAgLy8gLS09PSBFbWJlZCBhdHRlbXB0ICMyID09LS1cblxuICAgICAgICAvL0VtYmVkIFBERiBpZiB0cmFkaXRpb25hbCBzdXBwb3J0IGlzIHByb3ZpZGVkLCBvciBpZiB0aGlzIGRldmVsb3BlciBpcyB3aWxsaW5nIHRvIHJvbGwgd2l0aCBhc3N1bXB0aW9uXG4gICAgICAgIC8vdGhhdCBtb2Rlcm4gZGVza3RvcCAobm90IG1vYmlsZSkgYnJvd3NlcnMgbmF0aXZlbHkgc3VwcG9ydCBQREZzIFxuICAgICAgICBpZihzdXBwb3J0c1BERnMgfHwgKGFzc3VtcHRpb25Nb2RlICYmICFpc01vYmlsZURldmljZSkpe1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvL1Nob3VsZCB3ZSB1c2UgPGVtYmVkPiBvciA8aWZyYW1lPj8gSW4gbW9zdCBjYXNlcyA8ZW1iZWQ+LiBcbiAgICAgICAgICAgIC8vQWxsb3cgZGV2ZWxvcGVyIHRvIGZvcmNlIDxpZnJhbWU+LCBpZiBkZXNpcmVkXG4gICAgICAgICAgICAvL1RoZXJlIGlzIGFuIGVkZ2UgY2FzZSB3aGVyZSBTYWZhcmkgZG9lcyBub3QgcmVzcGVjdCAzMDIgcmVkaXJlY3QgcmVxdWVzdHMgZm9yIFBERiBmaWxlcyB3aGVuIHVzaW5nIDxlbWJlZD4gZWxlbWVudC5cbiAgICAgICAgICAgIC8vUmVkaXJlY3QgYXBwZWFycyB0byB3b3JrIGZpbmUgd2hlbiB1c2luZyA8aWZyYW1lPiBpbnN0ZWFkIG9mIDxlbWJlZD4gKEFkZHJlc3NlcyBpc3N1ZSAjMjEwKVxuICAgICAgICAgICAgbGV0IGVtYmVkdHlwZSA9IChmb3JjZUlmcmFtZSB8fCAoc3VwcG9ydFJlZGlyZWN0ICYmIGlzU2FmYXJpRGVza3RvcCkpID8gXCJpZnJhbWVcIiA6IFwiZW1iZWRcIjtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIGdlbmVyYXRlUERGT2JqZWN0TWFya3VwKGVtYmVkdHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0U2VsZWN0b3IsIHVybCwgcGRmT3BlbkZyYWdtZW50LCB3aWR0aCwgaGVpZ2h0LCBpZCwgb21pdElubGluZVN0eWxlcyk7XG5cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gLS09PSBFbWJlZCBhdHRlbXB0ICMzID09LS1cbiAgICAgICAgXG4gICAgICAgIC8vSWYgZXZlcnl0aGluZyBlbHNlIGhhcyBmYWlsZWQgYW5kIGEgUERGSlMgZmFsbGJhY2sgaXMgcHJvdmlkZWQsIHRyeSB0byB1c2UgaXRcbiAgICAgICAgaWYoUERGSlNfVVJMKXtcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0ZVBERkpTTWFya3VwKHRhcmdldE5vZGUsIHVybCwgcGRmT3BlbkZyYWdtZW50LCBQREZKU19VUkwsIGlkLCBvbWl0SW5saW5lU3R5bGVzKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gLS09PSBQREYgZW1iZWQgbm90IHN1cHBvcnRlZCEgVXNlIGZhbGxiYWNrID09LS0gXG5cbiAgICAgICAgLy9EaXNwbGF5IHRoZSBmYWxsYmFjayBsaW5rIGlmIGF2YWlsYWJsZVxuICAgICAgICBpZihmYWxsYmFja0xpbmspe1xuXG4gICAgICAgICAgICBmYWxsYmFja0hUTUwgPSAodHlwZW9mIGZhbGxiYWNrTGluayA9PT0gXCJzdHJpbmdcIikgPyBmYWxsYmFja0xpbmsgOiBmYWxsYmFja0hUTUxfZGVmYXVsdDtcbiAgICAgICAgICAgIHRhcmdldE5vZGUuaW5uZXJIVE1MID0gZmFsbGJhY2tIVE1MLnJlcGxhY2UoL1xcW3VybFxcXS9nLCB1cmwpO1xuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW1iZWRFcnJvcihcIlRoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGVtYmVkZGVkIFBERnNcIiwgc3VwcHJlc3NDb25zb2xlKTtcblxuICAgIH07XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBlbWJlZDogZnVuY3Rpb24gKGEsYixjKXsgcmV0dXJuIGVtYmVkKGEsYixjKTsgfSxcbiAgICAgICAgcGRmb2JqZWN0dmVyc2lvbjogKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBkZm9iamVjdHZlcnNpb247IH0pKCksXG4gICAgICAgIHN1cHBvcnRzUERGczogKGZ1bmN0aW9uICgpeyByZXR1cm4gc3VwcG9ydHNQREZzOyB9KSgpXG4gICAgfTtcblxufSkpO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/pdfobject/pdfobject.js\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_9_use_1_vue_loader_dist_stylePostLoader_js_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_vue_loader_dist_index_js_ruleSet_0_use_0_resize_sensor_vue_vue_type_style_index_0_id_07f4b013_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../vue-loader/dist/stylePostLoader.js!../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../vue-loader/dist/index.js??ruleSet[0].use[0]!./resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_vue_loader_dist_stylePostLoader_js_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_vue_loader_dist_index_js_ruleSet_0_use_0_resize_sensor_vue_vue_type_style_index_0_id_07f4b013_lang_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_vue_loader_dist_stylePostLoader_js_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_vue_loader_dist_index_js_ruleSet_0_use_0_resize_sensor_vue_vue_type_style_index_0_id_07f4b013_lang_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZT9jZWY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0U7QUFDL0UsWUFBNlM7O0FBRTdTOztBQUVBO0FBQ0E7O0FBRUEsYUFBYSw2RkFBRyxDQUFDLDZRQUFPOzs7O0FBSXhCLGlFQUFlLG9SQUFjLE1BQU0iLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvY2pzLmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOS51c2VbMV0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L3N0eWxlUG9zdExvYWRlci5qcyEuL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsyXSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vbm9kZV9tb2R1bGVzL3Z1ZTMtcmVzaXplLXNlbnNvci9zcmMvcmVzaXplLXNlbnNvci52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD0wN2Y0YjAxMyZsYW5nPWNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuLi8uLi92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzJdIS4uLy4uL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9yZXNpemUtc2Vuc29yLnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTA3ZjRiMDEzJmxhbmc9Y3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css":
/*!*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css ***!
  \*******************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PatientTestFileModalComponent_vue_vue_type_style_index_0_id_602a6bea_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PatientTestFileModalComponent_vue_vue_type_style_index_0_id_602a6bea_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PatientTestFileModalComponent_vue_vue_type_style_index_0_id_602a6bea_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC52dWU/YTVkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdHO0FBQ3hHLFlBQTZhOztBQUU3YTs7QUFFQTtBQUNBOztBQUVBLGFBQWEsMEdBQUcsQ0FBQyw2VkFBTzs7OztBQUl4QixpRUFBZSxvV0FBYyxNQUFNIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzFdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOS51c2VbMl0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3BhdGllbnQvdGVzdC90ZXN0RmlsZU1vZGFsL1BhdGllbnRUZXN0RmlsZU1vZGFsQ29tcG9uZW50LnZ1ZT92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmlkPTYwMmE2YmVhJnNjb3BlZD10cnVlJmxhbmc9Y3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFwaSBmcm9tIFwiIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOS51c2VbMV0hLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzJdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vUGF0aWVudFRlc3RGaWxlTW9kYWxDb21wb25lbnQudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9NjAyYTZiZWEmc2NvcGVkPXRydWUmbGFuZz1jc3NcIjtcblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBcImhlYWRcIjtcbm9wdGlvbnMuc2luZ2xldG9uID0gZmFsc2U7XG5cbnZhciB1cGRhdGUgPSBhcGkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgZGVmYXVsdCBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css\n");

/***/ }),

/***/ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css":
/*!*****************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_loader_dist_cjs_js_clonedRuleSet_9_use_1_vue_loader_dist_stylePostLoader_js_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_annotationLayer_css_vue_type_style_index_0_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../vue-loader/dist/stylePostLoader.js!../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./annotationLayer.css?vue&type=style&index=0&lang=css */ \"./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_vue_loader_dist_stylePostLoader_js_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_annotationLayer_css_vue_type_style_index_0_lang_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_vue_loader_dist_stylePostLoader_js_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_annotationLayer_css_vue_type_style_index_0_lang_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL2Fubm90YXRpb25MYXllci5jc3M/YmJkNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQStFO0FBQy9FLFlBQWlQOztBQUVqUDs7QUFFQTtBQUNBOztBQUVBLGFBQWEsNkZBQUcsQ0FBQywwTkFBTzs7OztBQUl4QixpRUFBZSxpT0FBYyxNQUFNIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzFdIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9zdHlsZVBvc3RMb2FkZXIuanMhLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvZGlzdC9janMuanM/P2Nsb25lZFJ1bGVTZXQtOS51c2VbMl0hLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL2Fubm90YXRpb25MYXllci5jc3M/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZsYW5nPWNzcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcGkgZnJvbSBcIiEuLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgICAgICAgaW1wb3J0IGNvbnRlbnQgZnJvbSBcIiEhLi4vLi4vY3NzLWxvYWRlci9kaXN0L2Nqcy5qcz8/Y2xvbmVkUnVsZVNldC05LnVzZVsxXSEuLi8uLi92dWUtbG9hZGVyL2Rpc3Qvc3R5bGVQb3N0TG9hZGVyLmpzIS4uLy4uL3Bvc3Rjc3MtbG9hZGVyL2Rpc3QvY2pzLmpzPz9jbG9uZWRSdWxlU2V0LTkudXNlWzJdIS4vYW5ub3RhdGlvbkxheWVyLmNzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzXCI7XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cblxuZXhwb3J0IGRlZmF1bHQgY29udGVudC5sb2NhbHMgfHwge307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css\n");

/***/ }),

/***/ "./node_modules/vue3-pdf/src/vuePdfNoSss.vue":
/*!***************************************************!*\
  !*** ./node_modules/vue3-pdf/src/vuePdfNoSss.vue ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _vuePdfNoSss_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vuePdfNoSss.vue?vue&type=script&lang=js */ \"./node_modules/vue3-pdf/src/vuePdfNoSss.vue?vue&type=script&lang=js\");\n/* harmony import */ var _annotationLayer_css_vue_type_style_index_0_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./annotationLayer.css?vue&type=style&index=0&lang=css */ \"./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css\");\n\n\n\n;\n/* hot reload */\nif (false) {}\n\n_vuePdfNoSss_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default.__file = \"node_modules/vue3-pdf/src/vuePdfNoSss.vue\"\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_vuePdfNoSss_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL3Z1ZVBkZk5vU3NzLnZ1ZT9hNzJiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUE4RDtBQUNMOztBQUV6RCxDQUE4RDtBQUM5RDtBQUNBLElBQUksS0FBVSxFQUFFLEVBUWY7O0FBRUQsb0ZBQWE7O0FBRWIsaUVBQWUsNkUiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL3Z1ZVBkZk5vU3NzLnZ1ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzY3JpcHQgZnJvbSBcIi4vdnVlUGRmTm9Tc3MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCJcbmV4cG9ydCAqIGZyb20gXCIuL3Z1ZVBkZk5vU3NzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiXG5cbmltcG9ydCBcIi4vYW5ub3RhdGlvbkxheWVyLmNzcz92dWUmdHlwZT1zdHlsZSZpbmRleD0wJmxhbmc9Y3NzXCJcbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7XG4gIHNjcmlwdC5fX2htcklkID0gXCIxMzQ5NDc0NVwiXG4gIGNvbnN0IGFwaSA9IF9fVlVFX0hNUl9SVU5USU1FX19cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIWFwaS5jcmVhdGVSZWNvcmQoJzEzNDk0NzQ1Jywgc2NyaXB0KSkge1xuICAgIGFwaS5yZWxvYWQoJzEzNDk0NzQ1Jywgc2NyaXB0KVxuICB9XG4gIFxufVxuXG5zY3JpcHQuX19maWxlID0gXCJub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL3Z1ZVBkZk5vU3NzLnZ1ZVwiXG5cbmV4cG9ydCBkZWZhdWx0IHNjcmlwdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue3-pdf/src/vuePdfNoSss.vue\n");

/***/ }),

/***/ "./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-pdf/src/vuePdfNoSss.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-pdf/src/vuePdfNoSss.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _componentFactory_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./componentFactory.js */ \"./node_modules/vue3-pdf/src/componentFactory.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process/browser */ \"./node_modules/process/browser.js\");\n\r\n\r\n\t\r\n\r\n\tif ( process.env.VUE_ENV !== 'server' ) {\r\n\r\n\t\tvar pdfjsWrapper = __webpack_require__(/*! ./pdfjsWrapper.js */ \"./node_modules/vue3-pdf/src/pdfjsWrapper.js\").default;\r\n\t\tvar PDFJS = __webpack_require__(/*! pdfjs-dist-sig/es5/build/pdf.js */ \"./node_modules/pdfjs-dist-sig/es5/build/pdf.js\");\r\n\r\n\t\tif ( typeof window !== 'undefined' && 'Worker' in window && navigator.appVersion.indexOf('MSIE 10') === -1 ) {\r\n\r\n\t\t\tvar PdfjsWorker = __webpack_require__(/*! worker-loader!pdfjs-dist-sig/es5/build/pdf.worker.js */ \"./node_modules/worker-loader/dist/cjs.js!./node_modules/pdfjs-dist-sig/es5/build/pdf.worker.js\");\r\n\t\t\tPDFJS.GlobalWorkerOptions.workerPort = new PdfjsWorker();\r\n\t\t}\r\n\r\n\t\tvar component = (0,_componentFactory_js__WEBPACK_IMPORTED_MODULE_0__.default)(pdfjsWrapper(PDFJS));\r\n\t} else {\r\n\r\n\t\tvar component = (0,_componentFactory_js__WEBPACK_IMPORTED_MODULE_0__.default)({});\r\n\t}\r\n\r\n\t/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (component);\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL3Z1ZVBkZk5vU3NzLnZ1ZT9kNDU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0NBR3FEOztDQUVwRCxDQUFDLEVBQUUsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFOztFQUV2QyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLG1HQUFvQztFQUN2RCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxtQkFBTyxDQUFDLHVGQUFpQyxDQUFDOztFQUV0RCxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRTs7R0FFNUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsbUJBQU8sQ0FBQyw0SkFBc0QsQ0FBQztHQUNqRixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7RUFDekQ7O0VBRUEsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSw2REFBZ0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDdEQsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFOztFQUVOLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsNkRBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUM7Q0FDckM7O0NBRUEsaUVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBQyIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vbm9kZV9tb2R1bGVzL3Z1ZTMtcGRmL3NyYy92dWVQZGZOb1Nzcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMuanMiLCJzb3VyY2VzQ29udGVudCI6WyI8c3R5bGUgc3JjPVwiLi9hbm5vdGF0aW9uTGF5ZXIuY3NzXCI+PC9zdHlsZT5cclxuPHNjcmlwdD5cclxuXHJcblx0aW1wb3J0IGNvbXBvbmVudEZhY3RvcnkgZnJvbSAnLi9jb21wb25lbnRGYWN0b3J5LmpzJ1xyXG5cclxuXHRpZiAoIHByb2Nlc3MuZW52LlZVRV9FTlYgIT09ICdzZXJ2ZXInICkge1xyXG5cclxuXHRcdHZhciBwZGZqc1dyYXBwZXIgPSByZXF1aXJlKCcuL3BkZmpzV3JhcHBlci5qcycpLmRlZmF1bHQ7XHJcblx0XHR2YXIgUERGSlMgPSByZXF1aXJlKCdwZGZqcy1kaXN0LXNpZy9lczUvYnVpbGQvcGRmLmpzJyk7XHJcblxyXG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAnV29ya2VyJyBpbiB3aW5kb3cgJiYgbmF2aWdhdG9yLmFwcFZlcnNpb24uaW5kZXhPZignTVNJRSAxMCcpID09PSAtMSApIHtcclxuXHJcblx0XHRcdHZhciBQZGZqc1dvcmtlciA9IHJlcXVpcmUoJ3dvcmtlci1sb2FkZXIhcGRmanMtZGlzdC1zaWcvZXM1L2J1aWxkL3BkZi53b3JrZXIuanMnKTtcclxuXHRcdFx0UERGSlMuR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJQb3J0ID0gbmV3IFBkZmpzV29ya2VyKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNvbXBvbmVudCA9IGNvbXBvbmVudEZhY3RvcnkocGRmanNXcmFwcGVyKFBERkpTKSk7XHJcblx0fSBlbHNlIHtcclxuXHJcblx0XHR2YXIgY29tcG9uZW50ID0gY29tcG9uZW50RmFjdG9yeSh7fSk7XHJcblx0fVxyXG5cclxuXHRleHBvcnQgZGVmYXVsdCBjb21wb25lbnQ7XHJcbjwvc2NyaXB0PiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-pdf/src/vuePdfNoSss.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./node_modules/vue3-resize-sensor/src/resize-sensor.vue":
/*!***************************************************************!*\
  !*** ./node_modules/vue3-resize-sensor/src/resize-sensor.vue ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _resize_sensor_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resize-sensor.vue?vue&type=script&lang=js */ \"./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=script&lang=js\");\n/* harmony import */ var _resize_sensor_vue_vue_type_style_index_0_id_07f4b013_lang_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css */ \"./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css\");\n\n\n\n;\n/* hot reload */\nif (false) {}\n\n_resize_sensor_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default.__file = \"node_modules/vue3-resize-sensor/src/resize-sensor.vue\"\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_resize_sensor_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZT9mZGZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFnRTtBQUNMOztBQUUzRCxDQUF3RTtBQUN4RTtBQUNBLElBQUksS0FBVSxFQUFFLEVBUWY7O0FBRUQsc0ZBQWE7O0FBRWIsaUVBQWUsK0UiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzY3JpcHQgZnJvbSBcIi4vcmVzaXplLXNlbnNvci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuZXhwb3J0ICogZnJvbSBcIi4vcmVzaXplLXNlbnNvci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anNcIlxuXG5pbXBvcnQgXCIuL3Jlc2l6ZS1zZW5zb3IudnVlP3Z1ZSZ0eXBlPXN0eWxlJmluZGV4PTAmaWQ9MDdmNGIwMTMmbGFuZz1jc3NcIlxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgc2NyaXB0Ll9faG1ySWQgPSBcIjA3ZjRiMDEzXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnMDdmNGIwMTMnLCBzY3JpcHQpKSB7XG4gICAgYXBpLnJlbG9hZCgnMDdmNGIwMTMnLCBzY3JpcHQpXG4gIH1cbiAgXG59XG5cbnNjcmlwdC5fX2ZpbGUgPSBcIm5vZGVfbW9kdWxlcy92dWUzLXJlc2l6ZS1zZW5zb3Ivc3JjL3Jlc2l6ZS1zZW5zb3IudnVlXCJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue3-resize-sensor/src/resize-sensor.vue\n");

/***/ }),

/***/ "./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=script&lang=js":
/*!**************************************************************************************************************************************************!*\
  !*** ./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=script&lang=js ***!
  \**************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\");\n\r\n\r\n\r\n\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\r\n\r\n\t// thanks to https://github.com/marcj/css-element-queries\r\n\tprops: {\r\n\t\tinitial: {\r\n\t\t\ttype: Boolean,\r\n\t\t\tdefault: false,\r\n\t\t}\r\n\t},\r\n\tdata: function() {\r\n\t\treturn {\r\n\t\t\tsize: {\r\n\t\t\t\twidth: -1,\r\n\t\t\t\theight: -1\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\tmethods: {\r\n\t\treset: function() {\r\n\r\n\t\t\tvar expand = this.$el.firstChild;\r\n\t\t\tvar shrink = this.$el.lastChild;\r\n\t\t\texpand.scrollLeft = 100000;\r\n\t\t\texpand.scrollTop = 100000;\r\n\t\t\tshrink.scrollLeft = 100000;\r\n\t\t\tshrink.scrollTop = 100000;\r\n\t\t},\r\n\t\tupdate: function() {\r\n\t\t\t\r\n\t\t\tthis.size.width = this.$el.offsetWidth;\r\n\t\t\tthis.size.height = this.$el.offsetHeight;\r\n\t\t}\r\n\t},\r\n\twatch: {\r\n\t\tsize: {\r\n\t\t\tdeep: true,\r\n\t\t\thandler: function(size) {\r\n\t\t\t\t\r\n\t\t\t\tthis.reset();\r\n\t\t\t\tthis.$emit('resize', { width: this.size.width, height: this.size.height });\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\trender: function() {\r\n\t\t\r\n\t\tvar style = 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';\r\n\t\tvar styleChild = 'position: absolute; left: 0; top: 0;';\r\n\r\n\t\treturn (0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('div', {\r\n\t\t\tstyle: style + 'animation-name: resizeSensorVisibility;',\r\n\t\t\tonAnimationStart: this.update\r\n\t\t},[\r\n\t\t\t(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('div', {\r\n\t\t\t\tstyle: style,\r\n\t\t\t\tonScroll: this.update\r\n\t\t\t}, [\r\n\t\t\t\t(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('div', {\r\n\t\t\t\t\tstyle: styleChild + 'width: 100000px; height: 100000px;'\r\n\t\t\t\t})\r\n\t\t\t]),\r\n\t\t\t(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('div', {\r\n\t\t\t\tstyle: style,\r\n\t\t\t\tonScroll: this.update\r\n\t\t\t}, [\r\n\t\t\t\t(0,vue__WEBPACK_IMPORTED_MODULE_0__.h)('div', {\r\n\t\t\t\t\tstyle: styleChild + 'width: 200%; height: 200%;'\r\n\t\t\t\t})\r\n\t\t\t]),\r\n\t\t]);\r\n\t},\r\n\tbeforeUnmount: function() {\r\n\t\t\r\n\t\tthis.$emit('resize', { width: 0, height: 0 });\r\n\t\tthis.$emit('resizeSensorBeforeDestroy');\r\n\t},\r\n\tmounted: function() {\r\n\r\n\t\tif ( this.initial === true )\r\n\t\t\tthis.$nextTick(this.update);\r\n\t\t\r\n\t\tif ( this.$el.offsetParent !== this.$el.parentNode )\r\n\t\t\tthis.$el.parentNode.style.position = 'relative';\r\n\r\n\t\tif ( 'attachEvent' in this.$el && !('AnimationEvent' in window) ) {\r\n\r\n\t\t\tvar onresizeHandler = function() {\r\n\r\n\t\t\t\tthis.update();\r\n\t\t\t\tremoveOnresizeEvent();\r\n\t\t\t}.bind(this);\r\n\t\t\r\n\t\t\tvar removeOnresizeEvent = function() {\r\n\t\t\t\t\r\n\t\t\t\tthis.$el.detachEvent('onresize', onresizeHandler);\r\n\t\t\t\tthis.$off('resizeSensorBeforeDestroy', removeOnresizeEvent);\r\n\t\t\t}.bind(this);\r\n\t\t\t\r\n\t\t\tthis.$el.attachEvent('onresize', onresizeHandler);\r\n\t\t\tthis.$on('resizeSensorBeforeDestroy', removeOnresizeEvent);\r\n\t\t\tthis.reset();\r\n\t\t}\r\n\t}\r\n});\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZT9lNjEzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQU9hO0FBQ1U7O0FBRXZCLGlFQUFlOztDQUVkLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztDQUN4RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtFQUNOLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtHQUNSLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ2IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUNmO0NBQ0QsQ0FBQztDQUNELENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0VBQ2hCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0dBQ04sQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0lBQ0wsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0lBQ1QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDO0dBQ1Y7RUFDRDtDQUNELENBQUM7Q0FDRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7RUFDUixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFOztHQUVqQixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDaEMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUMvQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDekIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7R0FDMUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzFCLENBQUM7RUFDRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7O0dBRWxCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ3RDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUN6QztDQUNELENBQUM7Q0FDRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtFQUNOLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtHQUNMLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ1YsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTs7SUFFdkIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDWixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7R0FDM0U7RUFDRDtDQUNELENBQUM7Q0FDRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7O0VBRWxCLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUMxSCxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7O0VBRXZELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLHNDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7R0FDZixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ3hELENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzdCLENBQUMsQ0FBQztHQUNELHNDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7SUFDUixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDWixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0dBQ3JCLENBQUMsRUFBRTtJQUNGLHNDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7S0FDUixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3hELENBQUM7R0FDRixDQUFDLENBQUM7R0FDRixzQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0lBQ1IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ1osQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUNyQixDQUFDLEVBQUU7SUFDRixzQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO0tBQ1IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2hELENBQUM7R0FDRixDQUFDLENBQUM7RUFDSCxDQUFDLENBQUM7Q0FDSCxDQUFDO0NBQ0QsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7O0VBRXpCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0VBQzdDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0NBQ3hDLENBQUM7Q0FDRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTs7RUFFbkIsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRTtHQUMxQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7RUFFNUIsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtHQUNsRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7RUFFaEQsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFOztHQUVqRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7O0lBRWhDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDYixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUN0QixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7R0FFWixDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTs7SUFFcEMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUM1RCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzs7R0FFWixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUNqRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztHQUMxRCxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUNiO0NBQ0Q7QUFDRCxDQUFDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIjxzdHlsZT5cclxuQGtleWZyYW1lcyByZXNpemVTZW5zb3JWaXNpYmlsaXR5IHtcclxuXHRmcm9tIHsgdG9wOiAwOyB9XHJcbn1cclxuPC9zdHlsZT5cclxuXHJcbjxzY3JpcHQ+XHJcblwidXNlIHN0cmljdFwiO1xyXG5pbXBvcnQgeyBoIH0gZnJvbSAndnVlJ1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG5cclxuXHQvLyB0aGFua3MgdG8gaHR0cHM6Ly9naXRodWIuY29tL21hcmNqL2Nzcy1lbGVtZW50LXF1ZXJpZXNcclxuXHRwcm9wczoge1xyXG5cdFx0aW5pdGlhbDoge1xyXG5cdFx0XHR0eXBlOiBCb29sZWFuLFxyXG5cdFx0XHRkZWZhdWx0OiBmYWxzZSxcclxuXHRcdH1cclxuXHR9LFxyXG5cdGRhdGE6IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c2l6ZToge1xyXG5cdFx0XHRcdHdpZHRoOiAtMSxcclxuXHRcdFx0XHRoZWlnaHQ6IC0xXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cdG1ldGhvZHM6IHtcclxuXHRcdHJlc2V0OiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdHZhciBleHBhbmQgPSB0aGlzLiRlbC5maXJzdENoaWxkO1xyXG5cdFx0XHR2YXIgc2hyaW5rID0gdGhpcy4kZWwubGFzdENoaWxkO1xyXG5cdFx0XHRleHBhbmQuc2Nyb2xsTGVmdCA9IDEwMDAwMDtcclxuXHRcdFx0ZXhwYW5kLnNjcm9sbFRvcCA9IDEwMDAwMDtcclxuXHRcdFx0c2hyaW5rLnNjcm9sbExlZnQgPSAxMDAwMDA7XHJcblx0XHRcdHNocmluay5zY3JvbGxUb3AgPSAxMDAwMDA7XHJcblx0XHR9LFxyXG5cdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHJcblx0XHRcdHRoaXMuc2l6ZS53aWR0aCA9IHRoaXMuJGVsLm9mZnNldFdpZHRoO1xyXG5cdFx0XHR0aGlzLnNpemUuaGVpZ2h0ID0gdGhpcy4kZWwub2Zmc2V0SGVpZ2h0O1xyXG5cdFx0fVxyXG5cdH0sXHJcblx0d2F0Y2g6IHtcclxuXHRcdHNpemU6IHtcclxuXHRcdFx0ZGVlcDogdHJ1ZSxcclxuXHRcdFx0aGFuZGxlcjogZnVuY3Rpb24oc2l6ZSkge1xyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdHRoaXMucmVzZXQoKTtcclxuXHRcdFx0XHR0aGlzLiRlbWl0KCdyZXNpemUnLCB7IHdpZHRoOiB0aGlzLnNpemUud2lkdGgsIGhlaWdodDogdGhpcy5zaXplLmhlaWdodCB9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblx0cmVuZGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdFxyXG5cdFx0dmFyIHN0eWxlID0gJ3Bvc2l0aW9uOiBhYnNvbHV0ZTsgbGVmdDogMDsgdG9wOiAwOyByaWdodDogMDsgYm90dG9tOiAwOyBvdmVyZmxvdzogaGlkZGVuOyB6LWluZGV4OiAtMTsgdmlzaWJpbGl0eTogaGlkZGVuOyc7XHJcblx0XHR2YXIgc3R5bGVDaGlsZCA9ICdwb3NpdGlvbjogYWJzb2x1dGU7IGxlZnQ6IDA7IHRvcDogMDsnO1xyXG5cclxuXHRcdHJldHVybiBoKCdkaXYnLCB7XHJcblx0XHRcdHN0eWxlOiBzdHlsZSArICdhbmltYXRpb24tbmFtZTogcmVzaXplU2Vuc29yVmlzaWJpbGl0eTsnLFxyXG5cdFx0XHRvbkFuaW1hdGlvblN0YXJ0OiB0aGlzLnVwZGF0ZVxyXG5cdFx0fSxbXHJcblx0XHRcdGgoJ2RpdicsIHtcclxuXHRcdFx0XHRzdHlsZTogc3R5bGUsXHJcblx0XHRcdFx0b25TY3JvbGw6IHRoaXMudXBkYXRlXHJcblx0XHRcdH0sIFtcclxuXHRcdFx0XHRoKCdkaXYnLCB7XHJcblx0XHRcdFx0XHRzdHlsZTogc3R5bGVDaGlsZCArICd3aWR0aDogMTAwMDAwcHg7IGhlaWdodDogMTAwMDAwcHg7J1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdF0pLFxyXG5cdFx0XHRoKCdkaXYnLCB7XHJcblx0XHRcdFx0c3R5bGU6IHN0eWxlLFxyXG5cdFx0XHRcdG9uU2Nyb2xsOiB0aGlzLnVwZGF0ZVxyXG5cdFx0XHR9LCBbXHJcblx0XHRcdFx0aCgnZGl2Jywge1xyXG5cdFx0XHRcdFx0c3R5bGU6IHN0eWxlQ2hpbGQgKyAnd2lkdGg6IDIwMCU7IGhlaWdodDogMjAwJTsnXHJcblx0XHRcdFx0fSlcclxuXHRcdFx0XSksXHJcblx0XHRdKTtcclxuXHR9LFxyXG5cdGJlZm9yZVVubW91bnQ6IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHJcblx0XHR0aGlzLiRlbWl0KCdyZXNpemUnLCB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfSk7XHJcblx0XHR0aGlzLiRlbWl0KCdyZXNpemVTZW5zb3JCZWZvcmVEZXN0cm95Jyk7XHJcblx0fSxcclxuXHRtb3VudGVkOiBmdW5jdGlvbigpIHtcclxuXHJcblx0XHRpZiAoIHRoaXMuaW5pdGlhbCA9PT0gdHJ1ZSApXHJcblx0XHRcdHRoaXMuJG5leHRUaWNrKHRoaXMudXBkYXRlKTtcclxuXHRcdFxyXG5cdFx0aWYgKCB0aGlzLiRlbC5vZmZzZXRQYXJlbnQgIT09IHRoaXMuJGVsLnBhcmVudE5vZGUgKVxyXG5cdFx0XHR0aGlzLiRlbC5wYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuXHJcblx0XHRpZiAoICdhdHRhY2hFdmVudCcgaW4gdGhpcy4kZWwgJiYgISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykgKSB7XHJcblxyXG5cdFx0XHR2YXIgb25yZXNpemVIYW5kbGVyID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRcdFx0cmVtb3ZlT25yZXNpemVFdmVudCgpO1xyXG5cdFx0XHR9LmJpbmQodGhpcyk7XHJcblx0XHRcclxuXHRcdFx0dmFyIHJlbW92ZU9ucmVzaXplRXZlbnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcclxuXHRcdFx0XHR0aGlzLiRlbC5kZXRhY2hFdmVudCgnb25yZXNpemUnLCBvbnJlc2l6ZUhhbmRsZXIpO1xyXG5cdFx0XHRcdHRoaXMuJG9mZigncmVzaXplU2Vuc29yQmVmb3JlRGVzdHJveScsIHJlbW92ZU9ucmVzaXplRXZlbnQpO1xyXG5cdFx0XHR9LmJpbmQodGhpcyk7XHJcblx0XHRcdFxyXG5cdFx0XHR0aGlzLiRlbC5hdHRhY2hFdmVudCgnb25yZXNpemUnLCBvbnJlc2l6ZUhhbmRsZXIpO1xyXG5cdFx0XHR0aGlzLiRvbigncmVzaXplU2Vuc29yQmVmb3JlRGVzdHJveScsIHJlbW92ZU9ucmVzaXplRXZlbnQpO1xyXG5cdFx0XHR0aGlzLnJlc2V0KCk7XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG48L3NjcmlwdD5cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue":
/*!**********************************************************************************************!*\
  !*** ./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _PatientTestFileModalComponent_vue_vue_type_template_id_602a6bea_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true */ \"./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true\");\n/* harmony import */ var _PatientTestFileModalComponent_ts_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PatientTestFileModalComponent.ts?vue&type=script&lang=ts */ \"./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.ts?vue&type=script&lang=ts\");\n/* harmony import */ var _PatientTestFileModalComponent_vue_vue_type_style_index_0_id_602a6bea_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css */ \"./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css\");\n\n\n\n\n;\n_PatientTestFileModalComponent_ts_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.default.render = _PatientTestFileModalComponent_vue_vue_type_template_id_602a6bea_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render\n_PatientTestFileModalComponent_ts_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.default.__scopeId = \"data-v-602a6bea\"\n/* hot reload */\nif (false) {}\n\n_PatientTestFileModalComponent_ts_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.default.__file = \"resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue\"\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_PatientTestFileModalComponent_ts_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_1__.default);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC52dWU/MmVjYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXNHO0FBQ3ZCO0FBQ0w7O0FBRTFFLENBQW9HO0FBQ3BHLHFHQUFhLEdBQUcsZ0hBQU07QUFDdEIsd0dBQWdCO0FBQ2hCO0FBQ0EsSUFBSSxLQUFVLEVBQUUsRUFZZjs7QUFFRCxxR0FBYTs7QUFFYixpRUFBZSw4RiIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9jb21wb25lbnRzL3BhdGllbnQvdGVzdC90ZXN0RmlsZU1vZGFsL1BhdGllbnRUZXN0RmlsZU1vZGFsQ29tcG9uZW50LnZ1ZS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHJlbmRlciB9IGZyb20gXCIuL1BhdGllbnRUZXN0RmlsZU1vZGFsQ29tcG9uZW50LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD02MDJhNmJlYSZzY29wZWQ9dHJ1ZVwiXG5pbXBvcnQgc2NyaXB0IGZyb20gXCIuL1BhdGllbnRUZXN0RmlsZU1vZGFsQ29tcG9uZW50LnRzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzXCJcbmV4cG9ydCAqIGZyb20gXCIuL1BhdGllbnRUZXN0RmlsZU1vZGFsQ29tcG9uZW50LnRzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzXCJcblxuaW1wb3J0IFwiLi9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC52dWU/dnVlJnR5cGU9c3R5bGUmaW5kZXg9MCZpZD02MDJhNmJlYSZzY29wZWQ9dHJ1ZSZsYW5nPWNzc1wiXG5zY3JpcHQucmVuZGVyID0gcmVuZGVyXG5zY3JpcHQuX19zY29wZUlkID0gXCJkYXRhLXYtNjAyYTZiZWFcIlxuLyogaG90IHJlbG9hZCAqL1xuaWYgKG1vZHVsZS5ob3QpIHtcbiAgc2NyaXB0Ll9faG1ySWQgPSBcIjYwMmE2YmVhXCJcbiAgY29uc3QgYXBpID0gX19WVUVfSE1SX1JVTlRJTUVfX1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghYXBpLmNyZWF0ZVJlY29yZCgnNjAyYTZiZWEnLCBzY3JpcHQpKSB7XG4gICAgYXBpLnJlbG9hZCgnNjAyYTZiZWEnLCBzY3JpcHQpXG4gIH1cbiAgXG4gIG1vZHVsZS5ob3QuYWNjZXB0KFwiLi9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9NjAyYTZiZWEmc2NvcGVkPXRydWVcIiwgKCkgPT4ge1xuICAgIGFwaS5yZXJlbmRlcignNjAyYTZiZWEnLCByZW5kZXIpXG4gIH0pXG5cbn1cblxuc2NyaXB0Ll9fZmlsZSA9IFwicmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcGF0aWVudC90ZXN0L3Rlc3RGaWxlTW9kYWwvUGF0aWVudFRlc3RGaWxlTW9kYWxDb21wb25lbnQudnVlXCJcblxuZXhwb3J0IGRlZmF1bHQgc2NyaXB0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue\n");

/***/ }),

/***/ "./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.ts?vue&type=script&lang=ts":
/*!*********************************************************************************************************************!*\
  !*** ./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.ts?vue&type=script&lang=ts ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_22_PatientTestFileModalComponent_ts_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__.default)\n/* harmony export */ });\n/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_ts_loader_index_js_clonedRuleSet_22_PatientTestFileModalComponent_ts_vue_type_script_lang_ts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/ts-loader/index.js??clonedRuleSet-22!./PatientTestFileModalComponent.ts?vue&type=script&lang=ts */ \"./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/ts-loader/index.js??clonedRuleSet-22!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.ts?vue&type=script&lang=ts\");\n //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29tcG9uZW50cy9wYXRpZW50L3Rlc3QvdGVzdEZpbGVNb2RhbC9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC50cz8yNzZjIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQTRPIiwiZmlsZSI6Ii4vcmVzb3VyY2VzL2pzL2NvbXBvbmVudHMvcGF0aWVudC90ZXN0L3Rlc3RGaWxlTW9kYWwvUGF0aWVudFRlc3RGaWxlTW9kYWxDb21wb25lbnQudHM/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9dHMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2JhYmVsLWxvYWRlci9saWIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtNS51c2VbMF0hLi4vLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3RzLWxvYWRlci9pbmRleC5qcz8/Y2xvbmVkUnVsZVNldC0yMiEuL1BhdGllbnRUZXN0RmlsZU1vZGFsQ29tcG9uZW50LnRzP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPXRzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzPz9jbG9uZWRSdWxlU2V0LTUudXNlWzBdIS4uLy4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy90cy1sb2FkZXIvaW5kZXguanM/P2Nsb25lZFJ1bGVTZXQtMjIhLi9QYXRpZW50VGVzdEZpbGVNb2RhbENvbXBvbmVudC50cz92dWUmdHlwZT1zY3JpcHQmbGFuZz10c1wiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.ts?vue&type=script&lang=ts\n");

/***/ }),

/***/ "./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true":
/*!****************************************************************************************************************************************!*\
  !*** ./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true ***!
  \****************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "render": () => (/* reexport safe */ _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PatientTestFileModalComponent_vue_vue_type_template_id_602a6bea_scoped_true__WEBPACK_IMPORTED_MODULE_0__.render)
/* harmony export */ });
/* harmony import */ var _node_modules_babel_loader_lib_index_js_clonedRuleSet_5_use_0_node_modules_vue_loader_dist_templateLoader_js_ruleSet_1_rules_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PatientTestFileModalComponent_vue_vue_type_template_id_602a6bea_scoped_true__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!../../../../../../node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true */ "./node_modules/babel-loader/lib/index.js??clonedRuleSet-5.use[0]!./node_modules/vue-loader/dist/templateLoader.js??ruleSet[1].rules[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=template&id=602a6bea&scoped=true");


/***/ }),

/***/ "./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css":
/*!***************************************************************************************!*\
  !*** ./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_loader_dist_cjs_js_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_vue_loader_dist_stylePostLoader_js_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_annotationLayer_css_vue_type_style_index_0_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../style-loader/dist/cjs.js!../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../vue-loader/dist/stylePostLoader.js!../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./annotationLayer.css?vue&type=style&index=0&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue3-pdf/src/annotationLayer.css?vue&type=style&index=0&lang=css");


/***/ }),

/***/ "./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_loader_dist_cjs_js_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_vue_loader_dist_stylePostLoader_js_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_vue_loader_dist_index_js_ruleSet_0_use_0_resize_sensor_vue_vue_type_style_index_0_id_07f4b013_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../style-loader/dist/cjs.js!../../css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../vue-loader/dist/stylePostLoader.js!../../postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../vue-loader/dist/index.js??ruleSet[0].use[0]!./resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=style&index=0&id=07f4b013&lang=css");


/***/ }),

/***/ "./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css":
/*!******************************************************************************************************************************************************!*\
  !*** ./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css ***!
  \******************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _node_modules_style_loader_dist_cjs_js_node_modules_css_loader_dist_cjs_js_clonedRuleSet_9_use_1_node_modules_vue_loader_dist_stylePostLoader_js_node_modules_postcss_loader_dist_cjs_js_clonedRuleSet_9_use_2_node_modules_vue_loader_dist_index_js_ruleSet_0_use_0_PatientTestFileModalComponent_vue_vue_type_style_index_0_id_602a6bea_scoped_true_lang_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../../../../../node_modules/style-loader/dist/cjs.js!../../../../../../node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!../../../../../../node_modules/vue-loader/dist/stylePostLoader.js!../../../../../../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!../../../../../../node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css */ "./node_modules/style-loader/dist/cjs.js!./node_modules/css-loader/dist/cjs.js??clonedRuleSet-9.use[1]!./node_modules/vue-loader/dist/stylePostLoader.js!./node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-9.use[2]!./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./resources/js/components/patient/test/testFileModal/PatientTestFileModalComponent.vue?vue&type=style&index=0&id=602a6bea&scoped=true&lang=css");


/***/ }),

/***/ "./node_modules/vue3-pdf/src/vuePdfNoSss.vue?vue&type=script&lang=js":
/*!***************************************************************************!*\
  !*** ./node_modules/vue3-pdf/src/vuePdfNoSss.vue?vue&type=script&lang=js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _vue_loader_dist_index_js_ruleSet_0_use_0_vuePdfNoSss_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default)\n/* harmony export */ });\n/* harmony import */ var _vue_loader_dist_index_js_ruleSet_0_use_0_vuePdfNoSss_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../vue-loader/dist/index.js??ruleSet[0].use[0]!./vuePdfNoSss.vue?vue&type=script&lang=js */ \"./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-pdf/src/vuePdfNoSss.vue?vue&type=script&lang=js\");\n //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL3Z1ZVBkZk5vU3NzLnZ1ZT85MTY1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQXdIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZTMtcGRmL3NyYy92dWVQZGZOb1Nzcy52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL3Z1ZVBkZk5vU3NzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiOyBleHBvcnQgKiBmcm9tIFwiLSEuLi8uLi92dWUtbG9hZGVyL2Rpc3QvaW5kZXguanM/P3J1bGVTZXRbMF0udXNlWzBdIS4vdnVlUGRmTm9Tc3MudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue3-pdf/src/vuePdfNoSss.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=script&lang=js":
/*!***************************************************************************************!*\
  !*** ./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=script&lang=js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* reexport safe */ _vue_loader_dist_index_js_ruleSet_0_use_0_resize_sensor_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__.default)\n/* harmony export */ });\n/* harmony import */ var _vue_loader_dist_index_js_ruleSet_0_use_0_resize_sensor_vue_vue_type_script_lang_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! -!../../vue-loader/dist/index.js??ruleSet[0].use[0]!./resize-sensor.vue?vue&type=script&lang=js */ \"./node_modules/vue-loader/dist/index.js??ruleSet[0].use[0]!./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=script&lang=js\");\n //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1yZXNpemUtc2Vuc29yL3NyYy9yZXNpemUtc2Vuc29yLnZ1ZT8xMWMzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQTBIIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZTMtcmVzaXplLXNlbnNvci9zcmMvcmVzaXplLXNlbnNvci52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IH0gZnJvbSBcIi0hLi4vLi4vdnVlLWxvYWRlci9kaXN0L2luZGV4LmpzPz9ydWxlU2V0WzBdLnVzZVswXSEuL3Jlc2l6ZS1zZW5zb3IudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzXCI7IGV4cG9ydCAqIGZyb20gXCItIS4uLy4uL3Z1ZS1sb2FkZXIvZGlzdC9pbmRleC5qcz8/cnVsZVNldFswXS51c2VbMF0hLi9yZXNpemUtc2Vuc29yLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qc1wiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vue3-resize-sensor/src/resize-sensor.vue?vue&type=script&lang=js\n");

/***/ }),

/***/ "./node_modules/vue3-pdf/src/componentFactory.js":
/*!*******************************************************!*\
  !*** ./node_modules/vue3-pdf/src/componentFactory.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var vue3_resize_sensor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vue3-resize-sensor */ \"./node_modules/vue3-resize-sensor/src/resize-sensor.vue\");\n/* harmony import */ var vue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.esm-bundler.js\");\n/* harmony import */ var mitt__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mitt */ \"./node_modules/mitt/dist/mitt.es.js\");\n\r\n\r\n\r\n\r\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(pdfjsWrapper) {\r\n\r\n\tvar createLoadingTask = pdfjsWrapper.createLoadingTask;\r\n\tvar PDFJSWrapper = pdfjsWrapper.PDFJSWrapper;\r\n\r\n\treturn {\r\n\t\tcreateLoadingTask: createLoadingTask,\r\n\t\trender: function() {\r\n\t\t\treturn (0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('span', {\r\n\t\t\t\tstyle: 'position: relative; display: block'\r\n\t\t\t}, [\r\n\t\t\t\t(0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('canvas', {\r\n\t\t\t\t\tstyle: 'display: inline-block; width: 100%; height: 100%; vertical-align: top',\r\n\t\t\t\t\tref:'canvas'\r\n\t\t\t\t}),\r\n\t\t\t\t(0,vue__WEBPACK_IMPORTED_MODULE_1__.h)('span', {\r\n\t\t\t\t\tstyle: 'display: inline-block; width: 100%; height: 100%',\r\n\t\t\t\t\tclass: 'annotationLayer',\r\n\t\t\t\t\tref:'annotationLayer'\r\n\t\t\t\t}),\r\n\t\t\t\t(0,vue__WEBPACK_IMPORTED_MODULE_1__.h)(vue3_resize_sensor__WEBPACK_IMPORTED_MODULE_0__.default, {\r\n\t\t\t\t\tprops: {\r\n\t\t\t\t\t\tinitial: true\r\n\t\t\t\t\t},\r\n\t\t\t\t\ton: {\r\n\t\t\t\t\t\tresize: this.resize\r\n\t\t\t\t\t},\r\n\t\t\t\t})\r\n\t\t\t])\r\n\t\t},\r\n\t\tprops: {\r\n\t\t\tsrc: {\r\n\t\t\t\ttype: [String, Object, Uint8Array],\r\n\t\t\t\tdefault: '',\r\n\t\t\t},\r\n\t\t\tpage: {\r\n\t\t\t\ttype: Number,\r\n\t\t\t\tdefault: 1,\r\n\t\t\t},\r\n\t\t\trotate: {\r\n\t\t\t\ttype: Number,\r\n\t\t\t},\r\n\t\t},\r\n\t\twatch: {\r\n\t\t\tsrc: function() {\r\n\r\n\t\t\t\tthis.pdf.loadDocument(this.src);\r\n\t\t\t},\r\n\t\t\tpage: function() {\r\n\r\n\t\t\t\tthis.pdf.loadPage(this.page, this.rotate);\r\n\t\t\t},\r\n\t\t\trotate: function() {\r\n\t\t\t\tthis.pdf.renderPage(this.rotate);\r\n\t\t\t},\r\n\t\t},\r\n\t\tmethods: {\r\n\t\t\tresize: function(size) {\r\n\r\n\t\t\t\t// check if the element is attached to the dom tree || resizeSensor being destroyed\r\n\t\t\t\tif ( this.$el.parentNode === null || (size.width === 0 && size.height === 0) )\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t// on IE10- canvas height must be set\r\n\t\t\t\tthis.$refs.canvas.style.height = this.$refs.canvas.offsetWidth * (this.$refs.canvas.height / this.$refs.canvas.width) + 'px';\r\n\t\t\t\t// update the page when the resolution is too poor\r\n\t\t\t\tvar resolutionScale = this.pdf.getResolutionScale();\r\n\r\n\t\t\t\tif ( resolutionScale < 0.85 || resolutionScale > 1.15 )\r\n\t\t\t\t\tthis.pdf.renderPage(this.rotate);\r\n\r\n\t\t\t\t// this.$refs.annotationLayer.style.transform = 'scale('+resolutionScale+')';\r\n\t\t\t},\r\n\t\t\tprint: function(dpi, pageList) {\r\n\r\n\t\t\t\tthis.pdf.printPage(dpi, pageList);\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\t// doc: mounted hook is not called during server-side rendering.\r\n\t\tmounted: function() {\r\n\t\t\tconst emitter = (0,mitt__WEBPACK_IMPORTED_MODULE_2__.default)()\r\n\r\n\t\t\tthis.pdf = new PDFJSWrapper(this.$refs.canvas, this.$refs.annotationLayer, emitter);\r\n\r\n\t\t\temitter.on('loaded', () => {\r\n\t\t\t\tthis.pdf.loadPage(this.page, this.rotate);\r\n\t\t\t});\r\n\r\n\t\t\temitter.on('page-size', ({ width, height }) => {\r\n\t\t\t\tthis.$refs.canvas.style.height = this.$refs.canvas.offsetWidth * (height / width) + 'px';\r\n\t\t\t});\r\n\r\n\t\t\tthis.pdf.loadDocument(this.src);\r\n\t\t},\r\n\r\n\t\t// doc: destroyed hook is not called during server-side rendering.\r\n\t\tunmounted: function() {\r\n\r\n\t\t\tthis.pdf.destroy();\r\n\t\t}\r\n\t}\r\n\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL2NvbXBvbmVudEZhY3RvcnkuanM/Y2VjOSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTZDO0FBQ3RCO0FBQ0E7O0FBRXZCLDZCQUFlLG9DQUFTOztBQUV4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsc0NBQUM7QUFDWCwrQkFBK0I7QUFDL0IsSUFBSTtBQUNKLElBQUksc0NBQUM7QUFDTCxtQ0FBbUMsYUFBYSxjQUFjO0FBQzlEO0FBQ0EsS0FBSztBQUNMLElBQUksc0NBQUM7QUFDTCxtQ0FBbUMsYUFBYTtBQUNoRDtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksc0NBQUMsQ0FBQyx1REFBWTtBQUNsQjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ04sS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLG1CQUFtQiw2Q0FBSTs7QUFFdkI7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUosNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBLElBQUk7O0FBRUo7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL3Z1ZTMtcGRmL3NyYy9jb21wb25lbnRGYWN0b3J5LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlc2l6ZVNlbnNvciBmcm9tICd2dWUzLXJlc2l6ZS1zZW5zb3InXHJcbmltcG9ydCB7IGggfSBmcm9tICd2dWUnXHJcbmltcG9ydCBtaXR0IGZyb20gJ21pdHQnXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihwZGZqc1dyYXBwZXIpIHtcclxuXHJcblx0dmFyIGNyZWF0ZUxvYWRpbmdUYXNrID0gcGRmanNXcmFwcGVyLmNyZWF0ZUxvYWRpbmdUYXNrO1xyXG5cdHZhciBQREZKU1dyYXBwZXIgPSBwZGZqc1dyYXBwZXIuUERGSlNXcmFwcGVyO1xyXG5cclxuXHRyZXR1cm4ge1xyXG5cdFx0Y3JlYXRlTG9hZGluZ1Rhc2s6IGNyZWF0ZUxvYWRpbmdUYXNrLFxyXG5cdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmV0dXJuIGgoJ3NwYW4nLCB7XHJcblx0XHRcdFx0c3R5bGU6ICdwb3NpdGlvbjogcmVsYXRpdmU7IGRpc3BsYXk6IGJsb2NrJ1xyXG5cdFx0XHR9LCBbXHJcblx0XHRcdFx0aCgnY2FudmFzJywge1xyXG5cdFx0XHRcdFx0c3R5bGU6ICdkaXNwbGF5OiBpbmxpbmUtYmxvY2s7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IHZlcnRpY2FsLWFsaWduOiB0b3AnLFxyXG5cdFx0XHRcdFx0cmVmOidjYW52YXMnXHJcblx0XHRcdFx0fSksXHJcblx0XHRcdFx0aCgnc3BhbicsIHtcclxuXHRcdFx0XHRcdHN0eWxlOiAnZGlzcGxheTogaW5saW5lLWJsb2NrOyB3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlJyxcclxuXHRcdFx0XHRcdGNsYXNzOiAnYW5ub3RhdGlvbkxheWVyJyxcclxuXHRcdFx0XHRcdHJlZjonYW5ub3RhdGlvbkxheWVyJ1xyXG5cdFx0XHRcdH0pLFxyXG5cdFx0XHRcdGgocmVzaXplU2Vuc29yLCB7XHJcblx0XHRcdFx0XHRwcm9wczoge1xyXG5cdFx0XHRcdFx0XHRpbml0aWFsOiB0cnVlXHJcblx0XHRcdFx0XHR9LFxyXG5cdFx0XHRcdFx0b246IHtcclxuXHRcdFx0XHRcdFx0cmVzaXplOiB0aGlzLnJlc2l6ZVxyXG5cdFx0XHRcdFx0fSxcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRdKVxyXG5cdFx0fSxcclxuXHRcdHByb3BzOiB7XHJcblx0XHRcdHNyYzoge1xyXG5cdFx0XHRcdHR5cGU6IFtTdHJpbmcsIE9iamVjdCwgVWludDhBcnJheV0sXHJcblx0XHRcdFx0ZGVmYXVsdDogJycsXHJcblx0XHRcdH0sXHJcblx0XHRcdHBhZ2U6IHtcclxuXHRcdFx0XHR0eXBlOiBOdW1iZXIsXHJcblx0XHRcdFx0ZGVmYXVsdDogMSxcclxuXHRcdFx0fSxcclxuXHRcdFx0cm90YXRlOiB7XHJcblx0XHRcdFx0dHlwZTogTnVtYmVyLFxyXG5cdFx0XHR9LFxyXG5cdFx0fSxcclxuXHRcdHdhdGNoOiB7XHJcblx0XHRcdHNyYzogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucGRmLmxvYWREb2N1bWVudCh0aGlzLnNyYyk7XHJcblx0XHRcdH0sXHJcblx0XHRcdHBhZ2U6IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHR0aGlzLnBkZi5sb2FkUGFnZSh0aGlzLnBhZ2UsIHRoaXMucm90YXRlKTtcclxuXHRcdFx0fSxcclxuXHRcdFx0cm90YXRlOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0aGlzLnBkZi5yZW5kZXJQYWdlKHRoaXMucm90YXRlKTtcclxuXHRcdFx0fSxcclxuXHRcdH0sXHJcblx0XHRtZXRob2RzOiB7XHJcblx0XHRcdHJlc2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xyXG5cclxuXHRcdFx0XHQvLyBjaGVjayBpZiB0aGUgZWxlbWVudCBpcyBhdHRhY2hlZCB0byB0aGUgZG9tIHRyZWUgfHwgcmVzaXplU2Vuc29yIGJlaW5nIGRlc3Ryb3llZFxyXG5cdFx0XHRcdGlmICggdGhpcy4kZWwucGFyZW50Tm9kZSA9PT0gbnVsbCB8fCAoc2l6ZS53aWR0aCA9PT0gMCAmJiBzaXplLmhlaWdodCA9PT0gMCkgKVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0XHQvLyBvbiBJRTEwLSBjYW52YXMgaGVpZ2h0IG11c3QgYmUgc2V0XHJcblx0XHRcdFx0dGhpcy4kcmVmcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy4kcmVmcy5jYW52YXMub2Zmc2V0V2lkdGggKiAodGhpcy4kcmVmcy5jYW52YXMuaGVpZ2h0IC8gdGhpcy4kcmVmcy5jYW52YXMud2lkdGgpICsgJ3B4JztcclxuXHRcdFx0XHQvLyB1cGRhdGUgdGhlIHBhZ2Ugd2hlbiB0aGUgcmVzb2x1dGlvbiBpcyB0b28gcG9vclxyXG5cdFx0XHRcdHZhciByZXNvbHV0aW9uU2NhbGUgPSB0aGlzLnBkZi5nZXRSZXNvbHV0aW9uU2NhbGUoKTtcclxuXHJcblx0XHRcdFx0aWYgKCByZXNvbHV0aW9uU2NhbGUgPCAwLjg1IHx8IHJlc29sdXRpb25TY2FsZSA+IDEuMTUgKVxyXG5cdFx0XHRcdFx0dGhpcy5wZGYucmVuZGVyUGFnZSh0aGlzLnJvdGF0ZSk7XHJcblxyXG5cdFx0XHRcdC8vIHRoaXMuJHJlZnMuYW5ub3RhdGlvbkxheWVyLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZSgnK3Jlc29sdXRpb25TY2FsZSsnKSc7XHJcblx0XHRcdH0sXHJcblx0XHRcdHByaW50OiBmdW5jdGlvbihkcGksIHBhZ2VMaXN0KSB7XHJcblxyXG5cdFx0XHRcdHRoaXMucGRmLnByaW50UGFnZShkcGksIHBhZ2VMaXN0KTtcclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBkb2M6IG1vdW50ZWQgaG9vayBpcyBub3QgY2FsbGVkIGR1cmluZyBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuXHJcblx0XHRtb3VudGVkOiBmdW5jdGlvbigpIHtcclxuXHRcdFx0Y29uc3QgZW1pdHRlciA9IG1pdHQoKVxyXG5cclxuXHRcdFx0dGhpcy5wZGYgPSBuZXcgUERGSlNXcmFwcGVyKHRoaXMuJHJlZnMuY2FudmFzLCB0aGlzLiRyZWZzLmFubm90YXRpb25MYXllciwgZW1pdHRlcik7XHJcblxyXG5cdFx0XHRlbWl0dGVyLm9uKCdsb2FkZWQnLCAoKSA9PiB7XHJcblx0XHRcdFx0dGhpcy5wZGYubG9hZFBhZ2UodGhpcy5wYWdlLCB0aGlzLnJvdGF0ZSk7XHJcblx0XHRcdH0pO1xyXG5cclxuXHRcdFx0ZW1pdHRlci5vbigncGFnZS1zaXplJywgKHsgd2lkdGgsIGhlaWdodCB9KSA9PiB7XHJcblx0XHRcdFx0dGhpcy4kcmVmcy5jYW52YXMuc3R5bGUuaGVpZ2h0ID0gdGhpcy4kcmVmcy5jYW52YXMub2Zmc2V0V2lkdGggKiAoaGVpZ2h0IC8gd2lkdGgpICsgJ3B4JztcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHR0aGlzLnBkZi5sb2FkRG9jdW1lbnQodGhpcy5zcmMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvLyBkb2M6IGRlc3Ryb3llZCBob29rIGlzIG5vdCBjYWxsZWQgZHVyaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cclxuXHRcdHVubW91bnRlZDogZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHR0aGlzLnBkZi5kZXN0cm95KCk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue3-pdf/src/componentFactory.js\n");

/***/ }),

/***/ "./node_modules/vue3-pdf/src/pdfjsWrapper.js":
/*!***************************************************!*\
  !*** ./node_modules/vue3-pdf/src/pdfjsWrapper.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var pdfjs_dist_sig_es5_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdfjs-dist-sig/es5/web/pdf_viewer */ \"./node_modules/pdfjs-dist-sig/es5/web/pdf_viewer.js\");\n/* harmony import */ var pdfjs_dist_sig_es5_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pdfjs_dist_sig_es5_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_0__);\n\r\n\r\nvar pendingOperation = Promise.resolve();\r\n\r\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(PDFJS) {\r\n\r\n\tfunction isPDFDocumentLoadingTask(obj) {\r\n\r\n\t\treturn typeof(obj) === 'object' && obj !== null && obj.__PDFDocumentLoadingTask === true;\r\n\t\t// or: return obj.constructor.name === 'PDFDocumentLoadingTask';\r\n\t}\r\n\r\n\tfunction createLoadingTask(src, options) {\r\n\r\n\t\tvar source;\r\n\t\tif ( typeof(src) === 'string' )\r\n\t\t\tsource = { url: src };\r\n\t\telse if ( src instanceof Uint8Array )\r\n\t\t\tsource = { data: src };\r\n\t\telse if ( typeof(src) === 'object' && src !== null )\r\n\t\t\tsource = Object.assign({}, src);\r\n\t\telse\r\n\t\t\tthrow new TypeError('invalid src type');\r\n\r\n\t\t// source.verbosity = PDFJS.VerbosityLevel.INFOS;\r\n\t\t// source.pdfBug = true;\r\n\t\t// source.stopAtErrors = true;\r\n\r\n\t\tif ( options && options.withCredentials )\r\n\t\t\tsource.withCredentials = options.withCredentials;\r\n\r\n\t\tvar loadingTask = PDFJS.getDocument(source);\r\n\t\tloadingTask.__PDFDocumentLoadingTask = true; // since PDFDocumentLoadingTask is not public\r\n\r\n\t\tif ( options && options.onPassword )\r\n\t\t\tloadingTask.onPassword = options.onPassword;\r\n\r\n\t\tif ( options && options.onProgress )\r\n\t\t\tloadingTask.onProgress = options.onProgress;\r\n\r\n\t\treturn loadingTask;\r\n\t}\r\n\r\n\r\n\tfunction PDFJSWrapper(canvasElt, annotationLayerElt, emitter) {\r\n\r\n\t\tvar pdfDoc = null;\r\n\t\tvar pdfPage = null;\r\n\t\tvar pdfRender = null;\r\n\t\tvar canceling = false;\r\n\r\n\t\tcanvasElt.getContext('2d').save();\r\n\r\n\t\tfunction clearCanvas() {\r\n\r\n\t\t\tcanvasElt.getContext('2d').clearRect(0, 0, canvasElt.width, canvasElt.height);\r\n\t\t}\r\n\r\n\t\tfunction clearAnnotations() {\r\n\r\n\t\t\twhile ( annotationLayerElt.firstChild )\r\n\t\t\t\tannotationLayerElt.removeChild(annotationLayerElt.firstChild);\r\n\t\t}\r\n\r\n\t\tthis.destroy = function() {\r\n\r\n\t\t\tif ( pdfDoc === null )\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// Aborts all network requests and destroys worker.\r\n\t\t\tpendingOperation = pdfDoc.destroy();\r\n\t\t\tpdfDoc = null;\r\n\t\t}\r\n\r\n\t\tthis.getResolutionScale = function() {\r\n\r\n\t\t\treturn canvasElt.offsetWidth / canvasElt.width;\r\n\t\t}\r\n\r\n\t\tthis.printPage = function(dpi, pageNumberOnly) {\r\n\r\n\t\t\tif ( pdfPage === null )\r\n\t\t\t\treturn;\r\n\r\n\t\t\t// 1in == 72pt\r\n\t\t\t// 1in == 96px\r\n\t\t\tvar PRINT_RESOLUTION = dpi === undefined ? 150 : dpi;\r\n\t\t\tvar PRINT_UNITS = PRINT_RESOLUTION / 72.0;\r\n\t\t\tvar CSS_UNITS = 96.0 / 72.0;\r\n\r\n\t\t\tvar iframeElt = document.createElement('iframe');\r\n\r\n\t\t\tfunction removeIframe() {\r\n\r\n\t\t\t\tiframeElt.parentNode.removeChild(iframeElt);\r\n\t\t\t}\r\n\r\n\t\t\tnew Promise(function(resolve, reject) {\r\n\r\n\t\t\t\tiframeElt.frameBorder = '0';\r\n\t\t\t\tiframeElt.scrolling = 'no';\r\n\t\t\t\tiframeElt.width = '0px;'\r\n\t\t\t\tiframeElt.height = '0px;'\r\n\t\t\t\tiframeElt.style.cssText = 'position: absolute; top: 0; left: 0';\r\n\r\n\t\t\t\tiframeElt.onload = function() {\r\n\r\n\t\t\t\t\tresolve(this.contentWindow);\r\n\t\t\t\t}\r\n\r\n\t\t\t\twindow.document.body.appendChild(iframeElt);\r\n\t\t\t})\r\n\t\t\t.then(function(win) {\r\n\r\n\t\t\t\twin.document.title = '';\r\n\r\n\t\t\t\treturn pdfDoc.getPage(1)\r\n\t\t\t\t.then(function(page) {\r\n\r\n\t\t\t\t\tvar viewport = page.getViewport({ scale: 1 });\r\n\t\t\t\t\twin.document.head.appendChild(win.document.createElement('style')).textContent =\r\n\t\t\t\t\t\t'@supports ((size:A4) and (size:1pt 1pt)) {' +\r\n\t\t\t\t\t\t\t'@page { margin: 1pt; size: ' + ((viewport.width * PRINT_UNITS) / CSS_UNITS) + 'pt ' + ((viewport.height * PRINT_UNITS) / CSS_UNITS) + 'pt; }' +\r\n\t\t\t\t\t\t'}' +\r\n\r\n\t\t\t\t\t\t'@media print {' +\r\n\t\t\t\t\t\t\t'body { margin: 0 }' +\r\n\t\t\t\t\t\t\t'canvas { page-break-before: avoid; page-break-after: always; page-break-inside: avoid }' +\r\n\t\t\t\t\t\t'}'+\r\n\r\n\t\t\t\t\t\t'@media screen {' +\r\n\t\t\t\t\t\t\t'body { margin: 0 }' +\r\n\t\t\t\t\t\t'}'+\r\n\r\n\t\t\t\t\t\t''\r\n\t\t\t\t\treturn win;\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t\t.then(function(win) {\r\n\r\n\t\t\t\tvar allPages = [];\r\n\r\n\t\t\t\tfor ( var pageNumber = 1; pageNumber <= pdfDoc.numPages; ++pageNumber ) {\r\n\r\n\t\t\t\t\tif ( pageNumberOnly !== undefined && pageNumberOnly.indexOf(pageNumber) === -1 )\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\tallPages.push(\r\n\t\t\t\t\t\tpdfDoc.getPage(pageNumber)\r\n\t\t\t\t\t\t.then(function(page) {\r\n\r\n\t\t\t\t\t\t\tvar viewport = page.getViewport({ scale: 1 });\r\n\r\n\t\t\t\t\t\t\tvar printCanvasElt = win.document.body.appendChild(win.document.createElement('canvas'));\r\n\t\t\t\t\t\t\tprintCanvasElt.width = (viewport.width * PRINT_UNITS);\r\n\t\t\t\t\t\t\tprintCanvasElt.height = (viewport.height * PRINT_UNITS);\r\n\r\n\t\t\t\t\t\t\treturn page.render({\r\n\t\t\t\t\t\t\t\tcanvasContext: printCanvasElt.getContext('2d'),\r\n\t\t\t\t\t\t\t\ttransform: [ // Additional transform, applied just before viewport transform.\r\n\t\t\t\t\t\t\t\t\tPRINT_UNITS, 0, 0,\r\n\t\t\t\t\t\t\t\t\tPRINT_UNITS, 0, 0\r\n\t\t\t\t\t\t\t\t],\r\n\t\t\t\t\t\t\t\tviewport: viewport,\r\n\t\t\t\t\t\t\t\tintent: 'print'\r\n\t\t\t\t\t\t\t}).promise;\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tPromise.all(allPages)\r\n\t\t\t\t.then(function() {\r\n\r\n\t\t\t\t\twin.focus(); // Required for IE\r\n\t\t\t\t\tif (win.document.queryCommandSupported('print')) {\r\n\t\t\t\t\t\twin.document.execCommand('print', false, null);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\twin.print();\r\n\t\t\t\t\t  }\r\n\t\t\t\t\tremoveIframe();\r\n\t\t\t\t})\r\n\t\t\t\t.catch(function(err) {\r\n\r\n\t\t\t\t\tremoveIframe();\r\n\t\t\t\t\temitter.emit('error', err);\r\n\t\t\t\t})\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tthis.renderPage = function(rotate) {\r\n\t\t\tif ( pdfRender !== null ) {\r\n\r\n\t\t\t\tif ( canceling )\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcanceling = true;\r\n\t\t\t\tpdfRender.cancel();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\tif ( pdfPage === null )\r\n\t\t\t\treturn;\r\n\r\n\t\t\tvar pageRotate = (pdfPage.rotate === undefined ? 0 : pdfPage.rotate) + (rotate === undefined ? 0 : rotate);\r\n\r\n\t\t\tvar scale = canvasElt.offsetWidth / pdfPage.getViewport({ scale: 1 }).width * (window.devicePixelRatio || 1);\r\n\t\t\tvar viewport = pdfPage.getViewport({ scale: scale, rotation:pageRotate });\r\n\r\n\t\t\temitter.emit('page-size', { width: viewport.width, height: viewport.height, scale });\r\n\r\n\t\t\tcanvasElt.width = viewport.width;\r\n\t\t\tcanvasElt.height = viewport.height;\r\n\r\n\t\t\tpdfRender = pdfPage.render({\r\n\t\t\t\tcanvasContext: canvasElt.getContext('2d'),\r\n\t\t\t\tviewport: viewport\r\n\t\t\t});\r\n\r\n\t\t\tannotationLayerElt.style.visibility = 'hidden';\r\n\t\t\tclearAnnotations();\r\n\r\n\t\t\tvar viewer = {\r\n\t\t\t\tscrollPageIntoView: function(params) {\r\n\t\t\t\t\temitter.emit('link-clicked', params.pageNumber)\r\n\t\t\t\t},\r\n\t\t\t};\r\n\r\n\t\t\tvar linkService = new pdfjs_dist_sig_es5_web_pdf_viewer__WEBPACK_IMPORTED_MODULE_0__.PDFLinkService();\r\n\t\t\tlinkService.setDocument(pdfDoc);\r\n\t\t\tlinkService.setViewer(viewer);\r\n\r\n\t\t\tpendingOperation = pendingOperation.then(function() {\r\n\r\n\t\t\t\tvar getAnnotationsOperation =\r\n\t\t\t\tpdfPage.getAnnotations({ intent: 'display' })\r\n\t\t\t\t.then(function(annotations) {\r\n\r\n\t\t\t\t\tPDFJS.AnnotationLayer.render({\r\n\t\t\t\t\t\tviewport: viewport.clone({ dontFlip: true }),\r\n\t\t\t\t\t\tdiv: annotationLayerElt,\r\n\t\t\t\t\t\tannotations: annotations,\r\n\t\t\t\t\t\tpage: pdfPage,\r\n\t\t\t\t\t\tlinkService: linkService,\r\n\t\t\t\t\t\trenderInteractiveForms: false\r\n\t\t\t\t\t});\r\n\t\t\t\t});\r\n\r\n\t\t\t\tvar pdfRenderOperation =\r\n\t\t\t\tpdfRender.promise\r\n\t\t\t\t.then(function() {\r\n\r\n\t\t\t\t\tannotationLayerElt.style.visibility = '';\r\n\t\t\t\t\tcanceling = false;\r\n\t\t\t\t\tpdfRender = null;\r\n\t\t\t\t})\r\n\t\t\t\t.catch(function(err) {\r\n\r\n\t\t\t\t\tpdfRender = null;\r\n\t\t\t\t\tif ( err instanceof PDFJS.RenderingCancelledException ) {\r\n\r\n\t\t\t\t\t\tcanceling = false;\r\n\t\t\t\t\t\tthis.renderPage(rotate);\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\temitter.emit('error', err);\r\n\t\t\t\t}.bind(this))\r\n\r\n\t\t\t\treturn Promise.all([getAnnotationsOperation, pdfRenderOperation]);\r\n\t\t\t}.bind(this));\r\n\t\t}\r\n\r\n\r\n\t\tthis.forEachPage = function(pageCallback) {\r\n\r\n\t\t\tvar numPages = pdfDoc.numPages;\r\n\r\n\t\t\t(function next(pageNum) {\r\n\r\n\t\t\t\tpdfDoc.getPage(pageNum)\r\n\t\t\t\t.then(pageCallback)\r\n\t\t\t\t.then(function() {\r\n\r\n\t\t\t\t\tif ( ++pageNum <= numPages )\r\n\t\t\t\t\t\tnext(pageNum);\r\n\t\t\t\t})\r\n\t\t\t})(1);\r\n\t\t}\r\n\r\n\r\n\t\tthis.loadPage = function(pageNumber, rotate) {\r\n\t\t\tpdfPage = null;\r\n\r\n\t\t\tif ( pdfDoc === null )\r\n\t\t\t\treturn;\r\n\r\n\t\t\tpendingOperation = pendingOperation.then(function() {\r\n\r\n\t\t\t\treturn pdfDoc.getPage(pageNumber);\r\n\t\t\t})\r\n\t\t\t.then(function(page) {\r\n\r\n\t\t\t\tpdfPage = page;\r\n\t\t\t\tthis.renderPage(rotate);\r\n\t\t\t\temitter.emit('page-loaded', page.pageNumber);\r\n\t\t\t}.bind(this))\r\n\t\t\t.catch(function(err) {\r\n\r\n\t\t\t\tclearCanvas();\r\n\t\t\t\tclearAnnotations();\r\n\t\t\t\temitter.emit('error', err);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.loadDocument = function(src) {\r\n\r\n\t\t\tpdfDoc = null;\r\n\t\t\tpdfPage = null;\r\n\r\n\t\t\temitter.emit('num-pages', undefined);\r\n\r\n\t\t\tif ( !src ) {\r\n\r\n\t\t\t\tcanvasElt.removeAttribute('width');\r\n\t\t\t\tcanvasElt.removeAttribute('height');\r\n\t\t\t\tclearAnnotations();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\t// wait for pending operation ends\r\n\t\t\tpendingOperation = pendingOperation.then(function() {\r\n\r\n\t\t\t\tvar loadingTask;\r\n\t\t\t\tif ( isPDFDocumentLoadingTask(src) ) {\r\n\r\n\t\t\t\t\tif ( src.destroyed ) {\r\n\r\n\t\t\t\t\t\temitter.emit('error', new Error('loadingTask has been destroyed'));\r\n\t\t\t\t\t\treturn\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tloadingTask = src;\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tloadingTask = createLoadingTask(src, {\r\n\t\t\t\t\t\tonPassword: function(updatePassword, reason) {\r\n\r\n\t\t\t\t\t\t\tvar reasonStr;\r\n\t\t\t\t\t\t\tswitch (reason) {\r\n\t\t\t\t\t\t\t\tcase PDFJS.PasswordResponses.NEED_PASSWORD:\r\n\t\t\t\t\t\t\t\t\treasonStr = 'NEED_PASSWORD';\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\tcase PDFJS.PasswordResponses.INCORRECT_PASSWORD:\r\n\t\t\t\t\t\t\t\t\treasonStr = 'INCORRECT_PASSWORD';\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\temitter.emit('password', updatePassword, reasonStr);\r\n\t\t\t\t\t\t},\r\n\t\t\t\t\t\tonProgress: function(status) {\r\n\r\n\t\t\t\t\t\t\tvar ratio = status.loaded / status.total;\r\n\t\t\t\t\t\t\temitter.emit('progress', Math.min(ratio, 1));\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn loadingTask.promise;\r\n\t\t\t})\r\n\t\t\t.then(function(pdf) {\r\n\r\n\t\t\t\tpdfDoc = pdf;\r\n\t\t\t\temitter.emit('num-pages', pdf.numPages);\r\n\t\t\t\temitter.emit('loaded');\r\n\t\t\t})\r\n\t\t\t.catch(function(err) {\r\n\r\n\t\t\t\tclearCanvas();\r\n\t\t\t\tclearAnnotations();\r\n\t\t\t\temitter.emit('error', err);\r\n\t\t\t})\r\n\t\t}\r\n\r\n\t\tannotationLayerElt.style.transformOrigin = '0 0';\r\n\t}\r\n\r\n\treturn {\r\n\t\tcreateLoadingTask: createLoadingTask,\r\n\t\tPDFJSWrapper: PDFJSWrapper,\r\n\t}\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlMy1wZGYvc3JjL3BkZmpzV3JhcHBlci5qcz9iNGY0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFtRTs7QUFFbkU7O0FBRUEsNkJBQWUsb0NBQVM7O0FBRXhCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7O0FBRTlDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsa0RBQWtELFFBQVE7O0FBRTFEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBLGlEQUFpRDtBQUNqRCxlQUFlLGFBQWEsc0hBQXNILEVBQUU7QUFDcEosUUFBUTs7QUFFUixxQkFBcUI7QUFDckIsY0FBYyxZQUFZO0FBQzFCLGdCQUFnQiwwQkFBMEIsMEJBQTBCLDJCQUEyQjtBQUMvRixRQUFROztBQUVSLHNCQUFzQjtBQUN0QixjQUFjLFlBQVk7QUFDMUIsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7QUFFQTs7QUFFQSw2QkFBNkIsK0JBQStCOztBQUU1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsV0FBVzs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0REFBNEQsV0FBVztBQUN2RSx1Q0FBdUMsb0NBQW9DOztBQUUzRSw4QkFBOEIsd0RBQXdEOztBQUV0RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEseUJBQXlCLDZFQUFjO0FBQ3ZDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEOztBQUVBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy92dWUzLXBkZi9zcmMvcGRmanNXcmFwcGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUERGTGlua1NlcnZpY2UgfSBmcm9tICdwZGZqcy1kaXN0LXNpZy9lczUvd2ViL3BkZl92aWV3ZXInO1xyXG5cclxudmFyIHBlbmRpbmdPcGVyYXRpb24gPSBQcm9taXNlLnJlc29sdmUoKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKFBERkpTKSB7XHJcblxyXG5cdGZ1bmN0aW9uIGlzUERGRG9jdW1lbnRMb2FkaW5nVGFzayhvYmopIHtcclxuXHJcblx0XHRyZXR1cm4gdHlwZW9mKG9iaikgPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiBvYmouX19QREZEb2N1bWVudExvYWRpbmdUYXNrID09PSB0cnVlO1xyXG5cdFx0Ly8gb3I6IHJldHVybiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ1BERkRvY3VtZW50TG9hZGluZ1Rhc2snO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gY3JlYXRlTG9hZGluZ1Rhc2soc3JjLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0dmFyIHNvdXJjZTtcclxuXHRcdGlmICggdHlwZW9mKHNyYykgPT09ICdzdHJpbmcnIClcclxuXHRcdFx0c291cmNlID0geyB1cmw6IHNyYyB9O1xyXG5cdFx0ZWxzZSBpZiAoIHNyYyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgKVxyXG5cdFx0XHRzb3VyY2UgPSB7IGRhdGE6IHNyYyB9O1xyXG5cdFx0ZWxzZSBpZiAoIHR5cGVvZihzcmMpID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwgKVxyXG5cdFx0XHRzb3VyY2UgPSBPYmplY3QuYXNzaWduKHt9LCBzcmMpO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHNyYyB0eXBlJyk7XHJcblxyXG5cdFx0Ly8gc291cmNlLnZlcmJvc2l0eSA9IFBERkpTLlZlcmJvc2l0eUxldmVsLklORk9TO1xyXG5cdFx0Ly8gc291cmNlLnBkZkJ1ZyA9IHRydWU7XHJcblx0XHQvLyBzb3VyY2Uuc3RvcEF0RXJyb3JzID0gdHJ1ZTtcclxuXHJcblx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgKVxyXG5cdFx0XHRzb3VyY2Uud2l0aENyZWRlbnRpYWxzID0gb3B0aW9ucy53aXRoQ3JlZGVudGlhbHM7XHJcblxyXG5cdFx0dmFyIGxvYWRpbmdUYXNrID0gUERGSlMuZ2V0RG9jdW1lbnQoc291cmNlKTtcclxuXHRcdGxvYWRpbmdUYXNrLl9fUERGRG9jdW1lbnRMb2FkaW5nVGFzayA9IHRydWU7IC8vIHNpbmNlIFBERkRvY3VtZW50TG9hZGluZ1Rhc2sgaXMgbm90IHB1YmxpY1xyXG5cclxuXHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm9uUGFzc3dvcmQgKVxyXG5cdFx0XHRsb2FkaW5nVGFzay5vblBhc3N3b3JkID0gb3B0aW9ucy5vblBhc3N3b3JkO1xyXG5cclxuXHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm9uUHJvZ3Jlc3MgKVxyXG5cdFx0XHRsb2FkaW5nVGFzay5vblByb2dyZXNzID0gb3B0aW9ucy5vblByb2dyZXNzO1xyXG5cclxuXHRcdHJldHVybiBsb2FkaW5nVGFzaztcclxuXHR9XHJcblxyXG5cclxuXHRmdW5jdGlvbiBQREZKU1dyYXBwZXIoY2FudmFzRWx0LCBhbm5vdGF0aW9uTGF5ZXJFbHQsIGVtaXR0ZXIpIHtcclxuXHJcblx0XHR2YXIgcGRmRG9jID0gbnVsbDtcclxuXHRcdHZhciBwZGZQYWdlID0gbnVsbDtcclxuXHRcdHZhciBwZGZSZW5kZXIgPSBudWxsO1xyXG5cdFx0dmFyIGNhbmNlbGluZyA9IGZhbHNlO1xyXG5cclxuXHRcdGNhbnZhc0VsdC5nZXRDb250ZXh0KCcyZCcpLnNhdmUoKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjbGVhckNhbnZhcygpIHtcclxuXHJcblx0XHRcdGNhbnZhc0VsdC5nZXRDb250ZXh0KCcyZCcpLmNsZWFyUmVjdCgwLCAwLCBjYW52YXNFbHQud2lkdGgsIGNhbnZhc0VsdC5oZWlnaHQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGNsZWFyQW5ub3RhdGlvbnMoKSB7XHJcblxyXG5cdFx0XHR3aGlsZSAoIGFubm90YXRpb25MYXllckVsdC5maXJzdENoaWxkIClcclxuXHRcdFx0XHRhbm5vdGF0aW9uTGF5ZXJFbHQucmVtb3ZlQ2hpbGQoYW5ub3RhdGlvbkxheWVyRWx0LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0aWYgKCBwZGZEb2MgPT09IG51bGwgKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdC8vIEFib3J0cyBhbGwgbmV0d29yayByZXF1ZXN0cyBhbmQgZGVzdHJveXMgd29ya2VyLlxyXG5cdFx0XHRwZW5kaW5nT3BlcmF0aW9uID0gcGRmRG9jLmRlc3Ryb3koKTtcclxuXHRcdFx0cGRmRG9jID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmdldFJlc29sdXRpb25TY2FsZSA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0cmV0dXJuIGNhbnZhc0VsdC5vZmZzZXRXaWR0aCAvIGNhbnZhc0VsdC53aWR0aDtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLnByaW50UGFnZSA9IGZ1bmN0aW9uKGRwaSwgcGFnZU51bWJlck9ubHkpIHtcclxuXHJcblx0XHRcdGlmICggcGRmUGFnZSA9PT0gbnVsbCApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0Ly8gMWluID09IDcycHRcclxuXHRcdFx0Ly8gMWluID09IDk2cHhcclxuXHRcdFx0dmFyIFBSSU5UX1JFU09MVVRJT04gPSBkcGkgPT09IHVuZGVmaW5lZCA/IDE1MCA6IGRwaTtcclxuXHRcdFx0dmFyIFBSSU5UX1VOSVRTID0gUFJJTlRfUkVTT0xVVElPTiAvIDcyLjA7XHJcblx0XHRcdHZhciBDU1NfVU5JVFMgPSA5Ni4wIC8gNzIuMDtcclxuXHJcblx0XHRcdHZhciBpZnJhbWVFbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcclxuXHJcblx0XHRcdGZ1bmN0aW9uIHJlbW92ZUlmcmFtZSgpIHtcclxuXHJcblx0XHRcdFx0aWZyYW1lRWx0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lRWx0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0bmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XHJcblxyXG5cdFx0XHRcdGlmcmFtZUVsdC5mcmFtZUJvcmRlciA9ICcwJztcclxuXHRcdFx0XHRpZnJhbWVFbHQuc2Nyb2xsaW5nID0gJ25vJztcclxuXHRcdFx0XHRpZnJhbWVFbHQud2lkdGggPSAnMHB4OydcclxuXHRcdFx0XHRpZnJhbWVFbHQuaGVpZ2h0ID0gJzBweDsnXHJcblx0XHRcdFx0aWZyYW1lRWx0LnN0eWxlLmNzc1RleHQgPSAncG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDAnO1xyXG5cclxuXHRcdFx0XHRpZnJhbWVFbHQub25sb2FkID0gZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRcdFx0cmVzb2x2ZSh0aGlzLmNvbnRlbnRXaW5kb3cpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0d2luZG93LmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lRWx0KTtcclxuXHRcdFx0fSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24od2luKSB7XHJcblxyXG5cdFx0XHRcdHdpbi5kb2N1bWVudC50aXRsZSA9ICcnO1xyXG5cclxuXHRcdFx0XHRyZXR1cm4gcGRmRG9jLmdldFBhZ2UoMSlcclxuXHRcdFx0XHQudGhlbihmdW5jdGlvbihwYWdlKSB7XHJcblxyXG5cdFx0XHRcdFx0dmFyIHZpZXdwb3J0ID0gcGFnZS5nZXRWaWV3cG9ydCh7IHNjYWxlOiAxIH0pO1xyXG5cdFx0XHRcdFx0d2luLmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQod2luLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJykpLnRleHRDb250ZW50ID1cclxuXHRcdFx0XHRcdFx0J0BzdXBwb3J0cyAoKHNpemU6QTQpIGFuZCAoc2l6ZToxcHQgMXB0KSkgeycgK1xyXG5cdFx0XHRcdFx0XHRcdCdAcGFnZSB7IG1hcmdpbjogMXB0OyBzaXplOiAnICsgKCh2aWV3cG9ydC53aWR0aCAqIFBSSU5UX1VOSVRTKSAvIENTU19VTklUUykgKyAncHQgJyArICgodmlld3BvcnQuaGVpZ2h0ICogUFJJTlRfVU5JVFMpIC8gQ1NTX1VOSVRTKSArICdwdDsgfScgK1xyXG5cdFx0XHRcdFx0XHQnfScgK1xyXG5cclxuXHRcdFx0XHRcdFx0J0BtZWRpYSBwcmludCB7JyArXHJcblx0XHRcdFx0XHRcdFx0J2JvZHkgeyBtYXJnaW46IDAgfScgK1xyXG5cdFx0XHRcdFx0XHRcdCdjYW52YXMgeyBwYWdlLWJyZWFrLWJlZm9yZTogYXZvaWQ7IHBhZ2UtYnJlYWstYWZ0ZXI6IGFsd2F5czsgcGFnZS1icmVhay1pbnNpZGU6IGF2b2lkIH0nICtcclxuXHRcdFx0XHRcdFx0J30nK1xyXG5cclxuXHRcdFx0XHRcdFx0J0BtZWRpYSBzY3JlZW4geycgK1xyXG5cdFx0XHRcdFx0XHRcdCdib2R5IHsgbWFyZ2luOiAwIH0nICtcclxuXHRcdFx0XHRcdFx0J30nK1xyXG5cclxuXHRcdFx0XHRcdFx0JydcclxuXHRcdFx0XHRcdHJldHVybiB3aW47XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fSlcclxuXHRcdFx0LnRoZW4oZnVuY3Rpb24od2luKSB7XHJcblxyXG5cdFx0XHRcdHZhciBhbGxQYWdlcyA9IFtdO1xyXG5cclxuXHRcdFx0XHRmb3IgKCB2YXIgcGFnZU51bWJlciA9IDE7IHBhZ2VOdW1iZXIgPD0gcGRmRG9jLm51bVBhZ2VzOyArK3BhZ2VOdW1iZXIgKSB7XHJcblxyXG5cdFx0XHRcdFx0aWYgKCBwYWdlTnVtYmVyT25seSAhPT0gdW5kZWZpbmVkICYmIHBhZ2VOdW1iZXJPbmx5LmluZGV4T2YocGFnZU51bWJlcikgPT09IC0xIClcclxuXHRcdFx0XHRcdFx0Y29udGludWU7XHJcblxyXG5cdFx0XHRcdFx0YWxsUGFnZXMucHVzaChcclxuXHRcdFx0XHRcdFx0cGRmRG9jLmdldFBhZ2UocGFnZU51bWJlcilcclxuXHRcdFx0XHRcdFx0LnRoZW4oZnVuY3Rpb24ocGFnZSkge1xyXG5cclxuXHRcdFx0XHRcdFx0XHR2YXIgdmlld3BvcnQgPSBwYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSk7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciBwcmludENhbnZhc0VsdCA9IHdpbi5kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHdpbi5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKSk7XHJcblx0XHRcdFx0XHRcdFx0cHJpbnRDYW52YXNFbHQud2lkdGggPSAodmlld3BvcnQud2lkdGggKiBQUklOVF9VTklUUyk7XHJcblx0XHRcdFx0XHRcdFx0cHJpbnRDYW52YXNFbHQuaGVpZ2h0ID0gKHZpZXdwb3J0LmhlaWdodCAqIFBSSU5UX1VOSVRTKTtcclxuXHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHBhZ2UucmVuZGVyKHtcclxuXHRcdFx0XHRcdFx0XHRcdGNhbnZhc0NvbnRleHQ6IHByaW50Q2FudmFzRWx0LmdldENvbnRleHQoJzJkJyksXHJcblx0XHRcdFx0XHRcdFx0XHR0cmFuc2Zvcm06IFsgLy8gQWRkaXRpb25hbCB0cmFuc2Zvcm0sIGFwcGxpZWQganVzdCBiZWZvcmUgdmlld3BvcnQgdHJhbnNmb3JtLlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRQUklOVF9VTklUUywgMCwgMCxcclxuXHRcdFx0XHRcdFx0XHRcdFx0UFJJTlRfVU5JVFMsIDAsIDBcclxuXHRcdFx0XHRcdFx0XHRcdF0sXHJcblx0XHRcdFx0XHRcdFx0XHR2aWV3cG9ydDogdmlld3BvcnQsXHJcblx0XHRcdFx0XHRcdFx0XHRpbnRlbnQ6ICdwcmludCdcclxuXHRcdFx0XHRcdFx0XHR9KS5wcm9taXNlO1xyXG5cdFx0XHRcdFx0XHR9KVxyXG5cdFx0XHRcdFx0KTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFByb21pc2UuYWxsKGFsbFBhZ2VzKVxyXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHRcdHdpbi5mb2N1cygpOyAvLyBSZXF1aXJlZCBmb3IgSUVcclxuXHRcdFx0XHRcdGlmICh3aW4uZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkKCdwcmludCcpKSB7XHJcblx0XHRcdFx0XHRcdHdpbi5kb2N1bWVudC5leGVjQ29tbWFuZCgncHJpbnQnLCBmYWxzZSwgbnVsbCk7XHJcblx0XHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHdpbi5wcmludCgpO1xyXG5cdFx0XHRcdFx0ICB9XHJcblx0XHRcdFx0XHRyZW1vdmVJZnJhbWUoKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHRcdC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuXHJcblx0XHRcdFx0XHRyZW1vdmVJZnJhbWUoKTtcclxuXHRcdFx0XHRcdGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBlcnIpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdH0pXHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5yZW5kZXJQYWdlID0gZnVuY3Rpb24ocm90YXRlKSB7XHJcblx0XHRcdGlmICggcGRmUmVuZGVyICE9PSBudWxsICkge1xyXG5cclxuXHRcdFx0XHRpZiAoIGNhbmNlbGluZyApXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0Y2FuY2VsaW5nID0gdHJ1ZTtcclxuXHRcdFx0XHRwZGZSZW5kZXIuY2FuY2VsKCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIHBkZlBhZ2UgPT09IG51bGwgKVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHJcblx0XHRcdHZhciBwYWdlUm90YXRlID0gKHBkZlBhZ2Uucm90YXRlID09PSB1bmRlZmluZWQgPyAwIDogcGRmUGFnZS5yb3RhdGUpICsgKHJvdGF0ZSA9PT0gdW5kZWZpbmVkID8gMCA6IHJvdGF0ZSk7XHJcblxyXG5cdFx0XHR2YXIgc2NhbGUgPSBjYW52YXNFbHQub2Zmc2V0V2lkdGggLyBwZGZQYWdlLmdldFZpZXdwb3J0KHsgc2NhbGU6IDEgfSkud2lkdGggKiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSk7XHJcblx0XHRcdHZhciB2aWV3cG9ydCA9IHBkZlBhZ2UuZ2V0Vmlld3BvcnQoeyBzY2FsZTogc2NhbGUsIHJvdGF0aW9uOnBhZ2VSb3RhdGUgfSk7XHJcblxyXG5cdFx0XHRlbWl0dGVyLmVtaXQoJ3BhZ2Utc2l6ZScsIHsgd2lkdGg6IHZpZXdwb3J0LndpZHRoLCBoZWlnaHQ6IHZpZXdwb3J0LmhlaWdodCwgc2NhbGUgfSk7XHJcblxyXG5cdFx0XHRjYW52YXNFbHQud2lkdGggPSB2aWV3cG9ydC53aWR0aDtcclxuXHRcdFx0Y2FudmFzRWx0LmhlaWdodCA9IHZpZXdwb3J0LmhlaWdodDtcclxuXHJcblx0XHRcdHBkZlJlbmRlciA9IHBkZlBhZ2UucmVuZGVyKHtcclxuXHRcdFx0XHRjYW52YXNDb250ZXh0OiBjYW52YXNFbHQuZ2V0Q29udGV4dCgnMmQnKSxcclxuXHRcdFx0XHR2aWV3cG9ydDogdmlld3BvcnRcclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRhbm5vdGF0aW9uTGF5ZXJFbHQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xyXG5cdFx0XHRjbGVhckFubm90YXRpb25zKCk7XHJcblxyXG5cdFx0XHR2YXIgdmlld2VyID0ge1xyXG5cdFx0XHRcdHNjcm9sbFBhZ2VJbnRvVmlldzogZnVuY3Rpb24ocGFyYW1zKSB7XHJcblx0XHRcdFx0XHRlbWl0dGVyLmVtaXQoJ2xpbmstY2xpY2tlZCcsIHBhcmFtcy5wYWdlTnVtYmVyKVxyXG5cdFx0XHRcdH0sXHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgbGlua1NlcnZpY2UgPSBuZXcgUERGTGlua1NlcnZpY2UoKTtcclxuXHRcdFx0bGlua1NlcnZpY2Uuc2V0RG9jdW1lbnQocGRmRG9jKTtcclxuXHRcdFx0bGlua1NlcnZpY2Uuc2V0Vmlld2VyKHZpZXdlcik7XHJcblxyXG5cdFx0XHRwZW5kaW5nT3BlcmF0aW9uID0gcGVuZGluZ09wZXJhdGlvbi50aGVuKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRcdFx0XHR2YXIgZ2V0QW5ub3RhdGlvbnNPcGVyYXRpb24gPVxyXG5cdFx0XHRcdHBkZlBhZ2UuZ2V0QW5ub3RhdGlvbnMoeyBpbnRlbnQ6ICdkaXNwbGF5JyB9KVxyXG5cdFx0XHRcdC50aGVuKGZ1bmN0aW9uKGFubm90YXRpb25zKSB7XHJcblxyXG5cdFx0XHRcdFx0UERGSlMuQW5ub3RhdGlvbkxheWVyLnJlbmRlcih7XHJcblx0XHRcdFx0XHRcdHZpZXdwb3J0OiB2aWV3cG9ydC5jbG9uZSh7IGRvbnRGbGlwOiB0cnVlIH0pLFxyXG5cdFx0XHRcdFx0XHRkaXY6IGFubm90YXRpb25MYXllckVsdCxcclxuXHRcdFx0XHRcdFx0YW5ub3RhdGlvbnM6IGFubm90YXRpb25zLFxyXG5cdFx0XHRcdFx0XHRwYWdlOiBwZGZQYWdlLFxyXG5cdFx0XHRcdFx0XHRsaW5rU2VydmljZTogbGlua1NlcnZpY2UsXHJcblx0XHRcdFx0XHRcdHJlbmRlckludGVyYWN0aXZlRm9ybXM6IGZhbHNlXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0dmFyIHBkZlJlbmRlck9wZXJhdGlvbiA9XHJcblx0XHRcdFx0cGRmUmVuZGVyLnByb21pc2VcclxuXHRcdFx0XHQudGhlbihmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0XHRhbm5vdGF0aW9uTGF5ZXJFbHQuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cdFx0XHRcdFx0Y2FuY2VsaW5nID0gZmFsc2U7XHJcblx0XHRcdFx0XHRwZGZSZW5kZXIgPSBudWxsO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LmNhdGNoKGZ1bmN0aW9uKGVycikge1xyXG5cclxuXHRcdFx0XHRcdHBkZlJlbmRlciA9IG51bGw7XHJcblx0XHRcdFx0XHRpZiAoIGVyciBpbnN0YW5jZW9mIFBERkpTLlJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiApIHtcclxuXHJcblx0XHRcdFx0XHRcdGNhbmNlbGluZyA9IGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR0aGlzLnJlbmRlclBhZ2Uocm90YXRlKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XHJcblx0XHRcdFx0fS5iaW5kKHRoaXMpKVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoW2dldEFubm90YXRpb25zT3BlcmF0aW9uLCBwZGZSZW5kZXJPcGVyYXRpb25dKTtcclxuXHRcdFx0fS5iaW5kKHRoaXMpKTtcclxuXHRcdH1cclxuXHJcblxyXG5cdFx0dGhpcy5mb3JFYWNoUGFnZSA9IGZ1bmN0aW9uKHBhZ2VDYWxsYmFjaykge1xyXG5cclxuXHRcdFx0dmFyIG51bVBhZ2VzID0gcGRmRG9jLm51bVBhZ2VzO1xyXG5cclxuXHRcdFx0KGZ1bmN0aW9uIG5leHQocGFnZU51bSkge1xyXG5cclxuXHRcdFx0XHRwZGZEb2MuZ2V0UGFnZShwYWdlTnVtKVxyXG5cdFx0XHRcdC50aGVuKHBhZ2VDYWxsYmFjaylcclxuXHRcdFx0XHQudGhlbihmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0XHRpZiAoICsrcGFnZU51bSA8PSBudW1QYWdlcyApXHJcblx0XHRcdFx0XHRcdG5leHQocGFnZU51bSk7XHJcblx0XHRcdFx0fSlcclxuXHRcdFx0fSkoMSk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHRoaXMubG9hZFBhZ2UgPSBmdW5jdGlvbihwYWdlTnVtYmVyLCByb3RhdGUpIHtcclxuXHRcdFx0cGRmUGFnZSA9IG51bGw7XHJcblxyXG5cdFx0XHRpZiAoIHBkZkRvYyA9PT0gbnVsbCApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cclxuXHRcdFx0cGVuZGluZ09wZXJhdGlvbiA9IHBlbmRpbmdPcGVyYXRpb24udGhlbihmdW5jdGlvbigpIHtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHBkZkRvYy5nZXRQYWdlKHBhZ2VOdW1iZXIpO1xyXG5cdFx0XHR9KVxyXG5cdFx0XHQudGhlbihmdW5jdGlvbihwYWdlKSB7XHJcblxyXG5cdFx0XHRcdHBkZlBhZ2UgPSBwYWdlO1xyXG5cdFx0XHRcdHRoaXMucmVuZGVyUGFnZShyb3RhdGUpO1xyXG5cdFx0XHRcdGVtaXR0ZXIuZW1pdCgncGFnZS1sb2FkZWQnLCBwYWdlLnBhZ2VOdW1iZXIpO1xyXG5cdFx0XHR9LmJpbmQodGhpcykpXHJcblx0XHRcdC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuXHJcblx0XHRcdFx0Y2xlYXJDYW52YXMoKTtcclxuXHRcdFx0XHRjbGVhckFubm90YXRpb25zKCk7XHJcblx0XHRcdFx0ZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMubG9hZERvY3VtZW50ID0gZnVuY3Rpb24oc3JjKSB7XHJcblxyXG5cdFx0XHRwZGZEb2MgPSBudWxsO1xyXG5cdFx0XHRwZGZQYWdlID0gbnVsbDtcclxuXHJcblx0XHRcdGVtaXR0ZXIuZW1pdCgnbnVtLXBhZ2VzJywgdW5kZWZpbmVkKTtcclxuXHJcblx0XHRcdGlmICggIXNyYyApIHtcclxuXHJcblx0XHRcdFx0Y2FudmFzRWx0LnJlbW92ZUF0dHJpYnV0ZSgnd2lkdGgnKTtcclxuXHRcdFx0XHRjYW52YXNFbHQucmVtb3ZlQXR0cmlidXRlKCdoZWlnaHQnKTtcclxuXHRcdFx0XHRjbGVhckFubm90YXRpb25zKCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyB3YWl0IGZvciBwZW5kaW5nIG9wZXJhdGlvbiBlbmRzXHJcblx0XHRcdHBlbmRpbmdPcGVyYXRpb24gPSBwZW5kaW5nT3BlcmF0aW9uLnRoZW4oZnVuY3Rpb24oKSB7XHJcblxyXG5cdFx0XHRcdHZhciBsb2FkaW5nVGFzaztcclxuXHRcdFx0XHRpZiAoIGlzUERGRG9jdW1lbnRMb2FkaW5nVGFzayhzcmMpICkge1xyXG5cclxuXHRcdFx0XHRcdGlmICggc3JjLmRlc3Ryb3llZCApIHtcclxuXHJcblx0XHRcdFx0XHRcdGVtaXR0ZXIuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ2xvYWRpbmdUYXNrIGhhcyBiZWVuIGRlc3Ryb3llZCcpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuXHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0bG9hZGluZ1Rhc2sgPSBzcmM7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHJcblx0XHRcdFx0XHRsb2FkaW5nVGFzayA9IGNyZWF0ZUxvYWRpbmdUYXNrKHNyYywge1xyXG5cdFx0XHRcdFx0XHRvblBhc3N3b3JkOiBmdW5jdGlvbih1cGRhdGVQYXNzd29yZCwgcmVhc29uKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciByZWFzb25TdHI7XHJcblx0XHRcdFx0XHRcdFx0c3dpdGNoIChyZWFzb24pIHtcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgUERGSlMuUGFzc3dvcmRSZXNwb25zZXMuTkVFRF9QQVNTV09SRDpcclxuXHRcdFx0XHRcdFx0XHRcdFx0cmVhc29uU3RyID0gJ05FRURfUEFTU1dPUkQnO1xyXG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0XHRcdGNhc2UgUERGSlMuUGFzc3dvcmRSZXNwb25zZXMuSU5DT1JSRUNUX1BBU1NXT1JEOlxyXG5cdFx0XHRcdFx0XHRcdFx0XHRyZWFzb25TdHIgPSAnSU5DT1JSRUNUX1BBU1NXT1JEJztcclxuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdGVtaXR0ZXIuZW1pdCgncGFzc3dvcmQnLCB1cGRhdGVQYXNzd29yZCwgcmVhc29uU3RyKTtcclxuXHRcdFx0XHRcdFx0fSxcclxuXHRcdFx0XHRcdFx0b25Qcm9ncmVzczogZnVuY3Rpb24oc3RhdHVzKSB7XHJcblxyXG5cdFx0XHRcdFx0XHRcdHZhciByYXRpbyA9IHN0YXR1cy5sb2FkZWQgLyBzdGF0dXMudG90YWw7XHJcblx0XHRcdFx0XHRcdFx0ZW1pdHRlci5lbWl0KCdwcm9ncmVzcycsIE1hdGgubWluKHJhdGlvLCAxKSk7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIGxvYWRpbmdUYXNrLnByb21pc2U7XHJcblx0XHRcdH0pXHJcblx0XHRcdC50aGVuKGZ1bmN0aW9uKHBkZikge1xyXG5cclxuXHRcdFx0XHRwZGZEb2MgPSBwZGY7XHJcblx0XHRcdFx0ZW1pdHRlci5lbWl0KCdudW0tcGFnZXMnLCBwZGYubnVtUGFnZXMpO1xyXG5cdFx0XHRcdGVtaXR0ZXIuZW1pdCgnbG9hZGVkJyk7XHJcblx0XHRcdH0pXHJcblx0XHRcdC5jYXRjaChmdW5jdGlvbihlcnIpIHtcclxuXHJcblx0XHRcdFx0Y2xlYXJDYW52YXMoKTtcclxuXHRcdFx0XHRjbGVhckFubm90YXRpb25zKCk7XHJcblx0XHRcdFx0ZW1pdHRlci5lbWl0KCdlcnJvcicsIGVycik7XHJcblx0XHRcdH0pXHJcblx0XHR9XHJcblxyXG5cdFx0YW5ub3RhdGlvbkxheWVyRWx0LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIHtcclxuXHRcdGNyZWF0ZUxvYWRpbmdUYXNrOiBjcmVhdGVMb2FkaW5nVGFzayxcclxuXHRcdFBERkpTV3JhcHBlcjogUERGSlNXcmFwcGVyLFxyXG5cdH1cclxufVxyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vue3-pdf/src/pdfjsWrapper.js\n");

/***/ }),

/***/ "./node_modules/worker-loader/dist/cjs.js!./node_modules/pdfjs-dist-sig/es5/build/pdf.worker.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/worker-loader/dist/cjs.js!./node_modules/pdfjs-dist-sig/es5/build/pdf.worker.js ***!
  \******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = function() {\n  return new Worker(__webpack_require__.p + \"160dfa7c4355122d6db0.worker.js\");\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC1zaWcvZXM1L2J1aWxkL3BkZi53b3JrZXIuanM/M2VhMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLG9CQUFvQixxQkFBdUI7QUFDM0MiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd29ya2VyLWxvYWRlci9kaXN0L2Nqcy5qcyEuL25vZGVfbW9kdWxlcy9wZGZqcy1kaXN0LXNpZy9lczUvYnVpbGQvcGRmLndvcmtlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgV29ya2VyKF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCIxNjBkZmE3YzQzNTUxMjJkNmRiMC53b3JrZXIuanNcIik7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/worker-loader/dist/cjs.js!./node_modules/pdfjs-dist-sig/es5/build/pdf.worker.js\n");

/***/ }),

/***/ "?b942":
/*!************************!*\
  !*** canvas (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?e97d":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?4b1a":
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8c50":
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?a9a4":
/*!*********************!*\
  !*** url (ignored) ***!
  \*********************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?3098":
/*!**********************!*\
  !*** zlib (ignored) ***!
  \**********************/
/***/ (() => {

/* (ignored) */

/***/ })

}]);